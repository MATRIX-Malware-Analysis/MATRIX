{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4c706e55-cde3-414f-b697-d8556778e5c0",
    "created": "2024-08-14T16:33:19.210746Z",
    "modified": "2024-08-14T16:33:19.210749Z",
    "name": "Add/Sub Encoder",
    "description": " Encodes payload with add or sub instructions. This idea came from (offensive-security) muts' hp nnm 7.5.1 exploit. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/x86/add_sub.rb",
            "external_id": "add_sub.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Encoder\n  Rank = ManualRanking\n\n  def initialize\n    super(\n      'Name'             => 'Add/Sub Encoder',\n      'Description'      => %q{\n          Encodes payload with add or sub instructions. This idea came\n          from (offensive-security) muts' hp nnm 7.5.1 exploit.\n      },\n      'Author'           => 'Melih Sarica <ms[at]sevure.com>',\n      'Arch'             => ARCH_X86,\n      'License'          => MSF_LICENSE,\n      'Decoder'          =>\n        {\n          'BlockSize'  => 4\n        })\n  end\n\n  def add_or_sub(avchars)\n    add = [0x05, 0x50, 0x58, 0x25, 0x54, 0x5C]\n    sub = [0x2D, 0x50, 0x58, 0x25, 0x54, 0x5C]\n    return 1 if add.all?{|ch|avchars.include?ch.chr}\n    return 2 if sub.all?{|ch|avchars.include?ch.chr}\n    return 0\n  end\n\n  def write_inst(inst, mcode)\n    @data << inst\n    if mcode != 0\n      for i in 0...4\n        t = mcode & 0x000000FF;\n        @data << t\n        mcode = mcode >> 8;\n      end\n    end\n  end\n\n  def rand_with_av_chars()\n    t2 = 0\n    for i in 0...4\n      c = @avchars[rand(@avchars.size)].ord.to_i()\n      t2 = t2 <<8\n      t2 += c\n    end\n    return t2\n  end\n\n  def check_non_av_chars(target)\n    for i in 0...4\n      t = target & 0x000000FF;\n      return true if not @avchars.include?t.chr\n      target = target >> 8;\n    end\n    return false\n  end\n\n  def encode_inst(target)\n    begin\n      a = rand_with_av_chars()\n      b = rand_with_av_chars()\n      c = target - a - b if @set == 1\n      c = 0 - target - a - b if @set == 2\n      c = c%(0xFFFFFFFF+1)\n    end while check_non_av_chars(c) == true\n    write_inst(@inst[\"opcode\"], a)\n    write_inst(@inst[\"opcode\"], b)\n    write_inst(@inst[\"opcode\"], c)\n  end\n\n  def encode_shellcode(target, z1, z2)\n    write_inst(@inst[\"and\"], z1);\n    write_inst(@inst[\"and\"], z2);\n    encode_inst(target);\n    write_inst(@inst[\"push\"], 0);\n  end\n\n  def decoder_stub(state)\n    buf = \"\"\n    shellcode = state.buf.split(//)\n    while shellcode.size>0\n      buf << shellcode.pop(4).join\n    end\n    state.buf = buf\n    @data = \"\"\n    @avchars = \"\"\n    for i in 0..255\n      @avchars = @avchars + i.chr.to_s if not state.badchars.include?i.chr.to_s\n    end\n    offset = (datastore['BufferOffset'] || 0).to_i\n    @inst = {}\n    @set = add_or_sub(@avchars)\n    if @set == 0 then\n      raise EncodingError, \"Bad character list includes essential characters.\"\n      exit\n    elsif @set == 1 then #add\n      @inst[\"opcode\"] = 0x05\n    else #sub\n      @inst[\"opcode\"] = 0x2d\n    end\n    @inst[\"push\"] = 0x50\n    @inst[\"pop\"] = 0x58\n    @inst[\"and\"] = 0x25\n    @inst[\"push_esp\"] = 0x54\n    @inst[\"pop_esp\"] = 0x5c\n    if state.buf.size%4 != 0 then\n      raise EncodingError, \"Shellcode size must be divisible by 4, try nop padding.\"\n      exit\n    end\n    #init\n    write_inst(@inst[\"push_esp\"], 0)\n    write_inst(@inst[\"pop\"], 0)\n    encode_inst(offset)\n    write_inst(@inst[\"push\"], 0)\n    write_inst(@inst[\"pop_esp\"], 0)\n    #zeroing registers\n    begin\n      @z1 = rand_with_av_chars()\n      @z2 = rand_with_av_chars()\n    end while @z1&@z2 != 0\n    decoder = @data\n    return decoder\n  end\n\n  def encode_block(state, block)\n    #encoding shellcode\n    @data = \"\"\n    target = block.split(//)\n    return if target.size<4\n    t = 0\n    for i in 0..3\n      t1 = target[3-i][0].ord.to_i\n      t = t<<8\n      t = t + t1\n    end\n    encode_shellcode(t, @z1, @z2);\n    encoded = @data\n    return encoded\n  end\nend\n\n"
}