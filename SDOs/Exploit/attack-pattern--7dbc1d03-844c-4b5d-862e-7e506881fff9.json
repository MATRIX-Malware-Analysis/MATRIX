{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7dbc1d03-844c-4b5d-862e-7e506881fff9",
    "created": "2024-08-14T16:31:24.844001Z",
    "modified": "2024-08-14T16:31:24.844005Z",
    "name": "Telegram Message Client",
    "description": " This module can be used to send a document and/or message to multiple chats on telegram. Please refer to the module documentation for info on how to retrieve the bot token and corresponding chat ID values. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/client/telegram/send_message.rb",
            "external_id": "send_message.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'faraday'\n\nclass MetasploitModule < Msf::Auxiliary\n  def initialize\n    super(\n    'Name' => 'Telegram Message Client',\n    'Description' => %q{\n        This module can be used to send a document and/or message to\n        multiple chats on telegram. Please refer to the module\n        documentation for info on how to retrieve the bot token and corresponding chat\n        ID values.\n        },\n    'Author' => [\n      'Ege Balc\u0131 <egebalci[at]pm.me>', # Aka @egeblc of https://pentest.blog\n      'Gaurav Purswani' # @pingport80\n    ],\n    'License' => MSF_LICENSE,\n    )\n\n    register_options(\n      [\n        OptString.new('BOT_TOKEN', [true, 'Telegram BOT token', '']),\n        OptString.new('MESSAGE', [false, 'The message to be sent']),\n        OptInt.new('CHAT_ID', [false, 'Chat ID for the BOT', '']),\n        OptPath.new('DOCUMENT', [false, 'The path to the document(binary, video etc)']),\n        OptPath.new('IDFILE', [false, 'File containing chat IDs, one per line']),\n        OptEnum.new('FORMATTING', [false, 'Message formating option (Markdown|MarkdownV2|HTML)', 'Markdown', [ 'Markdown', 'MarkdownV2', 'HTML']])\n      ], self.class\n    )\n  end\n\n  def formatting\n    datastore['FORMATTING']\n  end\n\n  def message\n    datastore['MESSAGE']\n  end\n\n  def document\n    datastore['DOCUMENT']\n  end\n\n  def bot_token\n    datastore['BOT_TOKEN']\n  end\n\n  def id_file\n    datastore['IDFILE']\n  end\n\n  def send_document(conn, chat_id)\n    unless ::File.file?(document) && ::File.readable?(document)\n      fail_with(Failure::BadConfig, 'The document to be sent does not exist or is not a readable file!')\n    end\n    raw_params = { 'chat_id' => chat_id, 'document' => Faraday::UploadIO.new(document, 'application/octet-stream') }\n    params = {}\n    raw_params.each_with_object({}) do |(key, value), _tmp_params|\n      params[key] = value\n    end\n    response = conn.post(\"/bot#{bot_token}/sendDocument\", params)\n    if response.status == 200\n      print_good(\"Document sent successfully to #{chat_id}\")\n    elsif response.status == 403\n      print_bad(\"Error while sending document! Make sure you have access to message chat_id : #{chat_id}\")\n    else\n      print_bad(\"Error while sending the document to #{chat_id} API Status : #{response.status}\")\n    end\n  end\n\n  def send_message(conn, chat_id)\n    params = { 'chat_id' => chat_id, 'text' => message, 'parse_mode' => formatting }\n    response = conn.post(\"/bot#{bot_token}/sendMessage\", params)\n    if response.status == 200\n      print_good(\"Message sent successfully to #{chat_id}\")\n    elsif response.status == 403\n      print_bad(\"Error while sending document! Make sure you have access to message chat_id : #{chat_id}\")\n    else\n      print_bad(\"Error while sending the message to chat_id #{chat_id} API Status : #{response.status}\")\n    end\n  end\n\n  def run\n    unless document || message\n      fail_with(Failure::BadConfig, 'You must supply a message and/or document')\n    end\n    url = 'https://api.telegram.org'\n    conn = Faraday.new(url: url) do |faraday|\n      faraday.request :multipart\n      faraday.request :url_encoded\n      faraday.adapter Faraday.default_adapter\n    end\n\n    if id_file\n      print_warning(\"Opening `#{id_file}` to fetch chat IDs...\")\n      unless ::File.file?(id_file) && ::File.readable?(id_file)\n        fail_with(Failure::BadConfig, 'The ID file is not an existing readable file!')\n      end\n      File.readlines(id_file).each do |chat_id|\n        send_document(conn, chat_id) if document\n        send_message(conn, chat_id) if message\n      end\n      return\n    end\n    send_document(conn, datastore['CHAT_ID']) if document\n    send_message(conn, datastore['CHAT_ID']) if message\n  end\n\nend\n"
}