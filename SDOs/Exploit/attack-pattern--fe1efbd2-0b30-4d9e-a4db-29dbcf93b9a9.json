{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--fe1efbd2-0b30-4d9e-a4db-29dbcf93b9a9",
    "created": "2024-08-14T16:29:51.627461Z",
    "modified": "2024-08-14T16:29:51.627465Z",
    "name": "HTTP Host Header Injection Detection",
    "description": "Checks if the host is vulnerable to Host header injection",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/host_header_injection.rb",
            "external_id": "host_header_injection.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::WmapScanServer\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'HTTP Host Header Injection Detection',\n      'Description' => 'Checks if the host is vulnerable to Host header injection',\n      'Author'      =>\n        [\n          'Jay Turla', # @shipcod3\n          'Medz Barao' # @godflux\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          ['CVE', '2016-10073'], # validate, an instance of a described attack approach from the original reference\n          ['URL', 'http://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html']\n        ]\n    ))\n\n    register_options([\n      OptString.new('PATH', [true, \"The PATH to use while testing\", '/']),\n      OptEnum.new('METHOD', [true, 'HTTP Request Method', 'GET', ['GET', 'POST']]),\n      OptString.new('TARGETHOST', [false, 'The redirector target. Default is <random>.com']),\n      OptString.new('DATA', [false, 'POST data, if necessary', '']),\n      OptBool.new('SHOW_EVIDENCE', [false, \"Show evidences: headers or body\", false])\n    ])\n  end\n\n  def run_host(ip)\n\n    web_path = normalize_uri(datastore['PATH'])\n    http_method = datastore['METHOD']\n    target_host = datastore['TARGETHOST'] || Rex::Text.rand_text_alpha_lower(8)+\".com\"\n\n    # The 'Host' header specifies the domain name of the server (for virtual\n    # hosting), and (optionally) the TCP port number on which the server is listening.\n\n    # The 'X-Host' header specifies the originating domain name of the server\n    # (for virtual hosting) and optionally the TCP port number.\n\n    # The 'X-Forwarded-Host' header is a de-facto standard header for identifying\n    # the original host requested by the client in the Host HTTP request header.\n\n    begin\n\n      vprint_status(\"Sending request #{rhost}:#{rport}#{web_path} (#{vhost})(#{http_method}) with 'Host' value '#{target_host}'\")\n\n      res = send_request_raw({\n        'uri'     => web_path,\n        'method'  => http_method,\n        'data'    => datastore['DATA'],\n        'headers' => {\n          'Host'             => target_host,\n          'X-Host'           => target_host,\n          'X-Forwarded-Host' => target_host\n        }\n      })\n\n      unless res\n        vprint_error(\"#{rhost}:#{rport}#{web_path} (#{vhost}) did not reply to our request\")\n        return\n      end\n\n      if res.headers.include?(target_host)\n        evidence = \"headers\"\n        if datastore['SHOW_EVIDENCE']\n          vprint_status(\"Headers: [#{res.headers}]\")\n        end\n      end\n\n      if res.body.include?(target_host)\n        evidence = \"body\"\n        if datastore['SHOW_EVIDENCE']\n          vprint_status(\"Body: [#{res.body}]\")\n        end\n      end\n\n      if evidence\n        print_good(\"#{rhost}:#{rport}#{web_path} (#{vhost})(#{res.code})(#{http_method})(evidence into #{evidence}) is vulnerable to HTTP Host header injection\")\n\n        report_vuln(\n          host:  rhost,\n          port:  rport,\n          proto: 'tcp',\n          sname: ssl ? 'https' : 'http',\n          name:  self.name,\n          info:  \"Module used #{self.fullname}, vhost: #{vhost}, method: #{http_method}: evidence: #{evidence}\",\n          refs:  self.references\n        )\n\n        report_web_vuln({\n          :host        => rhost,\n          :port        => rport,\n          :vhost       => vhost,\n          :path        => web_path,\n          :pname       => \"Host,X-Host,X-Forwarded-Host headers\",\n          :risk        => 2,\n          :proof       => \"Evidence into #{evidence}\",\n          :description => \"HTTP Host Header Injection Detection\",\n          :name        => self.fullname,\n          :category    => \"web\",\n          :method      => http_method\n        })\n\n      else\n        vprint_error(\"#{rhost}:#{rport}#{web_path} (#{vhost}) returned #{res.code} #{res.message}\")\n      end\n\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n    rescue ::Timeout::Error, ::Errno::EPIPE\n    end\n  end\nend\n"
}