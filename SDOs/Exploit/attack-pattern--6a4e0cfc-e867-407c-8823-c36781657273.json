{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6a4e0cfc-e867-407c-8823-c36781657273",
    "created": "2024-08-14T16:27:08.741405Z",
    "modified": "2024-08-14T16:27:08.741409Z",
    "name": "SunRPC Portmap Program Enumerator",
    "description": " This module calls the target portmap service and enumerates all program entries and their running port numbers. '",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/misc/sunrpc_portmapper.rb",
            "external_id": "sunrpc_portmapper.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::SunRPC\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'SunRPC Portmap Program Enumerator',\n      'Description' => '\n        This module calls the target portmap service and enumerates all program\n        entries and their running port numbers.\n      ',\n      'Author'      => ['<tebo[at]attackresearch.com>'],\n      'References'  =>\n        [\n          ['URL',\t'https://www.ietf.org/rfc/rfc1057.txt']\n        ],\n      'License'\t=> MSF_LICENSE\n    )\n\n    register_options([\n      OptEnum.new('PROTOCOL', [true, 'Protocol to use', 'tcp', %w[tcp udp]]),\n    ])\n  end\n\n  def run_host(ip)\n    peer = \"#{ip}:#{rport}\"\n    proto = datastore['PROTOCOL']\n    vprint_status \"SunRPC - Enumerating programs\"\n\n    begin\n      program\t\t= 100000\n      progver\t\t= 2\n      procedure\t= 4\n\n      sunrpc_create(proto, program, progver)\n      sunrpc_authnull\n      resp = sunrpc_call(procedure, \"\")\n\n      progs = resp[3, 1].unpack('C')[0]\n      maps = []\n      if (progs == 0x01)\n        while Rex::Encoder::XDR.decode_int!(resp) == 1\n          maps << Rex::Encoder::XDR.decode!(resp, Integer, Integer, Integer, Integer)\n        end\n      end\n      sunrpc_destroy\n      return if maps.empty?\n      vprint_good(\"Found #{maps.size} programs available\")\n\n      table = Rex::Text::Table.new(\n        'Header'  => \"SunRPC Programs for #{ip}\",\n        'Indent'  => 1,\n        'Columns' => %w(Name Number Version Port Protocol)\n      )\n\n      maps.each do |map|\n        prog, vers, prot_num, port = map[0, 4]\n        thing = \"RPC Program ##{prog} v#{vers} on port #{port} w/ protocol #{prot_num}\"\n        if prot_num == 0x06\n          proto = 'tcp'\n        elsif prot_num == 0x11\n          proto = 'udp'\n        else\n          print_error(\"#{peer}: unknown protocol number for #{thing}\")\n          next\n        end\n\n        resolved = progresolv(prog)\n        table << [ resolved, prog, vers, port, proto ]\n        report_service(\n          host: ip,\n          port: port,\n          proto: proto,\n          name: resolved,\n          info: \"Prog: #{prog} Version: #{vers} - via portmapper\"\n        )\n      end\n\n      print_good(table.to_s)\n    rescue ::Rex::Proto::SunRPC::RPCTimeout, ::Rex::Proto::SunRPC::RPCError => e\n      vprint_error(e.to_s)\n    end\n  end\nend\n"
}