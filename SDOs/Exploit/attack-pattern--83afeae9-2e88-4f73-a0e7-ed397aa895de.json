{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--83afeae9-2e88-4f73-a0e7-ed397aa895de",
    "created": "2024-08-14T16:22:29.893933Z",
    "modified": "2024-08-14T16:22:29.893937Z",
    "name": "Microsoft SQL Server Interesting Data Finder",
    "description": " This module will search the specified MSSQL server for 'interesting' columns and data.  This module has been tested against the latest SQL Server 2019 docker container image (22/04/2021). ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/mssql/mssql_idf.rb",
            "external_id": "mssql_idf.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.digininja.org/metasploit/mssql_idf.php"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n##\n# Author: Robin Wood <robin@digininja.org> <http://www.digininja.org>\n# Version: 0.1\n#\n# This module will search the specified MSSQL server for\n# 'interesting' columns and data\n#\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::MSSQL\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Microsoft SQL Server Interesting Data Finder',\n      'Description'    => %q{\n        This module will search the specified MSSQL server for\n        'interesting' columns and data.\n\n        This module has been tested against the latest SQL Server 2019 docker container image (22/04/2021).\n      },\n      'Author'         => [ 'Robin Wood <robin[at]digininja.org>' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'URL', 'http://www.digininja.org/metasploit/mssql_idf.php' ],\n        ]\n    ))\n\n    register_options(\n      [\n        OptString.new('NAMES', [ true, 'Pipe separated list of column names',  'passw|bank|credit|card']),\n      ])\n  end\n\n  def print_with_underline(str)\n    print_line(str)\n    print_line(\"=\" * str.length)\n  end\n\n  def run\n    headings = [\n      [\"Database\", \"Schema\", \"Table\", \"Column\", \"Data Type\", \"Row Count\"]\n    ]\n\n    sql = \"\"\n    sql += \"DECLARE @dbname nvarchar(255), @id int, @sql varchar (4000); \"\n    sql += \"DECLARE table_cursor CURSOR FOR SELECT name FROM sys.databases \"\n    sql += \"OPEN table_cursor \"\n    sql += \"FETCH NEXT FROM table_cursor INTO @dbname \"\n    sql += \"WHILE (@@FETCH_STATUS = 0) \"\n    sql += \"BEGIN \"\n    sql += \"SET @sql = 'select ';\"\n    sql += \"SET @sql = @sql + ' ''' + @dbname + ''' as ''Database'', ';\"\n    sql += \"SET @sql = @sql + 'sys.schemas.name as ''Schema'', ';\"\n    sql += \"SET @sql = @sql + 'sys.objects.name as ''Table'', ';\"\n    sql += \"SET @sql = @sql + 'sys.columns.name as ''Column'', ';\"\n    sql += \"SET @sql = @sql + 'sys.types.name as ''Column Type'' ';\"\n    sql += \"SET @sql = @sql + 'from ' + @dbname + '.sys.columns ';\"\n    sql += \"SET @sql = @sql + 'inner join ' + @dbname + '.sys.objects on sys.objects.object_id = sys.columns.object_id ';\"\n    sql += \"SET @sql = @sql + 'inner join ' + @dbname + '.sys.types on sys.types.user_type_id = sys.columns.user_type_id ';\"\n    sql += \"SET @sql = @sql + 'inner join ' + @dbname + '.sys.schemas on sys.schemas.schema_id = sys.objects.schema_id ';\"\n\n    list = datastore['Names']\n    where = \"SET @sql = @sql + ' WHERE (\"\n    list.split(/\\|/).each { |val|\n      where += \" lower(sys.columns.name) like ''%\" + val + \"%'' OR \"\n    }\n\n    where.slice!(-3, 4)\n\n    where += \") ';\"\n\n    sql += where\n\n    sql += \"SET @sql = @sql + 'and sys.objects.type=''U'';';\"\n    sql += \"EXEC (@sql);\"\n    sql += \"FETCH NEXT FROM table_cursor INTO @dbname \"\n    sql += \"END \"\n    sql += \"CLOSE table_cursor \"\n    sql += \"DEALLOCATE table_cursor \"\n\n    begin\n      if mssql_login_datastore\n        result = mssql_query(sql, false)\n      else\n        print_error('Login failed')\n        return\n      end\n    rescue Rex::ConnectionRefused => e\n      print_error(\"Connection failed: #{e}\")\n      return\n    end\n\n    column_data = result[:rows]\n    widths = [0, 0, 0, 0, 0, 9]\n    total_width = 0\n\n    if result[:errors] && !result[:errors].empty?\n      result[:errors].each do |err|\n        print_error(err)\n      end\n    end\n\n    if column_data.nil?\n      print_error(\"No columns matched the pattern #{datastore['NAMES'].inspect}. Set the NAMES option to change this search pattern.\")\n      return\n    end\n\n    (column_data|headings).each { |row|\n      0.upto(4) { |col|\n        widths[col] = row[col].length if row[col].length > widths[col]\n      }\n    }\n\n    widths.each { |a|\n      total_width += a\n    }\n\n    print_line\n\n    buffer = \"\"\n    headings.each { |row|\n      0.upto(5) { |col|\n        buffer += row[col].ljust(widths[col] + 1)\n      }\n      print_line(buffer)\n      print_line\n      buffer = \"\"\n\n      0.upto(5) { |col|\n        buffer += print \"=\" * widths[col] + \" \"\n      }\n      print_line(buffer)\n      print_line\n    }\n\n    column_data.each { |row|\n      count_sql = \"SELECT COUNT(*) AS count FROM \"\n\n      full_table = \"\"\n      column_name = \"\"\n      buffer = \"\"\n      0.upto(4) { |col|\n        full_table += row[col] + '.' if col < 3\n        column_name = row[col] if col == 3\n        buffer += row[col].ljust(widths[col] + 1)\n      }\n      full_table.slice!(-1, 1)\n      count_sql += full_table\n\n      result = mssql_query(count_sql, false) if mssql_login_datastore\n\n      count_data = result[:rows]\n      row_count = count_data[0][0]\n\n      buffer += row_count.to_s\n      print_line(buffer)\n      print_line\n    }\n\n    print_line\n    disconnect\n  end\nend\n"
}