{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ed97bc2d-0dbb-42c8-958d-8d03bf8544a6",
    "created": "2024-08-14T16:27:56.545742Z",
    "modified": "2024-08-14T16:27:56.545746Z",
    "name": "NAT-PMP External Port Scanner",
    "description": "Scan NAT devices for their external listening ports using NAT-PMP",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/natpmp/natpmp_portscan.rb",
            "external_id": "natpmp_portscan.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::NATPMP\n  include Rex::Proto::NATPMP\n\n  def initialize\n    super(\n      'Name'        => 'NAT-PMP External Port Scanner',\n      'Description' => 'Scan NAT devices for their external listening ports using NAT-PMP',\n      'Author'      => 'Jon Hart <jhart[at]spoofed.org>',\n      'License'     => MSF_LICENSE\n      )\n\n    register_options(\n      [\n        OptString.new('PORTS', [true, \"Ports to scan (e.g. 22-25,80,110-900)\", \"1-1000\"])\n      ])\n  end\n\n  def run_host(host)\n    begin\n      udp_sock = Rex::Socket::Udp.create({\n        'LocalHost' => datastore['CHOST'] || nil,\n        'Context'   => {'Msf' => framework, 'MsfExploit' => self} }\n      )\n      add_socket(udp_sock)\n      peer = \"#{host}:#{datastore['RPORT']}\"\n      vprint_status(\"#{peer} Scanning #{protocol} ports #{datastore['PORTS']} using NATPMP\")\n\n      external_address = get_external_address(udp_sock, host, datastore['RPORT'])\n      if (external_address)\n        print_good(\"#{peer} responded with external address of #{external_address}\")\n      else\n        vprint_status(\"#{peer} didn't respond with an external address\")\n        return\n      end\n\n      # clear all mappings\n      map_port(udp_sock, host, datastore['RPORT'], 0, 0, Rex::Proto::NATPMP.const_get(protocol), 0)\n\n      Rex::Socket.portspec_crack(datastore['PORTS']).each do |port|\n        map_req = map_port_request(port, port, Rex::Proto::NATPMP.const_get(datastore['PROTOCOL']), 1)\n        udp_sock.sendto(map_req, host, datastore['RPORT'], 0)\n        while (r = udp_sock.recvfrom(16, 1.0) and r[1])\n          break if handle_reply(host, external_address, r)\n        end\n      end\n\n    rescue ::Interrupt\n      raise $!\n    rescue ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionRefused\n      nil\n    rescue ::Exception => e\n      print_error(\"Unknown error: #{e.class} #{e.backtrace}\")\n    end\n  end\n\n  def handle_reply(host, external_addr, pkt)\n    return if not pkt[1]\n\n    if(pkt[1] =~ /^::ffff:/)\n      pkt[1] = pkt[1].sub(/^::ffff:/, '')\n    end\n    host = pkt[1]\n    protocol = datastore['PROTOCOL'].to_s.downcase\n\n    (ver, op, result, epoch, int, ext, lifetime) = parse_map_port_response(pkt[0])\n    peer = \"#{host}:#{datastore['RPORT']}\"\n    if (result == 0)\n      # we always ask to map an external port to the same port on us.  If\n      # we get a successful reponse back but the port we requested be forwarded\n      # is different, that means that someone else already has it open\n      if (int != ext)\n        state = Msf::ServiceState::Open\n        print_good(\"#{peer} #{external_addr} - #{int}/#{protocol} #{state} because of successful mapping with unmatched ports\")\n        if inside_workspace_boundary?(external_addr)\n          report_service(\n            :host   => external_addr,\n            :port   => int,\n            :proto  => protocol,\n            :state => state\n          )\n        end\n      else\n        state = Msf::ServiceState::Closed\n        vprint_error(\"#{peer} #{external_addr} - #{int}/#{protocol} #{state} because of successful mapping with matched ports\")\n      end\n    else\n      state = Msf::ServiceState::Closed\n      vprint_error(\"#{peer} #{external_addr} - #{int}/#{protocol} #{state} because of code #{result} response\")\n    end\n\n    report_service(\n      :host \t=> host,\n      :port \t=> pkt[2],\n      :name \t=> 'natpmp',\n      :proto \t=> 'udp',\n      :state\t=> Msf::ServiceState::Open\n    )\n    true\n  end\nend\n"
}