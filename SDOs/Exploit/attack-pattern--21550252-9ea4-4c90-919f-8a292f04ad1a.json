{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--21550252-9ea4-4c90-919f-8a292f04ad1a",
    "created": "2024-08-14T16:31:13.6382Z",
    "modified": "2024-08-14T16:31:13.638204Z",
    "name": "Gopher gophermap Scanner",
    "description": "( This module identifies Gopher servers, and processes the gophermap file which lists all the files on the server. ) 'References'  => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/gopher/gopher_gophermap.rb",
            "external_id": "gopher_gophermap.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'Gopher gophermap Scanner',\n      'Description' => %q(\n        This module identifies Gopher servers, and processes the gophermap\n        file which lists all the files on the server.\n      ),\n      'References'  =>\n        [\n          ['URL', 'https://sdfeu.org/w/tutorials:gopher']\n        ],\n      'Author'      => 'h00die',\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        Opt::RPORT(70),\n        OptString.new('PATH', [false, 'Path to enumerate', ''])\n      ]\n    )\n  end\n\n  TYPE_MAP = {\n    '0' => 'Text file',\n    '1' => 'Directory',\n    '2' => 'CSO name server',\n    '3' => 'Error',\n    '4' => 'Mac HQX filer',\n    '5' => 'PC binary',\n    '6' => 'UNIX uuencoded file',\n    '7' => 'Search server',\n    '8' => 'Telnet Session',\n    '9' => 'Binary File',\n    'c' => 'Calendar',\n    'e' => 'Event',\n    'g' => 'GIF image',\n    'h' => 'HTML',\n    'i' => 'inline text',\n    's' => 'Sound',\n    'I' => 'Image',\n    'M' => 'MIME multipart/mixed message',\n    'T' => 'TN3270 Session'\n  }.freeze\n\n  def get_type(char)\n    TYPE_MAP.fetch(char.chomp)\n  end\n\n  def run_host(ip)\n    begin\n      connect\n      sock.put(\"#{datastore['path']}\\r\\n\")\n      gophermap = sock.get_once\n      if gophermap\n        gophermap.split(\"\\r\\n\").each do |line|\n          line_parts = line.split(\"\\t\")\n          next unless line_parts.length >= 2\n          # syntax: [type_character]description[tab]path[tab, after this is optional]server[tab]port\n          line_parts = line.split(\"\\t\")\n          desc = line_parts[0]\n          type_char = desc.slice!(0) # remove first character which is the file type\n          file_type = get_type(type_char)\n          if file_type && file_type == 'inline text'\n            print_good(desc)\n            next\n          end\n          if file_type\n            print_good(\"  #{file_type}: #{desc}\")\n          else\n            print_good(\"  Invalid File Type (#{type_char}): #{desc}\")\n          end\n          if line_parts.length >= 3\n            print_good(\"    Path: #{line_parts[2]}:#{line_parts[3]}#{line_parts[1]}\")\n          elsif line.length >= 2\n            print_good(\"    Path: #{line_parts[2]}#{line_parts[1]}\")\n          else\n            print_good(\"    Path: #{line_parts[1]}\")\n\n          end\n        end\n        report_service(host: ip, port: rport, service: 'gopher', info: gophermap)\n      else\n        print_error('No gophermap')\n      end\n    rescue ::Rex::ConnectionError, ::IOError, ::Errno::ECONNRESET\n    rescue ::Exception => e\n      print_error(\"#{ip}: #{e} #{e.backtrace}\")\n    ensure\n      disconnect\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        "h00die",
        ""
    ]
}