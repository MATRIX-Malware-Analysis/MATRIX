{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bd1bdb2a-788b-4818-b6da-5918f7ba5257",
    "created": "2024-08-14T16:33:19.155184Z",
    "modified": "2024-08-14T16:33:19.155187Z",
    "name": "Reverse Lookup IP Addresses",
    "description": " This module reverse resolves an IP address or IP address range to hostnames.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/recon/reverse_lookup.rb",
            "external_id": "reverse_lookup.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Common\n  include Msf::Exploit::Deprecated\n  moved_from 'post/windows/gather/reverse_lookup'\n  moved_from 'post/windows/recon/resolve_ip'\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Reverse Lookup IP Addresses',\n        'Description' => %q{\n          This module reverse resolves an IP address or IP address range to hostnames.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'mubix' ],\n        'Platform' => %w[win unix linux osx solaris bsd],\n        'SessionTypes' => %w[meterpreter powershell shell],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => []\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n              stdapi_railgun_memread\n            ]\n          }\n        }\n      )\n    )\n    register_options([\n      OptAddress.new('ADDRESS', [ false, 'IP address to resolve']),\n      OptAddressRange.new('RANGE', [ false, 'IP address range to resolve'])\n    ])\n  end\n\n  def resolve_ip(ip)\n    return unless Rex::Socket.dotted_ip?(ip)\n\n    session.platform == 'windows' ? win_resolve_ip(ip) : unix_resolve_ip(ip)\n  end\n\n  def unix_resolve_ip(ip)\n    return unless Rex::Socket.dotted_ip?(ip)\n\n    res = cmd_exec(\"host #{ip}\")\n\n    return if res.blank?\n\n    hostname = res.split(\"\\n\").first.split(' ').last\n\n    if hostname.blank? || !hostname.ends_with?('.')\n      print_error(\"Failed to resolve #{ip}\")\n      return\n    end\n\n    hostname.chomp('.')\n  end\n\n  def win_resolve_ip(ip)\n    return unless Rex::Socket.dotted_ip?(ip)\n\n    case session.type\n    when 'powershell'\n      host = cmd_exec(\"[System.Net.Dns]::GetHostEntry('#{ip}').HostName\").to_s\n\n      if host.blank?\n        print_error(\"Failed to resolve #{ip}\")\n        return\n      end\n\n      return host\n    when 'meterpreter'\n      ip_ino = Rex::Socket.addr_aton(ip)\n\n      result = client.railgun.ws2_32.gethostbyaddr(ip_ino, ip_ino.size, 2)\n\n      if result.blank? || result['return'] == 0\n        print_error(\"Failed to resolve #{ip}\")\n        return\n      end\n\n      memtext = client.railgun.memread(result['return'], 255)\n\n      unless memtext.include?(ip_ino)\n        print_error(\"Failed to resolve #{ip}\")\n        return\n      end\n\n      host = memtext.split(ip_ino)[1].split(\"\\00\")[0]\n\n      if host.blank?\n        print_error(\"Failed to resolve #{ip}\")\n        return\n      end\n\n      return host\n    else\n      fail_with(Failure::BadConfig, \"Unsupported sesssion type #{session.type}\")\n    end\n  rescue Rex::Post::Meterpreter::RequestError, Errno::ETIMEDOUT\n    print_error(\"Failed to resolve #{ip}\")\n    nil\n  end\n\n  def run\n    address = datastore['ADDRESS']\n    range = datastore['RANGE']\n\n    fail_with(Failure::BadConfig, 'ADDRESS or RANGE option must be set.') if address.blank? && range.blank?\n\n    if session.platform == 'windows'\n      if session.type == 'meterpreter'\n        # Add ws2_32 just in case it isn't there...\n        session.railgun.ws2_32\n\n        # Check if gethostbyaddr is available\n        modhandle = session.railgun.kernel32.GetModuleHandleA('ws2_32.dll')\n        if modhandle['return'] == 0\n          fail_with(Failure::Unknown, 'WS2_32 is not available at this time, exiting')\n        end\n\n        procaddr = session.railgun.kernel32.GetProcAddress(modhandle['return'], 'gethostbyaddr')\n        if procaddr['return'] == 0\n          fail_with(Failure::Unknown, 'WS2_32 was loaded but does not have the gethostbyaddr function, exiting')\n        end\n      end\n    else\n      fail_with(Failure::NoTarget, \"`host' command not found\") unless command_exists?('host')\n    end\n\n    unless address.blank?\n      print_status(\"Resolving #{address}\")\n      host = resolve_ip(address)\n      print_good(\"#{address} resolves to #{host}\") unless host.blank?\n    end\n\n    unless range.blank?\n      rex_range = Rex::Socket::RangeWalker.new(range)\n      print_status(\"Resolving #{range} (#{rex_range.num_ips} hosts)\")\n      rex_range.each do |ip|\n        host = resolve_ip(ip)\n        print_good(\"#{ip} resolves to #{host}\") unless host.blank?\n      end\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "%w[win unix linux osx solaris bsd]"
    ]
}