{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--202fe2af-244a-4132-8605-c445e81ddf82",
    "created": "2024-08-14T16:28:49.110534Z",
    "modified": "2024-08-14T16:28:49.110538Z",
    "name": "HTTP Header Detection",
    "description": "This module shows HTTP Headers returned by the scanned systems.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/http_header.rb",
            "external_id": "http_header.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html"
        },
        {
            "source_name": "reference",
            "url": "https://en.wikipedia.org/wiki/List_of_HTTP_header_fields"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'        => 'HTTP Header Detection',\n      'Description' => %q{ This module shows HTTP Headers returned by the scanned systems. },\n      'Author'      =>\n      [\n        'Christian Mehlmauer',\n        'rick2600'\n      ],\n      'References'  =>\n      [\n        ['URL', 'http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html'],\n        ['URL', 'https://en.wikipedia.org/wiki/List_of_HTTP_header_fields']\n      ],\n      'License'     => MSF_LICENSE\n    ))\n\n    register_options([\n      OptString.new('IGN_HEADER', [ true, 'List of headers to ignore, separated by comma',\n        'Vary,Date,Content-Length,Connection,Etag,Expires,Pragma,Accept-Ranges']),\n      OptEnum.new('HTTP_METHOD', [ true, 'HTTP Method to use, HEAD or GET', 'HEAD', ['GET', 'HEAD'] ]),\n      OptString.new('TARGETURI', [ true, 'The URI to use', '/'])\n    ])\n  end\n\n  def run_host(ip)\n    ignored_headers = datastore['IGN_HEADER'].split(',')\n\n    uri = normalize_uri(target_uri.path)\n    method = datastore['HTTP_METHOD']\n    vprint_status(\"#{peer}: requesting #{uri} via #{method}\")\n    res = send_request_raw({\n      'method'  => method,\n      'uri'     => uri\n    })\n\n    unless res\n      vprint_error(\"#{peer}: connection timed out\")\n      return\n    end\n\n    headers = res.headers\n    unless headers\n      vprint_status(\"#{peer}: no headers returned\")\n      return\n    end\n\n    # Header Names are case insensitve so convert them to upcase\n    headers_uppercase = headers.inject({}) do |hash, keys|\n      hash[keys[0].upcase] = keys[1]\n      hash\n    end\n\n    ignored_headers.each do |h|\n      if headers_uppercase.has_key?(h.upcase)\n        vprint_status(\"#{peer}: deleted header #{h}\")\n        headers_uppercase.delete(h.upcase)\n      end\n    end\n    headers_uppercase.to_a.compact.sort\n\n    counter = 0;\n    headers_uppercase.each do |h|\n      header_string = \"#{h[0]}: #{h[1]}\"\n      print_good \"#{peer}: #{header_string}\"\n\n      report_note(\n        :type => \"http.header.#{rport}.#{counter}\",\n        :data => header_string,\n        :host => ip,\n        :port => rport\n      )\n      counter = counter + 1\n    end\n    if counter == 0\n      print_warning \"#{peer}: all detected headers are defined in IGN_HEADER and were ignored \"\n    else\n      print_good \"#{peer}: detected #{counter} headers\"\n    end\n  end\nend\n"
}