{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--55eceaba-0728-47ac-bc5e-88babc4dbb24",
    "created": "2024-08-14T16:26:32.03502Z",
    "modified": "2024-08-14T16:26:32.035024Z",
    "name": "DNS Amplification Scanner",
    "description": " This module can be used to discover DNS servers which expose recursive name lookups which can be used in an amplification attack against a third party. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/dns/dns_amp.rb",
            "external_id": "dns_amp.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2006-0987"
        },
        {
            "source_name": "CVE",
            "external_id": "2006-0988"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Capture\n  include Msf::Auxiliary::UDPScanner\n  include Msf::Auxiliary::DRDoS\n\n  def initialize\n    super(\n      'Name'        => 'DNS Amplification Scanner',\n      'Description' => %q{\n          This module can be used to discover DNS servers which expose recursive\n          name lookups which can be used in an amplification attack against a\n          third party.\n      },\n      'Author'      => [ 'xistence <xistence[at]0x90.nl>'], # Original scanner module\n      'License'     => MSF_LICENSE,\n      'References'  =>\n          [\n              ['CVE', '2006-0987'],\n              ['CVE', '2006-0988'],\n          ]\n    )\n\n    register_options( [\n      Opt::RPORT(53),\n      OptString.new('DOMAINNAME', [true, 'Domain to use for the DNS request', 'isc.org' ]),\n      OptString.new('QUERYTYPE', [true, 'Query type(A, NS, SOA, MX, TXT, AAAA, RRSIG, DNSKEY, ANY)', 'ANY' ]),\n    ])\n  end\n\n  def rport\n    datastore['RPORT']\n  end\n\n  def setup\n    super\n\n    # Check for DNS query types byte\n    case datastore['QUERYTYPE']\n    when 'A'\n      querypacket=\"\\x01\"\n    when 'NS'\n      querypacket=\"\\x02\"\n    when 'SOA'\n      querypacket=\"\\x06\"\n    when 'MX'\n      querypacket=\"\\x0f\"\n    when 'TXT'\n      querypacket=\"\\x10\"\n    when 'AAAA'\n      querypacket=\"\\x1c\"\n    when 'RRSIG'\n      querypacket=\"\\x2e\"\n    when 'DNSKEY'\n      querypacket=\"\\x30\"\n    when 'ANY'\n      querypacket=\"\\xff\"\n    else\n      print_error(\"Invalid query type!\")\n      return\n    end\n\n    targdomainpacket = []\n    # Before every part of the domainname there should be the length of that part (instead of a \".\")\n    # So isc.org divided is 3isc3org\n    datastore['DOMAINNAME'].split('.').each do |domainpart|\n      # The length of the domain part in hex\n      domainpartlength =  \"%02x\" % domainpart.length\n      # Convert the name part to a hex string\n      domainpart = domainpart.each_byte.map { |b| b.to_s(16) }.join()\n      # Combine the length of the name part and the name part\n      targdomainpacket.push(domainpartlength + domainpart)\n    end\n    # Convert the targdomainpacket to a string\n    targdomainpacket = targdomainpacket.join.to_s\n    # Create a correct hex character string to be used in the packet\n    targdomainpacket = targdomainpacket.scan(/../).map { |x| x.hex.chr }.join\n    # DNS Packet including our target domain and query type\n    @msearch_probe = \"\\x09\\x8d\\x01\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\" + targdomainpacket + \"\\x00\\x00\" + querypacket + \"\\x00\\x01\"\n  end\n\n  def scanner_prescan(batch)\n    print_status(\"Sending DNS probes to #{batch[0]}->#{batch[-1]} (#{batch.length} hosts)\")\n    # Standard packet is 60 bytes. Add the domain size to this\n    sendpacketsize = 60 + datastore['DOMAINNAME'].length\n    print_status(\"Sending #{sendpacketsize} bytes to each host using the IN #{datastore['QUERYTYPE']} #{datastore['DOMAINNAME']} request\")\n    @results = {}\n  end\n\n  def scan_host(ip)\n    if spoofed?\n      datastore['ScannerRecvWindow'] = 0\n      scanner_spoof_send(@msearch_probe, ip, datastore['RPORT'], datastore['SRCIP'], datastore['NUM_REQUESTS'])\n    else\n      scanner_send(@msearch_probe, ip, datastore['RPORT'])\n    end\n  end\n\n  def scanner_process(data, shost, sport)\n\n    # Check the response data for \\x09\\x8d and the next 2 bytes, which contain our DNS flags\n    if data =~/\\x09\\x8d(..)/\n      flags = $1\n      flags = flags.unpack('B*')[0].scan(/./)\n      # Query Response\n      qr = flags[0]\n      # Recursion Available\n      ra = flags[8]\n      # Response Code\n      rcode = flags[12] + flags[13] + flags[14] + flags[15]\n\n      # If these flags are set, we get a valid response\n      # don't test recursion available if correct answer received\n      # at least the case with bind and \"additional-from-cache no\" or version < 9.5+\n      if qr == \"1\" and rcode == \"0000\"\n        sendlength = 60 + datastore['DOMAINNAME'].length\n        receivelength = 42 + data.length\n        amp = receivelength / sendlength.to_f\n        print_good(\"#{shost}:#{datastore['RPORT']} - Response is #{receivelength} bytes [#{amp.round(2)}x Amplification]\")\n        report_service(:host => shost, :port => datastore['RPORT'], :proto => 'udp', :name => \"dns\")\n        report_vuln(\n          :host => shost,\n          :port => datastore['RPORT'],\n          :proto => 'udp', :name => \"DNS\",\n          :info => \"DNS amplification -  #{data.length} bytes [#{amp.round(2)}x Amplification]\",\n          :refs => self.references)\n      end\n\n      # If these flags are set, we get a valid response but recursion is not available\n      if qr == \"1\" and ra == \"0\" and rcode == \"0101\"\n        print_status(\"#{shost}:#{datastore['RPORT']} - Recursion not allowed\")\n        report_service(:host => shost, :port => datastore['RPORT'], :proto => 'udp', :name => \"dns\")\n      end\n    end\n  end\nend\n"
}