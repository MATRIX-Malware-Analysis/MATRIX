{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9c6c22ec-1102-4877-80bf-a2dcda8328a9",
    "created": "2024-08-14T16:32:53.759393Z",
    "modified": "2024-08-14T16:32:53.759397Z",
    "name": "Apply Pot File To Hashes",
    "description": "Q This module uses a John the Ripper or Hashcat .pot file to crack any password hashes in the creds database instantly.  JtR's --show functionality is used to help combine all the passwords into an easy to use format. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/analyze/apply_pot.rb",
            "external_id": "apply_pot.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::PasswordCracker\n\n  def initialize\n    super(\n      'Name'            => 'Apply Pot File To Hashes',\n      'Description'     => %Q{\n          This module uses a John the Ripper or Hashcat .pot file to crack any password\n        hashes in the creds database instantly.  JtR's --show functionality is used to\n        help combine all the passwords into an easy to use format.\n      },\n      'Author'          => ['h00die'],\n      'License'         => MSF_LICENSE,\n      'Actions'         =>\n        [\n          ['john', 'Description' => 'Use John the Ripper'],\n          # ['hashcat', 'Description' => 'Use Hashcat'], # removed for simplicity\n        ],\n      'DefaultAction' => 'john',\n    )\n    deregister_options('ITERATION_TIMEOUT')\n    deregister_options('CUSTOM_WORDLIST')\n    deregister_options('KORELOGIC')\n    deregister_options('MUTATE')\n    deregister_options('USE_CREDS')\n    deregister_options('USE_DB_INFO')\n    deregister_options('USE_DEFAULT_WORDLIST')\n    deregister_options('USE_ROOT_WORDS')\n    deregister_options('USE_HOSTNAMES')\n\n  end\n\n  # Not all hash formats include an 'id' field, which coresponds which db entry\n  # an item is to its hash.  This can be problematic, especially when a username\n  # is used as a salt.  Due to all the variations, we make a small HashLookup\n  # class to handle all the fields for easier lookup later.\n  class HashLookup\n    attr_accessor :db_hash\n    attr_accessor :jtr_hash\n    attr_accessor :username\n    attr_accessor :id\n\n    def initialize(db_hash, jtr_hash, username, id)\n      @db_hash = db_hash\n      @jtr_hash = jtr_hash\n      @username = username\n      @id = id\n    end\n  end\n\n  def show_run_command(cracker_instance)\n    return unless datastore['ShowCommand']\n    cmd = cracker_instance.show_command\n    print_status(\"   Cracking Command: #{cmd.join(' ')}\")\n  end\n\n  def run\n    cracker = new_password_cracker(action.name)\n\n    lookups = []\n\n    # create one massive hash file with all the hashes\n    hashlist = Rex::Quickfile.new(\"hashes_tmp\")\n    framework.db.creds(workspace: myworkspace).each do |core|\n      next if core.private.type == 'Metasploit::Credential::Password'\n      jtr_hash = Metasploit::Framework::PasswordCracker::JtR::Formatter.hash_to_jtr(core)\n      hashlist.puts jtr_hash\n      lookups << HashLookup.new(core.private.data, jtr_hash, core.public, core.id)\n    end\n    hashlist.close\n    cracker.hash_path = hashlist.path\n    print_status \"Hashes Written out to #{hashlist.path}\"\n    cleanup_files = [cracker.hash_path]\n\n    # cycle through all hash types we dump asking jtr to show us\n    # cracked passwords.  The advantage to this vs just comparing\n    # john.pot to the hashes directly is we use jtr to recombine\n    # lanman, and other assorted nuances\n    ['bcrypt', 'bsdicrypt', 'crypt', 'descrypt', 'lm', 'nt',\n     'md5crypt', 'mysql', 'mysql-sha1', 'mssql', 'mssql05', 'mssql12',\n     'oracle', 'oracle11', 'oracle12c', 'dynamic_1506', #oracles\n     'dynamic_1034' #postgres\n      ].each do |format|\n\n      print_status(\"Checking #{format} hashes against pot file\")\n      cracker.format = format\n      show_run_command(cracker)\n      cracker.each_cracked_password.each do |password_line|\n        password_line.chomp!\n        next if password_line.blank? || password_line.nil?\n        fields = password_line.split(\":\")\n        core_id = nil\n        case format\n        when 'descrypt'\n          next unless fields.count >=3\n          username = fields.shift\n          core_id  = fields.pop\n          4.times { fields.pop } # Get rid of extra :\n        when 'md5crypt', 'descrypt', 'bsdicrypt', 'crypt', 'bcrypt'\n          next unless fields.count >=7\n          username = fields.shift\n          core_id  = fields.pop\n          4.times { fields.pop }\n        when 'mssql', 'mssql05', 'mssql12', 'mysql', 'mysql-sha1',\n             'oracle', 'dynamic_1506', 'oracle11', 'oracle12c'\n          next unless fields.count >=3\n          username = fields.shift\n          core_id  = fields.pop\n        when 'dynamic_1506' #oracle H code\n          next unless fields.count >=3\n          username = fields.shift\n          core_id  = fields.pop\n        when 'dynamic_1034' #postgres\n          next unless fields.count >=2\n          username = fields.shift\n          password = fields.join(':')\n          # unfortunately to match up all the fields we need to pull the hash\n          # field as well, and it is only available in the pot file.\n          pot = cracker.pot || cracker.john_pot_file\n\n          File.open(pot, 'rb').each do |line|\n            if line.start_with?('$dynamic_1034$') #postgres format\n              lookups.each do |l|\n                pot_hash = line.split(\":\")[0]\n                raw_pot_hash = pot_hash.split('$')[2]\n                if l.username.to_s == username &&\n                     l.jtr_hash == \"#{username}:$dynamic_1034$#{raw_pot_hash}\" &&\n                     l.db_hash  == raw_pot_hash\n                   core_id = l.id\n                   break\n                end\n              end\n            end\n          end\n        when 'lm', 'nt'\n          next unless fields.count >=7\n          username = fields.shift\n          core_id = fields.pop\n          2.times{ fields.pop }\n          # get the NT and LM hashes\n          nt_hash = fields.pop\n          lm_hash = fields.pop\n          core_id = fields.pop\n          password = fields.join(':')\n          if format == 'lm'\n            if password.blank?\n              if nt_hash == Metasploit::Credential::NTLMHash::BLANK_NT_HASH\n                password = ''\n              else\n                next\n              end\n            end\n            password = john_lm_upper_to_ntlm(password, nt_hash)\n            next if password.nil?\n          end\n          fields = password.split(':') #for consistency on the following join out of the case\n        end\n        unless core_id.nil?\n          password = fields.join(':')\n          print_good \"#{username}:#{password}\"\n          create_cracked_credential( username: username, password: password, core_id: core_id)\n        end\n      end\n    end\n    if datastore['DeleteTempFiles']\n      cleanup_files.each do |f|\n        File.delete(f)\n      end\n    end\n  end\nend\n"
}