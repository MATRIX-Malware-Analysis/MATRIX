{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d4cf6718-e8c5-46a5-bcfe-d95da6f8d485",
    "created": "2024-08-14T16:31:31.353897Z",
    "modified": "2024-08-14T16:31:31.353901Z",
    "name": "Elasticsearch Enumeration Utility",
    "description": " This module enumerates Elasticsearch instances. It uses the REST API in order to gather information about the server, the cluster, nodes in the cluster, indicies, and pull data from those indicies. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/elasticsearch_enum.rb",
            "external_id": "elasticsearch_enum.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/rest-apis.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include Msf::Module::Deprecated\n\n  moved_from 'auxiliary/scanner/elasticsearch/indices_enum'\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Elasticsearch Enumeration Utility',\n        'Description' => %q{\n          This module enumerates Elasticsearch instances. It uses the REST API\n          in order to gather information about the server, the cluster, nodes,\n          in the cluster, indicies, and pull data from those indicies.\n        },\n        'Author' => [\n          'Silas Cutler <Silas.Cutler[at]BlackListThisDomain.com>', # original indicies enum module\n          'h00die' # generic enum module\n        ],\n        'References' => [\n          ['URL', 'https://www.elastic.co/guide/en/elasticsearch/reference/current/rest-apis.html']\n        ],\n        'License' => MSF_LICENSE,\n        'DefaultOptions' => {\n          'SSL' => true\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(9200),\n        OptString.new('USERNAME', [false, 'A specific username to authenticate as', '']),\n        OptString.new('PASSWORD', [false, 'A specific password to authenticate as', '']),\n        OptInt.new('DOWNLOADROWS', [true, 'Number of beginning and ending rows to download per index', 5])\n      ]\n    )\n  end\n\n  def get_results(index)\n    vprint_status(\"Downloading #{datastore['DOWNLOADROWS']} rows from index #{index}\")\n    body = { 'query' => { 'query_string' => { 'query' => '*' } }, 'size' => datastore['DOWNLOADROWS'], 'from' => 0, 'sort' => [] }\n    request = {\n      'uri' => normalize_uri(target_uri.path, index, '_search/'),\n      'method' => 'POST',\n      'headers' => {\n        'Accept' => 'application/json'\n      },\n      'ctype' => 'application/json',\n      'data' => body.to_json\n    }\n    request['authorization'] = basic_auth(datastore['USERNAME'], datastore['PASSWORD']) if datastore['USERNAME'] || datastore['PASSWORD']\n\n    res = send_request_cgi(request)\n    vprint_error('Unable to establish connection') if res.nil?\n\n    if res && res.code == 200 && !res.body.empty?\n      json_body = res.get_json_document\n      if json_body.empty?\n        vprint_error('Unable to parse JSON')\n        return\n      end\n    else\n      vprint_error('Timeout or unexpected response...')\n      return\n    end\n\n    columns = json_body.dig('hits', 'hits')[0]['_source'].keys\n    elastic_table = Rex::Text::Table.new(\n      'Header' => \"#{index} Data\",\n      'Indent' => 2,\n      # we know at least 1 row since we wouldn't query an index w/o a row\n      'Columns' => columns\n    )\n    json_body.dig('hits', 'hits').each do |hash|\n      elastic_table << columns.map { |column| hash['_source'][column] }\n    end\n\n    l = store_loot('elasticserch.index.data', 'application/csv', rhost, elastic_table.to_csv, \"#{index}_data.csv\", nil, @service)\n    print_good(\"#{index} data stored to #{l}\")\n  end\n\n  def get_indices\n    vprint_status('Querying indices...')\n    request = {\n      'uri' => normalize_uri(target_uri.path, '_cat', 'indices/'),\n      'method' => 'GET',\n      'headers' => {\n        'Accept' => 'application/json'\n      },\n      'vars_get' => {\n        # this is the query https://github.com/cars10/elasticvue uses for the chrome browser extension\n        'h' => 'index,health,status,uuid,docs.count,store.size',\n        'bytes' => 'mb'\n      }\n    }\n    request['authorization'] = basic_auth(datastore['USERNAME'], datastore['PASSWORD']) if datastore['USERNAME'] || datastore['PASSWORD']\n\n    res = send_request_cgi(request)\n    vprint_error('Unable to establish connection') if res.nil?\n\n    if res && res.code == 200 && !res.body.empty?\n      json_body = res.get_json_document\n      if json_body.empty?\n        vprint_error('Unable to parse JSON')\n        return\n      end\n    else\n      vprint_error('Timeout or unexpected response...')\n      return\n    end\n\n    elastic_table = Rex::Text::Table.new(\n      'Header' => 'Indicies Information',\n      'Indent' => 2,\n      'Columns' =>\n      [\n        'Name',\n        'Health',\n        'Status',\n        'UUID',\n        'Documents',\n        'Storage Usage (MB)'\n      ]\n    )\n\n    indicies = []\n\n    json_body.each do |index|\n      next if datastore['VERBOSE'] == false && index['index'].starts_with?('.fleet')\n\n      indicies << index['index'] if index['docs.count'].to_i > 0 # avoid querying something with no data\n      elastic_table << [\n        index['index'],\n        index['health'],\n        index['status'],\n        index['uuid'],\n        index['docs.count'],\n        \"#{index['store.size']}MB\"\n      ]\n      report_note(\n        host: rhost,\n        port: rport,\n        proto: 'tcp',\n        type: 'elasticsearch.index',\n        data: index[0],\n        update: :unique_data\n      )\n    end\n\n    print_good(elastic_table.to_s)\n    indicies.each do |index|\n      get_results(index)\n    end\n  end\n\n  def get_cluster_info\n    vprint_status('Querying cluster information...')\n    request = {\n      'uri' => normalize_uri(target_uri.path, '_cluster', 'health'),\n      'method' => 'GET'\n    }\n    request['authorization'] = basic_auth(datastore['USERNAME'], datastore['PASSWORD']) if datastore['USERNAME'] || datastore['PASSWORD']\n\n    res = send_request_cgi(request)\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::NoAccess, 'Credentials required, or incorrect') if res.code == 401\n\n    if res.code == 200 && !res.body.empty?\n      json_body = res.get_json_document\n      if json_body.empty?\n        vprint_error('Unable to parse JSON')\n        return\n      end\n    end\n\n    elastic_table = Rex::Text::Table.new(\n      'Header' => 'Cluster Information',\n      'Indent' => 2,\n      'Columns' =>\n      [\n        'Cluster Name',\n        'Status',\n        'Number of Nodes'\n      ]\n    )\n\n    elastic_table << [\n      json_body['cluster_name'],\n      json_body['status'],\n      json_body['number_of_nodes']\n    ]\n    print_good(elastic_table.to_s)\n  end\n\n  def get_node_info\n    vprint_status('Querying node information...')\n    request = {\n      'uri' => normalize_uri(target_uri.path, '_cat', 'nodes'),\n      'method' => 'GET',\n      'headers' => {\n        'Accept' => 'application/json'\n      },\n      'vars_get' => {\n        'h' => 'ip,port,version,http,uptime,name,heap.current,heap.max,ram.current,ram.max,node.role,master,cpu,disk.used,disk.total'\n      }\n    }\n    request['authorization'] = basic_auth(datastore['USERNAME'], datastore['PASSWORD']) if datastore['USERNAME'] || datastore['PASSWORD']\n\n    res = send_request_cgi(request)\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::NoAccess, 'Credentials required, or incorrect') if res.code == 401\n\n    if res.code == 200 && !res.body.empty?\n      json_body = res.get_json_document\n      if json_body.empty?\n        vprint_error('Unable to parse JSON')\n        return\n      end\n    end\n\n    elastic_table = Rex::Text::Table.new(\n      'Header' => 'Node Information',\n      'Indent' => 2,\n      'Columns' =>\n      [\n        'IP',\n        'Transport Port',\n        'HTTP Port',\n        'Version',\n        'Name',\n        'Uptime',\n        'Ram Usage',\n        'Node Role',\n        'Master',\n        'CPU Load',\n        'Disk Usage'\n      ]\n    )\n    json_body.each do |node|\n      report_service(\n        host: node['ip'],\n        port: node['port'],\n        proto: 'tcp',\n        name: 'elasticsearch'\n      )\n      report_service(\n        host: node['ip'],\n        port: node['http'].split(':')[1],\n        proto: 'tcp',\n        name: 'elasticsearch'\n      )\n      elastic_table << [\n        node['ip'],\n        node['port'],\n        node['http'],\n        node['version'],\n        node['name'],\n        node['uptime'],\n        \"#{node['ram.current']}/#{node['ram.max']}\",\n        node['node.role'],\n        node['master'],\n        \"#{node['cpu']}%\",\n        \"#{node['disk.used']}/#{node['disk.total']}\"\n      ]\n    end\n    print_good(elastic_table.to_s)\n  end\n\n  def get_version_info\n    vprint_status('Querying version information...')\n    request = {\n      'uri' => normalize_uri(target_uri.path),\n      'method' => 'GET'\n    }\n    request['authorization'] = basic_auth(datastore['USERNAME'], datastore['PASSWORD']) if datastore['USERNAME'] || datastore['PASSWORD']\n\n    res = send_request_cgi(request)\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::NoAccess, 'Credentials required, or incorrect') if res.code == 401\n\n    # leaving this here for future travelers, this header was added in 7.14.0 https://www.elastic.co/guide/en/elasticsearch/reference/7.17/release-notes-7.14.0.html\n    # so it isn't too reliable to check for\n    # fail_with(Failure::Unreachable, \"#{peer} - Elasticsearch not detected in X-elastic-product header\") unless res.headers['X-elastic-product'] == 'Elasticsearch'\n\n    if res.code == 200 && !res.body.empty?\n      json_body = res.get_json_document\n      if json_body.empty?\n        vprint_error('Unable to parse JSON')\n        return\n      end\n    end\n\n    fail_with(Failure::Unreachable, \"#{peer} - Elasticsearch cluster name not found, likely not Elasticsearch server\") unless json_body['cluster_name']\n\n    elastic_table = Rex::Text::Table.new(\n      'Header' => 'Elastic Information',\n      'Indent' => 2,\n      'Columns' =>\n      [\n        'Name',\n        'Cluster Name',\n        'Version',\n        'Build Type',\n        'Lucene Version'\n      ]\n    )\n\n    elastic_table << [\n      json_body['name'],\n      json_body['cluster_name'],\n      json_body.dig('version', 'number'),\n      json_body.dig('version', 'build_type'),\n      json_body.dig('version', 'lucene_version'),\n    ]\n    print_good(elastic_table.to_s)\n\n    @service = report_service(\n      host: rhost,\n      port: rport,\n      proto: 'tcp',\n      name: 'elasticsearch'\n    )\n  end\n\n  def get_users\n    vprint_status('Querying user information...')\n    request = {\n      'uri' => normalize_uri(target_uri.path, '_security', 'user/'),\n      'method' => 'GET'\n    }\n    request['authorization'] = basic_auth(datastore['USERNAME'], datastore['PASSWORD']) if datastore['USERNAME'] || datastore['PASSWORD']\n\n    res = send_request_cgi(request)\n\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::NoAccess, 'Credentials required, or incorrect') if res.code == 401\n\n    if res.code == 200 && !res.body.empty?\n      json_body = res.get_json_document\n      if json_body.empty?\n        vprint_error('Unable to parse JSON')\n        return\n      end\n    end\n\n    if json_body.nil?\n      print_bad('Unable to pull user data')\n      return\n    end\n\n    elastic_table = Rex::Text::Table.new(\n      'Header' => 'User Information',\n      'Indent' => 2,\n      'Columns' =>\n      [\n        'Name',\n        'Roles',\n        'Email',\n        'Metadata',\n        'Enabled'\n      ]\n    )\n\n    json_body.each do |username, attributes|\n      elastic_table << [\n        username,\n        attributes['roles'],\n        attributes['email'],\n        attributes['metadata'],\n        attributes['enabled'],\n      ]\n    end\n    print_good(elastic_table.to_s)\n  end\n\n  def run\n    get_version_info\n    get_node_info\n    get_cluster_info\n    get_indices\n    get_users\n  end\nend\n"
}