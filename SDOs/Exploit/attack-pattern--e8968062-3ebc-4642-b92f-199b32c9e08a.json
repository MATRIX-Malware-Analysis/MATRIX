{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e8968062-3ebc-4642-b92f-199b32c9e08a",
    "created": "2024-08-14T16:28:00.351956Z",
    "modified": "2024-08-14T16:28:00.35196Z",
    "name": "TFTP Brute Forcer",
    "description": "This module uses a dictionary to brute force valid TFTP image names from a TFTP server.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/tftp/tftpbrute.rb",
            "external_id": "tftpbrute.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'TFTP Brute Forcer',\n      'Description' => 'This module uses a dictionary to brute force valid TFTP image names from a TFTP server.',\n      'Author'      => 'antoine',\n      'License'     => BSD_LICENSE\n    )\n\n    register_options(\n      [\n        Opt::RPORT(69),\n        Opt::CHOST,\n        OptPath.new('DICTIONARY', [ true, 'The list of filenames',\n          File.join(Msf::Config.data_directory, \"wordlists\", \"tftp.txt\") ])\n      ])\n  end\n\n  def run_host(ip)\n    begin\n\n      # Create an unbound UDP socket if no CHOST is specified, otherwise\n      # create a UDP socket bound to CHOST (in order to avail of pivoting)\n      udp_sock = Rex::Socket::Udp.create(\n        {\n          'LocalHost' => datastore['CHOST'] || nil,\n          'Context'   =>\n            {\n              'Msf'        => framework,\n              'MsfExploit' => self,\n            }\n        }\n      )\n      add_socket(udp_sock)\n\n      fd = File.open(datastore['DICTIONARY'], 'rb')\n      fd.read(fd.stat.size).split(\"\\n\").each do |filename|\n        filename.strip!\n        pkt = \"\\x00\\x01\" + filename + \"\\x00\" + \"netascii\" + \"\\x00\"\n        udp_sock.sendto(pkt, ip, datastore['RPORT'])\n        resp = udp_sock.get(3)\n        if resp and resp.length >= 2 and resp[0, 2] == \"\\x00\\x03\"\n          print_good(\"Found #{filename} on #{ip}\")\n          #Add Report\n          report_note(\n            :host\t=> ip,\n            :proto => 'udp',\n            :sname\t=> 'tftp',\n            :port\t=> datastore['RPORT'],\n            :type\t=> \"Found #{filename}\",\n            :data\t=> \"Found #{filename}\"\n          )\n        end\n      end\n      fd.close\n    rescue\n    ensure\n      udp_sock.close\n    end\n  end\nend\n"
}