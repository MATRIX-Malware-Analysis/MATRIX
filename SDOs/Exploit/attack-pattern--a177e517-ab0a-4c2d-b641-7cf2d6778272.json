{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a177e517-ab0a-4c2d-b641-7cf2d6778272",
    "created": "2024-08-14T16:26:36.48179Z",
    "modified": "2024-08-14T16:26:36.481793Z",
    "name": "Telephone Line Voice Scanner",
    "description": "This module dials a range of phone numbers and records audio from each answered call",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/voice/recorder.rb",
            "external_id": "recorder.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'fileutils'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::IAX2\n\n  def initialize\n    super(\n      'Name'           => 'Telephone Line Voice Scanner',\n      'Description'    => 'This module dials a range of phone numbers and records audio from each answered call',\n      'Author'         => [ 'hdm' ],\n      'License'        => MSF_LICENSE,\n      'References'     => [  ]\n    )\n    register_options([\n      OptString.new('TARGETS', [true, \"A list of telephone masks in the format of 1-555-555-5XXX, separated by commas\"]),\n      OptString.new('OUTPUT_PATH', [true, \"A local directory to store the resulting audio files\"]),\n      OptInt.new('CALL_TIME', [true, \"The maximum time in seconds to spent on each call (ring + recording)\", 52])\n    ])\n  end\n\n  def run\n    targets = crack_phone_ranges(datastore['TARGETS'].split(\",\"))\n    connect\n\n    ::FileUtils.mkdir_p( datastore['OUTPUT_PATH'] )\n\n    targets.each do |number|\n\n      c = create_call\n      begin\n        ::Timeout.timeout( datastore['CALL_TIME'] ) do\n          print_status(\"Dialing #{number}...\")\n          r = c.dial(number)\n          if not c\n            print_error(\"Failed to call #{number}\")\n            next\n          end\n          lstate = c.state\n          while c.state != :hangup\n            print_status(\"  Number: #{number}  State: #{c.state}  Frames: #{c.audio_buff.length}  DTMF: '#{c.dtmf}'\")\n            ::IO.select(nil, nil, nil, 1.0)\n          end\n        end\n      rescue ::Timeout::Error\n        # Timeouts are A-OK\n      ensure\n        c.hangup rescue nil\n      end\n\n      print_status(\"  COMPLETED   Number: #{number}  State: #{c.state}  Frames: #{c.audio_buff.length}  DTMF: '#{c.dtmf}'\")\n\n      if c.audio_buff.length > 0\n        opath = ::File.join( datastore['OUTPUT_PATH'], \"#{number}.raw\" )\n        cnt   = 0\n        ::File.open(opath, 'wb') do |fd|\n          c.audio_buff.each do |raw|\n            cnt += raw.length\n            fd.write(raw)\n          end\n        end\n        print_good(\"#{number} resulted in #{cnt} bytes of audio saved to #{opath}\")\n      end\n      # Next call\n    end\n  end\nend\n"
}