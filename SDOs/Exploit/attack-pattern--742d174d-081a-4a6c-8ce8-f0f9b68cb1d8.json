{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--742d174d-081a-4a6c-8ce8-f0f9b68cb1d8",
    "created": "2024-08-14T16:26:32.028213Z",
    "modified": "2024-08-14T16:26:32.028217Z",
    "name": "IPv6 Local Neighbor Discovery",
    "description": " Enumerate local IPv6 hosts which respond to Neighbor Solicitations with a link-local address. Note, that like ARP scanning, this usually cannot be performed beyond the local broadcast network. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/discovery/ipv6_neighbor.rb",
            "external_id": "ipv6_neighbor.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Ipv6\n  include Msf::Exploit::Remote::Capture\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n\n  def initialize\n    super(\n      'Name'        => 'IPv6 Local Neighbor Discovery',\n      'Description' => %q{\n        Enumerate local IPv6 hosts which respond to Neighbor Solicitations with a link-local address.\n        Note, that like ARP scanning, this usually cannot be performed beyond the local\n        broadcast network.\n    },\n    'Author'      => 'belch',\n    'License'     => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        OptString.new('SHOST', [false, \"Source IP Address\"]),\n        OptString.new('SMAC', [false, \"Source MAC Address\"]),\n        OptInt.new('TIMEOUT', [true, 'The number of seconds to wait for new data', 5]),\n    ])\n\n    deregister_options('SNAPLEN', 'FILTER')\n  end\n\n  def run_batch_size\n    datastore['BATCHSIZE'] || 256\n  end\n\n  def run_batch(hosts)\n    open_pcap({'SNAPLEN' => 68, 'FILTER' => \"arp[6:2] == 0x0002\"})\n\n    @netifaces = true\n    if not netifaces_implemented?\n      print_error(\"WARNING : Pcaprub is not uptodate, some functionality will not be available\")\n      @netifaces = false\n    end\n\n    print_status(\"Discovering IPv4 nodes via ARP...\")\n\n    @interface = datastore['INTERFACE'] || Pcap.lookupdev\n    @shost = datastore['SHOST']\n    @shost ||= get_ipv4_addr(@interface) if @netifaces\n    raise 'SHOST should be defined' unless @shost\n\n    @smac  = datastore['SMAC']\n    @smac ||= get_mac(@interface) if @netifaces\n    raise 'SMAC should be defined' unless @smac\n\n    addrs = []\n\n    begin\n      found = {}\n      hosts.each do |dhost|\n\n        probe = buildprobe(@shost, @smac, dhost)\n        capture.inject(probe)\n        while(reply = getreply())\n          next unless reply.is_arp?\n          if not found[reply.arp_saddr_ip]\n            print_good(sprintf(\"  %16s ALIVE\",reply.arp_saddr_ip))\n            addrs << [reply.arp_saddr_ip, reply.arp_saddr_mac]\n            report_host(:host => reply.arp_saddr_ip, :mac=>reply.arp_saddr_mac)\n            found[reply.arp_saddr_ip] = true\n          end\n        end\n      end\n\n      etime = ::Time.now.to_f + datastore['TIMEOUT']\n\n      while (::Time.now.to_f < etime)\n        while(reply = getreply())\n          next unless reply.is_arp?\n          if not found[reply.arp_saddr_ip]\n            print_good(sprintf(\"  %16s ALIVE\",reply.arp_saddr_ip))\n            addrs << [reply.arp_saddr_ip, reply.arp_saddr_mac]\n            report_host(:host => reply.arp_saddr_ip, :mac=>reply.arp_saddr_mac)\n            found[reply.arp_saddr_ip] = true\n          end\n        end\n\n        ::IO.select(nil, nil, nil, 0.50)\n      end\n\n    ensure\n      close_pcap()\n    end\n\n    neighbor_discovery(addrs)\n  end\n\n  def map_neighbor(nodes, adv)\n    nodes.each do |node|\n      ipv4_addr, mac_addr = node\n      next unless adv.eth_saddr == mac_addr\n      ipv6_addr = adv.ipv6_saddr\n      return {:eth => mac_addr, :ipv4 => ipv4_addr, :ipv6 => ipv6_addr}\n    end\n    nil\n  end\n\n  def neighbor_discovery(neighs)\n    print_status(\"Discovering IPv6 addresses for IPv4 nodes...\")\n    print_status(\"\")\n\n    smac  = @smac\n    open_pcap({'SNAPLEN' => 68, 'FILTER' => \"icmp6\"})\n\n    begin\n      neighs.each do |neigh|\n        host, dmac = neigh\n\n        shost = ipv6_linklocaladdr(smac)\n        neigh = ipv6_linklocaladdr(dmac)\n\n        probe = buildsolicitation(smac, shost, neigh)\n\n        capture.inject(probe)\n        Kernel.select(nil,nil,nil,0.1)\n\n        while(adv = getadvertisement())\n          next unless adv.is_ipv6?\n\n          addr = map_neighbor(neighs, adv)\n          next if not addr\n\n          print_status(sprintf(\"  %16s maps to %s\",addr[:ipv4], addr[:ipv6]))\n          report_note(\n            :host   => addr[:ipv4],\n            :type   => 'host.ipv4.ipv6.mapping',\n            :data   => \"system with IPv4 address #{addr[:ipv4]} matches to IPv6 address #{addr[:ipv6]}\"\n          )\t# with this we have the results in our database\n\n        end\n      end\n\n      etime = ::Time.now.to_f + (neighs.length * 0.5)\n\n      while (::Time.now.to_f < etime)\n        while(adv = getadvertisement())\n          next if not adv\n\n          addr = map_neighbor(neighs, adv)\n          next if not addr\n\n          print_status(sprintf(\"  %16s maps to %s\",addr[:ipv4], addr[:ipv6]))\n        end\n        ::IO.select(nil, nil, nil, 0.50)\n      end\n\n    ensure\n      close_pcap()\n    end\n  end\n\n  def buildprobe(shost, smac, dhost)\n    p = PacketFu::ARPPacket.new\n    p.eth_saddr = smac\n    p.eth_daddr = \"ff:ff:ff:ff:ff:ff\"\n    p.arp_opcode = 1\n    p.arp_saddr_mac = p.eth_saddr\n    p.arp_daddr_mac = p.eth_daddr\n    p.arp_saddr_ip = shost\n    p.arp_daddr_ip = dhost\n    p.to_s\n  end\n\n  def getreply\n    pkt = capture.next\n    Kernel.select(nil,nil,nil,0.1)\n    return if not pkt\n    p = PacketFu::Packet.parse(pkt)\n    return unless p.is_arp?\n    return unless p.arp_opcode == 2\n    p\n  end\n\n  def buildsolicitation(smac, shost, neigh)\n    dmac = ipv6_soll_mcast_mac(neigh)\n    dhost = ipv6_soll_mcast_addr6(neigh)\n\n    p = PacketFu::IPv6Packet.new\n    p.eth_saddr = smac\n    p.eth_daddr = dmac\n    p.ipv6_saddr = shost\n    p.ipv6_daddr = dhost\n    p.ipv6_next = 0x3a\n    p.ipv6_hop = 255\n    p.payload = ipv6_neighbor_solicitation(\n      IPAddr.new(neigh).to_i,\n      p.eth_src\n    )\n    p.ipv6_len = p.payload.size\n    ipv6_checksum!(p)\n    p.to_s\n  end\n\n  def getadvertisement\n    pkt = capture.next\n    Kernel.select(nil,nil,nil,0.1)\n    return if not pkt\n    p = PacketFu::Packet.parse(pkt)\n    return unless p.is_ipv6?\n    return unless p.ipv6_next == 0x3a\n    return unless p.icmpv6_type == 136 && p.icmpv6_code == 0\n    p\n  end\nend\n"
}