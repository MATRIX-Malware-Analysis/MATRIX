{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--23c0e5ab-ffc6-4ed4-8fff-3a1760fe60a2",
    "created": "2024-08-14T16:31:22.452869Z",
    "modified": "2024-08-14T16:31:22.452873Z",
    "name": "FTP Bounce Port Scanner",
    "description": " Enumerate TCP services via the FTP bounce PORT/LIST method. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/portscan/ftpbounce.rb",
            "external_id": "ftpbounce.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  # Order is important here\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n  include Msf::Exploit::Remote::Ftp\n\n  def initialize\n    super(\n      'Name'        => 'FTP Bounce Port Scanner',\n      'Description' => %q{\n        Enumerate TCP services via the FTP bounce PORT/LIST\n        method.\n      },\n      'Author'      => 'kris katterjohn',\n      'License'     => MSF_LICENSE\n    )\n\n    register_options([\n      OptString.new('PORTS', [true, \"Ports to scan (e.g. 22-25,80,110-900)\", \"1-10000\"]),\n      OptAddress.new('BOUNCEHOST', [true, \"FTP relay host\"]),\n      OptPort.new('BOUNCEPORT', [true, \"FTP relay port\", 21]),\n      OptInt.new('DELAY', [true, \"The delay between connections, per thread, in milliseconds\", 0]),\n      OptInt.new('JITTER', [true, \"The delay jitter factor (maximum value by which to +/- DELAY) in milliseconds.\", 0])\n    ])\n\n    deregister_options('RPORT')\n  end\n\n  # No IPv6 support yet\n  def support_ipv6?\n    false\n  end\n\n  def rhost\n    datastore['BOUNCEHOST']\n  end\n\n  def rport\n    datastore['BOUNCEPORT']\n  end\n\n  def run_host(ip)\n    ports = Rex::Socket.portspec_crack(datastore['PORTS'])\n    if ports.empty?\n      raise Msf::OptionValidateError.new(['PORTS'])\n    end\n\n    jitter_value = datastore['JITTER'].to_i\n    if jitter_value < 0\n      raise Msf::OptionValidateError.new(['JITTER'])\n    end\n\n    delay_value = datastore['DELAY'].to_i\n    if delay_value < 0\n      raise Msf::OptionValidateError.new(['DELAY'])\n    end\n\n    return if not connect_login\n\n    ports.each do |port|\n      # Clear out the receive buffer since we're heavily dependent\n      # on the response codes.  We need to do this between every\n      # port scan attempt unfortunately.\n      while true\n        r = sock.get_once(-1, 0.25)\n        break if not r or r.empty?\n      end\n\n      begin\n\n        # Add the delay based on JITTER and DELAY if needs be\n        add_delay_jitter(delay_value,jitter_value)\n\n        host = (ip.split('.') + [port / 256, port % 256]).join(',')\n        resp = send_cmd([\"PORT\", host])\n\n        if resp =~ /^5/\n          #print_error(\"Got error from PORT to #{ip}:#{port}\")\n          next\n        elsif not resp\n          next\n        end\n\n        resp = send_cmd([\"LIST\"])\n\n        if resp =~ /^[12]/\n          print_good(\" TCP OPEN #{ip}:#{port}\")\n          report_service(:host => ip, :port => port)\n        end\n      rescue ::Exception\n        print_error(\"Unknown error: #{$!}\")\n      end\n    end\n  end\nend\n"
}