{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--854cd157-9c56-42b0-9e55-359adb086c58",
    "created": "2024-08-14T16:26:52.946939Z",
    "modified": "2024-08-14T16:26:52.946943Z",
    "name": "Hidden DCERPC Service Discovery",
    "description": " This module will query the endpoint mapper and make a list of all ncacn_tcp RPC services. It will then connect to each of these services and use the management API to list all other RPC services accessible on this port. Any RPC service found attached to a TCP port, but not listed in the endpoint mapper, will be displayed and analyzed to see whether anonymous access is permitted. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/dcerpc/hidden.rb",
            "external_id": "hidden.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  # Exploit mixins should be called first\n  include Msf::Exploit::Remote::DCERPC\n\n  include Msf::Auxiliary::Report\n\n  # Scanner mixin should be near last\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name' => 'Hidden DCERPC Service Discovery',\n      'Description' => %q{\n        This module will query the endpoint mapper and make a list\n      of all ncacn_tcp RPC services. It will then connect to each of\n      these services and use the management API to list all other\n      RPC services accessible on this port. Any RPC service found attached\n      to a TCP port, but not listed in the endpoint mapper, will be displayed\n      and analyzed to see whether anonymous access is permitted.\n      },\n      'Author' => 'hdm',\n      'License' => MSF_LICENSE\n    )\n\n    deregister_options('RPORT')\n  end\n\n  # Obtain information about a single host\n  def run_host(ip)\n    epm = dcerpc_endpoint_list\n    if !epm\n      print_status(\"Could not contact the endpoint mapper on #{ip}\")\n      return\n    end\n\n    eports = {}\n\n    epm.each do |ep|\n      next if !(ep[:port] && ep[:prot] && (ep[:prot] == 'tcp'))\n\n      eports[ep[:port]] ||= {}\n      eports[ep[:port]][ep[:uuid] + '_' + ep[:vers]] = true\n    end\n\n    eports.each_pair do |eport, servs|\n      rport = eport\n      print_status(\"Looking for services on #{ip}:#{rport}...\")\n\n      ids = dcerpc_mgmt_inq_if_ids(rport)\n      next if !ids\n\n      ids.each do |id|\n        next if servs.key?(id[0] + '_' + id[1])\n\n        print_status(\"\\tHIDDEN: UUID #{id[0]} v#{id[1]}\")\n\n        conn = nil\n        bind = nil\n        call = nil\n        data = nil\n        error = nil\n        begin\n          connect(true, { 'RPORT' => eport })\n          conn = true\n\n          handle = dcerpc_handle(id[0], id[1], 'ncacn_ip_tcp', [eport])\n          dcerpc_bind(handle)\n          bind = true\n\n          dcerpc.call(0, NDR.long(0) * 128)\n          call = true\n\n          if (!dcerpc.last_response.nil? && !dcerpc.last_response.stub_data.nil?)\n            data = dcerpc.last_response.stub_data\n          end\n        rescue ::Interrupt\n          raise $ERROR_INFO\n        rescue ::Exception => e\n          error = e.to_s\n        end\n\n        if error\n          if error =~ (/DCERPC FAULT/) && error !~ (/nca_s_fault_access_denied/)\n            call = true\n          else\n            elog(e)\n          end\n        end\n\n        status = \"\\t\\t\"\n        status << 'CONN ' if conn\n        status << 'BIND ' if bind\n        status << 'CALL ' if call\n        status << \"DATA=#{data.unpack('H*')[0]} \" if data\n        status << \"ERROR=#{error} \" if error\n\n        print_status(status)\n        print_status('')\n\n        ## Add Report\n        report_note(\n          host: ip,\n          proto: 'tcp',\n          port: datastore['RPORT'],\n          type: \"DCERPC HIDDEN: UUID #{id[0]} v#{id[1]}\",\n          data: status\n        )\n      end\n    end\n  rescue ::Interrupt\n    raise $ERROR_INFO\n  rescue ::Exception => e\n    print_status(\"Error: #{e}\")\n  end\n\nend\n"
}