{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--419357d5-ba30-44db-aca2-e82bdce7cf7b",
    "created": "2024-08-14T16:31:34.863288Z",
    "modified": "2024-08-14T16:31:34.863293Z",
    "name": "LDAP Query and Enumeration Module",
    "description": " This module allows users to query an LDAP server using either a custom LDAP query, or a set of LDAP queries under a specific category. Users can also specify a JSON or YAML file containing custom queries to be executed using the RUN_QUERY_FILE action. If this action is specified, then QUERY_FILE_PATH must be a path to the location of this JSON/YAML file on disk.  Users can also run a single query by using the RUN_SINGLE_QUERY option and then setting the QUERY_FILTER datastore option to the filter to send to the LDAP server and QUERY_ATTRIBUTES to a comma separated string containing the list of attributes they are interested in obtaining from the results.  As a third option can run one of several predefined queries by setting ACTION to the appropriate value. These options will be loaded from the ldap_queries_default.yaml file located in the MSF configuration directory, located by default at ~/.msf4/ldap_queries_default.yaml.  All results will be returned to the user in table, CSV or JSON format, depending on the value of the OUTPUT_FORMAT datastore option. The characters || will be used as a delimiter should multiple items exist within a single column. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/ldap_query.rb",
            "external_id": "ldap_query.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::LDAP\n  require 'json'\n  require 'yaml'\n\n  def initialize(info = {})\n    actions, default_action = initialize_actions\n\n    super(\n      update_info(\n        info,\n        'Name' => 'LDAP Query and Enumeration Module',\n        'Description' => %q{\n          This module allows users to query an LDAP server using either a custom LDAP query, or\n          a set of LDAP queries under a specific category. Users can also specify a JSON or YAML\n          file containing custom queries to be executed using the RUN_QUERY_FILE action.\n          If this action is specified, then QUERY_FILE_PATH must be a path to the location\n          of this JSON/YAML file on disk.\n\n          Users can also run a single query by using the RUN_SINGLE_QUERY option and then setting\n          the QUERY_FILTER datastore option to the filter to send to the LDAP server and QUERY_ATTRIBUTES\n          to a comma separated string containing the list of attributes they are interested in obtaining\n          from the results.\n\n          As a third option can run one of several predefined queries by setting ACTION to the\n          appropriate value. These options will be loaded from the ldap_queries_default.yaml file\n          located in the MSF configuration directory, located by default at ~/.msf4/ldap_queries_default.yaml.\n\n          All results will be returned to the user in table, CSV or JSON format, depending on the value\n          of the OUTPUT_FORMAT datastore option. The characters || will be used as a delimiter\n          should multiple items exist within a single column.\n        },\n        'Author' => [\n          'Grant Willcox', # Original module author\n        ],\n        'References' => [\n        ],\n        'DisclosureDate' => '2022-05-19',\n        'License' => MSF_LICENSE,\n        'Actions' => actions,\n        'DefaultAction' => default_action,\n        'DefaultOptions' => {\n          'SSL' => false\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n\n    register_options([\n      Opt::RPORT(389), # Set to 636 for SSL/TLS\n      OptEnum.new('OUTPUT_FORMAT', [true, 'The output format to use', 'table', %w[csv table json]]),\n      OptString.new('BASE_DN', [false, 'LDAP base DN if you already have it']),\n      OptPath.new('QUERY_FILE_PATH', [false, 'Path to the JSON or YAML file to load and run queries from'], conditions: %w[ACTION == RUN_QUERY_FILE]),\n      OptString.new('QUERY_FILTER', [false, 'Filter to send to the target LDAP server to perform the query'], conditions: %w[ACTION == RUN_SINGLE_QUERY]),\n      OptString.new('QUERY_ATTRIBUTES', [false, 'Comma seperated list of attributes to retrieve from the server'], conditions: %w[ACTION == RUN_SINGLE_QUERY])\n    ])\n  end\n\n  def initialize_actions\n    user_config_file_path = File.join(::Msf::Config.config_directory, 'ldap_queries.yaml')\n    default_config_file_path = File.join(::Msf::Config.data_directory, 'auxiliary', 'gather', 'ldap_query', 'ldap_queries_default.yaml')\n\n    @loaded_queries = safe_load_queries(default_config_file_path) || []\n    if File.exist?(user_config_file_path)\n      @loaded_queries.concat(safe_load_queries(user_config_file_path) || [])\n    else\n      # If the user config file doesn't exist, then initialize it with a sample entry.\n      # Users can adjust this file to overwrite default actions to retrieve different attributes etc by default.\n      template = File.join(::Msf::Config.data_directory, 'auxiliary', 'gather', 'ldap_query', 'ldap_queries_template.yaml')\n      FileUtils.cp(template, user_config_file_path) if File.exist?(template)\n    end\n\n    # Combine the user settings with the default settings and then uniq them such that we only have one copy\n    # of each ACTION, however we use the user's custom settings if they have tweaked anything to prevent overriding\n    # their custom adjustments.\n    @loaded_queries = @loaded_queries.map { |h| [h['action'], h] }.to_h\n    @loaded_queries.select! do |_, entry|\n      if entry['action'].blank?\n        wlog('ldap query entry detected that was missing its action field')\n        return false\n      end\n\n      if %w[RUN_QUERY_FILE RUN_SINGLE_QUERY].include? entry['action']\n        wlog(\"ldap query entry detected that was using a reserved action name: #{entry['action']}\")\n        return false\n      end\n\n      if entry['filter'].blank?\n        wlog('ldap query entry detected that was missing its filter field')\n        return false\n      end\n\n      unless entry['attributes'].is_a? Array\n        wlog('ldap query entry detected that was missing its attributes field')\n        return false\n      end\n\n      true\n    end\n\n    actions = []\n    @loaded_queries.each_value do |entry|\n      actions << [entry['action'], { 'Description' => entry['description'] || '' }]\n    end\n    actions << ['RUN_QUERY_FILE', { 'Description' => 'Execute a custom set of LDAP queries from the JSON or YAML file specified by QUERY_FILE.' }]\n    actions << ['RUN_SINGLE_QUERY', { 'Description' => 'Execute a single LDAP query using the QUERY_FILTER and QUERY_ATTRIBUTES options.' }]\n    actions.sort!\n\n    default_action = 'RUN_QUERY_FILE'\n    unless @loaded_queries.empty? # Aka there is more than just RUN_QUERY_FILE and RUN_SINGLE_QUERY in the actions list...\n      default_action = actions[0][0] # Get the first entry's action name and set this as the default action.\n    end\n    [actions, default_action]\n  end\n\n  def safe_load_queries(filename)\n    begin\n      settings = YAML.safe_load(File.binread(filename))\n    rescue StandardError => e\n      elog(\"Couldn't parse #{filename}\", error: e)\n      return\n    end\n\n    return unless settings['queries'].is_a? Array\n\n    settings['queries']\n  end\n\n  def perform_ldap_query(ldap, filter, attributes, base: nil, scope: nil)\n    results = []\n    perform_ldap_query_streaming(ldap, filter, attributes, base: base, scope: scope) do |result|\n      results << result\n    end\n\n    query_result_table = ldap.get_operation_result.table\n    validate_query_result!(query_result_table, filter)\n\n    if results.nil? || results.empty?\n      print_error(\"No results found for #{filter}.\")\n      return nil\n    end\n\n    results\n  end\n\n  def perform_ldap_query_streaming(ldap, filter, attributes, base: nil, scope: nil)\n    query_attributes_data(ldap, attributes.map(&:to_sym))\n\n    base ||= @base_dn\n    scope ||= Net::LDAP::SearchScope_WholeSubtree\n    result_count = 0\n    ldap.search(base: base, filter: filter, attributes: attributes, scope: scope, return_result: false) do |result|\n      result_count += 1\n      yield result if block_given?\n    end\n\n    result_count\n  end\n\n  def generate_rex_tables(entry, format)\n    tbl = Rex::Text::Table.new(\n      'Header' => entry[:dn][0].split(',').join(' '),\n      'Indent' => 1,\n      'Columns' => %w[Name Attributes]\n    )\n\n    entry.each_key do |attr|\n      if format == 'table'\n        tbl << [attr, entry[attr].join(' || ')] unless attr == :dn # Skip over DN entries for tables since DN information is shown in header.\n      else\n        tbl << [attr, entry[attr].join(' || ')] # DN information is not shown in CSV output as a header so keep DN entries in.\n      end\n    end\n\n    case format\n    when 'table'\n      print_line(tbl.to_s)\n    when 'csv'\n      print_line(tbl.to_csv)\n    else\n      fail_with(Failure::BadConfig, \"Invalid format #{format} passed to generate_rex_tables!\")\n    end\n  end\n\n  def convert_nt_timestamp_to_time_string(nt_timestamp)\n    Time.at((nt_timestamp.to_i - 116444736000000000) / 10000000).utc.to_s\n  end\n\n  def convert_pwd_age_to_time_string(timestamp)\n    seconds = (timestamp.to_i / -1) / 10000000 # Convert always negative number to positive then convert to seconds from tick count.\n    days = seconds / 86400\n    hours = (seconds % 86400) / 3600\n    minutes = ((seconds % 86400) % 3600) / 60\n    real_seconds = (((seconds % 86400) % 3600) % 60)\n    return \"#{days}:#{hours.to_s.rjust(2, '0')}:#{minutes.to_s.rjust(2, '0')}:#{real_seconds.to_s.rjust(2, '0')}\"\n  end\n\n  # Read in a DER formatted certificate file and transform it into a\n  # OpenSSL::X509::Certificate object before then using that object to\n  # read the properties of the certificate and return this info as a string.\n  def read_der_certificate_file(cert)\n    openssl_certificate = OpenSSL::X509::Certificate.new(cert)\n    version = openssl_certificate.version\n    subject = openssl_certificate.subject\n    issuer = openssl_certificate.issuer\n    algorithm = openssl_certificate.signature_algorithm\n    extensions = openssl_certificate.extensions.join(' | ')\n    extensions.strip!\n    extensions.gsub!(/ \\|$/, '') # Strip whitespace and then strip trailing | from end of string.\n    [openssl_certificate, \"Version: 0x#{version}, Subject: #{subject}, Issuer: #{issuer}, Signature Algorithm: #{algorithm}, Extensions: #{extensions}\"]\n  end\n\n  # Taken from https://www.powershellgallery.com/packages/S.DS.P/2.1.3/Content/Transforms%5CsystemFlags.ps1\n  # and from https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/1e38247d-8234-4273-9de3-bbf313548631\n  FLAG_DISALLOW_DELETE = 0x80000000\n  FLAG_CONFIG_ALLOW_RENAME = 0x40000000\n  FLAG_CONFIG_ALLOW_MOVE = 0x20000000\n  FLAG_CONFIG_ALLOW_LIMITED_MOVE = 0x10000000\n  FLAG_DOMAIN_DISALLOW_RENAME = 0x8000000\n  FLAG_DOMAIN_DISALLOW_MOVE = 0x4000000\n  FLAG_DISALLOW_MOVE_ON_DELETE = 0x2000000\n  FLAG_ATTR_IS_RDN = 0x20\n  FLAG_SCHEMA_BASE_OBJECT = 0x10\n  FLAG_ATTR_IS_OPERATIONAL = 0x8\n  FLAG_ATTR_IS_CONSTRUCTED = 0x4\n  FLAG_ATTR_REQ_PARTIAL_SET_MEMBER = 0x2\n  FLAG_NOT_REPLICATED = 0x1\n\n  def convert_system_flags_to_string(flags)\n    flags_converted = flags.to_i\n    flag_string = ''\n    flag_string << 'FLAG_DISALLOW_DELETE | ' if flags_converted & FLAG_DISALLOW_DELETE > 0\n    flag_string << 'FLAG_CONFIG_ALLOW_RENAME | ' if flags_converted & FLAG_CONFIG_ALLOW_RENAME > 0\n    flag_string << 'FLAG_CONFIG_ALLOW_MOVE | ' if flags_converted & FLAG_CONFIG_ALLOW_MOVE > 0\n    flag_string << 'FLAG_CONFIG_ALLOW_LIMITED_MOVE | ' if flags_converted & FLAG_CONFIG_ALLOW_LIMITED_MOVE > 0\n    flag_string << 'FLAG_DOMAIN_DISALLOW_RENAME | ' if flags_converted & FLAG_DOMAIN_DISALLOW_RENAME > 0\n    flag_string << 'FLAG_DOMAIN_DISALLOW_MOVE | ' if flags_converted & FLAG_DOMAIN_DISALLOW_MOVE > 0\n    flag_string << 'FLAG_DISALLOW_MOVE_ON_DELETE | ' if flags_converted & FLAG_DISALLOW_MOVE_ON_DELETE > 0\n    flag_string << 'FLAG_ATTR_IS_RDN | ' if flags_converted & FLAG_ATTR_IS_RDN > 0\n    flag_string << 'FLAG_SCHEMA_BASE_OBJECT | ' if flags_converted & FLAG_SCHEMA_BASE_OBJECT > 0\n    flag_string << 'FLAG_ATTR_IS_OPERATIONAL | ' if flags_converted & FLAG_ATTR_IS_OPERATIONAL > 0\n    flag_string << 'FLAG_ATTR_IS_CONSTRUCTED | ' if flags_converted & FLAG_ATTR_IS_CONSTRUCTED > 0\n    flag_string << 'FLAG_ATTR_REQ_PARTIAL_SET_MEMBER | ' if flags_converted & FLAG_ATTR_REQ_PARTIAL_SET_MEMBER > 0\n    flag_string << 'FLAG_NOT_REPLICATED | ' if flags_converted & FLAG_NOT_REPLICATED > 0\n    flag_string.strip.gsub!(/ \\|$/, '')\n  end\n\n  def output_json_data(entry)\n    data = {}\n    entry.each_key do |attr|\n      data[attr] = entry[attr].length == 1 ? entry[attr][0] : entry[attr]\n    end\n    print_status(entry[:dn][0].split(',').join(' '))\n    print_line(JSON.pretty_generate(data))\n  end\n\n  def output_data_table(entry)\n    generate_rex_tables(entry, 'table')\n  end\n\n  def output_data_csv(entry)\n    generate_rex_tables(entry, 'csv')\n  end\n\n  def find_schema_dn(ldap)\n    results = ldap.search(attributes: ['objectCategory'], base: @base_dn, filter: '(objectClass=*)', scope: Net::LDAP::SearchScope_BaseObject)\n    validate_query_result!(ldap.get_operation_result.table)\n    if results.blank?\n      fail_with(Failure::UnexpectedReply, \"LDAP server didn't respond to our request to find the root DN!\")\n    end\n\n    # Double check that the entry has an instancetype attribute.\n    unless results[0].to_h.key?(:objectcategory)\n      fail_with(Failure::UnexpectedReply, \"LDAP server didn't respond to the root DN request with the objectcategory attribute field!\")\n    end\n\n    object_category_raw = results[0][:objectcategory][0]\n    schema_dn = object_category_raw.gsub(/CN=[A-Za-z0-9-]+,/, '')\n    print_good(\"#{peer} Discovered schema DN: #{schema_dn}\")\n\n    schema_dn\n  end\n\n  def query_attributes_data(ldap, attributes)\n    @attribute_properties = {} if @attribute_properties.nil?\n\n    filter = '(|'\n    attributes.each do |key|\n      next if @attribute_properties.key?(key) # Skip if we already have this one\n      next if key == :dn # Skip DN as it will never have a schema entry\n\n      filter += \"(LDAPDisplayName=#{key})\"\n    end\n    filter += ')'\n    return unless filter.include?('LDAPDisplayName=')\n\n    attributes_data = ldap.search(base: ['CN=Schema,CN=Configuration', @schema_dn].join(','), filter: filter, attributes: %i[LDAPDisplayName isSingleValued oMSyntax attributeSyntax])\n    query_result_table = ldap.get_operation_result.table\n    validate_query_result!(query_result_table)\n\n    attributes_data.each do |entry|\n      ldap_display_name = entry[:ldapdisplayname][0].to_s.downcase.to_sym\n      @attribute_properties[ldap_display_name] = {\n        issinglevalued: entry[:issinglevalued][0] == 'TRUE',\n        omsyntax: entry[:omsyntax][0].to_i,\n        attributesyntax: entry[:attributesyntax][0]\n      }\n    end\n  end\n\n  def normalize_entry(entry)\n    # Convert to a hash so we get the raw data we need from within the Net::LDAP::Entry object\n    entry = entry.to_h\n    normalized_entry = { dn: entry[:dn] }\n    entry.each_key do |attribute_name|\n      next if attribute_name == :dn # Skip the DN case as there will be no attributes_properties entry for it.\n\n      normalized_attribute = entry[attribute_name].map { |v| Rex::Text.to_hex_ascii(v) }\n      attribute_property = @attribute_properties[attribute_name]\n      unless attribute_property\n        normalized_entry[attribute_name] = normalized_attribute\n        next\n      end\n\n      case attribute_property[:omsyntax]\n      when 1 # Boolean\n        normalized_attribute[0] = entry[attribute_name][0] != 0\n      when 2 # Integer\n        if attribute_name == :systemflags\n          flags = entry[attribute_name][0]\n          converted_flags_string = convert_system_flags_to_string(flags)\n          normalized_attribute[0] = converted_flags_string\n        end\n      when 4 # OctetString or SID String\n        if attribute_property[:attributesyntax] == '2.5.5.17' # SID String\n          # Advice taken from https://ldapwiki.com/wiki/ObjectSID\n          object_sid_raw = entry[attribute_name][0]\n          begin\n            sid_data = Rex::Proto::MsDtyp::MsDtypSid.read(object_sid_raw)\n            sid_string = sid_data.to_s\n          rescue IOError => e\n            fail_with(Failure::UnexpectedReply, \"Failed to read SID. Error was #{e.message}\")\n          end\n          normalized_attribute[0] = sid_string\n        elsif attribute_property[:attributesyntax] == '2.5.5.10' # OctetString\n          if attribute_name.to_s.match(/guid$/i)\n            # Get the entry[attribute_name] object will be an array containing a single string entry,\n            # so reach in and extract that string, which will contain binary data.\n            bin_guid = entry[attribute_name][0]\n            if bin_guid.length == 16 # Length of binary data in bytes since this is what .length uses. In bits its 128 bits.\n              begin\n                decoded_guid = Rex::Proto::MsDtyp::MsDtypGuid.read(bin_guid)\n                decoded_guid_string = decoded_guid.get\n              rescue IOError => e\n                fail_with(Failure::UnexpectedReply, \"Failed to read GUID. Error was #{e.message}\")\n              end\n              normalized_attribute[0] = decoded_guid_string\n            end\n          elsif attribute_name == :cacertificate || attribute_name == :usercertificate\n            normalized_attribute = entry[attribute_name].map do |raw_key_data|\n              _certificate_file, read_data = read_der_certificate_file(raw_key_data)\n\n              read_data\n            end\n          end\n        end\n      when 6 # String (Object-Identifier)\n      when 10 # Enumeration\n      when 18 # NumbericString\n      when 19 # PrintableString\n      when 20 # Case-Ignore String\n      when 22 # IA5String\n      when 23 # GeneralizedTime String (UTC-Time)\n      when 24 # GeneralizedTime String (GeneralizedTime)\n      when 27 # Case Sensitive String\n      when 64 # DirectoryString String(Unicode)\n      when 65 # LargeInteger\n        if attribute_name == :creationtime || attribute_name.to_s.match(/lastlog(?:on|off)/)\n          timestamp = entry[attribute_name][0]\n          time_string = convert_nt_timestamp_to_time_string(timestamp)\n        elsif attribute_name.to_s.match(/lockoutduration$/i) || attribute_name.to_s.match(/pwdage$/)\n          timestamp = entry[attribute_name][0]\n          time_string = convert_pwd_age_to_time_string(timestamp)\n        end\n        normalized_attribute[0] = time_string\n      when 66 # String (Nt Security Descriptor)\n      when 127 # Object\n      else\n        print_error(\"Unknown oMSyntax entry: #{attribute_property[:omsyntax]}\")\n      end\n      normalized_entry[attribute_name] = normalized_attribute\n    end\n\n    normalized_entry\n  end\n\n  def show_output(entry)\n    case datastore['OUTPUT_FORMAT']\n    when 'csv'\n      output_data_csv(entry)\n    when 'table'\n      output_data_table(entry)\n    when 'json'\n      output_json_data(entry)\n    else\n      fail_with(Failure::BadConfig, 'Supported OUTPUT_FORMAT values are csv, table and json')\n    end\n  end\n\n  def run_queries_from_file(ldap, queries)\n    queries.each do |query|\n      unless query['action'] && query['filter'] && query['attributes']\n        fail_with(Failure::BadConfig, \"Each query in the query file must at least contain a 'action', 'filter' and 'attributes' attribute!\")\n      end\n      attributes = query['attributes']\n      if attributes.nil? || attributes.empty?\n        print_warning('At least one attribute needs to be specified per query in the query file for entries to work!')\n        break\n      end\n      filter = Net::LDAP::Filter.construct(query['filter'])\n      print_status(\"Running #{query['action']}...\")\n      query_base = query['base_dn_prefix'] ? [query['base_dn_prefix'], @base_dn].join(',') : nil\n\n      result_count = perform_ldap_query_streaming(ldap, filter, attributes, base: query_base) do |result|\n        show_output(normalize_entry(result))\n      end\n\n      print_warning(\"Query #{query['filter']} from #{query['action']} didn't return any results!\") if result_count == 0\n    end\n  end\n\n  def run\n    ldap_connect do |ldap|\n      validate_bind_success!(ldap)\n\n      if (@base_dn = datastore['BASE_DN'])\n        print_status(\"User-specified base DN: #{@base_dn}\")\n      else\n        print_status('Discovering base DN automatically')\n\n        unless (@base_dn = discover_base_dn(ldap))\n          fail_with(Failure::UnexpectedReply, \"Couldn't discover base DN!\")\n        end\n      end\n\n      @schema_dn = find_schema_dn(ldap)\n\n      case action.name\n      when 'RUN_QUERY_FILE'\n        unless datastore['QUERY_FILE_PATH']\n          fail_with(Failure::BadConfig, 'When using the RUN_QUERY_FILE action, one must specify the path to the JSON/YAML file containing the queries via QUERY_FILE_PATH!')\n        end\n        print_status(\"Loading queries from #{datastore['QUERY_FILE_PATH']}...\")\n\n        parsed_queries = safe_load_queries(datastore['QUERY_FILE_PATH']) || []\n        if parsed_queries.empty?\n          fail_with(Failure::BadConfig, \"No queries loaded from #{datastore['QUERY_FILE_PATH']}!\")\n        end\n\n        run_queries_from_file(ldap, parsed_queries)\n        return\n      when 'RUN_SINGLE_QUERY'\n        unless datastore['QUERY_FILTER'] && datastore['QUERY_ATTRIBUTES']\n          fail_with(Failure::BadConfig, 'When using the RUN_SINGLE_QUERY action, one must supply the QUERY_FILTER and QUERY_ATTRIBUTE datastore options!')\n        end\n\n        print_status(\"Sending single query #{datastore['QUERY_FILTER']} to the LDAP server...\")\n        attributes = datastore['QUERY_ATTRIBUTES']\n        if attributes.empty?\n          fail_with(Failure::BadConfig, 'Attributes list is empty as we could not find at least one attribute to filter on!')\n        end\n\n        # Split attributes string into an array of attributes, splitting on the comma character.\n        # Also downcase for consistency with rest of the code since LDAP searches aren't case sensitive.\n        attributes = attributes.downcase.split(',')\n\n        # Strip out leading and trailing whitespace from the attributes before using them.\n        attributes.map(&:strip!)\n        filter_string = datastore['QUERY_FILTER']\n        query_base = nil\n      else\n        query = @loaded_queries[datastore['ACTION']].nil? ? @loaded_queries[default_action] : @loaded_queries[datastore['ACTION']]\n        fail_with(Failure::BadConfig, \"Invalid action: #{datastore['ACTION']}\") unless query\n\n        filter_string = query['filter']\n        attributes = query['attributes']\n        query_base = (query['base_dn_prefix'] ? [query['base_dn_prefix'], @base_dn].join(',') : nil)\n      end\n\n      begin\n        filter = Net::LDAP::Filter.construct(filter_string)\n      rescue StandardError => e\n        fail_with(Failure::BadConfig, \"Could not compile the filter #{filter_string}. Error was #{e}\")\n      end\n\n      result_count = perform_ldap_query_streaming(ldap, filter, attributes, base: query_base) do |result|\n        show_output(normalize_entry(result))\n      end\n\n      if result_count == 0\n        print_error(\"No entries could be found for #{filter_string}!\")\n      else\n        print_status(\"Query returned #{result_count} result#{result_count == 1 ? '' : 's'}.\")\n      end\n    end\n  rescue Rex::ConnectionTimeout\n    fail_with(Failure::Unreachable, \"Couldn't reach #{datastore['RHOST']}!\")\n  rescue Net::LDAP::Error => e\n    fail_with(Failure::UnexpectedReply, \"Could not query #{datastore['RHOST']}! Error was: #{e.message}\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-05-19"
}