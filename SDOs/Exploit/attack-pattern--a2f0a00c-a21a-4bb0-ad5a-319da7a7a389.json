{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a2f0a00c-a21a-4bb0-ad5a-319da7a7a389",
    "created": "2024-08-14T16:31:13.642676Z",
    "modified": "2024-08-14T16:31:13.64268Z",
    "name": "SIP Username Enumerator (UDP)",
    "description": "Scan for numeric username/extensions using OPTIONS/REGISTER requests",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/sip/enumerator.rb",
            "external_id": "enumerator.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'SIP Username Enumerator (UDP)',\n      'Description' => 'Scan for numeric username/extensions using OPTIONS/REGISTER requests',\n      'Author'      => 'et',\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n    [\n      OptInt.new('BATCHSIZE', [true, 'The number of hosts to probe in each set', 256]),\n      OptInt.new('MINEXT',   [true, 'Starting extension',0]),\n      OptInt.new('MAXEXT',   [true, 'Ending extension', 9999]),\n      OptInt.new('PADLEN',   [true, 'Cero padding maximum length', 4]),\n      OptEnum.new('METHOD',  [true, 'Enumeration method', 'REGISTER', ['OPTIONS', 'REGISTER']]),\n      Opt::RPORT(5060),\n      Opt::CHOST,\n      Opt::CPORT(5060)\n    ])\n  end\n\n\n  # Define our batch size\n  def run_batch_size\n    datastore['BATCHSIZE'].to_i\n  end\n\n  # Operate on an entire batch of hosts at once\n  def run_batch(batch)\n\n    begin\n      udp_sock = nil\n      idx = 0\n\n      # Create an unbound UDP socket if no CHOST is specified, otherwise\n      # create a UDP socket bound to CHOST (in order to avail of pivoting)\n      udp_sock = Rex::Socket::Udp.create(\n        {\n          'LocalHost' => datastore['CHOST'] || nil,\n          'LocalPort' => datastore['CPORT'].to_i,\n          'Context'   => { 'Msf' => framework, 'MsfExploit' => self }\n        }\n      )\n      add_socket(udp_sock)\n\n      mini = datastore['MINEXT']\n      maxi = datastore['MAXEXT']\n\n      batch.each do |ip|\n        for i in (mini..maxi)\n          testext = padnum(i,datastore['PADLEN'])\n\n          case datastore['METHOD']\n          when 'REGISTER'\n            data = create_probe(ip,testext,'REGISTER')\n          when 'OPTIONS'\n            data = create_probe(ip,testext,'OPTIONS')\n          else\n            print_error(\"Method not found.\")\n            return\n          end\n\n\n          begin\n            udp_sock.sendto(data, ip, datastore['RPORT'].to_i, 0)\n          rescue ::Interrupt\n            raise $!\n          rescue ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionRefused\n            nil\n          end\n\n          if (idx % 10 == 0)\n            while (r = udp_sock.recvfrom(65535, 0.01) and r[1])\n              parse_reply(r,datastore['METHOD'])\n            end\n          end\n\n          idx += 1\n        end\n      end\n\n      while (r = udp_sock.recvfrom(65535, 3) and r[1])\n        parse_reply(r,datastore['METHOD'])\n      end\n\n    rescue ::Interrupt\n      raise $!\n    rescue ::Exception => e\n      print_error(\"Unknown error: #{e.class} #{e}\")\n    ensure\n      udp_sock.close if udp_sock\n    end\n  end\n\n  #\n  # The response parsers\n  #\n  def parse_reply(pkt,meth)\n\n    return if not pkt[1]\n\n    if(pkt[1] =~ /^::ffff:/)\n      pkt[1] = pkt[1].sub(/^::ffff:/, '')\n    end\n\n    resp  = pkt[0].split(/\\s+/)[1]\n    repcode = ''\n    agent = ''\n    verbs = ''\n    serv  = ''\n    prox  = ''\n\n    rhost,rport = pkt[1], pkt[2]\n\n    if(pkt[0] =~ /^To\\:\\s*(.*)$/i)\n      testn = \"#{$1.strip}\".split(';')[0]\n    end\n\n    case resp.to_i\n    when 401\n      print_good(\"Found user: #{testn} [Auth]\")\n      # Add Report\n      report_note(\n        :host\t=> rhost,\n        :proto => 'udp',\n        :sname\t=> 'sip',\n        :port\t=> rport,\n        :type\t=> \"Found user: #{testn} [Auth]\",\n        :data\t=> \"Found user: #{testn} [Auth]\"\n      )\n    when 200\n      print_good(\"Found user: #{testn} [Open]\")\n      #Add Report\n      report_note(\n        :host\t=> rhost,\n        :proto => 'udp',\n        :sname\t=> 'sip',\n        :port\t=> rport,\n        :type\t=> \"Found user: #{testn} [Open]\",\n        :data\t=> \"Found user: #{testn} [Open]\"\n      )\n    else\n      #print_error(\"Undefined error code: #{resp.to_i}\"\n    end\n  end\n\n  def create_probe(ip,toext,meth)\n    suser = Rex::Text.rand_text_alphanumeric(rand(8)+1)\n    shost = Rex::Socket.source_address(ip)\n    src   = \"#{shost}:#{datastore['CPORT']}\"\n\n    data  = \"#{meth} sip:#{toext}@#{ip} SIP/2.0\\r\\n\"\n    data << \"Via: SIP/2.0/UDP #{src};branch=z9hG4bK.#{\"%.8x\" % rand(0x100000000)};rport;alias\\r\\n\"\n    data << \"From: #{toext} <sip:#{suser}@#{src}>;tag=70c00e8c\\r\\n\"\n    data << \"To: #{toext} <sip:#{toext}@#{ip}>\\r\\n\"\n    data << \"Call-ID: #{rand(0x100000000)}@#{shost}\\r\\n\"\n    data << \"CSeq: 1 #{meth}\\r\\n\"\n    data << \"Contact: <sip:#{suser}@#{src}>\\r\\n\"\n    data << \"Content-Length: 0\\r\\n\"\n    data << \"Max-Forwards: 20\\r\\n\"\n    data << \"User-Agent: #{suser}\\r\\n\"\n    data << \"Accept: text/plain\\r\\n\"\n  end\n\n  def padnum(num,padding)\n    if padding >= num.to_s.length\n      ('0'*(padding-num.to_s.length)) << num.to_s\n    end\n  end\nend\n"
}