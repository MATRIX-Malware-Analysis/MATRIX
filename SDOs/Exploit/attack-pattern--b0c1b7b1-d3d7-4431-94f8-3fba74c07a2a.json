{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b0c1b7b1-d3d7-4431-94f8-3fba74c07a2a",
    "created": "2024-08-14T16:26:49.091136Z",
    "modified": "2024-08-14T16:26:49.091139Z",
    "name": "Modbus Banner Grabbing",
    "description": " This module grabs the banner of any device running the Modbus protocol by sending a request with Modbus Function Code 43 (Read Device Identification). Modbus is a data communications protocol originally published by Modicon (now Schneider Electric) in 1979 for use with its programmable logic controllers (PLCs). ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/scada/modbus_banner_grabbing.rb",
            "external_id": "modbus_banner_grabbing.rb"
        },
        {
            "source_name": "reference",
            "url": "https://modbus.org/docs/Modbus_Messaging_Implementation_Guide_V1_0b.pdf"
        },
        {
            "source_name": "reference",
            "url": "https://en.wikipedia.org/wiki/Modbus#Modbus_TCP_frame_format_(primarily_used_on_Ethernet_networks)"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/industrialarmy/Hello_Proto"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Modbus Banner Grabbing',\n        'Description' => %q{\n          This module grabs the banner of any device running the Modbus protocol\n          by sending a request with Modbus Function Code 43 (Read Device\n          Identification). Modbus is a data communications protocol originally\n          published by Modicon (now Schneider Electric) in 1979 for use with its\n          programmable logic controllers (PLCs).\n        },\n        'Author' => [\n          'Juan Escobar <juan[at]null-life.com>', # @itsecurityco\n          'Ezequiel Fernandez' # @capitan_alfa\n        ],\n        'References' => [\n          [ 'URL', 'https://modbus.org/docs/Modbus_Messaging_Implementation_Guide_V1_0b.pdf' ],\n          [ 'URL', 'https://en.wikipedia.org/wiki/Modbus#Modbus_TCP_frame_format_(primarily_used_on_Ethernet_networks)' ],\n          [ 'URL', 'https://github.com/industrialarmy/Hello_Proto' ],\n        ],\n        'License' => MSF_LICENSE,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(502),\n        OptInt.new('TIMEOUT', [true, 'Timeout for the network probe', 2])\n      ]\n    )\n  end\n\n  # Main Modbus exception codes\n  def handle_exception_codes(code)\n    case code\n    when \"\\xab\\x01\"\n      print_error('Illegal Function: The function code received in the query is not recognized or allowed by the slave.')\n    when \"\\xab\\x02\"\n      print_error('Illegal Data Address: Data address of some or all the required entities are not allowed or do not exist in slave.')\n    when \"\\xab\\x03\"\n      print_error('Illegal Data Value: Value is not accepted by slave.')\n    when \"\\xab\\x04\"\n      print_error('Slave Device Failure: Unrecoverable error occurred while slave was attempting to perform requested action.')\n    when \"\\xab\\x05\"\n      print_error('Acknowledge: Slave has accepted the request and is processing it, but requires a long period of time to process it.')\n    when \"\\xab\\x06\"\n      print_error('Slave Device Busy: Slave is engaged in processing a long-duration program command.')\n    when \"\\xab\\x07\"\n      print_error('Negative Acknowledge: Slave cannot perform the programming function recieved in the query.')\n    when \"\\xab\\x08\"\n      print_error('Memory Parity Error: Slave detected a parity error in memory.')\n    when \"\\xab\\x0a\"\n      print_error('Gateway Path Unavailable: The gateway was likely misconfigured or is overloaded as it was unable to internally connect the input and output channels.')\n    when \"\\xab\\x0b\"\n      print_error(\"Gateway Target Device Failed to Respond: Gateway could not find the target device on the network or the target device didn't respond.\")\n    else\n      print_error('MODBUS - received incorrect data.')\n    end\n  end\n\n  def run_host(ip)\n    object_name = {\n      0 => 'VendorName',\n      1 => 'ProductCode',\n      2 => 'Revision',\n      3 => 'VendorUrl',\n      4 => 'ProductName',\n      5 => 'ModelName',\n      6 => 'UserAppName',\n      7 => 'Reserved',\n      8 => 'Reserved',\n      9 => 'Reserved',\n      10 => 'Reserved',\n      128 => 'PrivateObjects',\n      255 => 'PrivateObjects'\n    }\n\n    # Modbus/TCP Response Bytes\n    mbtcp = {\n      'trans_id' => { 'start' => 0, 'bytes' => 2 },\n      'prot_id' => { 'start' => 2, 'bytes' => 2 },\n      'len' => { 'start' => 4, 'bytes' => 2 },\n      'unit_id' => { 'start' => 6, 'bytes' => 1 },\n      'func_code' => { 'start' => 7, 'bytes' => 1 },\n      'mei' => { 'start' => 8, 'bytes' => 1 },\n      'read_device_id' => { 'start' => 9, 'bytes' => 1 },\n      'conformity_level' => { 'start' => 10, 'bytes' => 1 },\n      'more_follows' => { 'start' => 11, 'bytes' => 1 },\n      'next_object_id' => { 'start' => 12, 'bytes' => 1 },\n      'num_objects' => { 'start' => 13, 'bytes' => 1 },\n      'object_id' => { 'start' => 14, 'bytes' => 1 },\n      'objects_len' => { 'start' => 15, 'bytes' => 1 },\n      'object_str_value' => { 'start' => 16, 'bytes' => nil }\n    }\n\n    begin\n      connect\n\n      packet = \"\\x44\\x62\" # Transaction Identifier\n      packet << \"\\x00\\x00\" # Protocol Identifier\n      packet << \"\\x00\\x05\" # Length\n      packet << \"\\xFF\" # Unit Identifier\n      packet << \"\\x2b\" # 0010 1011 = Function Code: Encapsulated Interface Transport (43)\n      packet << \"\\x0e\" # MEI type: Read Device Identification (14)\n      packet << \"\\x03\" # Read Device ID: Extended Device Identification (3)\n      packet << \"\\x00\" # Object ID: VendorName (0)\n\n      sock.put(packet)\n      data = sock.get_once(-1, datastore['TIMEOUT'])\n\n      unless data\n        raise ::Rex::ConnectionTimeout\n      end\n\n      # Read Device Identification (43)\n      unless data[mbtcp['func_code']['start'], 2] == \"\\x2b\\x0e\"\n        handle_exception_codes(data[mbtcp['func_code']['start'], 2])\n        return\n      end\n\n      num_objects = data[mbtcp['num_objects']['start'], mbtcp['num_objects']['bytes']]\n\n      if num_objects.nil?\n        print_error('MODBUS - No data was received from the target machine, its possible it may be offline or not responding.')\n        return\n      end\n\n      num_objects = num_objects.unpack1('C')\n      print_status(\"Number of Objects: #{num_objects}\")\n      object_start = mbtcp['object_id']['start']\n\n      for _i in 1..num_objects.to_i\n        object = Hash.new\n        object['id'] = data[object_start, mbtcp['object_id']['bytes']].unpack1('C')\n        object['len'] = data[object_start + mbtcp['object_id']['bytes'], mbtcp['objects_len']['bytes']].unpack1('C')\n        object['str_value'] = data[object_start + mbtcp['object_id']['bytes'] + mbtcp['objects_len']['bytes'], object['len']].unpack1('a*')\n        if object_name.key?(object['id'])\n          object['name'] = object_name[object['id']]\n        else\n          object['name'] = 'Missing_Name'\n        end\n\n        print_good(\"#{object['name']}: #{object['str_value']}\")\n        object_start = object_start + mbtcp['object_id']['bytes'] + mbtcp['objects_len']['bytes'] + object['len']\n\n        report_note(\n          host: ip,\n          proto: 'tcp',\n          port: rport,\n          sname: 'modbus',\n          type: \"modbus.#{object['name'].downcase}\",\n          data: object['str_value']\n        )\n      end\n    rescue ::Interrupt\n      print_error('MODBUS - Interrupt during payload')\n      raise $ERROR_INFO\n    rescue ::Rex::HostUnreachable, ::Rex::ConnectionError, ::Rex::ConnectionTimeout, ::Rex::ConnectionRefused => e\n      print_error(\"MODBUS - Network error during payload: #{e}\")\n      return\n    rescue ::EOFError\n      print_error('MODBUS - No reply')\n      return\n    end\n  end\n\n  def cleanup\n    disconnect\n  rescue StandardError\n    nil\n  end\nend\n"
}