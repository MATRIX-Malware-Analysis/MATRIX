{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--57d70d6b-3ed2-445b-93a3-44fae12c598c",
    "created": "2024-08-14T16:28:08.501294Z",
    "modified": "2024-08-14T16:28:08.501298Z",
    "name": "Rogue Gateway Detection: Receiver",
    "description": " This module listens for replies to the requests sent by the rogue_send module. The RPORT, CPORT, and ECHOID values must match the rogue_send parameters used exactly. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/rogue/rogue_recv.rb",
            "external_id": "rogue_recv.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Capture\n\n  def initialize\n    super(\n      'Name'        => 'Rogue Gateway Detection: Receiver',\n      'Description' => %q{\n        This module listens for replies to the requests sent by\n      the rogue_send module. The RPORT, CPORT, and ECHOID values\n      must match the rogue_send parameters used exactly.\n      },\n      'Author'      => 'hdm',\n      'License'     => MSF_LICENSE\n    )\n\n    register_options([\n      OptPort.new(\"RPORT\", [true, \"The destination port for the TCP SYN packet\", 80]),\n      OptPort.new(\"CPORT\", [true, \"The source port for the TCP SYN packet\", 13832]),\n      OptInt.new(\"ECHOID\", [true, \"The unique ICMP ECHO ID to embed into the packet\", 7893]),\n    ])\n  end\n\n  def build_filter\n    \"(icmp and icmp[0] == 0) or (\" +\n      \"tcp and (tcp[13] == 0x12 or (tcp[13] & 0x04) != 0) and \" +\n      \"src port #{datastore['RPORT']} and dst port #{datastore['CPORT']} \" +\n    \")\"\n  end\n\n  def run\n    open_pcap('SNAPLEN' => 128, 'FILTER' => build_filter)\n    print_status(\"Opening the capture interface...\")\n\n    print_status(\"Waiting for responses to rogue_send...\")\n    begin\n    each_packet do |pkt|\n      r = parse_reply(pkt)\n      next if not r\n      print_status(\"Reply from #{r[:internal]} using gateway #{r[:external]} (#{r[:type].to_s.upcase})\")\n    end\n    rescue ::Interrupt\n      raise $!\n    ensure\n      close_pcap\n    end\n  end\n\n  def parse_reply(r)\n    p = PacketFu::Packet.parse(r)\n    return unless p.is_eth?\n    if p.is_icmp?\n      return if(p.payload[0,2] != [datastore['ECHOID']].pack(\"n\"))\n      return unless p.payload.size >= 8\n      reply = {:raw => p}\n      reply[:type] = :icmp\n      reply[:internal] = Rex::Socket.addr_nota(p.payload[4,4])\n      reply[:external] = p.ip_saddr\n    elsif p.is_tcp?\n      return if p.tcp_ack.zero?\n      reply = {:packet => p}\n      reply[:type] = :tcp\n      reply[:internal] = Rex::Socket.addr_itoa(p.tcp_ack - 1)\n      reply[:external] = p.ip_saddr\n    else\n      reply = nil\n    end\n    return reply\n  end\nend\n"
}