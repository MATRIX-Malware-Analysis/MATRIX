{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6a571a08-1eba-4cb2-a300-7cb2fe6106b5",
    "created": "2024-08-14T16:27:03.803605Z",
    "modified": "2024-08-14T16:27:03.803609Z",
    "name": "IBM WebSphere MQ Channel Name Bruteforce",
    "description": "This module uses a dictionary to bruteforce MQ channel names. For all identified channels it also returns if SSL is used and whether it is a server-connection channel.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/misc/ibm_mq_channel_brute.rb",
            "external_id": "ibm_mq_channel_brute.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'IBM WebSphere MQ Channel Name Bruteforce',\n      'Description' => 'This module uses a dictionary to bruteforce MQ channel names. For all identified channels it also returns if SSL is used and whether it is a server-connection channel.',\n      'Author'      => 'Petros Koutroumpis',\n      'License'     => MSF_LICENSE\n    )\n    register_options([\n      Opt::RPORT(1414),\n      OptInt.new('TIMEOUT', [true, \"The socket connect timeout in seconds\", 10]),\n      OptInt.new('CONCURRENCY', [true, \"The number of concurrent channel names to check\", 10]),\n      OptPath.new('CHANNELS_FILE',\n        [ true, \"The file that contains a list of channel names\"]\n      )])\n  end\n\n  def create_packet(chan)\n    packet = \"\\x54\\x53\\x48\\x20\"+ \t# StructID\n    \"\\x00\\x00\\x01\\x0c\"+ \t\t# MQSegmLen\n    \"\\x02\" +\t\t\t \t# Byte Order\n    \"\\x01\" +\t\t\t \t# SegmType\n    \"\\x01\" +\t\t\t\t# CtlFlag1\n    \"\\x00\" +\t\t\t\t# CtlFlag2\n    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"+\t# LUWIdent\n    \"\\x22\\x02\\x00\\x00\"+\t\t\t# Encoding\n    \"\\xb5\\x01\" +\t\t\t# CCSID\n    \"\\x00\\x00\" +\t\t\t# Reserved\n    \"\\x49\\x44\\x20\\x20\" +\t\t# StructID\n    \"\\x0d\" +\t\t\t\t# FAP Level\n    \"\\x26\" +\t\t\t\t# CapFlag1 - Channel Type\n    \"\\x00\" +\t\t\t\t# ECapFlag1\n    \"\\x00\" +\t\t\t\t# IniErrFlg1\n    \"\\x00\\x00\" +\t\t\t# Reserved\n    \"\\x32\\x00\" +\t\t\t# MaxMsgBtch\n    \"\\xec\\x7f\\x00\\x00\" +\t\t# MaxTrSize\n    \"\\x00\\x00\\x40\\x00\" +\t\t# MaxMsgSize\n    \"\\xff\\xc9\\x9a\\x3b\" +\t\t# SegWrapVal\n    + chan + \t\t\t\t# Channel name\n    \"\\x20\" +\t\t\t\t# CapFlag2\n    \"\\x20\" +\t\t\t\t# ECapFlag2\n    \"\\x20\\x20\" +\t\t\t# ccsid\n    \"QM1\" + \"\\x20\"*45 +\t\t\t# Queue Manager Name\n    \"\\x20\\x20\\x20\\x20\" +\t\t# HBInterval\n    \"\\x20\\x20\" +\t\t\t# EFLLength\n    \"\\x20\" +\t\t\t\t# IniErrFlg2\n    \"\\x20\" +\t\t\t\t# Reserved1\n    \"\\x20\\x20\" +\t\t\t# HdrCprLst\n    \"\\x20\\x20\\x20\\x20\\x2c\\x01\\x00\\x00\"+ # MSGCprLst1\n    \"\\x8a\\x00\\x00\\x55\\x00\\xff\\x00\\xff\"+ # MsgCprLst2\n    \"\\xff\\xff\" +\t\t\t# Reserved2\n    \"\\xff\\xff\\xff\\xff\" +\t\t# SSLKeyRst\n    \"\\xff\\xff\\xff\\xff\" +\t\t# ConvBySKt\n    \"\\xff\" +\t\t\t\t# CapFlag3\n    \"\\xff\" +\t\t\t\t# ECapFlag3\n    \"\\xff\\xff\" +\t\t\t# Reserved3\n    \"\\x00\\x00\\x00\\x00\" +\t\t# ProcessId\n    \"\\x00\\x00\\x00\\x00\" +\t\t# ThreadId\n    \"\\x00\\x00\\x05\\x00\" +\t\t# TraceId\n    \"\\x00\\x00\\x10\\x13\\x00\\x00\" + \t# ProdId\n    \"\\x01\\x00\\x00\\x00\\x01\\x00\" + \t# ProdId\n    \"MQMID\" + \"\\x20\"*43 +\t\t# MQM Id\n    \"\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\"+ # Unknown\n    \"\\x20\\x20\\x20\\x20\\x20\\x20\\x00\\x00\"+ # Unknown\n    \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"+ # Unknown\n    \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"+ # Unknown\n    \"\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\"+ # Unknown\n    \"\\x00\\x00\\x00\\x00\\x00\\x00\"\t\t# Unknown\n  end\n\n\n  def run_host(ip)\n    @channels = []\n    @unencrypted_mqi_channels = []\n    begin\n      channel_list\n      rescue ::Rex::ConnectionRefused\n        fail_with(Failure::Unreachable, \"TCP Port closed.\")\n      rescue ::Rex::ConnectionError, ::IOError, ::Timeout::Error, Errno::ECONNRESET\n        fail_with(Failure::Unreachable, \"Connection Failed.\")\n      rescue ::Exception => e\n        fail_with(Failure::Unknown, e)\n      end\n      if(@channels.empty?)\n        print_status(\"#{ip}:#{rport} No channels found.\")\n      else\n        print_good(\"Channels found: #{@channels}\")\n        print_good(\"Unencrypted MQI Channels found: #{@unencrypted_mqi_channels}\")\n        report_note(\n          :host => rhost,\n          :port => rport,\n          :type => 'mq.channels'\n        )\n      print_line\n    end\n  end\n\n  def channel_list\n    channel_data = get_channel_names\n    while (channel_data.length > 0)\n      t = []\n      r = []\n      begin\n        1.upto(datastore['CONCURRENCY']) do\n          this_channel = channel_data.shift\n          if this_channel.nil?\n            next\n          end\n          t << framework.threads.spawn(\"Module(#{self.refname})-#{rhost}:#{rport}\", false, this_channel) do |channel|\n            connect\n            vprint_status \"#{rhost}:#{rport} - Sending request for #{channel}...\"\n            if channel.length.to_i > 20\n              print_error(\"Channel names cannot exceed 20 characters.  Skipping.\")\n              next\n            end\n            chan = channel + \"\\x20\"*(20-channel.length.to_i)\n            timeout = datastore['TIMEOUT'].to_i\n            s = connect(false,\n              {\n                'RPORT' => rport,\n                'RHOST' => rhost,\n              }\n            )\n            s.put(create_packet(chan))\n            data = s.get_once(-1,timeout)\n            if data.nil?\n              print_status(\"No response received. Try increasing timeout.\")\n              next\n            end\n            if not data[0...3].include? 'TSH'\n              next\n            end\n            if data[-4..-1] == \"\\x01\\x00\\x00\\x00\" # NO_CHANNEL code\n              next\n            end\n            if data[-4..-1] == \"\\x18\\x00\\x00\\x00\" # CIPHER_SPEC code\n              print_status(\"Found channel: #{channel}, IsEncrypted: True, IsMQI: N/A\")\n            elsif data[-4..-1] == \"\\x02\\x00\\x00\\x00\" # CHANNEL_WRONG_TYPE code\n              print_status(\"Found channel: #{channel}, IsEncrypted: False, IsMQI: False\")\n            else\n              print_status(\"Found channel: #{channel}, IsEncrypted: False, IsMQI: True\")\n              @unencrypted_mqi_channels << channel\n            end\n            @channels << channel\n            disconnect\n          end\n        end\n        t.each {|x| x.join }\n      end\n    end\n  end\n\n  def get_channel_names\n    if(! @common)\n      File.open(datastore['CHANNELS_FILE'], \"rb\") do |fd|\n        data = fd.read(fd.stat.size)\n        @common = data.split(/\\n/).compact.uniq\n      end\n    end\n    @common\n  end\n\nend\n"
}