{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--354fbc14-3616-4dc2-a0bb-683dd24ec41f",
    "created": "2024-08-14T16:33:19.180159Z",
    "modified": "2024-08-14T16:33:19.180163Z",
    "name": "Multi Gather DNS Reverse Lookup Scan",
    "description": " Performs DNS reverse lookup using the OS included DNS query command.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/gather/dns_reverse_lookup.rb",
            "external_id": "dns_reverse_lookup.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Multi Gather DNS Reverse Lookup Scan',\n        'Description' => %q{\n          Performs DNS reverse lookup using the OS included DNS query command.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Carlos Perez <carlos_perez[at]darkoperator.com>'],\n        'Platform' => %w[bsd linux osx solaris win],\n        'SessionTypes' => [ 'meterpreter', 'shell' ]\n      )\n    )\n    register_options(\n      [\n\n        OptAddressRange.new('RHOSTS', [true, 'IP Range to perform reverse lookup against.'])\n\n      ]\n    )\n  end\n\n  # Run Method for when run command is issued\n  def run\n    iprange = datastore['RHOSTS']\n    print_status(\"Performing DNS Reverse Lookup for IP range #{iprange}\")\n    iplst = []\n\n    a = []\n    ipadd = Rex::Socket::RangeWalker.new(iprange)\n    numip = ipadd.num_ips\n    while (iplst.length < numip)\n      ipa = ipadd.next_ip\n      if !ipa\n        break\n      end\n\n      iplst << ipa\n    end\n\n    case session.platform\n    when 'windows'\n      cmd = 'nslookup'\n    when 'solaris'\n      cmd = '/usr/sbin/host'\n    else\n      cmd = '/usr/bin/host'\n    end\n\n    while !iplst.nil? && !iplst.empty?\n      1.upto session.max_threads do\n        a << framework.threads.spawn(\"Module(#{refname})\", false, iplst.shift) do |ip_add|\n          next if ip_add.nil?\n\n          r = cmd_exec(cmd, \" #{ip_add}\")\n          case session.platform\n          when 'windows'\n            if r =~ /(Name)/\n              r.scan(/Name:\\s*\\S*\\s/) do |n|\n                hostname = n.split(':    ')\n                print_good \"\\t #{ip_add} is #{hostname[1].chomp(\"\\n\")}\"\n                report_host({\n                  host: ip_add,\n                  name: hostname[1].strip\n                })\n              end\n            else\n              vprint_status(\"#{ip_add} does not have a Reverse Lookup Record\")\n            end\n          else\n            if r !~ /not found/i\n              hostname = r.scan(/domain name pointer (\\S*)\\./).join\n              print_good \"\\t #{ip_add} is #{hostname}\"\n              report_host({\n                host: ip_add,\n                name: hostname.strip\n              })\n            else\n              vprint_status(\"#{ip_add} does not have a Reverse Lookup Record\")\n            end\n          end\n        end\n        a.map(&:join)\n      end\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "%w[bsd linux osx solaris win]"
    ]
}