{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3bb4133c-3a01-471c-926c-5f1f26089758",
    "created": "2024-08-14T16:21:58.067171Z",
    "modified": "2024-08-14T16:21:58.067175Z",
    "name": "FTP File Server",
    "description": " This module provides a FTP service ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/ftp.rb",
            "external_id": "ftp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::FtpServer\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'FTP File Server',\n      'Description'    => %q{\n        This module provides a FTP service\n      },\n      'Author'      => ['hdm'],\n      'License'     => MSF_LICENSE,\n      'Actions'     =>\n        [\n          [ 'Service', 'Description' => 'Serve files via FTP' ]\n        ],\n      'PassiveActions' =>\n        [\n          'Service'\n        ],\n      'DefaultAction'  => 'Service'\n    )\n\n    register_options(\n      [\n        OptString.new('FTPROOT',    [ true,  \"The FTP root directory to serve files from\", '/tmp/ftproot' ]),\n        OptString.new('FTPUSER',    [ false, \"Configure a specific username that should be allowed access\"], fallbacks: ['USERNAME']),\n        OptString.new('FTPPASS',    [ false, \"Configure a specific password that should be allowed access\"], fallbacks: ['PASSWORD']),\n      ])\n  end\n\n  def run\n    exploit()\n  end\n\n  def on_client_command_user(c,arg)\n    @state[c][:user] = arg\n    if(not datastore['FTPUSER'] or (arg == datastore['FTPUSER']))\n      c.put \"331 User name okay, need password...\\r\\n\"\n    else\n      c.put \"500 User name invalid\\r\\n\"\n    end\n    return\n  end\n\n  def on_client_command_pass(c,arg)\n    @state[c][:pass] = arg\n    if(not datastore['FTPPASS'] or (arg == datastore['FTPPASS']))\n      c.put \"230 Login OK\\r\\n\"\n      @state[c][:auth] = true\n    else\n      c.put \"500 Password invalid\\r\\n\"\n      @state[c][:auth] = false\n    end\n    return\n  end\n\n  def on_client_command_retr(c,arg)\n    print_status(\"#{@state[c][:name]} FTP download request for #{arg}\")\n\n    if(not @state[c][:auth])\n      c.put \"500 Access denied\\r\\n\"\n      return\n    end\n\n    path = ::File.join(datastore['FTPROOT'], Rex::FileUtils.clean_path(arg))\n    if(not ::File.exist?(path))\n      c.put \"550 File does not exist\\r\\n\"\n      return\n    end\n\n    conn = establish_data_connection(c)\n    if(not conn)\n      c.put(\"425 Can't build data connection\\r\\n\")\n      return\n    end\n\n    c.put(\"150 Opening BINARY mode data connection for #{arg}\\r\\n\")\n    conn.put(::File.read(path, ::File.size(path), mode: 'rb'))\n    c.put(\"226 Transfer complete.\\r\\n\")\n    conn.close\n  end\n\n  def on_client_command_list(c,arg)\n\n    if(not @state[c][:auth])\n      c.put \"500 Access denied\\r\\n\"\n      return\n    end\n\n    conn = establish_data_connection(c)\n    if(not conn)\n      c.put(\"425 Can't build data connection\\r\\n\")\n      return\n    end\n\n    pwd = ::File.join(datastore['FTPROOT'], @state[c][:cwd])\n    buf = ''\n\n    begin\n      Dir.new(pwd).entries.each do |ent|\n        path = ::File.join(datastore['FTPROOT'], ent)\n        if(::File.directory?(path))\n          buf << \"drwxr-xr-x   2 0      0       512 Jan  1  2000 #{ent}\\r\\n\"\n        end\n        if(::File.file?(path))\n          buf << \"-rw-r--r--   1 0      0       #{::File.size(path)} Jan  1  2000 #{ent}\\r\\n\"\n        end\n      end\n    rescue ::Exception\n    end\n\n    c.put(\"150 Opening ASCII mode data connection for /bin/ls\\r\\n\")\n    conn.put(\"total #{buf.length}\\r\\n\" + buf)\n    c.put(\"226 Transfer complete.\\r\\n\")\n    conn.close\n  end\n\n  def on_client_command_size(c,arg)\n\n    if(not @state[c][:auth])\n      c.put \"500 Access denied\\r\\n\"\n      return\n    end\n\n    path = ::File.join(datastore['FTPROOT'], Rex::FileUtils.clean_path(arg))\n    if(not ::File.exist?(path))\n      c.put \"550 File does not exist\\r\\n\"\n      return\n    end\n\n    c.put(\"213 #{::File.size(path)}\\r\\n\")\n  end\n\n\n  def on_client_command_cwd(c,arg)\n\n    if(not @state[c][:auth])\n      c.put \"500 Access denied\\r\\n\"\n      return\n    end\n\n    upath = ::File.expand_path(datastore['FTPROOT'])\n    npath = ::File.expand_path(::File.join(datastore['FTPROOT'], @state[c][:cwd], arg))\n    bpath = npath[upath.length, npath.length - upath.length]\n\n    # Check for traversal above the root directory\n    if not (npath[0, upath.length] == upath or bpath == '')\n      bpath = '/'\n    end\n\n    npath = ::File.expand_path(::File.join(datastore['FTPROOT'], bpath))\n    if not (::File.exist?(npath) and ::File.directory?(npath))\n      c.put \"550 Directory does not exist\\r\\n\"\n      return\n    end\n\n    bpath = '/' if bpath == ''\n    @state[c][:cwd] = bpath\n\n    c.put \"250 CWD command successful.\\r\\n\"\n  end\nend\n"
}