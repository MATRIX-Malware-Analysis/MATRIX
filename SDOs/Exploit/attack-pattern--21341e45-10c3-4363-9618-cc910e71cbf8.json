{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--21341e45-10c3-4363-9618-cc910e71cbf8",
    "created": "2024-08-14T16:32:40.253091Z",
    "modified": "2024-08-14T16:32:40.253096Z",
    "name": "Censys Search",
    "description": " The module uses the Censys REST API to access the same data accessible through the web interface. The search endpoint allows queries using the Censys Search Language against the Hosts dataset. Setting the CERTIFICATES option will also retrieve the certificate details for each relevant service by querying the Certificates dataset. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/censys_search.rb",
            "external_id": "censys_search.rb"
        },
        {
            "source_name": "reference",
            "url": "https://search.censys.io"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n\n  CENSYS_SEARCH_API = 'search.censys.io'.freeze\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Censys Search',\n        'Description' => %q{\n          The module uses the Censys REST API to access the same data accessible\n          through the web interface. The search endpoint allows queries using\n          the Censys Search Language against the Hosts dataset. Setting the\n          CERTIFICATES option will also retrieve the certificate details for each\n          relevant service by querying the Certificates dataset.\n        },\n        'Author' => [\n          'Nixawk', # original Metasploit module\n          'e2002e', # rework to use the API v2\n          'Christophe De La Fuente' # rework to use the API v2\n        ],\n        'References' => [\n          ['URL', 'https://search.censys.io']\n        ],\n        'License' => MSF_LICENSE,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [],\n          'Reliability' => []\n        }\n      )\n    )\n\n    register_options([\n      OptString.new('CENSYS_UID', [true, 'The Censys API UID']),\n      OptString.new('CENSYS_SECRET', [true, 'The Censys API SECRET']),\n      OptString.new('QUERY', [true, 'The Censys search query']),\n      OptBool.new('CERTIFICATES', [false, 'Query infos about certificates', false])\n    ])\n  end\n\n  def basic_auth_header\n    auth_str = datastore['CENSYS_UID'].to_s + ':' + datastore['CENSYS_SECRET'].to_s\n    'Basic ' + Rex::Text.encode_base64(auth_str)\n  end\n\n  def search(keyword)\n    begin\n      @cli = Rex::Proto::Http::Client.new(CENSYS_SEARCH_API, 443, {}, true)\n      @cli.connect\n\n      response = @cli.request_cgi(\n        'method' => 'GET',\n        'uri' => \"/api/v2/hosts/search?q=#{keyword}\",\n        'headers' => { 'Authorization' => basic_auth_header }\n      )\n      res = @cli.send_recv(response)\n    rescue ::Rex::ConnectionError, Errno::ECONNREFUSED, Errno::ETIMEDOUT => e\n      fail_with(Failure::Unreachable, \"#search: HTTP Connection Failed: #{e}\")\n    end\n    fail_with(Failure::Unreachable, '#search: HTTP Connection Failed') unless res\n\n    records = ActiveSupport::JSON.decode(res.body)\n    if records['code'] == 200\n      parse_record(records['result'])\n    else\n      fail_with(Failure::UnexpectedReply, \"Error returned by '/api/v2/hosts/search': code=#{records['code']}, status=#{records['status']}, error=#{records['error']}\")\n    end\n  end\n\n  def get_certificate_details(cert_fingerprint)\n    return if cert_fingerprint.nil?\n\n    begin\n      response = @cli.request_cgi(\n        'method' => 'GET',\n        'uri' => \"/api/v1/view/certificates/#{cert_fingerprint}\",\n        'headers' => { 'Authorization' => basic_auth_header }\n      )\n      res = @cli.send_recv(response)\n    rescue ::Rex::ConnectionError, Errno::ECONNREFUSED, Errno::ETIMEDOUT\n      print_error('#get_certificate_details - HTTP Connection Failed')\n      return\n    end\n    return unless res\n\n    cert_details = ActiveSupport::JSON.decode(res.body)\n    subject = cert_details.dig('parsed', 'subject_dn')\n    return unless subject\n\n    issuer = cert_details.dig('parsed', 'issuer_dn')\n    cert_details = subject\n    cert_details << \" (Issuer: #{issuer})\" if issuer\n    cert_details\n  end\n\n  def parse_record(records)\n    unless records&.dig('hits')&.any?\n      print_error('The query did not return any records')\n      return\n    end\n    records['hits'].each do |hit|\n      ip = hit['ip']\n      services = hit['services']\n      ports = []\n      certs = []\n      services.each do |service|\n        port = service['port']\n        name = service['service_name']\n        ports << \"#{port}/#{name}\"\n        cert_details = nil\n        if datastore['CERTIFICATES'] && service['certificate']\n          cert_details = get_certificate_details(service['certificate'])\n          if cert_details\n            certs << \"Certificate for #{port}/#{name}: #{cert_details}\"\n          else\n            vprint_error(\"Unable to get certificate details for #{port}/#{name}\")\n          end\n        end\n        if cert_details\n          report_service(host: ip, port: port, name: name, info: cert_details)\n        else\n          report_service(host: ip, port: port, name: name)\n        end\n      end\n      print_good(\"#{ip} - #{ports.join(',')}\")\n      certs.each { |cert| print_status(cert) }\n    end\n  end\n\n  # Check to see if Censys Search API host resolves properly\n  def censys_resolvable?\n    begin\n      Rex::Socket.resolv_to_dotted(CENSYS_SEARCH_API)\n    rescue RuntimeError, SocketError\n      return false\n    end\n    true\n  end\n\n  def run\n    unless censys_resolvable?\n      fail_with(Failure::Unreachable, \"Unable to resolve #{CENSYS_SEARCH_API}\")\n    end\n\n    search(datastore['QUERY'])\n  end\nend\n"
}