{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--8ff0d7e2-eb51-467f-969a-7c9d20aacce1",
    "created": "2024-08-14T16:27:03.800501Z",
    "modified": "2024-08-14T16:27:03.800506Z",
    "name": "VxWorks WDB Agent Version Scanner",
    "description": "Scan for exposed VxWorks wdbrpc daemons",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/vxworks/wdbrpc_version.rb",
            "external_id": "wdbrpc_version.rb"
        },
        {
            "source_name": "reference",
            "url": "http://blog.metasploit.com/2010/08/vxworks-vulnerabilities.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::WDBRPC\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'VxWorks WDB Agent Version Scanner',\n      'Description' => 'Scan for exposed VxWorks wdbrpc daemons',\n      'Author'      => 'hdm',\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          ['URL', 'http://blog.metasploit.com/2010/08/vxworks-vulnerabilities.html'],\n          ['US-CERT-VU', '362332']\n        ]\n    )\n\n    register_options(\n    [\n      OptInt.new('BATCHSIZE', [true, 'The number of hosts to probe in each set', 256]),\n      Opt::RPORT(17185)\n    ])\n  end\n\n\n  # Define our batch size\n  def run_batch_size\n    datastore['BATCHSIZE'].to_i\n  end\n\n  # Operate on an entire batch of hosts at once\n  def run_batch(batch)\n\n    begin\n      udp_sock = nil\n      idx = 0\n\n      udp_sock = Rex::Socket::Udp.create(\n        {\n          'Context' => {'Msf' => framework, 'MsfExploit' => self}\n        }\n      )\n      add_socket(udp_sock)\n\n      batch.each do |ip|\n\n        begin\n          udp_sock.sendto(create_probe(ip), ip, datastore['RPORT'].to_i, 0)\n        rescue ::Interrupt\n          raise $!\n        rescue ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionRefused\n          nil\n        end\n\n        if (idx % 10 == 0)\n          while (r = udp_sock.recvfrom(65535, 0.01) and r[1])\n            parse_reply(r)\n          end\n        end\n\n        idx += 1\n      end\n\n      cnt = 0\n      del = 10\n      sts = Time.now.to_i\n      while (r = udp_sock.recvfrom(65535, del) and r[1])\n        parse_reply(r)\n\n        # Prevent an indefinite loop if the targets keep replying\n        cnt += 1\n        break if cnt > run_batch_size\n\n        # Escape after 15 seconds regardless of batch size\n        break if ((sts + 15) < Time.now.to_i)\n\n        del = 1.0\n      end\n\n    rescue ::Interrupt\n      raise $!\n    rescue ::Exception => e\n      print_status(\"Unknown error: #{e.class} #{e}\")\n    ensure\n      udp_sock.close if udp_sock\n    end\n  end\n\n  #\n  # The response parsers\n  #\n  def parse_reply(pkt)\n\n    return if not pkt[1]\n\n    if(pkt[1] =~ /^::ffff:/)\n      pkt[1] = pkt[1].sub(/^::ffff:/, '')\n    end\n\n    data = pkt[0]\n\n    # Bare RPC response\n    if data.length == 24\n      ecode = data[20,4].unpack(\"N\")[0]\n      emesg = \"unknown\"\n      case ecode\n      when 3\n        # Should not be hit\n        emesg = \"Device requires the VxWorks 5 WDB protocol\"\n      when 5\n        emesg = \"Device failed to parse the probe\"\n      end\n\n      print_status(\"#{pkt[1]} Error: code=#{ecode} #{emesg}\")\n      return\n    end\n\n    if data.length < 80\n      print_status(\"#{pkt[1]}: Unknown response #{data.unpack(\"H*\")[0]}\")\n      return\n    end\n\n    res = wdbrpc_parse_connect_reply(data)\n    print_good(\"#{pkt[1]}: #{res[:rt_vers]} #{res[:rt_bsp_name]} #{res[:rt_bootline]}\")\n\n    report_note(\n      :host   => pkt[1],\n      :port   => datastore['RPORT'],\n      :proto  => 'udp',\n      :type   => 'vxworks.target_info',\n      :data   => res,\n      :update => :unique\n    )\n  end\n\n  def create_probe(ip)\n    wdbrpc_request_connect(ip)\n  end\nend\n"
}