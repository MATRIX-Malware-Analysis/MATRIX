{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--995e179d-3a3a-4bb7-8d8e-dc9d4dc9e4e4",
    "created": "2024-08-14T16:27:45.376517Z",
    "modified": "2024-08-14T16:27:45.376524Z",
    "name": "SNMP Enumeration Module",
    "description": "This module allows enumeration of any devices with SNMP protocol support. It supports hardware, software, and network information. The default community used is \"public\".' 'References'  => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/snmp/snmp_enum.rb",
            "external_id": "snmp_enum.rb"
        },
        {
            "source_name": "reference",
            "url": "https://net-snmp.sourceforge.io/docs/man/snmpwalk.html"
        },
        {
            "source_name": "reference",
            "url": "http://www.nothink.org/codes/snmpcheck/index.php"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::SNMPClient\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'SNMP Enumeration Module',\n      'Description' => 'This module allows enumeration of any devices with SNMP\n        protocol support. It supports hardware, software, and network information.\n        The default community used is \"public\".',\n      'References'  =>\n        [\n          [ 'URL', 'https://en.wikipedia.org/wiki/Simple_Network_Management_Protocol' ],\n          [ 'URL', 'https://net-snmp.sourceforge.io/docs/man/snmpwalk.html' ],\n          [ 'URL', 'http://www.nothink.org/codes/snmpcheck/index.php' ],\n        ],\n      'Author'      => 'Matteo Cantoni <goony[at]nothink.org>',\n      'License'     => MSF_LICENSE\n    ))\n  end\n\n  def run_host(ip)\n\n    begin\n      snmp = connect_snmp\n\n      fields_order = [\n        \"Host IP\", \"Hostname\", \"Description\", \"Contact\",\n        \"Location\", \"Uptime snmp\", \"Uptime system\",\n        \"System date\", \"domain\", \"User accounts\",\n        \"Network information\", \"Network interfaces\",\n        \"Network IP\", \"Routing information\",\n        \"TCP connections and listening ports\", \"Listening UDP ports\",\n        \"Network services\", \"Share\", \"IIS server information\",\n        \"Storage information\", \"File system information\",\n        \"Device information\", \"Software components\",\n        \"Processes\"\n      ]\n\n      output_data = {}\n      output_data = {\"Host IP\"=>ip}\n\n      sysName = snmp.get_value('1.3.6.1.2.1.1.5.0').to_s\n      output_data[\"Hostname\"] = sysName.strip\n\n      # print connected status after the first query so if there are\n      # any timeout or connectivity errors; the code would already\n      # have jumped to error handling where the error status is\n      # already being displayed.\n      print_good(\"#{ip}, Connected.\")\n\n      sysDesc = snmp.get_value('1.3.6.1.2.1.1.1.0').to_s\n      sysDesc.gsub!(/^\\s+|\\s+$|\\n+|\\r+/, ' ')\n      output_data[\"Description\"] = sysDesc.strip\n\n      sysContact = snmp.get_value('1.3.6.1.2.1.1.4.0').to_s\n      output_data[\"Contact\"] = sysContact.strip\n\n      sysLocation = snmp.get_value('1.3.6.1.2.1.1.6.0').to_s\n      output_data[\"Location\"] = sysLocation.strip\n\n      sysUpTimeInstance = snmp.get_value('1.3.6.1.2.1.1.3.0').to_s\n      output_data[\"Uptime system\"] = sysUpTimeInstance.strip\n\n      hrSystemUptime = snmp.get_value('1.3.6.1.2.1.25.1.1.0').to_s\n      output_data[\"Uptime snmp\"] = hrSystemUptime.strip\n      hrSystemUptime = '-' if hrSystemUptime.to_s =~ /Null/\n\n      year = month = day = hour = minutes = seconds = tenths = 0\n\n      systemDate = snmp.get_value('1.3.6.1.2.1.25.1.2.0')\n      str = systemDate.to_s\n      if (str.empty? or str =~ /Null/ or str =~ /^noSuch/)\n        output_data[\"System date\"] = '-'\n      else\n\n        # RFC 2579 - Textual Conventions for SMIv2\n        # http://www.faqs.org/rfcs/rfc2579.html\n\n        systemDate = systemDate.unpack('C*')\n\n        year    = systemDate[0] * 256 + systemDate[1]\n        month   = systemDate[2] || 0\n        day     = systemDate[3] || 0\n        hour    = systemDate[4] || 0\n        minutes = systemDate[5] || 0\n        seconds = systemDate[6] || 0\n        tenths  = systemDate[7] || 0\n        output_data[\"System date\"] = sprintf(\"%d-%d-%d %02d:%02d:%02d.%d\", year, month, day, hour, minutes, seconds, tenths)\n      end\n\n      if (sysDesc =~ /Windows/)\n        domPrimaryDomain = snmp.get_value('1.3.6.1.4.1.77.1.4.1.0').to_s\n\n        output_data[\"Domain\"] = domPrimaryDomain.strip\n\n        users = []\n\n        snmp.walk([\"1.3.6.1.4.1.77.1.2.25.1.1\",\"1.3.6.1.4.1.77.1.2.25.1\"]) do |user,entry|\n          users.push([[user.value]])\n        end\n\n        if not users.empty?\n          output_data[\"User accounts\"] = users\n        end\n      end\n\n      network_information = {}\n\n      ipForwarding = snmp.get_value('1.3.6.1.2.1.4.1.0')\n\n      if ipForwarding == 0 || ipForwarding == 2\n        ipForwarding = \"no\"\n        network_information[\"IP forwarding enabled\"] = ipForwarding\n      elsif ipForwarding == 1\n        ipForwarding = \"yes\"\n        network_information[\"IP forwarding enabled\"] = ipForwarding\n      end\n\n      ipDefaultTTL = snmp.get_value('1.3.6.1.2.1.4.2.0')\n      if ipDefaultTTL.to_s !~ /Null/\n        network_information[\"Default TTL\"] = ipDefaultTTL\n      end\n\n      tcpInSegs = snmp.get_value('1.3.6.1.2.1.6.10.0')\n      if tcpInSegs.to_s !~ /Null/\n        network_information[\"TCP segments received\"] = tcpInSegs\n      end\n\n      tcpOutSegs = snmp.get_value('1.3.6.1.2.1.6.11.0')\n      if tcpOutSegs.to_s !~ /Null/\n        network_information[\"TCP segments sent\"] = tcpOutSegs\n      end\n\n      tcpRetransSegs = snmp.get_value('1.3.6.1.2.1.6.12.0')\n      if tcpRetransSegs.to_s !~ /Null/\n        network_information[\"TCP segments retrans\"] = tcpRetransSegs\n      end\n\n      ipInReceives = snmp.get_value('1.3.6.1.2.1.4.3.0')\n      if ipInReceives.to_s !~ /Null/\n        network_information[\"Input datagrams\"] = ipInReceives\n      end\n\n      ipInDelivers = snmp.get_value('1.3.6.1.2.1.4.9.0')\n      if ipInDelivers.to_s !~ /Null/\n        network_information[\"Delivered datagrams\"]=ipInDelivers\n      end\n\n      ipOutRequests = snmp.get_value('1.3.6.1.2.1.4.10.0')\n      if ipOutRequests.to_s !~ /Null/\n        network_information[\"Output datagrams\"]=ipOutRequests\n      end\n\n      if not network_information.empty?\n        output_data[\"Network information\"] = network_information\n      end\n\n      network_interfaces = []\n\n      snmp.walk([\n        \"1.3.6.1.2.1.2.2.1.1\", \"1.3.6.1.2.1.2.2.1.2\", \"1.3.6.1.2.1.2.2.1.6\",\n        \"1.3.6.1.2.1.2.2.1.3\", \"1.3.6.1.2.1.2.2.1.4\", \"1.3.6.1.2.1.2.2.1.5\",\n        \"1.3.6.1.2.1.2.2.1.10\", \"1.3.6.1.2.1.2.2.1.16\", \"1.3.6.1.2.1.2.2.1.7\"\n      ]) do |index,descr,mac,type,mtu,speed,inoc,outoc,status|\n\n        ifindex  = index.value\n        ifdescr  = descr.value\n        ifmac    = mac.value.to_s =~ /noSuchInstance/ ? 'unknown' : mac.value.unpack(\"H2H2H2H2H2H2\").join(\":\")\n        iftype   = type.value\n        ifmtu    = mtu.value\n        ifspeed  = speed.value.to_s =~ /noSuchInstance/ ? 'unknown' : speed.value.to_i / 1000000\n        ifinoc   = inoc.value\n        ifoutoc  = outoc.value\n        ifstatus = status.value\n\n        case iftype\n        when 1\n          iftype = \"other\"\n        when 2\n          iftype = \"regular1822\"\n        when 3\n          iftype = \"hdh1822\"\n        when 4\n          iftype = \"ddn-x25\"\n        when 5\n          iftype = \"rfc877-x25\"\n        when 6\n          iftype = \"ethernet-csmacd\"\n        when 7\n          iftype = \"iso88023-csmacd\"\n        when 8\n          iftype = \"iso88024-tokenBus\"\n        when 9\n          iftype = \"iso88025-tokenRing\"\n        when 10\n          iftype = \"iso88026-man\"\n        when 11\n          iftype = \"starLan\"\n        when 12\n          iftype = \"proteon-10Mbit\"\n        when 13\n          iftype = \"proteon-80Mbit\"\n        when 14\n          iftype = \"hyperchannel\"\n        when 15\n          iftype = \"fddi\"\n        when 16\n          iftype = \"lapb\"\n        when 17\n          iftype = \"sdlc\"\n        when 18\n          iftype = \"ds1\"\n        when 19\n          iftype = \"e1\"\n        when 20\n          iftype = \"basicISDN\"\n        when 21\n          iftype = \"primaryISDN\"\n        when 22\n          iftype = \"propPointToPointSerial\"\n        when 23\n          iftype = \"ppp\"\n        when 24\n          iftype = \"softwareLoopback\"\n        when 25\n          iftype = \"eon\"\n        when 26\n          iftype = \"ethernet-3Mbit\"\n        when 27\n          iftype = \"nsip\"\n        when 28\n          iftype = \"slip\"\n        when 29\n          iftype = \"ultra\"\n        when 30\n          iftype = \"ds3\"\n        when 31\n          iftype = \"sip\"\n        when 32\n          iftype = \"frame-relay\"\n        else\n          iftype = \"unknown\"\n        end\n\n        case ifstatus\n        when 1\n          ifstatus = \"up\"\n        when 2\n          ifstatus = \"down\"\n        when 3\n          ifstatus = \"testing\"\n        else\n          ifstatus = \"unknown\"\n        end\n\n        network_interfaces.push({\n          \"Interface\" => \"[ #{ifstatus} ] #{ifdescr}\",\n          \"Id\" => ifindex,\n          \"Mac Address\" => ifmac,\n          \"Type\" => iftype,\n          \"Speed\" => \"#{ifspeed} Mbps\",\n          \"MTU\" => ifmtu,\n          \"In octets\" => ifinoc,\n          \"Out octets\" => ifoutoc\n        })\n      end\n\n      if not network_interfaces.empty?\n        output_data[\"Network interfaces\"] = network_interfaces\n      end\n\n      network_ip = []\n\n      snmp.walk([\n        \"1.3.6.1.2.1.4.20.1.2\", \"1.3.6.1.2.1.4.20.1.1\",\n        \"1.3.6.1.2.1.4.20.1.3\", \"1.3.6.1.2.1.4.20.1.4\"\n      ]) do |ifid,ipaddr,netmask,bcast|\n        network_ip.push([ifid.value, ipaddr.value, netmask.value, bcast.value])\n      end\n\n      if not network_ip.empty?\n        output_data[\"Network IP\"] = [[\"Id\",\"IP Address\",\"Netmask\",\"Broadcast\"]] + network_ip\n      end\n\n      routing = []\n\n      snmp.walk([\n        \"1.3.6.1.2.1.4.21.1.1\", \"1.3.6.1.2.1.4.21.1.7\",\n        \"1.3.6.1.2.1.4.21.1.11\",\"1.3.6.1.2.1.4.21.1.3\"\n      ]) do |dest,hop,mask,metric|\n        if (metric.value.to_s.empty?)\n          metric.value = '-'\n        end\n        routing.push([dest.value, hop.value, mask.value, metric.value])\n      end\n\n      if not routing.empty?\n        output_data[\"Routing information\"] = [[\"Destination\",\"Next hop\",\"Mask\",\"Metric\"]] + routing\n      end\n\n      tcp = []\n\n      snmp.walk([\n        \"1.3.6.1.2.1.6.13.1.2\",\"1.3.6.1.2.1.6.13.1.3\",\"1.3.6.1.2.1.6.13.1.4\",\n        \"1.3.6.1.2.1.6.13.1.5\",\"1.3.6.1.2.1.6.13.1.1\"\n      ]) do |ladd,lport,radd,rport,state|\n\n        if (ladd.value.to_s.empty?  or ladd.value.to_s =~ /noSuchInstance/)\n          ladd = \"-\"\n        else\n          ladd  = ladd.value\n        end\n\n        if (lport.value.to_s.empty? or lport.value.to_s =~ /noSuchInstance/)\n          lport = \"-\"\n        else\n          lport = lport.value\n        end\n\n        if (radd.value.to_s.empty?  or radd.value.to_s =~ /noSuchInstance/)\n          radd = \"-\"\n        else\n          radd  = radd.value\n        end\n\n        if (rport.value.to_s.empty? or rport.value.to_s =~ /noSuchInstance/)\n          rport = \"-\"\n        else\n          rport = rport.value\n        end\n\n        case state.value\n        when 1\n          state = \"closed\"\n        when 2\n          state = \"listen\"\n        when 3\n          state = \"synSent\"\n        when 4\n          state = \"synReceived\"\n        when 5\n          state = \"established\"\n        when 6\n          state = \"finWait1\"\n        when 7\n          state = \"finWait2\"\n        when 8\n          state = \"closeWait\"\n        when 9\n          state = \"lastAck\"\n        when 10\n          state = \"closing\"\n        when 11\n          state = \"timeWait\"\n        when 12\n          state = \"deleteTCB\"\n        else\n          state = \"unknown\"\n        end\n\n        tcp.push([ladd, lport, radd, rport, state])\n      end\n\n      if not tcp.empty?\n        output_data[\"TCP connections and listening ports\"] = [[\"Local address\",\"Local port\",\"Remote address\",\"Remote port\",\"State\"]] + tcp\n      end\n\n      udp = []\n\n      snmp.walk([\"1.3.6.1.2.1.7.5.1.1\",\"1.3.6.1.2.1.7.5.1.2\"]) do |ladd,lport|\n        udp.push([ladd.value, lport.value])\n      end\n\n      if not udp.empty?\n        output_data[\"Listening UDP ports\"] = [[\"Local address\",\"Local port\"]] + udp\n      end\n\n      if (sysDesc =~ /Windows/)\n        network_services = []\n        n = 0\n        snmp.walk([\"1.3.6.1.4.1.77.1.2.3.1.1\",\"1.3.6.1.4.1.77.1.2.3.1.2\"]) do |name,installed|\n          network_services.push([n,name.value])\n          n+=1\n        end\n\n        if not network_services.empty?\n          output_data[\"Network services\"] = [[\"Index\",\"Name\"]] + network_services\n        end\n\n        share = []\n\n        snmp.walk([\n          \"1.3.6.1.4.1.77.1.2.27.1.1\",\"1.3.6.1.4.1.77.1.2.27.1.2\",\"1.3.6.1.4.1.77.1.2.27.1.3\"\n        ]) do |name,path,comment|\n          share.push({\" Name\"=>name.value, \"  Path\"=>path.value, \"  Comment\"=>comment.value})\n        end\n\n        if not share.empty?\n          output_data[\"Share\"] = share\n        end\n\n        iis = {}\n\n        http_totalBytesSentLowWord = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.2.0')\n        if http_totalBytesSentLowWord.to_s !~ /Null/\n          iis[\"TotalBytesSentLowWord\"] = http_totalBytesSentLowWord\n        end\n\n        http_totalBytesReceivedLowWord = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.4.0')\n        if http_totalBytesReceivedLowWord.to_s !~ /Null/\n          iis[\"TotalBytesReceivedLowWord\"] = http_totalBytesReceivedLowWord\n        end\n\n        http_totalFilesSent = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.5.0')\n        if http_totalFilesSent.to_s !~ /Null/\n          iis[\"TotalFilesSent\"] = http_totalFilesSent\n        end\n\n        http_currentAnonymousUsers = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.6.0')\n        if http_currentAnonymousUsers.to_s !~ /Null/\n          iis[\"CurrentAnonymousUsers\"] = http_currentAnonymousUsers\n        end\n\n        http_currentNonAnonymousUsers = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.7.0')\n        if http_currentNonAnonymousUsers.to_s !~ /Null/\n          iis[\"CurrentNonAnonymousUsers\"] = http_currentNonAnonymousUsers\n        end\n\n        http_totalAnonymousUsers = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.8.0')\n        if http_totalAnonymousUsers.to_s !~ /Null/\n          iis[\"TotalAnonymousUsers\"] = http_totalAnonymousUsers\n        end\n\n        http_totalNonAnonymousUsers = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.9.0')\n        if http_totalNonAnonymousUsers.to_s !~ /Null/\n          iis[\"TotalNonAnonymousUsers\"] = http_totalNonAnonymousUsers\n        end\n\n        http_maxAnonymousUsers = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.10.0')\n        if http_maxAnonymousUsers.to_s !~ /Null/\n          iis[\"MaxAnonymousUsers\"] = http_maxAnonymousUsers\n        end\n\n        http_maxNonAnonymousUsers = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.11.0')\n        if http_maxNonAnonymousUsers.to_s !~ /Null/\n          iis[\"MaxNonAnonymousUsers\"] = http_maxNonAnonymousUsers\n        end\n\n        http_currentConnections = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.12.0')\n        if http_currentConnections.to_s !~ /Null/\n          iis[\"CurrentConnections\"] = http_currentConnections\n        end\n\n        http_maxConnections = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.13.0')\n        if http_maxConnections.to_s !~ /Null/\n          iis[\"MaxConnections\"] = http_maxConnections\n        end\n\n        http_connectionAttempts = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.14.0')\n        if http_connectionAttempts.to_s !~ /Null/\n          iis[\"ConnectionAttempts\"] = http_connectionAttempts\n        end\n\n        http_logonAttempts = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.15.0')\n        if http_logonAttempts.to_s !~ /Null/\n          iis[\"LogonAttempts\"] = http_logonAttempts\n        end\n\n        http_totalGets = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.16.0')\n        if http_totalGets.to_s !~ /Null/\n          iis[\"Gets\"] = http_totalGets\n        end\n\n        http_totalPosts = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.17.0')\n        if http_totalPosts.to_s !~ /Null/\n          iis[\"Posts\"] = http_totalPosts\n        end\n\n        http_totalHeads = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.18.0')\n        if http_totalHeads.to_s !~ /Null/\n          iis[\"Heads\"] = http_totalHeads\n        end\n\n        http_totalOthers = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.19.0')\n        if http_totalOthers.to_s !~ /Null/\n          iis[\"Others\"] = http_totalOthers\n        end\n\n        http_totalCGIRequests = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.20.0')\n        if http_totalCGIRequests.to_s !~ /Null/\n          iis[\"CGIRequests\"] = http_totalCGIRequests\n        end\n\n        http_totalBGIRequests = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.21.0')\n        if http_totalBGIRequests.to_s !~ /Null/\n          iis[\"BGIRequests\"] = http_totalBGIRequests\n        end\n\n        http_totalNotFoundErrors = snmp.get_value('1.3.6.1.4.1.311.1.7.3.1.22.0')\n        if http_totalNotFoundErrors.to_s !~ /Null/\n          iis[\"NotFoundErrors\"] = http_totalNotFoundErrors\n        end\n\n        if not iis.empty?\n          output_data[\"IIS server information\"] = iis\n        end\n      end\n\n      storage_information = []\n\n      snmp.walk([\n        \"1.3.6.1.2.1.25.2.3.1.1\", \"1.3.6.1.2.1.25.2.3.1.2\", \"1.3.6.1.2.1.25.2.3.1.3\",\n        \"1.3.6.1.2.1.25.2.3.1.4\", \"1.3.6.1.2.1.25.2.3.1.5\", \"1.3.6.1.2.1.25.2.3.1.6\"\n      ]) do |index,type,descr,allocation,size,used|\n\n        case type.value.to_s\n        when /^1.3.6.1.2.1.25.2.1.1$/\n          type.value = \"Other\"\n        when /^1.3.6.1.2.1.25.2.1.2$/\n          type.value = \"Ram\"\n        when /^1.3.6.1.2.1.25.2.1.3$/\n          type.value = \"Virtual Memory\"\n        when /^1.3.6.1.2.1.25.2.1.4$/\n          type.value = \"Fixed Disk\"\n        when /^1.3.6.1.2.1.25.2.1.5$/\n          type.value = \"Removable Disk\"\n        when /^1.3.6.1.2.1.25.2.1.6$/\n          type.value = \"Floppy Disk\"\n        when /^1.3.6.1.2.1.25.2.1.7$/\n          type.value = \"Compact Disc\"\n        when /^1.3.6.1.2.1.25.2.1.8$/\n          type.value = \"RamDisk\"\n        when /^1.3.6.1.2.1.25.2.1.9$/\n          type.value = \"Flash Memory\"\n        when /^1.3.6.1.2.1.25.2.1.10$/\n          type.value = \"Network Disk\"\n        else\n          type.value = \"unknown\"\n        end\n\n        allocation.value = \"unknown\" if allocation.value.to_s =~ /noSuchInstance/\n        size.value       = \"unknown\" if size.value.to_s =~ /noSuchInstance/\n        used.value       = \"unknown\" if used.value.to_s =~ /noSuchInstance/\n\n        storage_information.push([[descr.value],[index.value],[type.value],[allocation.value],[size.value],[used.value]])\n      end\n\n      if not storage_information.empty?\n        storage = []\n        storage_information.each {|a,b,c,d,e,f|\n          s = {}\n\n          e = number_to_human_size(e,d)\n          f = number_to_human_size(f,d)\n\n          s[\"Description\"]= a\n          s[\"Device id\"] = b\n          s[\"Filesystem type\"] = c\n          s[\"Device unit\"] = d\n          s[\"Memory size\"] = e\n          s[\"Memory used\"] = f\n\n          storage.push(s)\n        }\n        output_data[\"Storage information\"] = storage\n      end\n\n      file_system = {}\n\n      hrFSIndex = snmp.get_value('1.3.6.1.2.1.25.3.8.1.1.1')\n      if hrFSIndex.to_s !~ /Null/\n        file_system[\"Index\"] = hrFSIndex\n      end\n\n      hrFSMountPoint = snmp.get_value('1.3.6.1.2.1.25.3.8.1.2.1')\n      if hrFSMountPoint.to_s !~ /Null/\n        file_system[\"Mount point\"] = hrFSMountPoint\n      end\n\n      hrFSRemoteMountPoint = snmp.get_value('1.3.6.1.2.1.25.3.8.1.3.1')\n      if hrFSRemoteMountPoint.to_s !~ /Null/ and hrFSRemoteMountPoint.to_s !~ /^noSuch/\n        if hrFSRemoteMountPoint.empty?\n          hrFSRemoteMountPoint = '-'\n        end\n        file_system[\"Remote mount point\"] = hrFSRemoteMountPoint\n      end\n\n      hrFSType = snmp.get_value('1.3.6.1.2.1.25.3.8.1.4.1')\n\n      case hrFSType.to_s\n      when /^1.3.6.1.2.1.25.3.9.1$/\n        hrFSType = \"Other\"\n      when /^1.3.6.1.2.1.25.3.9.2$/\n        hrFSType = \"Unknown\"\n      when /^1.3.6.1.2.1.25.3.9.3$/\n        hrFSType = \"BerkeleyFFS\"\n      when /^1.3.6.1.2.1.25.3.9.4$/\n        hrFSType = \"Sys5FS\"\n      when /^1.3.6.1.2.1.25.3.9.5$/\n        hrFSType = \"Fat\"\n      when /^1.3.6.1.2.1.25.3.9.6$/\n        hrFSType = \"HPFS\"\n      when /^1.3.6.1.2.1.25.3.9.7$/\n        hrFSType = \"HFS\"\n      when /^1.3.6.1.2.1.25.3.9.8$/\n        hrFSType = \"MFS\"\n      when /^1.3.6.1.2.1.25.3.9.9$/\n        hrFSType = \"NTFS\"\n      when /^1.3.6.1.2.1.25.3.9.10$/\n        hrFSType = \"VNode\"\n      when /^1.3.6.1.2.1.25.3.9.11$/\n        hrFSType = \"Journaled\"\n      when /^1.3.6.1.2.1.25.3.9.12$/\n        hrFSType = \"iso9660\"\n      when /^1.3.6.1.2.1.25.3.9.13$/\n        hrFSType = \"RockRidge\"\n      when /^1.3.6.1.2.1.25.3.9.14$/\n        hrFSType = \"NFS\"\n      when /^1.3.6.1.2.1.25.3.9.15$/\n        hrFSType = \"Netware\"\n      when /^1.3.6.1.2.1.25.3.9.16$/\n        hrFSType = \"AFS\"\n      when /^1.3.6.1.2.1.25.3.9.17$/\n        hrFSType = \"DFS\"\n      when /^1.3.6.1.2.1.25.3.9.18$/\n        hrFSType = \"Appleshare\"\n      when /^1.3.6.1.2.1.25.3.9.19$/\n        hrFSType = \"RFS\"\n      when /^1.3.6.1.2.1.25.3.9.20$/\n        hrFSType = \"DGCFS\"\n      when /^1.3.6.1.2.1.25.3.9.21$/\n        hrFSType = \"BFS\"\n      when /^1.3.6.1.2.1.25.3.9.22$/\n        hrFSType = \"FAT32\"\n      when /^1.3.6.1.2.1.25.3.9.23$/\n        hrFSType = \"LinuxExt2\"\n      else\n        hrFSType = \"Null\"\n      end\n\n      if hrFSType.to_s !~ /Null/\n        file_system[\"Type\"] = hrFSType\n      end\n\n      hrFSAccess = snmp.get_value('1.3.6.1.2.1.25.3.8.1.5.1')\n      if hrFSAccess.to_s !~ /Null/\n        file_system[\"Access\"] = hrFSAccess\n      end\n\n      hrFSBootable = snmp.get_value('1.3.6.1.2.1.25.3.8.1.6.1')\n      if hrFSBootable.to_s !~ /Null/\n        file_system[\"Bootable\"] = hrFSBootable\n      end\n\n      if not file_system.empty?\n        output_data[\"File system information\"] = file_system\n      end\n\n      device_information = []\n\n      snmp.walk([\n        \"1.3.6.1.2.1.25.3.2.1.1\", \"1.3.6.1.2.1.25.3.2.1.2\",\n        \"1.3.6.1.2.1.25.3.2.1.5\", \"1.3.6.1.2.1.25.3.2.1.3\"\n      ]) do |index,type,status,descr|\n\n        case type.value.to_s\n        when /^1.3.6.1.2.1.25.3.1.1$/\n          type.value = \"Other\"\n        when /^1.3.6.1.2.1.25.3.1.2$/\n          type.value = \"Unknown\"\n        when /^1.3.6.1.2.1.25.3.1.3$/\n          type.value = \"Processor\"\n        when /^1.3.6.1.2.1.25.3.1.4$/\n          type.value = \"Network\"\n        when /^1.3.6.1.2.1.25.3.1.5$/\n          type.value = \"Printer\"\n        when /^1.3.6.1.2.1.25.3.1.6$/\n          type.value = \"Disk Storage\"\n        when /^1.3.6.1.2.1.25.3.1.10$/\n          type.value = \"Video\"\n        when /^1.3.6.1.2.1.25.3.1.11$/\n          type.value = \"Audio\"\n        when /^1.3.6.1.2.1.25.3.1.12$/\n          type.value = \"Coprocessor\"\n        when /^1.3.6.1.2.1.25.3.1.13$/\n          type.value = \"Keyboard\"\n        when /^1.3.6.1.2.1.25.3.1.14$/\n          type.value = \"Modem\"\n        when /^1.3.6.1.2.1.25.3.1.15$/\n          type.value = \"Parallel Port\"\n        when /^1.3.6.1.2.1.25.3.1.16$/\n          type.value = \"Pointing\"\n        when /^1.3.6.1.2.1.25.3.1.17$/\n          type.value = \"Serial Port\"\n        when /^1.3.6.1.2.1.25.3.1.18$/\n          type.value = \"Tape\"\n        when /^1.3.6.1.2.1.25.3.1.19$/\n          type.value = \"Clock\"\n        when /^1.3.6.1.2.1.25.3.1.20$/\n          type.value = \"Volatile Memory\"\n        when /^1.3.6.1.2.1.25.3.1.21$/\n          type.value = \"Non Volatile Memory\"\n        else\n          type.value = \"unknown\"\n        end\n\n        case status.value\n        when 1\n          status.value = \"unknown\"\n        when 2\n          status.value = \"running\"\n        when 3\n          status.value = \"warning\"\n        when 4\n          status.value = \"testing\"\n        when 5\n          status.value = \"down\"\n        else\n          status.value = \"unknown\"\n        end\n\n        descr.value = \"unknown\" if descr.value.to_s =~ /noSuchInstance/\n\n        device_information.push([index.value, type.value, status.value, descr.value])\n      end\n\n      if not device_information.empty?\n        output_data[\"Device information\"] = [[\"Id\",\"Type\",\"Status\",\"Descr\"]] + device_information\n      end\n\n      software_list = []\n\n      snmp.walk([\"1.3.6.1.2.1.25.6.3.1.1\",\"1.3.6.1.2.1.25.6.3.1.2\"]) do |index,name|\n        software_list.push([index.value,name.value])\n      end\n\n      if not software_list.empty?\n        output_data[\"Software components\"] = [[\"Index\",\"Name\"]] + software_list\n      end\n\n      process_interfaces = []\n\n      snmp.walk([\n        \"1.3.6.1.2.1.25.4.2.1.1\", \"1.3.6.1.2.1.25.4.2.1.2\", \"1.3.6.1.2.1.25.4.2.1.4\",\n        \"1.3.6.1.2.1.25.4.2.1.5\", \"1.3.6.1.2.1.25.4.2.1.7\"\n      ]) do |id,name,path,param,status|\n\n        if status.value == 1\n          status.value = \"running\"\n        elsif status.value == 2\n          status.value = \"runnable\"\n        else\n          status.value = \"unknown\"\n        end\n\n        process_interfaces.push([id.value, status.value, name.value, path.value, param.value])\n      end\n\n      if not process_interfaces.empty?\n        output_data[\"Processes\"] = [[\"Id\",\"Status\",\"Name\",\"Path\",\"Parameters\"]] + process_interfaces\n      end\n\n      print_line(\"\\n[*] System information:\\n\")\n\n      line = \"\"\n      width = 30  # name field width\n      twidth = 32 # table like display cell width\n\n      fields_order.each {|k|\n        if not output_data.has_key?(k)\n          next\n        end\n\n        v = output_data[k]\n\n        case v\n        when Array\n          content = \"\"\n\n          v.each{ |a|\n            case a\n            when Hash\n              a.each{ |sk, sv|\n                sk = truncate_to_twidth(sk, twidth)\n                content << sprintf(\"%s%s: %s\\n\", sk, \" \"*([0,width-sk.length].max), sv)\n              }\n              content << \"\\n\"\n            when Array\n              a.each { |sv|\n                sv = sv.to_s.strip\n                # I don't like cutting info\n                #sv = truncate_to_twidth(sv, twidth)\n                content << sprintf(\"%-20s\", sv)\n              }\n              content << \"\\n\"\n            else\n              content << sprintf(\"    %s\\n\", a)\n              content << \"\\n\"\n            end\n          }\n\n          report_note(\n            :host  => ip,\n            :proto => 'udp',\n            :sname => 'snmp',\n            :port  => datastore['RPORT'].to_i,\n            :type  => \"snmp.#{k}\",\n            :data  => content\n          )\n\n          line << \"\\n[*] #{k}:\\n\\n#{content}\"\n\n        when Hash\n          content = \"\"\n          v.each{ |sk, sv|\n            sk = truncate_to_twidth(sk,twidth)\n            content << sprintf(\"%s%s: %s\\n\", sk, \" \"*([0,width-sk.length].max), sv)\n          }\n\n          report_note(\n            :host  => ip,\n            :proto => 'udp',\n            :sname => 'snmp',\n            :port  => datastore['RPORT'].to_i,\n            :type  => \"snmp.#{k}\",\n            :data  => content\n          )\n\n          line << \"\\n[*] #{k}:\\n\\n#{content}\"\n          content << \"\\n\"\n        else\n          if (v.nil? or v.empty? or v =~ /Null/)\n            v = '-'\n          end\n\n          report_note(\n            :host  => ip,\n            :proto => 'udp',\n            :sname => 'snmp',\n            :port  => datastore['RPORT'].to_i,\n            :type  => \"snmp.#{k}\",\n            :data  => v\n          )\n\n          k = truncate_to_twidth(k,twidth)\n          line << sprintf(\"%s%s: %s\\n\", k, \" \"*([0,width-k.length].max), v)\n        end\n      }\n\n      print_line(line)\n      print_line('')\n\n    rescue SNMP::RequestTimeout\n      print_error(\"#{ip} SNMP request timeout.\")\n    rescue Rex::ConnectionError\n      print_error(\"#{ip} Connection refused.\")\n    rescue SNMP::InvalidIpAddress\n      print_error(\"#{ip} Invalid IP Address. Check it with 'snmpwalk tool'.\")\n    rescue SNMP::UnsupportedVersion\n      print_error(\"#{ip} Unsupported SNMP version specified. Select from '1' or '2c'.\")\n    rescue SNMP::ParseError\n      print_error(\"#{ip} Encountered an SNMP parsing error while trying to enumerate the host.\")\n    rescue ::Interrupt\n      raise $!\n    rescue ::Exception => e\n      print_error(\"Unknown error: #{e.class} #{e}\")\n      elog(e)\n    ensure\n      disconnect_snmp\n    end\n  end\n\n  def truncate_to_twidth(string,twidth)\n    string.slice(0..twidth-2)\n  end\n\n  def number_to_human_size(size,unit)\n    size = size.first.to_i * unit.first.to_i\n\n    if size < 1024\n      \"#{size} bytes\"\n    elsif size < 1024.0 * 1024.0\n      \"%.02f KB\" % (size / 1024.0)\n    elsif size < 1024.0 * 1024.0 * 1024.0\n      \"%.02f MB\" % (size / 1024.0 / 1024.0)\n    else\n      \"%.02f GB\" % (size / 1024.0 / 1024.0 / 1024.0)\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        "Matteo Cantoni <goony[at]nothink.org>",
        ""
    ]
}