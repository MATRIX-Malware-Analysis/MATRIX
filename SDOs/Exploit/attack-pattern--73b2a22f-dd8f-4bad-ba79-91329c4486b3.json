{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--73b2a22f-dd8f-4bad-ba79-91329c4486b3",
    "created": "2024-08-14T16:22:00.813162Z",
    "modified": "2024-08-14T16:22:00.813166Z",
    "name": "Native DNS Server (Example)",
    "description": " This module provides a Rex based DNS service which can store static entries resolve names over pivots, and serve DNS requests across routed session comms. DNS tunnels can operate across the Rex switchboard, and DNS other modules can use this as a template. Setting static records via hostfile allows for DNS spoofing attacks without direct traffic manipulation at the handlers. handlers for requests and responses provided here mimic the internal Rex functionality but utilize methods within this module's namespace to output content processed in the Proc contexts via vprint_status. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/dns/native_server.rb",
            "external_id": "native_server.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::DNS::Client\n  include Msf::Exploit::Remote::DNS::Server\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Native DNS Server (Example)',\n      'Description'    => %q{\n        This module provides a Rex based DNS service which can store static entries,\n        resolve names over pivots, and serve DNS requests across routed session comms.\n        DNS tunnels can operate across the Rex switchboard, and DNS other modules\n        can use this as a template. Setting static records via hostfile allows for DNS\n        spoofing attacks without direct traffic manipulation at the handlers. handlers\n        for requests and responses provided here mimic the internal Rex functionality,\n        but utilize methods within this module's namespace to output content processed\n        in the Proc contexts via vprint_status.\n      },\n      'Author'         => 'RageLtMan <rageltman[at]sempervictus>',\n      'License'        => MSF_LICENSE,\n      'References'     => [],\n      'Actions'   =>\n        [\n          [ 'Service', 'Description' => 'Run DNS service' ]\n        ],\n      'PassiveActions' =>\n        [\n          'Service'\n        ],\n      'DefaultAction'  => 'Service'\n    ))\n  end\n\n  #\n  # Wrapper for service execution and cleanup\n  #\n  def run\n    begin\n      start_service\n      service.wait\n    rescue Rex::BindFailed => e\n      print_error \"Failed to bind to port #{datastore['RPORT']}: #{e.message}\"\n    end\n  end\n\n  #\n  # Creates Proc to handle incoming requests\n  #\n  def on_dispatch_request(cli,data)\n    return if data.strip.empty?\n    req = Packet.encode_drb(data)\n    peer = \"#{cli.peerhost}:#{cli.peerport}\"\n    asked = req.question.map(&:qname).map(&:to_s).join(', ')\n    vprint_status(\"Received request for #{asked} from #{peer}\")\n    answered = []\n    # Find cached items, remove request from forwarded packet\n    req.question.each do |ques|\n      cached = service.cache.find(ques.qname, ques.qtype.to_s)\n      if cached.empty?\n        next\n      else\n        req.instance_variable_set(:@answer, (req.answer + cached).uniq)\n        answered << ques\n        cached.map do |hit|\n          if hit.respond_to?(:address)\n            hit.name.to_s + ':' + hit.address.to_s + ' ' + hit.type.to_s\n          else\n            hit.name.to_s + ' ' + hit.type.to_s\n          end\n        end.each {|h| vprint_status(\"Cache hit for #{h}\")}\n      end\n    end unless service.cache.nil?\n    # Forward remaining requests, cache responses\n    if answered.count < req.question.count and service.fwd_res\n      if !req.header.rd\n        vprint_status(\"Recursion forbidden in query for #{req.question.first.name} from #{peer}\")\n      else\n        forward = req.dup\n        # forward.question = req.question - answered\n        forward.instance_variable_set(:@question, req.question - answered)\n        forwarded = service.fwd_res.send(Packet.validate(forward))\n        forwarded.answer.each do |ans|\n          rstring = ans.respond_to?(:address) ? \"#{ans.name}:#{ans.address}\" : ans.name\n          vprint_status(\"Caching response #{rstring} #{ans.type}\")\n          service.cache.cache_record(ans)\n        end unless service.cache.nil?\n        # Merge the answers and use the upstream response\n        forward.instance_variable_set(:@answer, (req.answer + forwarded.answer).uniq)\n        req = forwarded\n      end\n    end\n    service.send_response(cli, Packet.validate(Packet.generate_response(req)).encode)\n  end\n\n  #\n  # Creates Proc to handle outbound responses\n  #\n  def on_send_response(cli,data)\n    res = Packet.encode_drb(data)\n    peer = \"#{cli.peerhost}:#{cli.peerport}\"\n    asked = res.question.map(&:qname).map(&:to_s).join(', ')\n    vprint_status(\"Sending response for #{asked} to #{peer}\")\n    cli.write(data)\n  end\n\n\nend\n"
}