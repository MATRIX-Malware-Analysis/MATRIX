{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ab8b4a0a-3188-4762-b722-f3f1b6b5432e",
    "created": "2024-08-14T16:30:44.332985Z",
    "modified": "2024-08-14T16:30:44.332988Z",
    "name": "Squid Proxy Port Scanner",
    "description": " A exposed Squid proxy will usually allow an attacker to make requests on their behalf. If misconfigured, this may give the attacker information about devices that they cannot normally reach. For example, an attacker may be able to make requests for internal IP addresses against an open Squid proxy exposed to the Internet, therefore performing a port scan against the internal network.  The `auxiliary/scanner/http/open_proxy` module can be used to test for open proxies, though a Squid proxy does not have to be on the open Internet in order to allow for pivoting (e.g. an Intranet Squid proxy which allows the attack to pivot to another part of the internal network).  This module will not be able to scan network ranges or ports denied by Squid ACLs. Fortunately it is possible to detect whether a host was up and the port was closed, or if the request was blocked by an ACL, based on the response Squid gives. This feedback is provided to the user in meterpreter `VERBOSE` output, otherwise only open and permitted ports are printed. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/squid_pivot_scanning.rb",
            "external_id": "squid_pivot_scanning.rb"
        },
        {
            "source_name": "reference",
            "url": "http://wiki.squid-cache.org/SquidFaq/SecurityPitfalls"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/socket/range_walker'\n\nclass MetasploitModule < Msf::Auxiliary\n\n  # Exploit mixins should be called first\n  include Msf::Exploit::Remote::HttpClient\n  # Scanner mixin should be near last\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::Report\n\n  def initialize\n    super(\n      'Name'        => 'Squid Proxy Port Scanner',\n      'Description' => %q{\n        A exposed Squid proxy will usually allow an attacker to make requests on\n        their behalf. If misconfigured, this may give the attacker information\n        about devices that they cannot normally reach. For example, an attacker\n        may be able to make requests for internal IP addresses against an open\n        Squid proxy exposed to the Internet, therefore performing a port scan\n        against the internal network.\n\n        The `auxiliary/scanner/http/open_proxy` module can be used to test for\n        open proxies, though a Squid proxy does not have to be on the open\n        Internet in order to allow for pivoting (e.g. an Intranet Squid proxy\n        which allows the attack to pivot to another part of the internal\n        network).\n\n        This module will not be able to scan network ranges or ports denied by\n        Squid ACLs. Fortunately it is possible to detect whether a host was up\n        and the port was closed, or if the request was blocked by an ACL, based\n        on the response Squid gives. This feedback is provided to the user in\n        meterpreter `VERBOSE` output, otherwise only open and permitted ports\n        are printed.\n        },\n      'Author'      =>\n        [\n          'willis',     # Original meterpreter module\n          '0x44434241'  # Detection updates and documentation\n        ],\n      'References'\t=>\n        [\n          'URL', 'http://wiki.squid-cache.org/SquidFaq/SecurityPitfalls'\n        ],\n      'License'\t    => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        OptString.new('RANGE', [true, 'IPs to scan through Squid proxy', '']),\n        OptString.new('PORTS', [true, 'Ports to scan; must be TCP', '21,80,139,443,445,1433,1521,1723,3389,8080,9100']),\n        OptBool.new('MANUAL_CHECK', [true, 'Stop the scan if server seems to answer positively to every request', true]),\n        OptString.new('CANARY_IP', [true, 'The IP to check if the proxy always answers positively; the IP should not respond.', '1.2.3.4'])\n      ]\n    )\n\n  end\n\n  def run_host(target_host)\n    begin\n      iplist = Rex::Socket::RangeWalker.new(datastore['RANGE'])\n      portlist = Rex::Socket.portspec_crack(datastore['PORTS'])\n      dead = false\n\n      if portlist.empty?\n        raise Msf::OptionValidateError.new(['PORTS'])\n      end\n\n      vprint_status(\"[#{rhost}] Verifying manual testing is not required...\")\n\n      manual = false\n      # request a non-existent page first to make sure the server doesn't respond with a 200 to everything.\n      res_test = send_request_cgi({\n        'uri'     => \"http://#{datastore['CANARY_IP']}:80\",\n        'method'  => 'GET',\n        'data'    => '',\n        'version' => '1.0',\n        'vhost'   => ''\n      }, 10)\n\n      if res_test && res_test.body && (res_test.code == 200)\n        print_error(\"#{rhost} likely answers positively to every request, check it manually.\")\n        print_error(\"\\t\\t Proceeding with the scan may increase false positives.\")\n        manual = true\n      end\n\n      iplist.each do |target|\n        next if manual && datastore['MANUAL_CHECK']\n\n        alive = nil\n\n        portlist.each do |port|\n          next if dead\n\n          vprint_status(\"[#{rhost}] Requesting #{target}:#{port}\")\n          if port == 443\n            res = send_request_cgi({\n              'uri'     => \"https://#{target}:#{port}\",\n              'method'  => 'GET',\n              'data'    => '',\n              'version' => '1.0',\n              'vhost'   => ''\n            }, 10)\n          else\n            res = send_request_cgi({\n              'uri'     => \"http://#{target}:#{port}\",\n              'method'  => 'GET',\n              'data'    => '',\n              'version' => '1.0',\n              'vhost'   => ''\n            }, 10)\n          end\n\n          if res && res.body\n            # Look at the HTTP headers back from Squid first, for some easy error detection.\n            if res.headers.key?('X-Squid-Error')\n              case res.headers['X-Squid-Error']\n              when /ERR_CONNECT_FAIL/\n                # Usually a HTTP 503, page body can give some more information. Example:\n                # <p id=\"sysmsg\">The system returned: <i>(111) Connection refused</i></p>\n                if res.body =~ /id=\"sysmsg\".*Connection refused/\n                  if alive.nil?\n                    print_good(\"[#{rhost}] #{target} is alive.\")\n                    alive = true\n                  end\n                  vprint_status(\"[#{rhost}] #{target} is alive but #{port} is closed.\")\n                elsif res.body =~ /id=\"sysmsg\".*No route to host/\n                  dead = true\n                  print_error(\"[#{rhost}] No route to #{target}\")\n                end\n              when /ERR_ACCESS_DENIED/\n                # Indicates that the Squid ACLs do not allow connecting to this port.\n                # See: https://wiki.squid-cache.org/SquidFaq/SquidAcl\n                vprint_status(\"[#{rhost}] #{target}:#{port} likely blocked by ACL.\")\n              when /ERR_DNS_FAIL/\n                # Squid could not resolve the destination hostname.\n                dead = true\n                print_error(\"[#{rhost}] Squid could not resolve '#{target}', try putting the IP in the RANGE parameter if known.\")\n              else\n                print_error(\"[#{rhost}] #{target}:#{port} unknown Squid proxy error: '#{res.headers['X-Squid-Error']}' (HTTP #{res.code})\")\n              end\n              next # Skip to next port if the host is not marked as dead\n            end\n\n            # By this stage, we've likely got a good connection. Parsing the body might no longer be reasonable if the\n            # destination port is not serving HTTP (eg: SSH), but we can derive information from the headers Squid\n            # returns.\n            if res.code.between?(300, 399)\n              # We can be more verbose if we have a known redirect.\n              print_good(\"[#{rhost}] #{target}:#{port} seems open (HTTP #{res.code} redirect to: '#{res.headers['Location']}', server header: '#{res.headers['Server']}')\")\n              report_service(host: target, port: port, name: res.headers['Server'], info: 'Redirect to: ' + res.headers['Location'])\n            else\n              # 200 OK, 404 Not Found etc - still indicates the port was open and responding.\n              server = res.headers['Server'] || 'unknown'\n              print_good(\"[#{rhost}] #{target}:#{port} seems open (HTTP #{res.code}, server header: '#{server}').\")\n              report_service(host: target, port: port, name: server, info: res.body)\n            end\n\n          end\n        end\n        dead = false\n      end\n\n      rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n      rescue ::Timeout::Error, ::Errno::EPIPE\n    end\n  end\nend\n"
}