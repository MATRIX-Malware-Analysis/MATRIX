{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2b2ff458-134f-47bc-9927-802ebd3ee846",
    "created": "2024-08-14T16:31:04.4622Z",
    "modified": "2024-08-14T16:31:04.462204Z",
    "name": "HTTP Virtual Host Brute Force Scanner",
    "description": " This module tries to identify unique virtual hosts hosted by the target web server.  ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/scanner/http/vhost_scanner.rb",
            "external_id": "vhost_scanner.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\n\n#\n# May I reuse some methods?\n#\nrequire 'cgi'\n\n\n\nclass MetasploitModule < Msf::Auxiliary\n\n    include Msf::Exploit::Remote::HttpClient\n    include Msf::Auxiliary::WmapScanServer\n    include Msf::Auxiliary::Scanner\n    include Msf::Auxiliary::Report\n\n\n    def initialize(info = {})\n      super(update_info(info,\n        'Name'   \t\t=> 'HTTP Virtual Host Brute Force Scanner',\n        'Description'\t=> %q{\n          This module tries to identify unique virtual hosts\n        hosted by the target web server.\n\n          },\n        'Author' \t\t=> [ 'et [at] cyberspace.org' ],\n        'License'\t\t=> BSD_LICENSE))\n\n      register_options(\n      [\n        OptString.new('PATH', [ true,  \"The PATH to use while testing\", '/']),\n        OptString.new('QUERY', [ false,  \"HTTP URI Query\", '']),\n        OptString.new('DOMAIN', [ true,  \"Domain name\", '']),\n        OptString.new('HEADERS', [ false,  \"HTTP Headers\", '']),\n        OptPath.new('SUBDOM_LIST', [false, \"Path to text file with subdomains\"]),\n      ])\n\n    end\n\n    def run_host(ip)\n      if datastore['SUBDOM_LIST'] and ::File.file?(datastore['SUBDOM_LIST'])\n        valstr = IO.readlines(datastore['SUBDOM_LIST']).map {\n          |e| e.gsub(\".#{datastore['DOMAIN']}\", \"\").chomp\n        }\n      else\n        valstr = [\n          \"admin\",\n          \"services\",\n          \"webmail\",\n          \"console\",\n          \"apps\",\n          \"mail\",\n          \"intranet\",\n          \"intra\",\n          \"spool\",\n          \"corporate\",\n          \"www\",\n          \"web\"\n        ]\n      end\n\n      datastore['QUERY'] ? tquery = queryparse(datastore['QUERY']): nil\n      datastore['HEADERS'] ? thead = headersparse(datastore['HEADERS']) : nil\n\n      noexistsres = nil\n      resparr = []\n\n      2.times do |n|\n\n        randhost = Rex::Text.rand_text_alpha(5)+\".\"+datastore['DOMAIN']\n\n\n        begin\n          noexistsres = send_request_cgi({\n            'uri'  \t\t=>  normalize_uri(datastore['PATH']),\n            'vars_get' \t=>  tquery,\n            'headers' \t=>  thead,\n            'vhost'\t\t=>  randhost,\n            'method'   \t=> 'GET',\n            'ctype'\t\t=> 'text/plain'\n          }, 20)\n\n          print_status(\"[#{ip}] Sending request with random domain #{randhost} \")\n\n          if noexistsres\n            resparr[n] = noexistsres.body\n          end\n\n        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n        rescue ::Timeout::Error, ::Errno::EPIPE\n        end\n      end\n\n      if resparr[0] != resparr[1]\n        print_error(\"[#{ip}] Unable to identify error response\")\n        return\n      end\n\n      vprint_status(\"Running with #{valstr.length} sudomains\")\n      valstr.each do |astr|\n        thost = astr+\".\"+datastore['DOMAIN']\n\n        begin\n          res = send_request_cgi({\n            'uri'  \t\t=>  normalize_uri(datastore['PATH']),\n            'vars_get' \t=>  tquery,\n            'headers' \t=>  thead,\n            'vhost'\t\t=>  thost,\n            'method'   \t=> 'GET',\n            'ctype'\t\t=> 'text/plain'\n          }, 20)\n\n\n          if res and noexistsres\n\n            if res.body !=  noexistsres.body\n              print_good(\"[#{ip}] Vhost found  #{thost} \")\n\n              report_note(\n                :host\t=> ip,\n                :proto => 'tcp',\n                :sname => (ssl ? 'https' : 'http'),\n                :port\t=> rport,\n                :type\t=> 'VHOST',\n                :data\t=> thost,\n                :update => :unique_data\n              )\n\n            else\n              vprint_status(\"NOT Found #{thost}\")\n            end\n          else\n            print_status(\"[#{ip}] NO Response\")\n          end\n\n        rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout\n        rescue ::Timeout::Error, ::Errno::EPIPE\n        end\n\n      end\n\n    end\n  end\n"
}