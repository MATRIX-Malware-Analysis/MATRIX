{
    "type": "weakness",
    "spec_version": "2.1",
    "id": "weakness--5f29fa2a-b6cb-4b44-8563-2d77fde66538",
    "created": "2024-08-13T14:46:48.815782Z",
    "modified": "2024-08-13T14:46:48.815782Z",
    "name": "Reliance on Data/Memory Layout",
    "description": "The product makes invalid assumptions about how protocol data or memory is organized at a lower level, resulting in unintended program behavior.",
    "object_marking_refs": [
        "marking-definition--613f2e26-407d-48c7-9eca-b8e91df99dc9"
    ],
    "external_references": [
        {
            "source_name": "CWE",
            "external_id": "188"
        }
    ],
    "x_mitre_common_consequences": [
        {
            "impact": "Modify Memory",
            "scope": "Integrity"
        },
        {
            "impact": "Read Memory",
            "scope": "Integrity"
        },
        {
            "impact": "Modify Memory",
            "scope": "Confidentiality"
        },
        {
            "impact": "Read Memory",
            "scope": "Confidentiality"
        }
    ],
    "x_mitre_content_history": [
        {
            "submission_date": "2006-07-19",
            "submission_name": "CLASP",
            "submission_organization": null
        }
    ],
    "x_mitre_detection_methods": [
        {
            "description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
            "effectiveness": "High",
            "method": "Fuzzing"
        }
    ],
    "x_mitre_likelihood_of_exploit": "Low",
    "x_mitre_potential_mitigations": [
        {
            "description": "In flat address space situations, never allow computing memory addresses as offsets from another memory address.",
            "effectiveness": null,
            "phase": "Implementation"
        },
        {
            "description": "Fully specify protocol layout unambiguously, providing a structured grammar (e.g., a compilable yacc grammar).",
            "effectiveness": null,
            "phase": "Architecture and Design"
        },
        {
            "description": "Testing: Test that the implementation properly handles each case in the protocol grammar.",
            "effectiveness": null,
            "phase": "Testing"
        }
    ],
    "x_mitre_references": [
        {
            "external_reference_id": "REF-62"
        },
        {
            "external_reference_id": "REF-18"
        }
    ],
    "x_mitre_related_weaknesses": [
        {
            "cwe_id": "1105",
            "nature": "ChildOf"
        },
        {
            "cwe_id": "435",
            "nature": "ChildOf"
        }
    ]
}