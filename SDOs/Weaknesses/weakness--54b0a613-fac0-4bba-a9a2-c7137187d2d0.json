{
    "type": "weakness",
    "spec_version": "2.1",
    "id": "weakness--54b0a613-fac0-4bba-a9a2-c7137187d2d0",
    "created": "2024-08-13T14:46:49.006957Z",
    "modified": "2024-08-13T14:46:49.006957Z",
    "name": "Access of Memory Location After End of Buffer",
    "description": "The product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.",
    "object_marking_refs": [
        "marking-definition--613f2e26-407d-48c7-9eca-b8e91df99dc9"
    ],
    "external_references": [
        {
            "source_name": "CWE",
            "external_id": "788"
        }
    ],
    "x_mitre_common_consequences": [
        {
            "impact": "Read Memory",
            "scope": "Confidentiality"
        },
        {
            "impact": "Modify Memory",
            "scope": "Integrity"
        },
        {
            "impact": "DoS: Crash, Exit, or Restart",
            "scope": "Integrity"
        },
        {
            "impact": "Modify Memory",
            "scope": "Availability"
        },
        {
            "impact": "DoS: Crash, Exit, or Restart",
            "scope": "Availability"
        },
        {
            "impact": "Modify Memory",
            "scope": "Integrity"
        },
        {
            "impact": "Execute Unauthorized Code or Commands",
            "scope": "Integrity"
        }
    ],
    "x_mitre_content_history": [
        {
            "submission_date": "2009-10-21",
            "submission_name": "CWE Content Team",
            "submission_organization": "MITRE"
        }
    ],
    "x_mitre_detection_methods": [
        {
            "description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
            "effectiveness": "High",
            "method": "Fuzzing"
        },
        {
            "description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
            "effectiveness": "High",
            "method": "Automated Static Analysis"
        }
    ],
    "x_mitre_likelihood_of_exploit": "Unknown",
    "x_mitre_observed_examples": [
        {
            "description": "Classic stack-based buffer overflow in media player using a long entry in a playlist",
            "link": "https://www.cve.org/CVERecord?id=CVE-2009-2550",
            "reference": "CVE-2009-2550"
        },
        {
            "description": "Heap-based buffer overflow in media player using a long entry in a playlist",
            "link": "https://www.cve.org/CVERecord?id=CVE-2009-2403",
            "reference": "CVE-2009-2403"
        },
        {
            "description": "large precision value in a format string triggers overflow",
            "link": "https://www.cve.org/CVERecord?id=CVE-2009-0689",
            "reference": "CVE-2009-0689"
        },
        {
            "description": "attacker-controlled array index leads to code execution",
            "link": "https://www.cve.org/CVERecord?id=CVE-2009-0558",
            "reference": "CVE-2009-0558"
        },
        {
            "description": "OS kernel trusts userland-supplied length value, allowing reading of sensitive information",
            "link": "https://www.cve.org/CVERecord?id=CVE-2008-4113",
            "reference": "CVE-2008-4113"
        },
        {
            "description": "Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)",
            "link": "https://www.cve.org/CVERecord?id=CVE-2007-4268",
            "reference": "CVE-2007-4268"
        }
    ],
    "x_mitre_references": [
        {
            "external_reference_id": "REF-961"
        }
    ],
    "x_mitre_related_weaknesses": [
        {
            "cwe_id": "119",
            "nature": "ChildOf"
        },
        {
            "cwe_id": "119",
            "nature": "ChildOf"
        },
        {
            "cwe_id": "119",
            "nature": "ChildOf"
        }
    ]
}