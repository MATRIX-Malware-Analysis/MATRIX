{
    "type": "weakness",
    "spec_version": "2.1",
    "id": "weakness--16d717f9-c99c-40b0-be1b-94d495dae198",
    "created": "2024-08-13T14:46:48.964164Z",
    "modified": "2024-08-13T14:46:48.964164Z",
    "name": "Free of Memory not on the Heap",
    "description": "The product calls free() on a pointer to memory that was not allocated using associated heap allocation functions such as malloc(), calloc(), or realloc().",
    "object_marking_refs": [
        "marking-definition--613f2e26-407d-48c7-9eca-b8e91df99dc9"
    ],
    "external_references": [
        {
            "source_name": "CWE",
            "external_id": "590"
        }
    ],
    "x_mitre_common_consequences": [
        {
            "impact": "Execute Unauthorized Code or Commands",
            "scope": "Integrity"
        },
        {
            "impact": "Modify Memory",
            "scope": "Integrity"
        },
        {
            "impact": "Execute Unauthorized Code or Commands",
            "scope": "Confidentiality"
        },
        {
            "impact": "Modify Memory",
            "scope": "Confidentiality"
        },
        {
            "impact": "Execute Unauthorized Code or Commands",
            "scope": "Availability"
        },
        {
            "impact": "Modify Memory",
            "scope": "Availability"
        }
    ],
    "x_mitre_content_history": [
        {
            "submission_date": "2006-12-15",
            "submission_name": "CWE Community",
            "submission_organization": null
        }
    ],
    "x_mitre_detection_methods": [
        {
            "description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.",
            "effectiveness": "High",
            "method": "Fuzzing"
        },
        {
            "description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)",
            "effectiveness": "High",
            "method": "Automated Static Analysis"
        }
    ],
    "x_mitre_likelihood_of_exploit": "Unknown",
    "x_mitre_potential_mitigations": [
        {
            "description": "Only free pointers that you have called malloc on previously. This is the recommended solution. Keep track of which pointers point at the beginning of valid chunks and free them only once.",
            "effectiveness": null,
            "phase": "Implementation"
        },
        {
            "description": "Before freeing a pointer, the programmer should make sure that the pointer was previously allocated on the heap and that the memory belongs to the programmer. Freeing an unallocated pointer will cause undefined behavior in the program.",
            "effectiveness": null,
            "phase": "Implementation"
        },
        {
            "description": "\n                  ",
            "effectiveness": null,
            "phase": "Architecture and Design"
        },
        {
            "description": "Use a language that provides abstractions for memory allocation and deallocation.",
            "effectiveness": null,
            "phase": "Architecture and Design"
        },
        {
            "description": "Use a tool that dynamically detects memory management problems, such as valgrind.",
            "effectiveness": null,
            "phase": "Testing"
        }
    ],
    "x_mitre_references": [
        {
            "external_reference_id": "REF-480"
        }
    ],
    "x_mitre_related_weaknesses": [
        {
            "cwe_id": "762",
            "nature": "ChildOf"
        },
        {
            "cwe_id": "123",
            "nature": "CanPrecede"
        }
    ]
}