{
    "type": "course-of-action",
    "spec_version": "2.1",
    "id": "course-of-action--27fea8af-3c60-4928-977b-8e5035157928",
    "created": "2024-08-14T07:36:38.382141Z",
    "modified": "2024-08-14T07:36:38.382141Z",
    "name": "Process Code Segment Verification",
    "description": "Comparing the \"text\" or \"code\" memory segments to a source of truth.",
    "x_d3fend_id": "D3-PCSV",
    "x_kb_article": "## How it works\nA process code segment is an executable portion of computer memory allocated to a particular process. Process Code Segment Verification implements verification to compare a process code segment to some expected value.\n\n### Verification logic\nVerification can occur during application startup, or continuously during execution. The logic which verifies the process code may be separate in a third-party process, embedded in the application itself at compile time, or dynamically linked at runtime.\n\n### System of record\nExamples of systems of record:\n\n * On-disk application binary files or checksums\n * Remotely stored binary data or checksums\n * Embedded binary data or checksums\n\n### Post Verification Actions\nIf the verification function determines a process code segment may have been altered, a capability may invoke Eviction techniques  as **Process Termination** to end the current process, or **Executable Blacklisting** to prevent the executable from launching in the future.\n\n## Considerations\n\n### False positives\n\nFalse positives commonly occur in the case that the layout of code in the process segment is legitimately modified:\n\n*  Operating system features or third-party security software may modify the layout of process code, for example in the defensive technique **Segment Address Offset Randomization**, or in the case that a module is rebased.  In both of these cases, the alteration occurs before the code is fully loaded into memory, and it would be possible to avoid the false positive by securely feeding this constant offset and any relocation data into the verification logic.\n\n* Process code segments may be written to modify themselves or other process code segments; however, this goes against widely-accepted current practices in software development.\n\n### False negatives\n\nFalse negatives can occur via alteration of the verification logic or source of truth, or insufficient verification logic.\n\n* Verification techniques which are executed only locally may be defeated by altering the local verification logic.\n\n* Verification that is run only on a recurring basis could be evaded if the malicious alteration is completed before verification is run.\n\n* Verification that requests an operation to be performed on a subset of the code segment could be evaded by performing that operation on a copy of the relevant bytes of the code segment.\n\n* Verification based on a system of record that can be altered may fail if that system of record is modifiable by a malicious user."
}